{"all-named-html-entities":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  allNamedEntities,\n  allNamedEntitiesSetOnly,\n  allNamedEntitiesSetOnlyCaseInsensitive,\n  entStartsWith,\n  entEndsWith,\n  entStartsWithCaseInsensitive,\n  entEndsWithCaseInsensitive,\n  brokenNamedEntities,\n  decode,\n  minLength,\n  maxLength,\n  uncertain,\n&#x7D; from \"all-named-html-entities\";\n\nassert.equal(Object.keys(allNamedEntities).length, 2125);\nassert.equal(entStartsWith.A.E[0], \"AElig\");"},"allNamedEntities.js":{"title":"`allNamedEntities`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; allNamedEntities &#x7D; from \"all-named-html-entities\";\n\n// total named entities count:\nassert.equal(Object.keys(allNamedEntities).length, 2125);\n\n// show the first-one:\nassert.equal(Object.keys(allNamedEntities).sort()[0], \"AElig\");\n\n// &AElig; decoded:\nassert.equal(allNamedEntities.AElig, \"Æ\");"},"entEndsWith.js":{"title":"`entEndsWith`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; entEndsWith &#x7D; from \"all-named-html-entities\";\n\n// here's list of named HTML entities which end with character \"2\":\nassert.deepEqual(entEndsWith[\"2\"], &#x7B;\n  1: [\"blk12\", \"frac12\"],\n  p: [\"sup2\"],\n&#x7D;);\n\n// query directly\nassert.equal(entEndsWith[\"2\"].p[0], \"sup2\");"},"entStartsWith.js":{"title":"`entStartsWith`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; entStartsWith &#x7D; from \"all-named-html-entities\";\n\n// for perf reasons, they're pre-grouped by first two letters\nassert.deepEqual(entStartsWith.A, &#x7B;\n  a: [\"Aacute\"],\n  b: [\"Abreve\"],\n  c: [\"Acirc\", \"Acy\"],\n  E: [\"AElig\"],\n  f: [\"Afr\"],\n  g: [\"Agrave\"],\n  l: [\"Alpha\"],\n  m: [\"Amacr\"],\n  M: [\"AMP\"],\n  n: [\"And\"],\n  o: [\"Aogon\", \"Aopf\"],\n  p: [\"ApplyFunction\"],\n  r: [\"Aring\"],\n  s: [\"Ascr\", \"Assign\"],\n  t: [\"Atilde\"],\n  u: [\"Auml\"],\n&#x7D;);\n\n// query directly\nassert.equal(entStartsWith.A.E[0], \"AElig\");"},"entStartsWithCaseInsensitive.js":{"title":"`entStartsWithCaseInsensitive`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; entStartsWithCaseInsensitive &#x7D; from \"all-named-html-entities\";\n\n// case-insensitive \"entStartsWithCaseInsensitive\" is useful\n// when looking for possibly mis-typed entities; emlint uses it\n\n// which entities, lowercased, start with \"j\"?\nassert.deepEqual(entStartsWithCaseInsensitive.j, &#x7B;\n  c: [\"jcirc\", \"jcy\"],\n  f: [\"jfr\"],\n  m: [\"jmath\"],\n  o: [\"jopf\"],\n  s: [\"jscr\", \"jsercy\"],\n  u: [\"jukcy\"],\n&#x7D;);"}},"array-group-str-omit-num-char":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; groupStr &#x7D; from \"array-group-str-omit-num-char\";\n\nassert.deepEqual(groupStr([\"a1-1\", \"a2-2\", \"b3-3\", \"c4-4\"]), &#x7B;\n  \"a*-*\": 2,\n  \"b3-3\": 1,\n  \"c4-4\": 1,\n&#x7D;);"}},"array-includes-with-glob":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; includesWithGlob &#x7D; from \"array-includes-with-glob\";\n\nassert.equal(includesWithGlob([\"xc\", \"yc\", \"zc\"], \"*c\"), true);\n// (all 3)\n\nassert.equal(includesWithGlob([\"xc\", \"yc\", \"zc\"], \"*a\"), false);\n// (none found)\n\nassert.equal(includesWithGlob([\"something\", \"anything\", \"zzz\"], \"some*\"), true);\n// (1 hit)"}},"array-of-arrays-into-ast":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; generateAst &#x7D; from \"array-of-arrays-into-ast\";\n\nassert.deepEqual(generateAst([[1, 2, 3], [1, 2], [5]]), &#x7B;\n  1: [\n    &#x7B;\n      2: [\n        &#x7B;\n          3: [null],\n        &#x7D;,\n        null,\n      ],\n    &#x7D;,\n  ],\n  5: [null],\n&#x7D;);"}},"array-of-arrays-sort-by-col":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; sortByCol &#x7D; from \"array-of-arrays-sort-by-col\";\n\n// sort by second column, index number 1\nassert.deepEqual(sortByCol([[1, 9, 4], [1], [1, 9, 3], [1, 9, 2]], 1), [\n  [1, 9, 2],\n  [1, 9, 3],\n  [1, 9, 4],\n  [1],\n]);"},"sort-by-column.js":{"title":"Sort by a certain column","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; sortByCol &#x7D; from \"array-of-arrays-sort-by-col\";\n\n// Sort by a second element (column index === 1):\nassert.deepEqual(sortByCol([[1, 9, 0], [1], [1, 8, 2], [1, 7, 5]], 1), [\n  [1, 7, 5],\n  [1, 8, 2],\n  [1, 9, 0],\n  [1],\n]);\n// notice 7-8-9"}},"array-pull-all-with-glob":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; pull &#x7D; from \"array-pull-all-with-glob\";\n\nassert.deepEqual(\n  pull(\n    [\"keep_me\", \"name-1\", \"name-2\", \"name-jhkgdhgkhdfghdkghfdk\"],\n    [\"name-*\"]\n  ),\n  [\"keep_me\"]\n);"}},"arrayiffy-if-string":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; arrayiffy &#x7D; from \"arrayiffy-if-string\";\n\nassert.deepEqual(arrayiffy(\"aaa\"), [\"aaa\"]);\n\nassert.deepEqual(arrayiffy(\"\"), []);\n\nassert.equal(arrayiffy(true), true);\n\nassert.equal(arrayiffy(), undefined);"}},"ast-compare":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\n// Find out, does an object/array/string/nested-mix is a subset or equal to another input:\nassert.equal(\n  compare(\n    &#x7B;\n      a: &#x7B;\n        b: \"d\",\n        c: [],\n        e: \"f\",\n        g: \"h\",\n      &#x7D;,\n    &#x7D;,\n    &#x7B;\n      a: &#x7B;\n        b: \"d\",\n        c: [],\n      &#x7D;,\n    &#x7D;\n  ),\n  true\n);"},"compare-arrays.js":{"title":"Compare Arrays","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\nassert.equal(compare([\"a\", \"b\", \"c\"], [\"a\", \"b\"]), true);\n// true, because second is a subset of first\n\nassert.equal(compare([\"a\", \"b\", \"c\"], [\"b\", \"a\"]), false);\n// => false, because order is wrong\n\nassert.equal(compare([\"a\", \"b\"], [\"a\", \"b\", \"c\"]), false);\n// => false, because second is not a subset of first (it's opposite)\n\nassert.equal(\n  compare([&#x7B; a: \"b\" &#x7D;, &#x7B; c: \"d\" &#x7D;, &#x7B; e: \"f\" &#x7D;], [&#x7B; a: \"b\" &#x7D;, &#x7B; c: \"d\" &#x7D;]),\n  true\n);\n// => plain objects nested in arrays"},"compare-objects.js":{"title":"Compare Plain Objects","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\n// Find out, does an object/array/string/nested-mix is a subset or equal to another input:\nassert.equal(compare(&#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;, &#x7B; a: \"1\", b: \"2\" &#x7D;), true);\n// true, because second (smallObj) is subset of (or equal) first (bigObj).\n\nassert.equal(compare(&#x7B; a: \"1\", b: \"2\" &#x7D;, &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;), false);\n// => false, because second (smallObj) is not a subset (or equal) to first (bigObj)."},"compare-strings.js":{"title":"Compare Strings","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\nassert.equal(compare(\"a\\nb\", \"a\\nb\"), true);\n\nassert.equal(compare(\"a\", \"b\"), false);"},"opts-hungryForWhitespace.js":{"title":"`opts.hungryForWhitespace`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\n// by default, key values will be strictly matched using `===`\nassert.equal(\n  compare(\n    &#x7B; a: \"\\n\\n\\n\", b: \"\\t\\t\\t\", c: \"whatever\" &#x7D;,\n    &#x7B; a: \"\\r\\r\\r\", b: \"       \" &#x7D;,\n    &#x7B;\n      hungryForWhitespace: false,\n    &#x7D;\n  ),\n  false\n);\n\n// whitespace is matched leniently with the following option:\nassert.equal(\n  compare(\n    &#x7B; a: \"\\n\\n\\n\", b: \"\\t\\t\\t\", c: \"whatever\" &#x7D;,\n    &#x7B; a: \"\\r\\r\\r\", b: \"       \" &#x7D;,\n    &#x7B;\n      hungryForWhitespace: true,\n    &#x7D;\n  ),\n  true\n);\n\n// the fun doesn't stop here, any \"empty\" structures will be\n// reported as matching:\nassert.equal(\n  compare(\n    &#x7B; a: &#x7B; z: \"\\n\\n\\n\" &#x7D;, b: [\"\\t\\t\\t\"], c: \"whatever\" &#x7D;,\n    &#x7B; a: [[[[[\"\\r\\r\\r\"]]]]], b: &#x7B; c: &#x7B; d: \" \" &#x7D; &#x7D; &#x7D;,\n    &#x7B;\n      hungryForWhitespace: true, // <--- !\n    &#x7D;\n  ),\n  true // <--- !!!\n);\n// \"empty\" thing is:\n//   - string that trims to zero-length\n//   - array with zero or more whitespace strings only\n//   - plain object with zero or more keys with \"empty\" values\n//     (empty arrays, empty plain objects or empty strings)"},"opts-verboseWhenMismatches.js":{"title":"`opts.verboseWhenMismatches`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; compare &#x7D; from \"ast-compare\";\n\n// by default, returns a boolean without explanation\nassert.equal(\n  compare(\n    &#x7B; a: \"1\", b: \"2\" &#x7D;,\n    &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;,\n    &#x7B;\n      verboseWhenMismatches: false, // <---\n    &#x7D;\n  ),\n  false\n);\n\nassert.equal(\n  compare(\n    &#x7B; a: \"1\", b: \"2\" &#x7D;,\n    &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;,\n    &#x7B;\n      verboseWhenMismatches: true, // <---\n    &#x7D;\n  ),\n  'The given object has key \"c\" which the other-one does not have.'\n);\n\n// when opts.verboseWhenMismatches is enabled, a negative result is\n// string (explanation). A positive result is boolean \"true\".\nassert.equal(\n  compare(\n    &#x7B; a: \"1\", b: \"2\" &#x7D;,\n    &#x7B; a: \"1\", b: \"2\" &#x7D;,\n    &#x7B;\n      verboseWhenMismatches: true, // <---\n    &#x7D;\n  ),\n  true\n);"}},"ast-contains-only-empty-space":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; empty &#x7D; from \"ast-contains-only-empty-space\";\n\nassert.equal(\n  empty(&#x7B;\n    a: [\n      &#x7B;\n        x: &#x7B;\n          y: [\n            &#x7B;\n              z: [\"\\n\"],\n            &#x7D;,\n          ],\n        &#x7D;,\n      &#x7D;,\n    ],\n    b: [\"\\t\\t\\t  \"],\n    c: [\"\\n \\n\\n\"],\n    d: [\"\\t   \"],\n  &#x7D;),\n  true\n);"},"more-examples.js":{"title":"More Examples","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; empty &#x7D; from \"ast-contains-only-empty-space\";\n\nassert.equal(empty([&#x7B; content: &#x7B;&#x7D; &#x7D;]), true);\n\nassert.equal(empty([&#x7B; tag: \"style\" &#x7D;]), false);\n\n// Works on simple arrays as well:\nassert.equal(empty([\"   \", \" \"]), true);\n\n// Works on strings as well:\nassert.equal(empty(\"   \"), true);\n\n// Object keys that have values as null are considered empty:\nassert.equal(empty(&#x7B; a: null &#x7D;), true);"}},"ast-deep-contains":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deepContains &#x7D; from \"ast-deep-contains\";\n\nconst gathered = [];\nconst errors = [];\n\nconst reference = [\n  &#x7B; c: \"2\" &#x7D;, // will end up not used\n  &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;,\n  &#x7B; x: \"8\", y: \"9\", z: \"0\" &#x7D;,\n];\n\nconst structureToMatch = [\n  &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;, // matches but has different position in the source\n  &#x7B; x: \"8\", y: \"9\" &#x7D;, // \"z\" missing\n];\n\n// This program pre-matches first, then matches objects as a set-subset\ndeepContains(\n  reference,\n  structureToMatch,\n  (leftSideVal, rightSideVal) => &#x7B;\n    // This callback does the pre-matching and picks the key pairs for you.\n    // It's up to you what you will do with left- and right-side\n    // values - we normally feed them to unit test asserts but here we just push\n    // to array:\n    gathered.push([leftSideVal, rightSideVal]);\n  &#x7D;,\n  (err) => &#x7B;\n    errors.push(err);\n  &#x7D;\n);\n\n// imagine instead of pushing pairs into array, you fed them into assert\n// function in unit tests:\nassert.deepEqual(gathered, [\n  [\"1\", \"1\"],\n  [\"2\", \"2\"],\n  [\"3\", \"3\"],\n  [\"8\", \"8\"],\n  [\"9\", \"9\"],\n]);\nassert.equal(errors.length, 0);"}},"ast-delete-object":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deleteObj &#x7D; from \"ast-delete-object\";\n\n// if all keys in source object match target object's keys, the\n// source object gets deleted:\nassert.deepEqual(\n  deleteObj(\n    [\n      \"elem1\",\n      &#x7B;\n        findme1: \"zzz\",\n        findme2: \"yyy\",\n        somethingelse: \"qqq\",\n      &#x7D;,\n      \"elem2\",\n    ],\n    &#x7B;\n      findme1: \"zzz\",\n      findme2: \"yyy\",\n    &#x7D;\n  ),\n  [\"elem1\", \"elem2\"]\n);"},"opts-hungryForWhitespace.js":{"title":"`opts.hungryForWhitespace`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deleteObj &#x7D; from \"ast-delete-object\";\n\nassert.deepEqual(\n  deleteObj(\n    [\n      &#x7B; a: \"\\n\" &#x7D;, // that's empty\n      &#x7B;\n        key3: \"val3\",\n        key4: \"val4\",\n      &#x7D;,\n      &#x7B; b: \"   \" &#x7D;, // that's empty\n      &#x7B; c: \"\" &#x7D;, // that's empty\n    ],\n    &#x7B;&#x7D;, // empty thing to match again - we match \"empty\" vs \"empty\"\n    &#x7B; matchKeysStrictly: false, hungryForWhitespace: true &#x7D;\n  ),\n  [\n    &#x7B;\n      key3: \"val3\",\n      key4: \"val4\",\n    &#x7D;,\n  ]\n);\n\n// but\nassert.deepEqual(\n  deleteObj(\n    [\n      &#x7B; a: \"\\n\" &#x7D;, // that's empty\n      &#x7B;\n        key3: \"val3\",\n        key4: \"val4\",\n      &#x7D;,\n      &#x7B; b: \"   \" &#x7D;, // that's empty\n      &#x7B; c: \"\" &#x7D;, // that's empty\n    ],\n    &#x7B;&#x7D;, // empty thing to match again - we match \"empty\" vs \"empty\"\n    &#x7B; matchKeysStrictly: false, hungryForWhitespace: false &#x7D;\n  ),\n  [\n    &#x7B; a: \"\\n\" &#x7D;,\n    &#x7B;\n      key3: \"val3\",\n      key4: \"val4\",\n    &#x7D;,\n    &#x7B; b: \"   \" &#x7D;,\n    &#x7B; c: \"\" &#x7D;,\n  ]\n);\n// nothing happened because empty things were matched strictly, \"===\""},"opts-matchKeysStrictly.js":{"title":"`opts.matchKeysStrictly`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deleteObj &#x7D; from \"ast-delete-object\";\n\nconst source = [\n  \"elem1\",\n  &#x7B;\n    findme1: \"zzz\",\n    findme2: \"yyy\",\n    somethingelse: \"qqq\", // <--- this key will block deletion\n  &#x7D;,\n  \"elem2\",\n];\n\n// nothing happens - matching was strict\nassert.deepEqual(\n  deleteObj(\n    source,\n    &#x7B;\n      findme1: \"zzz\",\n      findme2: \"yyy\",\n    &#x7D;,\n    &#x7B;\n      matchKeysStrictly: true, // <--- strict matching\n    &#x7D;\n  ),\n  source\n);\n\n// but\nassert.deepEqual(\n  deleteObj(\n    source,\n    &#x7B;\n      findme1: \"zzz\",\n      findme2: \"yyy\",\n    &#x7D;,\n    &#x7B;\n      matchKeysStrictly: false,\n    &#x7D;\n  ),\n  [\"elem1\", \"elem2\"]\n);"}},"ast-get-object":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; getObj &#x7D; from \"ast-get-object\";\n\n// get - two input arguments\nassert.deepEqual(\n  getObj(\n    [\n      // <- search in this, the first argument, in this case, a nested array\n      &#x7B;\n        tag: \"meta\",\n        content: \"UTF-8\",\n        something: \"else\",\n      &#x7D;,\n      &#x7B;\n        tag: \"title\",\n        attrs: \"Text of the title\",\n      &#x7D;,\n    ],\n    &#x7B;\n      // <- search for this object, the second argument\n      tag: \"meta\",\n    &#x7D;\n  ),\n  [\n    &#x7B;\n      tag: \"meta\",\n      content: \"UTF-8\",\n      something: \"else\",\n    &#x7D;,\n  ]\n);\n\n// set - three input arguments\nassert.deepEqual(\n  getObj(\n    [\n      &#x7B;\n        tag: [\"two\", \"values\"],\n        content: \"UTF-8\",\n        something: \"else\",\n      &#x7D;,\n      &#x7B;\n        tag: \"title\",\n        attrs: \"Text of the title\",\n      &#x7D;,\n    ],\n    &#x7B;\n      tag: [\"two\", \"values\"],\n    &#x7D;,\n    [\n      &#x7B;\n        tag: [\"three\", \"values\", \"here\"],\n        content: \"UTF-8\",\n        something: \"else\",\n      &#x7D;,\n    ]\n  ),\n  [\n    &#x7B;\n      tag: [\"three\", \"values\", \"here\"], // <--- got updated\n      content: \"UTF-8\",\n      something: \"else\",\n    &#x7D;,\n    &#x7B;\n      tag: \"title\",\n      attrs: \"Text of the title\",\n    &#x7D;,\n  ]\n);"}},"ast-get-values-by-key":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; getByKey &#x7D; from \"ast-get-values-by-key\";\n\n// GETTER\n// ======\n\n// returns \"object-path\" notation paths where arrays use dots:\nassert.deepEqual(\n  getByKey(\n    &#x7B;\n      parsed: [\n        &#x7B;\n          tag: \"html\",\n        &#x7D;,\n      ],\n    &#x7D;,\n    \"tag\" // value to search for\n  ),\n  [&#x7B; val: \"html\", path: \"parsed.0.tag\" &#x7D;]\n);\n\n// SETTER\n// ======\n\nassert.deepEqual(\n  getByKey(\n    &#x7B;\n      parsed: [\n        &#x7B;\n          tag: \"html\",\n        &#x7D;,\n      ],\n      foo: &#x7B;\n        tag: null,\n      &#x7D;,\n      bar: &#x7B;\n        tag: null,\n      &#x7D;,\n    &#x7D;,\n    \"tag\", // value to search for\n    [123, 456] // pot of values to pick from (one result not enough)\n  ),\n  &#x7B;\n    parsed: [\n      &#x7B;\n        tag: 123,\n      &#x7D;,\n    ],\n    foo: &#x7B;\n      tag: 456,\n    &#x7D;,\n    bar: &#x7B;\n      tag: null, // value pot was depleted and there was nothing left to put here\n    &#x7D;,\n  &#x7D;\n);"},"real-use.js":{"title":"Replace all null's in keys `amount` with zero, but only under `orders`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; getByKey &#x7D; from \"ast-get-values-by-key\";\n\nconst source = &#x7B;\n  orders: [\n    &#x7B;\n      date: \"2020-09-26\",\n      amount: null, // replace\n      product: \"Bramble\",\n    &#x7D;,\n    &#x7B;\n      date: \"2020-09-26\",\n      amount: 2,\n      product: \"Croodle\",\n    &#x7D;,\n    &#x7B;\n      date: \"2020-09-26\",\n      amount: null, // replace\n      product: \"Zapple\",\n    &#x7D;,\n  ],\n&#x7D;;\n\n// first GET\nconst findings = getByKey(\n  source, // what to process\n  \"amount\" // what to look for\n);\nassert.deepEqual(findings, [\n  &#x7B; val: null, path: \"orders.0.amount\" &#x7D;,\n  &#x7B; val: 2, path: \"orders.1.amount\" &#x7D;,\n  &#x7B; val: null, path: \"orders.2.amount\" &#x7D;,\n]);\n\n// prepare replacement array for SET third input argument\nconst replacement = findings.map((&#x7B; val &#x7D;) => +val);\nassert.deepEqual(replacement, [0, 2, 0]);\n\n// then SET\nconst result = getByKey(\n  source, // what to process\n  \"amount\", // what to look for\n  replacement // pot of replacement values to consume (single-use, FIFO stack)\n);\nassert.deepEqual(result, &#x7B;\n  orders: [\n    &#x7B;\n      date: \"2020-09-26\",\n      amount: 0, // replace\n      product: \"Bramble\",\n    &#x7D;,\n    &#x7B;\n      date: \"2020-09-26\",\n      amount: 2,\n      product: \"Croodle\",\n    &#x7D;,\n    &#x7B;\n      date: \"2020-09-26\",\n      amount: 0, // replace\n      product: \"Zapple\",\n    &#x7D;,\n  ],\n&#x7D;);"},"wildcards.js":{"title":"Using wildcards (`matcher` api)","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; getByKey &#x7D; from \"ast-get-values-by-key\";\n\nconst source = &#x7B;\n  popsicles: 1,\n  tentacles: 0,\n  nested: [\n    &#x7B;\n      cutticles: \"yes\",\n    &#x7D;,\n  ],\n&#x7D;;\n\n// Two input arguments - getter:\nconst findings = getByKey(source, [\"*cles\"]);\n\nassert.deepEqual(findings, [\n  &#x7B;\n    val: 1,\n    path: \"popsicles\",\n  &#x7D;,\n  &#x7B;\n    val: 0,\n    path: \"tentacles\",\n  &#x7D;,\n  &#x7B;\n    val: \"yes\",\n    path: \"nested.0.cutticles\",\n  &#x7D;,\n]);\n\n// notice the path \"nested.0.cutticles\" is as per object-path notation -\n// it's not \"nested[0].cutticles\" as in \"normal\" JS paths\n\n// Three input arguments - setter:\nassert.deepEqual(getByKey(source, [\"*cles\"], [\"a\", \"b\", \"c\"]), &#x7B;\n  popsicles: \"a\",\n  tentacles: \"b\",\n  nested: [\n    &#x7B;\n      cutticles: \"c\",\n    &#x7D;,\n  ],\n&#x7D;);"}},"ast-is-empty":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isEmpty &#x7D; from \"ast-is-empty\";\n\nassert.equal(\n  isEmpty(&#x7B;\n    a: \"\",\n  &#x7D;),\n  true\n);\n\nassert.equal(\n  isEmpty(&#x7B;\n    a: [\"\"],\n    b: &#x7B;\n      c: &#x7B;\n        d: \"\",\n      &#x7D;,\n    &#x7D;,\n  &#x7D;),\n  true\n);\n\nassert.equal(\n  isEmpty([\n    &#x7B;\n      a: [\"\"],\n      b: &#x7B; c: &#x7B; d: \"\" &#x7D; &#x7D;,\n    &#x7D;,\n    \"\",\n    [\"\", \"\", \"\"],\n  ]),\n  true\n);"}},"ast-loose-compare":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; looseCompare &#x7D; from \"ast-loose-compare\";\n\nassert.equal(\n  looseCompare(\n    &#x7B;\n      a: &#x7B;\n        b: \"d\",\n        c: [],\n        e: \"f\",\n        g: \"h\",\n      &#x7D;,\n    &#x7D;,\n    &#x7B;\n      a: &#x7B;\n        b: \"d\",\n        c: [],\n      &#x7D;,\n    &#x7D;\n  ),\n  true\n);"},"more-examples.js":{"title":"More Examples","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; looseCompare &#x7D; from \"ast-loose-compare\";\n\nassert.equal(\n  looseCompare(&#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;, &#x7B; a: \"1\", b: \"2\" &#x7D;),\n  true\n);\n// true, because second (smallObj) is subset of (or equal) first (bigObj).\n\nassert.equal(\n  looseCompare(&#x7B; a: \"1\", b: \"2\" &#x7D;, &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;),\n  false\n);\n// false, because second (smallObj) is not a subset (or equal) to first (bigObj).\n\nassert.equal(looseCompare([\"a\", \"b\", \"c\"], [\"a\", \"b\"]), true);\n// true, because second is a subset of first\n\nassert.equal(looseCompare([\"a\", \"b\"], [\"a\", \"b\", \"c\"]), false);\n// false, because second is not a subset of first\n\nassert.equal(looseCompare(\"aaaaa\\nbbbbb\", \"aaaaa\\nbbbbb\"), true);\n// true, because strings are equal\n\nassert.equal(looseCompare(&#x7B; a: \"a\" &#x7D;), undefined);\n// the second argument is missing"},"whitespace.js":{"title":"Empty Values","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; looseCompare &#x7D; from \"ast-loose-compare\";\n\n// both values are empty - they trim() to zero-length\nassert.equal(\n  looseCompare(\n    &#x7B;\n      a: \"a\",\n      b: \"\\n \\n\\n\",\n    &#x7D;,\n    &#x7B;\n      a: \"a\",\n      b: \"\\t\\t \\t\",\n    &#x7D;\n  ),\n  true\n);"}},"ast-monkey":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; find &#x7D; from \"ast-monkey\";\n\nassert.deepEqual(\n  find(\n    &#x7B;\n      a1: &#x7B;\n        b1: \"c1\",\n      &#x7D;,\n      a2: &#x7B;\n        b2: \"c2\",\n      &#x7D;,\n      z1: &#x7B;\n        x1: \"y1\",\n      &#x7D;,\n    &#x7D;,\n    &#x7B; key: \"a*\" &#x7D;\n  ),\n  [\n    &#x7B;\n      index: 1,\n      key: \"a1\",\n      val: &#x7B;\n        b1: \"c1\",\n      &#x7D;,\n      path: [1],\n    &#x7D;,\n    &#x7B;\n      index: 3,\n      key: \"a2\",\n      val: &#x7B;\n        b2: \"c2\",\n      &#x7D;,\n      path: [3],\n    &#x7D;,\n  ]\n);"}},"ast-monkey-traverse":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; traverse &#x7D; from \"ast-monkey-traverse\";\n\nconst paths = [];\nconst source = &#x7B;\n  a: &#x7B;\n    foo: &#x7B;\n      bar: [\n        &#x7B;\n          foo: \"c\",\n        &#x7D;,\n      ],\n      d: &#x7B;\n        e: &#x7B;\n          foo: \"f\",\n        &#x7D;,\n      &#x7D;,\n    &#x7D;,\n  &#x7D;,\n&#x7D;;\n\ntraverse(source, (key, val, innerObj) => &#x7B;\n  // if currently an object is traversed, you get both \"key\" and \"val\"\n  // if it's array, only \"key\" is present, \"val\" is undefined\n  const current = val !== undefined ? val : key;\n  if (\n    // it's object (not array)\n    val !== undefined &&\n    // and has the key we need\n    key === \"foo\"\n  ) &#x7B;\n    // push the path to array in the outer scope\n    paths.push(innerObj.path);\n  &#x7D;\n  return current;\n&#x7D;);\n\n// notice object-path notation \"a.foo.bar.0.foo\" - array segments use dots too:\nassert.deepEqual(paths, [\"a.foo\", \"a.foo.bar.0.foo\", \"a.foo.d.e.foo\"]);"},"compatible-with-object-path.js":{"title":"Compatible With `object-path`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport op from \"object-path\";\nimport &#x7B; traverse &#x7D; from \"ast-monkey-traverse\";\n\nconst input = &#x7B; a: \"1\", b: [&#x7B; c: \"2\" &#x7D;] &#x7D;;\nObject.freeze(input); // let's freeze it, just for fun\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => &#x7B;\n  const current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n&#x7D;);\n\n// notice the object-path notation is \"b.0.c\" not \"b[0].c\"\nassert.deepEqual(result1, [\"a\", \"b\", \"b.0\", \"b.0.c\"]);\n\n// each reported path is fully compatible with `object-path` get() method\nassert.deepEqual(op.get(input, \"a\"), \"1\");\nassert.deepEqual(op.get(input, \"b\"), [&#x7B; c: \"2\" &#x7D;]);\nassert.deepEqual(op.get(input, \"b.0\"), &#x7B; c: \"2\" &#x7D;);\nassert.deepEqual(op.get(input, \"b.0.c\"), \"2\");"},"stopping.js":{"title":"Stop","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; traverse &#x7D; from \"ast-monkey-traverse\";\n\nconst input = &#x7B; a: \"1\", b: &#x7B; c: \"2\" &#x7D; &#x7D;;\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => &#x7B;\n  const current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n&#x7D;);\nassert.deepEqual(result1, [\"a\", \"b\", \"b.c\"]);\n\n// now let's stop the traversal at path \"b\" (that's real\n// path, how object-path would reference it)\nconst result2 = [];\ntraverse(input, (key1, val1, innerObj, stop) => &#x7B;\n  const current = val1 !== undefined ? val1 : key1;\n  result2.push(innerObj.path);\n  if (innerObj.path === \"b\") &#x7B;\n    stop.now = true; // <---------------- !!!!!!!!!!\n  &#x7D;\n  return current;\n&#x7D;);\nassert.deepEqual(result2, [\"a\", \"b\"]);"}},"ast-monkey-traverse-with-lookahead":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; traverse &#x7D; from \"ast-monkey-traverse-with-lookahead\";\n\nconst input = [\n  &#x7B;\n    a: \"b\",\n  &#x7D;,\n  &#x7B;\n    c: \"d\",\n  &#x7D;,\n  &#x7B;\n    e: \"f\",\n  &#x7D;,\n];\nconst gathered = [];\n\n// callback interface:\ntraverse(\n  input,\n  (key1, val1, innerObj) => &#x7B;\n    gathered.push([key1, val1, innerObj]);\n  &#x7D;,\n  1 // <---------------- report one upcoming value\n);\n\nassert.deepEqual(gathered, [\n  // ===================\n  [\n    &#x7B;\n      a: \"b\",\n    &#x7D;,\n    undefined,\n    &#x7B;\n      depth: 0,\n      path: \"0\",\n      parent: [\n        &#x7B;\n          a: \"b\",\n        &#x7D;,\n        &#x7B;\n          c: \"d\",\n        &#x7D;,\n        &#x7B;\n          e: \"f\",\n        &#x7D;,\n      ],\n      parentType: \"array\",\n      next: [\n        [\n          \"a\",\n          \"b\",\n          &#x7B;\n            depth: 1,\n            path: \"0.a\",\n            parent: &#x7B;\n              a: \"b\",\n            &#x7D;,\n            parentType: \"object\",\n          &#x7D;,\n        ],\n      ],\n    &#x7D;,\n  ],\n  // ===================\n  [\n    \"a\",\n    \"b\",\n    &#x7B;\n      depth: 1,\n      path: \"0.a\",\n      parent: &#x7B;\n        a: \"b\",\n      &#x7D;,\n      parentType: \"object\",\n      next: [\n        [\n          &#x7B;\n            c: \"d\",\n          &#x7D;,\n          undefined,\n          &#x7B;\n            depth: 0,\n            path: \"1\",\n            parent: [\n              &#x7B;\n                a: \"b\",\n              &#x7D;,\n              &#x7B;\n                c: \"d\",\n              &#x7D;,\n              &#x7B;\n                e: \"f\",\n              &#x7D;,\n            ],\n            parentType: \"array\",\n          &#x7D;,\n        ],\n      ],\n    &#x7D;,\n  ],\n  // ===================\n  [\n    &#x7B;\n      c: \"d\",\n    &#x7D;,\n    undefined,\n    &#x7B;\n      depth: 0,\n      path: \"1\",\n      parent: [\n        &#x7B;\n          a: \"b\",\n        &#x7D;,\n        &#x7B;\n          c: \"d\",\n        &#x7D;,\n        &#x7B;\n          e: \"f\",\n        &#x7D;,\n      ],\n      parentType: \"array\",\n      next: [\n        [\n          \"c\",\n          \"d\",\n          &#x7B;\n            depth: 1,\n            path: \"1.c\",\n            parent: &#x7B;\n              c: \"d\",\n            &#x7D;,\n            parentType: \"object\",\n          &#x7D;,\n        ],\n      ],\n    &#x7D;,\n  ],\n  // ===================\n  [\n    \"c\",\n    \"d\",\n    &#x7B;\n      depth: 1,\n      path: \"1.c\",\n      parent: &#x7B;\n        c: \"d\",\n      &#x7D;,\n      parentType: \"object\",\n      next: [\n        [\n          &#x7B;\n            e: \"f\",\n          &#x7D;,\n          undefined,\n          &#x7B;\n            depth: 0,\n            path: \"2\",\n            parent: [\n              &#x7B;\n                a: \"b\",\n              &#x7D;,\n              &#x7B;\n                c: \"d\",\n              &#x7D;,\n              &#x7B;\n                e: \"f\",\n              &#x7D;,\n            ],\n            parentType: \"array\",\n          &#x7D;,\n        ],\n      ],\n    &#x7D;,\n  ],\n  // ===================\n  [\n    &#x7B;\n      e: \"f\",\n    &#x7D;,\n    undefined,\n    &#x7B;\n      depth: 0,\n      path: \"2\",\n      parent: [\n        &#x7B;\n          a: \"b\",\n        &#x7D;,\n        &#x7B;\n          c: \"d\",\n        &#x7D;,\n        &#x7B;\n          e: \"f\",\n        &#x7D;,\n      ],\n      parentType: \"array\",\n      next: [\n        [\n          \"e\",\n          \"f\",\n          &#x7B;\n            depth: 1,\n            path: \"2.e\",\n            parent: &#x7B;\n              e: \"f\",\n            &#x7D;,\n            parentType: \"object\",\n          &#x7D;,\n        ],\n      ],\n    &#x7D;,\n  ],\n  // ===================\n  [\n    \"e\",\n    \"f\",\n    &#x7B;\n      depth: 1,\n      path: \"2.e\",\n      parent: &#x7B;\n        e: \"f\",\n      &#x7D;,\n      parentType: \"object\",\n      next: [],\n    &#x7D;,\n  ],\n  // ===================\n]);"}},"ast-monkey-util":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; pathNext, pathPrev, pathUp &#x7D; from \"ast-monkey-util\";\n\nassert.equal(pathNext(\"9.children.3\"), \"9.children.4\");\n\nassert.equal(pathPrev(\"9.children.33\"), \"9.children.32\");\n\nassert.equal(pathUp(\"9.children.1.children.2\"), \"9.children.1\");"}},"bitbucket-slug":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; bSlug &#x7D; from \"bitbucket-slug\";\n\nassert.equal(\n  bSlug(\"# Let's backwards-engineer BitBucket anchor link slug algorithm\"),\n  \"markdown-header-lets-backwards-engineer-bitbucket-anchor-link-slug-algorithm\"\n);"}},"charcode-is-valid-xml-name-character":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  isProduction4,\n  isProduction4a,\n  validFirstChar,\n  validSecondCharOnwards,\n&#x7D; from \"charcode-is-valid-xml-name-character\";\n\n// Spec: https://www.w3.org/TR/REC-xml/#NT-NameStartChar\n\nassert.equal(isProduction4(\"Z\"), true);\nassert.equal(isProduction4(\"?\"), false);\n\nassert.equal(isProduction4a(\"?\"), false);\nassert.equal(isProduction4a(\"-\"), true);\n\nassert.equal(validFirstChar(\"a\"), true);\nassert.equal(validFirstChar(\"1\"), false);\n\nassert.equal(validSecondCharOnwards(\"a\"), true);\nassert.equal(validSecondCharOnwards(\"?\"), false);"}},"check-types-mini":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; checkTypesMini &#x7D; from \"check-types-mini\";\n\nassert.throws(() => &#x7B;\n  checkTypesMini(\n    checkTypesMini(\n      &#x7B;\n        // object to check\n        option1: \"setting1\",\n        option2: \"false\",\n        option3: false,\n      &#x7D;,\n      &#x7B;\n        // reference defaults object\n        option1: \"setting1\",\n        option2: false,\n        option3: false,\n      &#x7D;\n    ),\n    /not boolean but string/g\n  );\n&#x7D;);"}},"codsen-parser":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; cparser &#x7D; from \"codsen-parser\";\n\nassert.deepEqual(cparser(\"<br>z</a>\"), [\n  &#x7B;\n    type: \"tag\",\n    kind: \"inline\",\n    tagName: \"br\",\n    tagNameStartsAt: 1,\n    tagNameEndsAt: 3,\n    closing: false,\n    void: true,\n    pureHTML: true,\n    recognised: true,\n    start: 0,\n    end: 4,\n    value: \"<br>\",\n    attribs: [],\n    children: [],\n  &#x7D;,\n  &#x7B;\n    type: \"text\",\n    start: 4,\n    end: 5,\n    value: \"z\",\n  &#x7D;,\n  &#x7B;\n    type: \"tag\",\n    kind: \"inline\",\n    tagName: \"a\",\n    tagNameStartsAt: 7,\n    tagNameEndsAt: 8,\n    closing: true,\n    void: false,\n    pureHTML: true,\n    recognised: true,\n    start: 5,\n    end: 9,\n    value: \"</a>\",\n    attribs: [],\n    children: [],\n  &#x7D;,\n]);"}},"codsen-tokenizer":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; tokenizer &#x7D; from \"codsen-tokenizer\";\n\nconst gathered = [];\n\n// it operates from a callback, like Array.prototype.forEach()\ntokenizer(`<td nowrap>`, &#x7B;\n  tagCb: (obj) => &#x7B;\n    gathered.push(obj);\n  &#x7D;,\n&#x7D;);\n\nassert.deepEqual(gathered, [\n  &#x7B;\n    type: \"tag\",\n    start: 0,\n    end: 11,\n    value: \"<td nowrap>\",\n    tagNameStartsAt: 1,\n    tagNameEndsAt: 3,\n    tagName: \"td\",\n    recognised: true,\n    closing: false,\n    void: false,\n    pureHTML: true,\n    kind: null,\n    attribs: [\n      &#x7B;\n        attribName: \"nowrap\",\n        attribNameRecognised: true,\n        attribNameStartsAt: 4,\n        attribNameEndsAt: 10,\n        attribOpeningQuoteAt: null,\n        attribClosingQuoteAt: null,\n        attribValueRaw: null,\n        attribValue: [],\n        attribValueStartsAt: null,\n        attribValueEndsAt: null,\n        attribStarts: 4,\n        attribEnds: 10,\n        attribLeft: 2,\n      &#x7D;,\n    ],\n  &#x7D;,\n]);"}},"color-shorthand-hex-to-six-digit":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; conv &#x7D; from \"color-shorthand-hex-to-six-digit\";\n\n// converts shorthand hex color codes within strings (imagine that could be\n// email template source code):\nassert.equal(\n  conv(\"aaaa #f0c zzzz\\n\\t\\t\\t#fc0\"),\n  \"aaaa #ff00cc zzzz\\n\\t\\t\\t#ffcc00\"\n);\n\n// converts shorthand hex colour codes within plain objects:\nassert.deepEqual(\n  conv(&#x7B;\n    a: \"#ffcc00\",\n    b: \"#f0c\",\n    c: \"text\",\n  &#x7D;),\n  &#x7B;\n    a: \"#ffcc00\",\n    b: \"#ff00cc\",\n    c: \"text\",\n  &#x7D;\n);\n\n// converts shorthand hex colour codes within arrays:\nassert.deepEqual(conv([\"#fc0\", \"#f0c\", \"text\", \"\"]), [\n  \"#ffcc00\",\n  \"#ff00cc\",\n  \"text\",\n  \"\",\n]);\n\n// converts shorthand hex colour codes within nested spaghetti's:\nassert.deepEqual(\n  conv([[[[[[&#x7B; x: [\"#fc0\"] &#x7D;]]]]], &#x7B; z: \"#f0c\" &#x7D;, [\"text\"], &#x7B; y: \"\" &#x7D;]),\n  [[[[[[&#x7B; x: [\"#ffcc00\"] &#x7D;]]]]], &#x7B; z: \"#ff00cc\" &#x7D;, [\"text\"], &#x7B; y: \"\" &#x7D;]\n);\n\n// in all other cases it silently returns the input:\nassert.equal(conv(null), null);"}},"csv-sort":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; sort &#x7D; from \"csv-sort\";\n\n// Sorts double-entry bookkeeping CSV's - bank statements for example\n// see https://en.wikipedia.org/wiki/Double-entry_bookkeeping\n\nassert.deepEqual(\n  sort(`Acc Number,Description,Debit Amount,Credit Amount,Balance,\n123456,Client #1 payment,,1000,1940\n123456,Bought carpet,30,,950\n123456,Bought table,10,,940\n123456,Bought pens,10,,1000\n123456,Bought chairs,20,,980\n`),\n  &#x7B;\n    res: [\n      [\"Acc Number\", \"Description\", \"Debit Amount\", \"Credit Amount\", \"Balance\"],\n      [\"123456\", \"Client #1 payment\", \"\", \"1000\", \"1940\"],\n      [\"123456\", \"Bought table\", \"10\", \"\", \"940\"],\n      [\"123456\", \"Bought carpet\", \"30\", \"\", \"950\"],\n      [\"123456\", \"Bought chairs\", \"20\", \"\", \"980\"],\n      [\"123456\", \"Bought pens\", \"10\", \"\", \"1000\"],\n    ],\n    msgContent: null,\n    msgType: null,\n  &#x7D;\n);\n// you'll have to join elements and lines from the array yourself"}},"csv-split-easy":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; splitEasy &#x7D; from \"csv-split-easy\";\n\nassert.deepEqual(\n  splitEasy(\n    'Product Name,Main Price,Discounted Price\\nTestarossa (Type F110),\"100,000\",\"90,000\"\\nF50,\"2,500,000\",\"1,800,000\"'\n  ),\n  [\n    [\"Product Name\", \"Main Price\", \"Discounted Price\"],\n    [\"Testarossa (Type F110)\", \"100000\", \"90000\"],\n    [\"F50\", \"2500000\", \"1800000\"],\n  ]\n);"}},"detect-is-it-html-or-xhtml":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; detectIsItHTMLOrXhtml &#x7D; from \"detect-is-it-html-or-xhtml\";\n\nassert.equal(\n  detectIsItHTMLOrXhtml(\n    `<img src=\"some.jpg\" width=\"zzz\" height=\"zzz\" border=\"0\" style=\"display:block;\" alt=\"zzz\"/>`\n  ),\n  \"xhtml\"\n);"}},"detect-templating-language":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; detectLang &#x7D; from \"detect-templating-language\";\n\n// detects Nunjucks\nassert.deepEqual(\n  detectLang(`<div>&#x7B;% if something %&#x7D;x&#x7B;% else %&#x7D;y&#x7B;% endif %&#x7D;</div>`),\n  &#x7B; name: \"Nunjucks\" &#x7D;\n);\n\n// detects JSP (Java Server Pages)\nassert.deepEqual(\n  detectLang(\n    `<div><c:set var=\"someList\" value=\"\\$&#x7B;jspProp.someList&#x7D;\" /></div>`\n  ),\n  &#x7B; name: \"JSP\" &#x7D;\n);"}},"detergent":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; det, opts, version &#x7D; from \"detergent\";\n\n// on default setting, widow removal and encoding are enabled:\nassert.equal(det(\"clean this text £\").res, \"clean this text&nbsp;&pound;\");"}},"easy-replace":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; er &#x7D; from \"easy-replace\";\n\nassert.equal(\n  er(\n    \"&nBsp; NBsp &nbSP NbsP;\",\n    &#x7B;\n      leftOutsideNot: \"\",\n      leftOutside: \"\",\n      leftMaybe: [\"&\", \"&amp;\"],\n      searchFor: \"nbsp\",\n      rightMaybe: \";\",\n      rightOutside: \"\",\n      rightOutsideNot: \"\",\n      i: &#x7B;\n        searchFor: true,\n      &#x7D;,\n    &#x7D;,\n    \"&nbsp;\"\n  ),\n  \"&nbsp; &nbsp; &nbsp; &nbsp;\"\n);"}},"edit-package-json":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; set, del &#x7D; from \"edit-package-json\";\n\n// edit JSON as string\nassert.equal(\n  set(\n    `&#x7B;\n  \"name\": \"test\",\n  \"dependencies\": &#x7B;\n    \"ranges-apply\": \"^2.0.0\",\n    \"string-left-right\": \"^2.3.30\"\n  &#x7D;,\n  \"devDependencies\": &#x7B;&#x7D;\n&#x7D;`,\n    \"dependencies.ranges-apply\", // path to amend\n    \"^3.2.2\" // new value\n  ),\n  `&#x7B;\n  \"name\": \"test\",\n  \"dependencies\": &#x7B;\n    \"ranges-apply\": \"^3.2.2\",\n    \"string-left-right\": \"^2.3.30\"\n  &#x7D;,\n  \"devDependencies\": &#x7B;&#x7D;\n&#x7D;`\n);\n\n// edit from JSON string\nassert.equal(\n  del(\n    `&#x7B;\n  \"name\": \"test\",\n  \"dependencies\": &#x7B;\n    \"ranges-apply\": \"^2.0.0\",\n    \"string-left-right\": \"^2.3.30\"\n  &#x7D;,\n  \"devDependencies\": &#x7B;&#x7D;\n&#x7D;`,\n    \"devDependencies\" // path to delete\n  ),\n  `&#x7B;\n  \"name\": \"test\",\n  \"dependencies\": &#x7B;\n    \"ranges-apply\": \"^2.0.0\",\n    \"string-left-right\": \"^2.3.30\"\n  &#x7D;\n&#x7D;`\n);"},"mini-del.js":{"title":"Minimal example, `del()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; del &#x7D; from \"edit-package-json\";\n\n// edit JSON as string\nassert.equal(\n  del(\n    `&#x7B;\n  \"a\": \"b\",\n  \"c\": \"d\"\n&#x7D;`,\n    \"c\" // path to delete\n  ),\n  `&#x7B;\n  \"a\": \"b\"\n&#x7D;`\n);"},"mini-set.js":{"title":"Minimal example, `set()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; set &#x7D; from \"edit-package-json\";\n\n// edit JSON as string\nassert.equal(\n  set(\n    `&#x7B;\n  \"a\": \"b\",\n  \"c\": &#x7B;\n    \"d\": \"e\"\n  &#x7D;\n&#x7D;`,\n    \"c.d\", // path\n    \"x\" // value to put\n  ),\n  `&#x7B;\n  \"a\": \"b\",\n  \"c\": &#x7B;\n    \"d\": \"x\"\n  &#x7D;\n&#x7D;`\n);"}},"email-all-chars-within-ascii":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; within &#x7D; from \"email-all-chars-within-ascii\";\n\n// enforces all characters to be within ASCII:\nassert.deepEqual(within(`<div>Motörhead</div>`), [\n  &#x7B;\n    type: \"character\",\n    line: 1,\n    column: 9,\n    positionIdx: 8,\n    value: \"ö\",\n    codePoint: 246,\n    UTF32Hex: \"00f6\",\n  &#x7D;,\n]);\n\n// enforces line lengths (500 is best for email):\nassert.deepEqual(within(`abcde`, &#x7B; lineLength: 3 &#x7D;), [\n  &#x7B;\n    type: \"line length\",\n    line: 1,\n    column: 5,\n    positionIdx: 5,\n    value: 5,\n  &#x7D;,\n]);"}},"email-comb":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; comb, defaults, version &#x7D; from \"email-comb\";\n\n// aptly named classes:\nconst source = `<head>\n<style type=\"text/css\">\n.unused1[z] &#x7B;a:1;&#x7D;\n.used[z] &#x7B;a:2;&#x7D;\n</style>\n</head>\n<body class=\"  used  \"><a class=\"used unused3\">z</a>\n</body>\n`;\n\nconst intended = `<head>\n<style type=\"text/css\">\n.used[z] &#x7B;a:2;&#x7D;\n</style>\n</head>\n<body class=\"used\"><a class=\"used\">z</a>\n</body>\n`;\n\nassert.equal(comb(source).result, intended);"}},"emlint":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; Linter &#x7D; from \"emlint\";\nconst linter = new Linter();\n\n// Correct \"not\" type Outlook conditional would be:\n// <!--[if !mso]><!-->\n//   <span class=\"foo\">z</span>\n// <!--<![endif]-->\n\n// We have a \"not\" type opening but \"only\" type\n// closing:\nconst messages = linter.verify(\n  `<!--[if !mso]><!-->\n  <span class=\"foo\">z</span>\n<![endif]-->`,\n  &#x7B;\n    rules: &#x7B;\n      all: 2,\n    &#x7D;,\n  &#x7D;\n);\n\nassert.deepEqual(messages, [\n  &#x7B;\n    line: 3,\n    column: 1,\n    severity: 2,\n    ruleId: \"comment-mismatching-pair\",\n    message: `Add \"<!--\".`,\n    idxFrom: 49,\n    idxTo: 61,\n    fix: &#x7B;\n      ranges: [[49, 49, \"<!--\"]],\n    &#x7D;,\n    keepSeparateWhenFixing: true,\n  &#x7D;,\n]);"}},"generate-atomic-css":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  genAtomic,\n  version,\n  headsAndTails,\n  extractFromToSource,\n&#x7D; from \"generate-atomic-css\";\n\nassert.deepEqual(\n  genAtomic(\n    `a\n\n/* GENERATE-ATOMIC-CSS-CONFIG-STARTS\n.pb$$$ &#x7B; padding-bottom: $$$px !important; &#x7D; | 5 | 10\n\n.mt$$$ &#x7B; margin-top: $$$px !important; &#x7D; | 1\nGENERATE-ATOMIC-CSS-CONFIG-ENDS\nGENERATE-ATOMIC-CSS-CONTENT-STARTS */\n\ntralala\n\n/* GENERATE-ATOMIC-CSS-CONTENT-ENDS */\n\nz`,\n    &#x7B;\n      includeConfig: false,\n      includeHeadsAndTails: false,\n    &#x7D;\n  ),\n  &#x7B;\n    log: &#x7B; count: 8 &#x7D;,\n    result: `a\n\n.pb5  &#x7B; padding-bottom:  5px !important; &#x7D;\n.pb6  &#x7B; padding-bottom:  6px !important; &#x7D;\n.pb7  &#x7B; padding-bottom:  7px !important; &#x7D;\n.pb8  &#x7B; padding-bottom:  8px !important; &#x7D;\n.pb9  &#x7B; padding-bottom:  9px !important; &#x7D;\n.pb10 &#x7B; padding-bottom: 10px !important; &#x7D;\n\n.mt0 &#x7B; margin-top:   0 !important; &#x7D;\n.mt1 &#x7B; margin-top: 1px !important; &#x7D;\n\nz\n`,\n  &#x7D;\n);"}},"html-all-known-attributes":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; allHtmlAttribs &#x7D; from \"html-all-known-attributes\";\n\nassert.equal(allHtmlAttribs.has(\"href\"), true);\n\nassert.equal(allHtmlAttribs.size, 702);\n\n// iterating:\nconst gathered = [];\nfor (const x of allHtmlAttribs) &#x7B;\n  // push first three\n  if (gathered.length < 3) &#x7B;\n    gathered.push(x);\n  &#x7D;\n&#x7D;\nassert.deepEqual(gathered, [\"abbr\", \"accept\", \"accept-charset\"]);"}},"html-crush":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; crush, defaults, version &#x7D; from \"html-crush\";\n\nassert.equal(\n  crush(\n    `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td>\n      hi\n    </td>\n  </tr>\n</table>`,\n    &#x7B; removeLineBreaks: true &#x7D;\n  ).result,\n  `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td> hi\n</td></tr></table>`\n);"}},"html-entities-not-email-friendly":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  notEmailFriendly,\n  notEmailFriendlySetOnly,\n  notEmailFriendlyLowercaseSetOnly,\n  notEmailFriendlyMinLength,\n  notEmailFriendlyMaxLength,\n&#x7D; from \"html-entities-not-email-friendly\";\n\n// it's object, mapping entity names to numeric equivalents\nassert.equal(Object.keys(notEmailFriendly).length, 1841);\n\n// it's a Set, only listing the bad entity names\nassert.equal(notEmailFriendlySetOnly.size, 1841);\n\n// is &GreaterTilde; email-friendly?\nassert.equal(notEmailFriendlySetOnly.has(\"GreaterTilde\"), true);\n// no, use numeric entity\n\n// is &nbsp; email-friendly?\nassert.equal(notEmailFriendlySetOnly.has(\"nbsp\"), false);\n// yes, it's OK"}},"html-img-alt":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; alts &#x7D; from \"html-img-alt\";\n\n// string-in, string-out:\nassert.equal(\n  alts('zzz<img src=\"spacer.gif\" >zzz'),\n  'zzz<img src=\"spacer.gif\" alt=\"\" >zzz'\n);"}},"html-table-patcher":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; patcher &#x7D; from \"html-table-patcher\";\n\nassert.equal(\n  patcher(\n    `<table>\n&#x7B;% if customer.details.hasAccount %&#x7D;\n<tr>\n  <td>\n    variation #1\n  </td>\n</tr>\n&#x7B;% else %&#x7D;\n<tr>\n  <td>\n    variation #2\n  </td>\n</tr>\n&#x7B;% endif %&#x7D;\n</table>`\n  ).result,\n  `<table>\n\n<tr>\n  <td>\n    &#x7B;% if customer.details.hasAccount %&#x7D;\n  </td>\n</tr>\n\n<tr>\n  <td>\n    variation #1\n  </td>\n</tr>\n\n<tr>\n  <td>\n    &#x7B;% else %&#x7D;\n  </td>\n</tr>\n\n<tr>\n  <td>\n    variation #2\n  </td>\n</tr>\n\n<tr>\n  <td>\n    &#x7B;% endif %&#x7D;\n  </td>\n</tr>\n\n</table>`\n);"}},"is-char-suitable-for-html-attr-name":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isAttrNameChar &#x7D; from \"is-char-suitable-for-html-attr-name\";\n\n// Follows the spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\nassert.equal(isAttrNameChar(\"a\"), true);\nassert.equal(isAttrNameChar(\"?\"), false);"}},"is-html-attribute-closing":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isAttrClosing &#x7D; from \"is-html-attribute-closing\";\n\nconst str = `<a href=\"zzz\" target=\"_blank\" style=\"color: black;\">`;\n\n// <a href=\"zzz\" target=\"_blank\" ...\n//                      ^\n//                  index 21\n\n// <a href=\"zzz\" target=\"_blank\" ...\n//                             ^\n//                         index 28\n\nassert.equal(\n  isAttrClosing(\n    str, // reference string\n    21, // known opening (or in absence of a quote, a start of a value)\n    28 // we ask, is this a closing on the attribute?\n  ),\n  true // the answer\n);"},"broken-1.js":{"title":"Broken #1","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isAttrClosing &#x7D; from \"is-html-attribute-closing\";\n\nassert.equal(\n  isAttrClosing(\n    `<a href=\"z' click here</a>`,\n    //       ^ ^\n    //       | \\\n    //       |  \\_________________________________\n    //       |                                   |\n    8, // known opening                          |\n    10 // is this an attribute closing at index 10?\n  ),\n  true\n);\n// => yes, indeed a closing of an attribute (not counting\n// the code is broken)"},"broken-2.js":{"title":"Broken #2","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isAttrClosing &#x7D; from \"is-html-attribute-closing\";\n\nassert.equal(\n  isAttrClosing(\n    `<a b = = = \"c\" d = = = 'e'>`,\n    //          ^ ^\n    //          | |\n    //          | L_______________________________\n    //          |                                |\n    11, // known opening                         |\n    13 // is this an attribute closing at index 13?\n  ),\n  true\n);\n// => true - indeed a closing of an attribute (not counting\n// the code is broken)"},"broken-3.js":{"title":"Broken #3","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isAttrClosing &#x7D; from \"is-html-attribute-closing\";\n\n// Correct code:\n// <img class=\"so-called\" alt=\"!\" border='10'/>\n\n// Broken code:\nconst str = `<img class=\"so-called \"alt !' border 10'/>`;\n//                      ^\n//                known opening at idx 11\n\nassert.equal(isAttrClosing(str, 11, 22), true);\n// => true - indeed a closing of an attribute\n\nassert.equal(isAttrClosing(str, 11, 28), false);\n// => not a closing of an attribute\n\nassert.equal(isAttrClosing(str, 11, 39), false);\n// => not a closing of an attribute"}},"is-html-tag-opening":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isOpening &#x7D; from \"is-html-tag-opening\";\n\nconst text = `<span>a < b<span>`;\n\n// opening span tag's opening\nassert.equal(isOpening(text, 0), true);\n\n// unencoded bracket between a and b\nassert.equal(isOpening(text, 8), false);\n\n// closing span tag's opening\nassert.equal(isOpening(text, 11), true);"},"opts.allowCustomTagNames.js":{"title":"`opts.allowCustomTagNames`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isOpening &#x7D; from \"is-html-tag-opening\";\n\n// recognised tag\nassert.equal(isOpening(`abc <div>`, 4), true);\n//                          ^\n\n// unrecognised tag\nassert.equal(isOpening(`abc <zzz>`, 4), false);\n//                          ^\n\n// but with opts.allowCustomTagNames result is \"true\"\nassert.equal(\n  isOpening(`abc <zzz>`, 4, &#x7B;\n    allowCustomTagNames: true,\n  &#x7D;),\n  true\n);"},"opts.skipOpeningBracket.js":{"title":"`opts.skipOpeningBracket`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isOpening &#x7D; from \"is-html-tag-opening\";\n\n// missing opening bracket:\nassert.equal(isOpening(`<a>div class=\"w-64 h-3\">`, 3), false);\n//                         ^\n// result is instant \"false\" because `idx` has to be\n// on an opening bracket (besides checking for tag name\n// being present and recognised and attributes being present)\n\n// but with opts.skipOpeningBracket we remove the requirement\n// that \"idx\" has to be on a bracket - algorithm detects valid\n// tag name and the attribute that follows and recognise it's a\n// tag starting:\nassert.equal(\n  isOpening(`<a>div class=\"w-64 h-3\">`, 3, &#x7B;\n    skipOpeningBracket: true,\n  &#x7D;),\n  true\n);"}},"is-language-code":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isLangCode &#x7D; from \"is-language-code\";\n\nassert.deepEqual(isLangCode(\"de-419-DE\"), &#x7B;\n  res: false,\n  message: 'Two region subtags, \"419\" and \"de\".',\n&#x7D;);\n\nassert.deepEqual(isLangCode(\"sr-Latn\"), &#x7B;\n  res: true,\n  message: null,\n&#x7D;);"},"various.js":{"title":"Various examples","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isLangCode &#x7D; from \"is-language-code\";\n\nassert.equal(isLangCode(\"de\").res, true);\n// => true because it's a German language code\n\nassert.equal(isLangCode(\"fr\").res, true);\n// => true because it's a French language code\n\nassert.equal(isLangCode(\"ja\").res, true);\n// => true because it's a Japanese language code\n\nassert.equal(isLangCode(\"zzz\").res, false);\n// => false - unrecognised. npm package \"ietf-language-tag-regex\" would fail this\n\nassert.equal(isLangCode(\"1\").res, false);\n// => false - not recognised language code\n\nassert.equal(isLangCode(\"x-klingon\").res, true);\n// => true - private use\n\nassert.equal(isLangCode(\"x-whatever\").res, true);\n// => true - private use\n\nassert.equal(isLangCode(\"zh-Hant\").res, true);\n// => true - Chinese written using the Traditional Chinese script\n\nassert.equal(isLangCode(\"zh-cmn-Hans-CN\").res, true);\n// => true - Chinese, Mandarin, Simplified script, as used in China\n\nassert.equal(isLangCode(\"zh-Hans-CN\").res, true);\n// => true - Chinese written using the Simplified script as used in mainland China\n\nassert.equal(isLangCode(\"sr-Latn-RS\").res, true);\n// => true - Serbian written using the Latin script as used in Serbia\n\nassert.equal(isLangCode(\"sl-rozaj\").res, true);\n// => true - Resian dialect of Slovenian\n\nassert.equal(isLangCode(\"sl-nedis\").res, true);\n// => true - Nadiza dialect of Slovenian\n\nassert.equal(isLangCode(\"de-CH-1901\").res, true);\n// => true - German as used in Switzerland using the 1901 variant [orthography]\n\nassert.equal(isLangCode(\"sl-IT-nedis\").res, true);\n// => true - Slovenian as used in Italy, Nadiza dialect\n\nassert.equal(isLangCode(\"hy-Latn-IT-arevela\").res, true);\n// => true - Eastern Armenian written in Latin script, as used in Italy\n\nassert.equal(isLangCode(\"en-US\").res, true);\n// => true - English as used in the United States\n\nassert.equal(isLangCode(\"de-CH-x-phonebk\").res, true);\n// => true - private use subtag (x-)\n\nassert.equal(isLangCode(\"az-Arab-x-AZE-derbend\").res, true);\n// => true - private use subtag\n\nassert.equal(isLangCode(\"x-whatever\").res, true);\n// => true - private use subtag using singleton x-\n\nassert.equal(isLangCode(\"qaa-Qaaa-QM-x-southern\").res, true);\n// => true\n\nassert.equal(isLangCode(\"de-Qaaa\").res, true);\n// => true - private use script subtag (Qaaa)\n\nassert.equal(isLangCode(\"sr-Latn-QM\").res, true);\n// => true - Serbian, Latin script, private region QM\n\nassert.equal(isLangCode(\"en-US-u-islamcal\").res, true);\n// => true - tag with extension\n\nassert.equal(isLangCode(\"zh-CN-a-myext-x-private\").res, true);\n// => true - tag with extension\n\nassert.equal(isLangCode(\"en-a-myext-b-another\").res, true);\n// => true - tag with extension\n\nassert.equal(isLangCode(\"de-419-DE\").res, false);\n// => false - two region tags\n\nassert.equal(isLangCode(\"a-DE\").res, false);\n// => false - use of a single-character subtag in primary position\n\nassert.equal(isLangCode(\"ar-a-aaa-b-bbb-a-ccc\").res, false);\n// => false - two extensions with same single-letter prefix"}},"is-media-descriptor":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isMediaD &#x7D; from \"is-media-descriptor\";\n\nassert.deepEqual(isMediaD(\"screeen\"), [\n  &#x7B;\n    idxFrom: 0,\n    idxTo: 7,\n    message: `Did you mean \"screen\"?`,\n    fix: &#x7B;\n      ranges: [[0, 7, \"screen\"]],\n    &#x7D;,\n  &#x7D;,\n]);"}},"is-relative-uri":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isRel &#x7D; from \"is-relative-uri\";\n\nassert.deepEqual(isRel(\".../resource.txt\"), &#x7B;\n  res: false,\n  message: `Three consecutive dots.`,\n&#x7D;);"}},"js-row-num":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fixRowNums &#x7D; from \"js-row-num\";\n\n// sets line number to 002 because it's on row number two\nassert.equal(\n  fixRowNums(`const foo = \"bar\";\\n console.log(\\`0 foo = \\$&#x7B;foo&#x7D;\\`)`),\n  `const foo = \"bar\";\\n console.log(\\`002 foo = \\$&#x7B;foo&#x7D;\\`)`\n);"}},"json-comb-core":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// STEP #1\n// =======\n\n// calculate the schema - superset of all possible keys used across\n// all JSON files\nconst schema = getKeysetSync([\n  &#x7B;\n    // <- object #1\n    a: \"a\",\n    b: \"c\",\n    c: &#x7B;\n      d: \"d\",\n      e: \"e\",\n    &#x7D;,\n  &#x7D;,\n  &#x7B;\n    // <- object #2\n    a: \"a\",\n  &#x7D;,\n  &#x7B;\n    // <- object #3\n    c: &#x7B;\n      f: \"f\",\n    &#x7D;,\n  &#x7D;,\n]);\n\nassert.deepEqual(schema, &#x7B;\n  a: false,\n  b: false,\n  c: &#x7B;\n    d: false,\n    e: false,\n    f: false,\n  &#x7D;,\n&#x7D;);\n\n// STEP #2\n// =======\n\n// now we can normalise the object #2 for example:\nassert.deepEqual(\n  enforceKeysetSync(\n    &#x7B;\n      // <- object #2\n      a: \"a\",\n    &#x7D;,\n    schema\n  ),\n  &#x7B;\n    a: \"a\",\n    b: false,\n    c: &#x7B;\n      d: false,\n      e: false,\n      f: false,\n    &#x7D;,\n  &#x7D;\n);"},"enforceKeyset.js":{"title":"Asynchronous `enforceKeyset()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// Let's enforce the keyset using previously-calculated schema.\n\n// Let's use an async IIFE to trigger the action and let us use await:\n(async () => &#x7B;\n  // let's create three plain objects, each somewhat overlapping with others:\n  const obj1 = &#x7B;\n    b: [\n      &#x7B;\n        c: \"ccc\",\n        d: \"ddd\",\n      &#x7D;,\n    ],\n    a: \"aaa\",\n  &#x7D;;\n  const obj2 = &#x7B;\n    a: \"ccc\",\n    e: \"eee\",\n  &#x7D;;\n  const obj3 = &#x7B;\n    a: \"zzz\",\n  &#x7D;;\n  // calculate the schema:\n  const schema = await getKeyset([obj1, obj2, obj3]);\n\n  assert.deepEqual(schema, &#x7B;\n    a: false,\n    b: [\n      &#x7B;\n        c: false,\n        d: false,\n      &#x7D;,\n    ],\n    e: false,\n  &#x7D;);\n\n  assert.deepEqual(await enforceKeyset(obj1, schema), &#x7B;\n    a: \"aaa\",\n    b: [\n      &#x7B;\n        c: \"ccc\",\n        d: \"ddd\",\n      &#x7D;,\n    ],\n    e: false, // <------ new key added\n  &#x7D;);\n\n  assert.deepEqual(await enforceKeyset(obj2, schema), &#x7B;\n    a: \"ccc\",\n    b: [\n      // <------- new key added\n      &#x7B;\n        c: false,\n        d: false,\n      &#x7D;,\n    ],\n    e: \"eee\",\n  &#x7D;);\n\n  assert.deepEqual(await enforceKeyset(obj3, schema), &#x7B;\n    a: \"zzz\",\n    b: [\n      // <------- new key added\n      &#x7B;\n        c: false,\n        d: false,\n      &#x7D;,\n    ],\n    e: false, // <------- new key added\n  &#x7D;);\n&#x7D;)();"},"enforceKeysetSync.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nconst schema = &#x7B;\n  a: false,\n  b: false,\n  c: &#x7B;\n    d: false,\n    e: false,\n    f: false,\n  &#x7D;,\n&#x7D;;\n\nassert.deepEqual(\n  enforceKeysetSync(\n    &#x7B;\n      c: &#x7B; d: \"x\" &#x7D;,\n    &#x7D;,\n    schema\n  ),\n  &#x7B;\n    a: false,\n    b: false,\n    c: &#x7B;\n      d: \"x\",\n      e: false,\n      f: false,\n    &#x7D;,\n  &#x7D;\n);"},"findUnusedSync-2.js":{"title":"Synchronous `findUnusedSync()` - example #2","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// This function will work on arrays of both normalised and not normalised object sets.\nassert.deepEqual(\n  findUnusedSync([\n    &#x7B;\n      a: [\n        &#x7B;\n          k: false,\n          l: false,\n          m: false,\n        &#x7D;,\n        &#x7B;\n          k: \"k\",\n          l: false,\n          m: \"m\",\n        &#x7D;,\n      ],\n      b: \"bbb1\",\n      c: false,\n    &#x7D;,\n    &#x7B;\n      a: [\n        &#x7B;\n          k: \"k\",\n          l: false,\n          m: \"m\",\n        &#x7D;,\n        &#x7B;\n          k: \"k\",\n          l: false,\n          m: \"m\",\n        &#x7D;,\n      ],\n      b: \"bbb2\",\n      c: false,\n    &#x7D;,\n    &#x7B; b: false &#x7D;,\n    &#x7B; c: false &#x7D;,\n  ]),\n  [\"c\", \"a[0].l\"]\n);"},"findUnusedSync.js":{"title":"Synchronous `findUnusedSync()` - example #1","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nassert.deepEqual(\n  findUnusedSync([\n    &#x7B;\n      // <- object #1\n      a: false,\n      b: \"bbb1\",\n      c: false,\n    &#x7D;,\n    &#x7B;\n      // <- object #2\n      a: \"aaa\",\n      b: \"bbb2\",\n      c: false,\n    &#x7D;,\n    &#x7B;&#x7D;, // <- object #3\n  ]),\n  [\"c\"]\n);"},"getKeyset.js":{"title":"Asynchronous `getKeyset()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// Let's calculate the schema of the following arrays of plain objects,\n// and do it asynchronously.\n\n// Let's use an async IIFE to trigger the action and let us use await:\n(async () => &#x7B;\n  // First, prepare array of promises:\n  const source = [\n    &#x7B;\n      a: \"a\",\n      b: \"c\",\n      c: &#x7B;\n        d: \"d\",\n        e: \"e\",\n      &#x7D;,\n    &#x7D;,\n    &#x7B;\n      a: \"a\",\n    &#x7D;,\n    &#x7B;\n      c: &#x7B;\n        f: \"f\",\n      &#x7D;,\n    &#x7D;,\n  ].map((el) => Promise.resolve(el));\n\n  // use async/await to avoid using .then\n  assert.deepEqual(await getKeyset(source), &#x7B;\n    a: false,\n    b: false,\n    c: &#x7B;\n      d: false,\n      e: false,\n      f: false,\n    &#x7D;,\n  &#x7D;);\n&#x7D;)();"},"getKeysetSync.js":{"title":"Synchronous `getKeysetSync()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nconst schema = getKeysetSync([\n  &#x7B;\n    // <- object #1\n    a: \"a\",\n    b: \"c\",\n    c: &#x7B;\n      d: \"d\",\n      e: \"e\",\n    &#x7D;,\n  &#x7D;,\n  &#x7B;\n    // <- object #2\n    a: \"a\",\n  &#x7D;,\n  &#x7B;\n    // <- object #3\n    c: &#x7B;\n      f: \"f\",\n    &#x7D;,\n  &#x7D;,\n]);\n\nassert.deepEqual(schema, &#x7B;\n  a: false,\n  b: false,\n  c: &#x7B;\n    d: false,\n    e: false,\n    f: false,\n  &#x7D;,\n&#x7D;);"},"noNewKeys-2.js":{"title":"Synchronous `noNewKeysSync()` - example #2","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nassert.deepEqual(\n  noNewKeysSync(\n    &#x7B;\n      // <- input we're checking\n      z: [\n        &#x7B;\n          a: \"a\",\n          b: \"b\",\n          c: \"c\",\n        &#x7D;,\n        &#x7B;\n          a: false,\n          b: false,\n          c: \"c\",\n        &#x7D;,\n      ],\n    &#x7D;,\n    &#x7B;\n      // <- reference keyset\n      z: [\n        &#x7B;\n          a: \"a\",\n          b: \"b\",\n        &#x7D;,\n        &#x7B;\n          a: false,\n          b: false,\n        &#x7D;,\n      ],\n    &#x7D;\n  ),\n  [\"z[0].c\", \"z[1].c\"]\n);"},"noNewKeys.js":{"title":"Synchronous `noNewKeysSync()` - example #1","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\n// We are going to catch the rogue key `b`:\n\nassert.deepEqual(\n  noNewKeysSync(\n    &#x7B;\n      // <- input we're checking\n      a: \"a\",\n      b: \"b\",\n      c: \"c\",\n    &#x7D;,\n    &#x7B;\n      // <- reference keyset\n      a: \"aaa\",\n      c: \"ccc\",\n    &#x7D;\n  ),\n  [\"b\"] // list of rogue paths\n);"},"sortAllObjectsSync.js":{"title":"Synchronous `getKeysetSync()`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n&#x7D; from \"json-comb-core\";\n\nassert.deepEqual(\n  sortAllObjectsSync(&#x7B;\n    a: \"a\",\n    c: \"c\",\n    b: \"b\",\n  &#x7D;),\n  &#x7B;\n    a: \"a\",\n    b: \"b\",\n    c: \"c\",\n  &#x7D;\n);"}},"json-variables":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; jVar &#x7D; from \"json-variables\";\n\nassert.deepEqual(\n  jVar(&#x7B;\n    a: \"some text %%_var1.key1.0_%% more text %%_var2.key2.key3.1_%%\",\n    b: \"something\",\n    var1: &#x7B; key1: [\"value1\"] &#x7D;,\n    var2: &#x7B; key2: &#x7B; key3: [\"\", \"value2\"] &#x7D; &#x7D;,\n  &#x7D;),\n  &#x7B;\n    a: \"some text value1 more text value2\",\n    b: \"something\",\n    var1: &#x7B; key1: [\"value1\"] &#x7D;,\n    var2: &#x7B; key2: &#x7B; key3: [\"\", \"value2\"] &#x7D; &#x7D;,\n  &#x7D;\n);"}},"lerna-clean-changelogs":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; cleanChangelogs &#x7D; from \"lerna-clean-changelogs\";\n\n// are all values equal to null:\nassert.equal(\n  cleanChangelogs(`# Change Log\n\nAll notable changes to this project will be documented in this file.\nSee [Conventional Commits](https://conventionalcommits.org) for commit guidelines.\n\n## 2.9.2 (2018-12-27)\n\n\n\n\n\n\n\n**Note:** Version bump only for package ranges-apply\n\n\n\n## [2.9.1](https://gitlab.com/codsen/codsen/tree/master/packages/ranges-apply/compare/ranges-apply@2.9.0...ranges-apply@2.9.1) (2018-12-27)\n\n**Note:** Version bump only for package ranges-apply\n\n## 2.9.0 (2018-12-26)\n\n### Bug Fixes\n\n* aaa\n\n### Features\n\n* bbb\n\n`).res,\n  //\n  //\n  //\n  // output:\n  `# Change Log\n\nAll notable changes to this project will be documented in this file.\nSee [Conventional Commits](https://conventionalcommits.org) for commit guidelines.\n\n## 2.9.0 (2018-12-26)\n\n### Bug Fixes\n\n- aaa\n\n### Features\n\n- bbb\n`\n);"}},"line-column-mini":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; lineCol, getLineStartIndexes &#x7D; from \"line-column-mini\";\n\n// index 14 is letter \"k\" on the fourth line:\nassert.deepEqual(lineCol(\"abc\\ndef\\r\\nghi\\njkl\", 14), &#x7B;\n  line: 4,\n  col: 2,\n&#x7D;);\n\n// ---------------------------------------------------------\n\n// if you know you might query multiple times, use caching\nconst lineIndexes = getLineStartIndexes(\"abc\\ndef\\r\\nghi\\njkl\");\nassert.deepEqual(lineCol(lineIndexes, 14), &#x7B;\n  line: 4,\n  col: 2,\n&#x7D;);\n// other queries will be by magnitude faster:\nassert.deepEqual(lineCol(lineIndexes, 15), &#x7B;\n  line: 4,\n  col: 3,\n&#x7D;);\n\n// by the way...\nassert.deepEqual(lineCol(lineIndexes, 99), null);"}},"object-all-values-equal-to":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; allEq &#x7D; from \"object-all-values-equal-to\";\n\n// are all values equal to null:\nassert.equal(allEq(&#x7B; a: null, c: null &#x7D;, null), true);\n// yes\n\n// are all values equal to \"false\":\nassert.equal(allEq(&#x7B; a: false, c: \"zzz\" &#x7D;, false), false);\n// no\n\n// are all values equal to \"false\"?\nassert.equal(\n  allEq(\n    &#x7B;\n      a: &#x7B;\n        b: false,\n        c: [\n          &#x7B;\n            d: false,\n            e: false,\n          &#x7D;,\n          &#x7B;\n            g: false,\n          &#x7D;,\n        ],\n      &#x7D;,\n      c: false,\n    &#x7D;,\n    false // reference value to check\n  ),\n  true // answer is, yes\n);"}},"object-boolean-combinations":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; combinations &#x7D; from \"object-boolean-combinations\";\n\nassert.deepEqual(\n  combinations(&#x7B;\n    a: true,\n    b: false,\n    c: true,\n  &#x7D;),\n  [\n    &#x7B; a: false, b: false, c: false &#x7D;,\n    &#x7B; a: true, b: false, c: false &#x7D;,\n    &#x7B; a: false, b: true, c: false &#x7D;,\n    &#x7B; a: true, b: true, c: false &#x7D;,\n    &#x7B; a: false, b: false, c: true &#x7D;,\n    &#x7B; a: true, b: false, c: true &#x7D;,\n    &#x7B; a: false, b: true, c: true &#x7D;,\n    &#x7B; a: true, b: true, c: true &#x7D;,\n  ]\n);\n// you get 2^n plain objects in an array"}},"object-delete-key":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deleteKey &#x7D; from \"object-delete-key\";\n\n// deleting key 'c', with value 'd'\nassert.deepEqual(\n  deleteKey(\n    &#x7B;\n      a: \"b\",\n      c: \"d\",\n    &#x7D;,\n    &#x7B;\n      key: \"c\",\n      val: \"d\",\n    &#x7D;\n  ),\n  &#x7B; a: \"b\" &#x7D;\n);\n\n// deleting key 'b' with value - array ['c', 'd']\nassert.deepEqual(\n  deleteKey(\n    &#x7B;\n      a: &#x7B; e: [&#x7B; b: [\"c\", \"d\"] &#x7D;] &#x7D;,\n      b: [\"c\", \"d\"],\n    &#x7D;,\n    &#x7B;\n      key: \"b\",\n      val: [\"c\", \"d\"],\n    &#x7D;\n  ),\n  &#x7B;&#x7D;\n);\n// notice program cleaned after itself, it didn't leave empty \"a\" key"},"by-key-only.js":{"title":"Deletion by the key only","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deleteKey &#x7D; from \"object-delete-key\";\n\nassert.deepEqual(\n  deleteKey(\n    &#x7B;\n      a: \"a\",\n      b: \"jlfghdjkhkdfhgdf\",\n      c: [&#x7B; b: \"weuhreorhelhgljdhflghd\" &#x7D;],\n    &#x7D;,\n    &#x7B;\n      key: \"b\",\n    &#x7D;\n  ),\n  &#x7B; a: \"a\" &#x7D;\n);"},"by-value-only.js":{"title":"Deletion by the value only","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deleteKey &#x7D; from \"object-delete-key\";\n\nassert.deepEqual(\n  deleteKey(\n    &#x7B;\n      a: \"a\",\n      skldjfslfl: \"x\",\n      c: [&#x7B; dlfgjdlkjlfgjhfg: \"x\" &#x7D;],\n    &#x7D;,\n    &#x7B;\n      val: \"x\",\n    &#x7D;\n  ),\n  &#x7B; a: \"a\" &#x7D;\n);\n\n// same but without cleanup:\nassert.deepEqual(\n  deleteKey(\n    &#x7B;\n      a: \"a\",\n      skldjfslfl: \"x\",\n      c: [&#x7B; dlfgjdlkjlfgjhfg: \"x\" &#x7D;],\n    &#x7D;,\n    &#x7B;\n      val: \"x\",\n      cleanup: false,\n    &#x7D;\n  ),\n  &#x7B;\n    a: \"a\",\n    c: [&#x7B;&#x7D;], // <--- !\n  &#x7D;\n);"},"disable-cleanup.js":{"title":"Disable the cleanup which would otherwise happen after deletion","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deleteKey &#x7D; from \"object-delete-key\";\n\nassert.deepEqual(\n  deleteKey(\n    &#x7B;\n      a: &#x7B; e: [&#x7B; b: &#x7B; c: \"d\" &#x7D; &#x7D;] &#x7D;,\n      b: &#x7B; c: \"d\" &#x7D;,\n    &#x7D;,\n    &#x7B;\n      key: \"b\",\n      val: &#x7B; c: \"d\" &#x7D;,\n      cleanup: false,\n    &#x7D;\n  ),\n  &#x7B; a: &#x7B; e: [&#x7B;&#x7D;] &#x7D; &#x7D;\n);"},"wildcards.js":{"title":"Wildcards","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deleteKey &#x7D; from \"object-delete-key\";\n\nassert.deepEqual(\n  deleteKey(\n    &#x7B;\n      a: [\"beep\", \"\", \"c\", \"boop\"],\n      bap: \"bap\",\n    &#x7D;,\n    &#x7B;\n      key: \"b*p\",\n      only: \"array\",\n    &#x7D;\n  ),\n  &#x7B;\n    a: [\"\", \"c\"],\n    bap: \"bap\",\n  &#x7D;\n);"}},"object-fill-missing-keys":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fillMissing &#x7D; from \"object-fill-missing-keys\";\n\n// deleting key 'c', with value 'd'\nassert.deepEqual(\n  fillMissing(\n    &#x7B;\n      // input object that could have came from JSON\n      b: \"b\",\n    &#x7D;,\n    &#x7B;\n      // schema reference object\n      a: false,\n      b: false,\n      c: false,\n    &#x7D;\n  ),\n  &#x7B;\n    // patched result\n    a: false,\n    b: \"b\",\n    c: false,\n  &#x7D;\n);"},"do-not-fill.js":{"title":"An option to not fill the paths if they contain placeholders","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fillMissing &#x7D; from \"object-fill-missing-keys\";\n\nassert.deepEqual(\n  fillMissing(\n    &#x7B;\n      // input object\n      a: &#x7B;\n        b: false, // <---- we don't want to automatically normalise this key\n        x: \"x\",\n      &#x7D;,\n      z: \"z\",\n    &#x7D;,\n    &#x7B;\n      // reference schema object\n      a: &#x7B;\n        b: &#x7B;\n          c: false,\n          d: false,\n        &#x7D;,\n        x: false,\n      &#x7D;,\n      z: false,\n    &#x7D;,\n    &#x7B;\n      doNotFillThesePathsIfTheyContainPlaceholders: [\"a.b\"],\n    &#x7D;\n  ),\n  &#x7B;\n    a: &#x7B;\n      b: false, // <---\n      x: \"x\",\n    &#x7D;,\n    z: \"z\",\n  &#x7D;\n);"},"truncation.js":{"title":"Truncation upon request, to minimize the object footprint","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fillMissing &#x7D; from \"object-fill-missing-keys\";\n\nassert.deepEqual(\n  fillMissing(\n    &#x7B;\n      // input object\n      a: &#x7B;\n        b: &#x7B;\n          // this object in \"b\"'s value will be removed and set to placeholder \"false\"\n          c: false,\n          d: false,\n        &#x7D;,\n        x: &#x7B;\n          // this too\n          y: false,\n        &#x7D;,\n      &#x7D;,\n      z: \"z\",\n    &#x7D;,\n    &#x7B;\n      // schema object\n      a: &#x7B;\n        b: &#x7B;\n          c: false,\n          d: false,\n        &#x7D;,\n        x: false,\n      &#x7D;,\n      z: false,\n    &#x7D;,\n    &#x7B;\n      // settings\n      doNotFillThesePathsIfTheyContainPlaceholders: [\"lalala\", \"a.b\", \"a.x\"],\n    &#x7D;\n  ),\n  &#x7B;\n    // result\n    a: &#x7B;\n      b: false,\n      x: false,\n    &#x7D;,\n    z: \"z\",\n  &#x7D;\n);"},"useNullAsExplicitFalse.js":{"title":"`opts.useNullAsExplicitFalse`","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fillMissing &#x7D; from \"object-fill-missing-keys\";\n\n// on\nassert.deepEqual(\n  fillMissing(\n    &#x7B;\n      // object we're working on\n      a: null,\n    &#x7D;,\n    &#x7B;\n      // reference schema\n      a: [\"z\"],\n    &#x7D;,\n    &#x7B;\n      // options\n      useNullAsExplicitFalse: true, // <--- !\n    &#x7D;\n  ),\n  &#x7B;\n    // result\n    a: null,\n  &#x7D;\n);\n\n// off\nassert.deepEqual(\n  fillMissing(\n    &#x7B;\n      // object we're working on\n      a: null,\n    &#x7D;,\n    &#x7B;\n      // reference schema\n      a: [\"z\"],\n    &#x7D;,\n    &#x7B;\n      // options\n      useNullAsExplicitFalse: false, // <--- !\n    &#x7D;\n  ),\n  &#x7B;\n    // result\n    a: [\"z\"],\n  &#x7D;\n);"},"using-placeholder-true.js":{"title":"Using placeholder to cause the value population","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fillMissing &#x7D; from \"object-fill-missing-keys\";\n\nassert.deepEqual(\n  fillMissing(\n    &#x7B;\n      // object we work upon\n      a: &#x7B;\n        b: true, // <-- not placeholder but lower in data hierarchy (boolean)\n        x: \"x\",\n      &#x7D;,\n      z: \"z\",\n    &#x7D;,\n    &#x7B;\n      // reference (schema) object\n      a: &#x7B;\n        b: &#x7B;\n          c: false,\n          d: false,\n        &#x7D;,\n        x: false,\n      &#x7D;,\n      z: false,\n    &#x7D;,\n    &#x7B;\n      doNotFillThesePathsIfTheyContainPlaceholders: [\"a.b\"],\n    &#x7D;\n  ),\n  &#x7B;\n    a: &#x7B;\n      b: &#x7B;\n        c: false, // <---- values added!\n        d: false, // <---- values added!\n      &#x7D;,\n      x: \"x\",\n    &#x7D;,\n    z: \"z\",\n  &#x7D;\n);"}},"object-flatten-all-arrays":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; flattenAllArrays &#x7D; from \"object-flatten-all-arrays\";\n\nassert.deepEqual(\n  flattenAllArrays(&#x7B;\n    a: \"a\",\n    b: \"b\",\n    c: [\n      &#x7B;\n        b: \"b\",\n        a: \"a\",\n      &#x7D;,\n      &#x7B;\n        d: \"d\",\n        c: \"c\",\n      &#x7D;,\n    ],\n  &#x7D;),\n  &#x7B;\n    a: \"a\",\n    b: \"b\",\n    c: [\n      &#x7B;\n        a: \"a\",\n        b: \"b\",\n        c: \"c\",\n        d: \"d\",\n      &#x7D;,\n    ],\n  &#x7D;\n);"}},"object-flatten-referencing":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; flattenReferencing &#x7D; from \"object-flatten-referencing\";\n\nassert.deepEqual(\n  flattenReferencing(\n    &#x7B;\n      key1: \"val11.val12\",\n      key2: \"val21.val22\",\n    &#x7D;,\n    &#x7B;\n      key1: \"Contact us\",\n      key2: \"Tel. 0123456789\",\n    &#x7D;\n  ),\n  &#x7B;\n    key1: \"%%_val11.val12_%%\",\n    key2: \"%%_val21.val22_%%\",\n  &#x7D;\n);"}},"object-merge-advanced":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; mergeAdvanced &#x7D; from \"object-merge-advanced\";\n\nassert.deepEqual(\n  mergeAdvanced(\n    &#x7B;\n      a: [\"c\"],\n      m: \"n\",\n    &#x7D;,\n    &#x7B;\n      a: \"b\",\n      k: \"l\",\n    &#x7D;,\n    &#x7B;\n      ignoreKeys: [\"a\"],\n    &#x7D;\n  ),\n  &#x7B;\n    a: [\"c\"],\n    k: \"l\",\n    m: \"n\",\n  &#x7D;\n);"}},"object-no-new-keys":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; noNewKeys &#x7D; from \"object-no-new-keys\";\n\nassert.deepEqual(\n  noNewKeys(\n    &#x7B;\n      a: &#x7B;\n        b: \"b\",\n        c: \"c\",\n      &#x7D;,\n      x: \"y\",\n    &#x7D;,\n    &#x7B;\n      a: &#x7B;\n        c: \"z\",\n      &#x7D;,\n    &#x7D;\n  ),\n  [\"a.b\", \"x\"]\n);"}},"object-set-all-values-to":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; setAllValuesTo &#x7D; from \"object-set-all-values-to\";\n\nassert.deepEqual(\n  setAllValuesTo(&#x7B;\n    a: \"a\",\n    b: \"b\",\n    c: \"c\",\n    d: \"d\",\n  &#x7D;),\n  &#x7B;\n    a: false,\n    b: false,\n    c: false,\n    d: false,\n  &#x7D;\n);\n\n// you can change the default \"false\" to something else:\nassert.deepEqual(\n  setAllValuesTo(\n    &#x7B;\n      a: \"a\",\n      b: \"b\",\n      c: \"c\",\n      d: \"d\",\n    &#x7D;,\n    \"x\"\n  ),\n  &#x7B;\n    a: \"x\",\n    b: \"x\",\n    c: \"x\",\n    d: \"x\",\n  &#x7D;\n);"}},"ranges-apply":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\nconst ranges = [\n  [4, 19, \"bad grey wolf\"],\n  [35, 43, \"little Red Riding Hood\"],\n];\nassert.equal(\n  rApply(oldString, ranges),\n  \"The bad grey wolf jumps over the little Red Riding Hood.\"\n);"}},"ranges-crop":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rCrop &#x7D; from \"ranges-crop\";\n\nassert.deepEqual(\n  rCrop(\n    [\n      [2, 3],\n      [9, 10, \"bad grey wolf\"],\n      [1, 2],\n    ],\n    7\n  ),\n  [[1, 3]] // sorted, merged and cropped\n);"}},"ranges-ent-decode":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rEntDecode &#x7D; from \"ranges-ent-decode\";\n\n// see codsen.com/ranges/\nassert.deepEqual(rEntDecode(\"a &#x26; b &amp; c\"), [\n  [2, 8, \"&\"], // <--- that's Ranges notation, instructing to replace\n  [11, 16, \"&\"],\n]);"}},"ranges-invert":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rInvert &#x7D; from \"ranges-invert\";\n\nassert.deepEqual(\n  rInvert(\n    [\n      [3, 5],\n      [5, 7],\n    ],\n    9 // string length needed to set the boundary\n  ),\n  [\n    [0, 3],\n    [7, 9],\n  ]\n);"}},"ranges-is-index-within":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isIndexWithin &#x7D; from \"ranges-is-index-within\";\n\nassert.equal(\n  isIndexWithin(8, [\n    [1, 2],\n    [5, 10],\n  ]),\n  true\n);\n\nassert.equal(\n  isIndexWithin(12, [\n    [1, 2],\n    [5, 10],\n  ]),\n  false\n);"}},"ranges-iterate":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rIterate &#x7D; from \"ranges-iterate\";\n\n// Ranges in the following example \"punches out\" a \"hole\" from `a` to `g`\n// (included), replacing it with `xyz`. That's what gets iterated.\n\nconst gathered = [];\n\n// a callback-based interface:\nrIterate(\"abcdefghij\", [[0, 7, \"xyz\"]], (&#x7B; i, val &#x7D;) => &#x7B;\n  gathered.push(`i = $&#x7B;i&#x7D;; val = $&#x7B;val&#x7D;`);\n&#x7D;);\n\nassert.deepEqual(gathered, [\n  \"i = 0; val = x\",\n  \"i = 1; val = y\",\n  \"i = 2; val = z\",\n  \"i = 3; val = h\",\n  \"i = 4; val = i\",\n  \"i = 5; val = j\",\n]);"}},"ranges-merge":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rMerge &#x7D; from \"ranges-merge\";\n\n// joining edges:\nassert.deepEqual(\n  rMerge([\n    [1, 2],\n    [2, 3],\n    [9, 10],\n  ]),\n  [\n    [1, 3],\n    [9, 10],\n  ]\n);\n\n// an overlap:\nassert.deepEqual(\n  rMerge([\n    [1, 5],\n    [2, 10],\n  ]),\n  [[1, 10]]\n);"}},"ranges-offset":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rOffset &#x7D; from \"ranges-offset\";\n\nassert.deepEqual(\n  rOffset(\n    [\n      [3, 5],\n      [8, 7],\n    ],\n    10\n  ),\n  [\n    [13, 15],\n    [18, 17],\n  ]\n);\n\n// ranges are empty, nothing happens:\nassert.deepEqual(rOffset(null, 10), null);\n\n// if input does not resemble ranges, nothing happens:\nassert.deepEqual(rOffset(true, 10), true);"}},"ranges-process-outside":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rProcessOutside &#x7D; from \"ranges-process-outside\";\n\nconst gathered = [];\n\n// a callback interface:\nrProcessOutside(\n  \"abcdefghij\",\n  [\n    [1, 5], // delete from \"b\" to \"f\"\n  ],\n  (fromIdx, toIdx, offsetValueCb) => &#x7B;\n    gathered.push(fromIdx);\n  &#x7D;\n);\n\nassert.deepEqual(gathered, [0, 5, 6, 7, 8, 9]);"}},"ranges-push":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; Ranges &#x7D; from \"ranges-push\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\n\nconst gatheredRanges = new Ranges();\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\n\n// push the ranges\ngatheredRanges.push(35, 43, \"little Red Riding Hood\");\ngatheredRanges.push(4, 19, \"bad grey wolf\");\n\n// retrieve the merged and sorted ranges by calling .current()\nassert.deepEqual(gatheredRanges.current(), [\n  [4, 19, \"bad grey wolf\"],\n  [35, 43, \"little Red Riding Hood\"],\n]);\n\nassert.equal(\n  rApply(oldString, gatheredRanges.current()),\n  \"The bad grey wolf jumps over the little Red Riding Hood.\"\n);\n\n// wipe all gathered ranges\ngatheredRanges.wipe();\nassert.equal(gatheredRanges.current(), null);"}},"ranges-regex":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\nconst result = rRegex(/the/gi, oldString);\n\n// all regex matches, but in Ranges notation (see codsen.com/ranges/):\nassert.deepEqual(result, [\n  [0, 3],\n  [31, 34],\n]);\n\n// if you slice the ranges, you'll get original regex caught values:\nassert.deepEqual(\n  result.map(([from, to]) => oldString.slice(from, to)),\n  [\"The\", \"the\"]\n);"},"clashing-replacements.js":{"title":"Clashing replacement values","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\nimport &#x7B; Ranges &#x7D; from \"ranges-push\";\n\n// Two tasks:\n// 1. replace numbers with asterisks (*)\n// 2. but delete all zero chunks\n\n// tasks clash\n\nconst source = \"sequence: 1234 5678 0000 1234\";\nconst gatheredRanges = new Ranges();\n// now can push() new ranges into \"gatheredRanges\"\n\n// 1.\n\n// conceal number chunks:\nconst fix1 = rRegex(/\\d/g, source, \"*\");\n// \\d matches digit\nassert.deepEqual(fix1, [\n  [10, 14, \"****\"],\n\n  [15, 19, \"****\"],\n\n  [20, 24, \"****\"],\n\n  [25, 29, \"****\"],\n]);\n// replacement is correct:\nassert.equal(rApply(source, fix1), \"sequence: **** **** **** ****\");\n// push it in:\ngatheredRanges.push(fix1);\n\n// 2.\n\n// delete zero chunks:\nconst fix2 = rRegex(/\\b[0]+\\b/g, source);\nassert.deepEqual(fix2, [[20, 24]]);\n// deletion is correct:\nassert.equal(rApply(source, fix2), \"sequence: 1234 5678  1234\");\n// push it in:\ngatheredRanges.push(fix2);\n\n// 3. - MERGE and APPLY\n\n// what have we got in \"gatheredRanges\"?\nassert.deepEqual(gatheredRanges.current(), [\n  [10, 14, \"****\"],\n  [15, 19, \"****\"],\n  [20, 24, \"****\"],\n  [25, 29, \"****\"],\n]);\n// notice [[19, 23, \"brown\"]] is absent - \"ranges-merge\" program detected\n// we're deleting an encompassing range of indexes [12, 29] which\n// encompasses to-be-inserted values range at [19, 23] and discarded the\n// latter.\n\n// apply both fixes in one go:\nassert.equal(\n  rApply(source, gatheredRanges.current()),\n  \"sequence: **** **** **** ****\"\n);\n\n// hey, the zero chunk deletion range [20, 24] was merged with\n// replacement range [20, 24, \"****\"] and former got lost!\n\n// How do we make that the deletion would make precedence over everything\n// else?\n\n// Answer is, put `null` in replacement. It will be interpreted as explicit\n// deletion.\n\n// insert null as replacement:\nconst fix3 = rRegex(/\\b[0]+\\b/g, source, null);\nassert.deepEqual(fix3, [[20, 24, null]]);\n// deletion is correct:\nassert.equal(rApply(source, fix3), \"sequence: 1234 5678  1234\");\n\n// wipe the \"gatheredRanges\"\ngatheredRanges.wipe();\n\n// push again\ngatheredRanges.push(fix1); // asterisks\ngatheredRanges.push(fix3); // zero chunk\n\n// apply again:\nassert.equal(\n  rApply(source, gatheredRanges.current()),\n  \"sequence: **** ****  ****\"\n);\n// null in [20, 24, null] overrode the insertion instruction [20, 24, \"****\"]"},"nothing-to-find.js":{"title":"Nothing was found","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\n\nassert.equal(rRegex(/abc/g, \"xyz\"), null);\n// Falsy null means no ranges, other Ranges ecosystem\n// packages will accept null as input value\n// For the record, an empty array is truthy"},"replacement-mini.js":{"title":"Replacing values","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\n\n// Task: fix \"brow\" typo using regex and Ranges\n\nconst source = \"the typo in 'quick brow fox' sentence\";\n\n// 1. \"brow\"\nconst fix1 = rRegex(/\\bbrow\\b/g, source);\n// \\b matches word boundary\nassert.deepEqual(fix1, [[19, 23]]);\n// apply ranges to get the result string:\nassert.equal(rApply(source, fix1), \"the typo in 'quick  fox' sentence\");\n\n// But in Ranges terms, two elements mean deletion range, not replacement!\n// For replacement, you add a third element, value to put.\nconst fix2 = rRegex(/\\bbrow\\b/g, source, \"brown\");\n// \\b matches word boundary\nassert.deepEqual(fix2, [[19, 23, \"brown\"]]);\n// apply ranges to get the result string:\nassert.equal(rApply(source, fix2), \"the typo in 'quick brown fox' sentence\");"}},"ranges-sort":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rSort &#x7D; from \"ranges-sort\";\n\n// Ranges (see codsen.com/ranges/) are sorted:\nassert.deepEqual(\n  rSort([\n    [2, 3],\n    [9, 10, \"bad grey wolf\"],\n    [1, 2],\n  ]),\n  [\n    [1, 2],\n    [2, 3],\n    [9, 10, \"bad grey wolf\"],\n  ]\n);"}},"regex-empty-conditional-comments":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; emptyCondCommentRegex &#x7D; from \"regex-empty-conditional-comments\";\n\n// empty comment which was meant to target Outlook-only\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if !mso]>\n<![endif]-->`),\n  true\n);\n\n// empty comment which was meant to target non-Outlook-only\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if !mso]><!-- -->\n<!--<![endif]-->`),\n  true\n);\n\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if !mso]><!-- -->\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<!--<![endif]-->`),\n  false\n);\n\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if gte mso 9]><xml>\n<o:OfficeDocumentSettings>\n<o:AllowPNG/>\n<o:PixelsPerInch>96</o:PixelsPerInch>\n</o:OfficeDocumentSettings>\n</xml><![endif]-->`),\n  false\n);\n\nassert.equal(\n  emptyCondCommentRegex().exec(\"<html><!--[if !mso]><![endif]--><title>\")[0],\n  \"<!--[if !mso]><![endif]-->\"\n);\n\nassert.deepEqual(\n  `<html> <!--[if !mso]><![endif]--> <title>text</title> <!--[if gte mso 9]>\n<xml>\n<![endif]-->`.match(emptyCondCommentRegex()),\n  [\"<!--[if !mso]><![endif]-->\"]\n);"}},"regex-is-jinja-nunjucks":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isJinjaNunjucksRegex &#x7D; from \"regex-is-jinja-nunjucks\";\n\n// detects Jinja/Nunjucks code\nassert.equal(\n  isJinjaNunjucksRegex().test(\n    `<div>&#x7B;% if data.purchases.count > 1 %&#x7D;these&#x7B;% else %&#x7D;this&#x7B;% endif %&#x7D;</div>`\n  ),\n  true\n);\n\n// in case if it's not nunjucks\nassert.equal(isJinjaNunjucksRegex().test(`<div>tralala</div>`), false);"}},"regex-is-jsp":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isJSP &#x7D; from \"regex-is-jsp\";\n\n// detects JSP code\nassert.equal(isJSP().test(`<div><% out.println(\"Hi!\"); %></div>`), true);\n\n// in case if it's not nunjucks\nassert.equal(isJSP().test(`<div>tralala</div>`), false);"}},"regex-jinja-specific":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isJinjaSpecific &#x7D; from \"regex-jinja-specific\";\n\nassert.equal(\n  isJinjaSpecific().test(`<div>&#x7B;&#x7B; '%.2f'|format(3.1415926) &#x7D;&#x7D;</div>`),\n  true\n);\n\n// in case of ambiguous, Nunjucks-or-Jinja code\nassert.equal(isJinjaSpecific().test(`<div>&#x7B;&#x7B; value &#x7D;&#x7D;</div>`), false);"}},"str-indexes-of-plus":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; strIndexesOfPlus &#x7D; from \"str-indexes-of-plus\";\n\n// searches for string in a string, returns array:\nassert.deepEqual(strIndexesOfPlus(\"abc-abc-abc-abc\", \"abc\"), [0, 4, 8, 12]);\n\n// all graphemes are counted as one, emoji too:\nassert.deepEqual(\n  strIndexesOfPlus(\"🐴-🦄\", \"🦄\"),\n  [2] // not [3] considering unicorn is 2-characters long\n);\n\n// you can offset the start of a search:\nassert.deepEqual(strIndexesOfPlus(\"abczabc\", \"abc\", 3), [4]);"}},"string-apostrophes":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; convertOne, convertAll &#x7D; from \"string-apostrophes\";\n\nassert.deepEqual(\n  convertAll(`In the '60s, rock 'n' roll`, &#x7B;\n    convertApostrophes: true,\n    convertEntities: false,\n  &#x7D;),\n  &#x7B;\n    result: \"In the ’60s, rock ’n’ roll\",\n    ranges: [\n      [7, 8, \"’\"],\n      [18, 21, \"’n’\"],\n    ],\n  &#x7D;\n);\n\nassert.deepEqual(\n  convertOne(`test's`, &#x7B;\n    from: 4,\n    to: 5,\n    convertApostrophes: true,\n    convertEntities: true,\n  &#x7D;),\n  [[4, 5, \"&rsquo;\"]]\n);"}},"string-character-is-astral-surrogate":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  isHighSurrogate,\n  isLowSurrogate,\n&#x7D; from \"string-character-is-astral-surrogate\";\n\n// 🧢 = \\uD83E\\uDDE2\n\nassert.equal(isHighSurrogate(\"\\uD83E\"), true);\n// the first character, high surrogate of the cap is indeed a high surrogate\n\nassert.equal(isHighSurrogate(\"\\uDDE2\"), false);\n// the second character, low surrogate of the cap is NOT a high surrogate\n\nassert.equal(isLowSurrogate(\"\\uD83E\"), false);\n// the first character, high surrogate of the cap is NOT a low surrogate\n// it's a high surrogate\n\nassert.equal(isLowSurrogate(\"\\uDDE2\"), true);\n// the second character, low surrogate of the cap is indeed a low surrogate"}},"string-collapse-leading-whitespace":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; collWhitespace &#x7D; from \"string-collapse-leading-whitespace\";\n\n// if leading/trailing whitespace doesn't contain \\n, collapse to a single space\nassert.equal(collWhitespace(\"  aaa   \"), \" aaa \");\n\n// otherwise, collapse to a single \\n (default setting)\nassert.equal(collWhitespace(\"     \\n\\n   aaa  \\n\\n\\n    \"), \"\\naaa\\n\");\n\n// does nothing to trimmed strings:\nassert.equal(collWhitespace(\"aaa\"), \"aaa\");\n\n// if there are multiple lines string is still processed in trim-fashion -\n// only beginning and ending whitespace is changed:\nassert.equal(\n  collWhitespace(\"  abc  \\n  def  \\n  ghi  \"),\n  \" abc  \\n  def  \\n  ghi \"\n);"}},"string-collapse-white-space":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; collapse &#x7D; from \"string-collapse-white-space\";\n\nassert.equal(\n  collapse(\"  aaa     bbb    ccc   dddd  \").result,\n  \"aaa bbb ccc dddd\"\n);\n\nassert.equal(collapse(\"   \\t\\t\\t   aaa   \\t\\t\\t   \").result, \"aaa\");\n\nassert.equal(\n  collapse(\"   aaa   bbb  \\n    ccc   ddd   \", &#x7B; trimLines: false &#x7D;).result,\n  \"aaa bbb \\n ccc ddd\"\n);\n\nassert.equal(\n  collapse(\"   aaa   bbb  \\n    ccc   ddd   \", &#x7B; trimLines: true &#x7D;).result,\n  \"aaa bbb\\nccc ddd\"\n);\n\n// \\xa0 is an unencoded non-breaking space:\nassert.equal(\n  collapse(\n    \"     \\xa0    aaa   bbb    \\xa0    \\n     \\xa0     ccc   ddd   \\xa0   \",\n    &#x7B; trimLines: true, trimnbsp: true &#x7D;\n  ).result,\n  \"aaa bbb\\nccc ddd\"\n);"},"cb.js":{"title":"Minify a chunk of CSS selector","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; collapse &#x7D; from \"string-collapse-white-space\";\n\nassert.equal(\n  collapse(`div > span`, &#x7B;\n    cb: (&#x7B; suggested, whiteSpaceStartsAt, whiteSpaceEndsAt, str &#x7D;) => &#x7B;\n      if (str[whiteSpaceStartsAt - 1] === \">\") &#x7B;\n        // console.log(`> on the left! - wipe this whitespace`);\n        return [whiteSpaceStartsAt, whiteSpaceEndsAt];\n      &#x7D;\n      if (str[whiteSpaceEndsAt] === \">\") &#x7B;\n        // console.log(`> on the right! - wipe this whitespace`);\n        return [whiteSpaceStartsAt, whiteSpaceEndsAt];\n      &#x7D;\n      return suggested;\n    &#x7D;,\n  &#x7D;).result,\n  \"div>span\"\n);"}},"string-convert-indexes":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  nativeToUnicode,\n  unicodeToNative,\n&#x7D; from \"string-convert-indexes\";\n\n// CONVERTING NATIVE JS INDEXES TO UNICODE-CHAR-COUNT-BASED\n// 𝌆 - \\uD834\\uDF06\n\n// at index 1, we have low surrogate, that's still grapheme index zero\nassert.equal(nativeToUnicode(\"\\uD834\\uDF06aa\", \"1\"), \"0\");\n// notice it's retained as string. The same type as input is retained!\n\n// at index 2, we have first letter a - that's second index, counting graphemes\nassert.equal(nativeToUnicode(\"\\uD834\\uDF06aa\", 3), 2);\n\n// convert many indexes at once - any nested data structure is fine:\nassert.deepEqual(nativeToUnicode(\"\\uD834\\uDF06aa\", [1, 0, 2, 3]), [0, 0, 1, 2]);\n\n// numbers from an AST-like complex structure are still picked out and converted:\nassert.deepEqual(nativeToUnicode(\"\\uD834\\uDF06aa\", [1, \"0\", [[[2]]], 3]), [\n  0, // notice matching type is retained\n  \"0\", // notice matching type is retained\n  [[[1]]],\n  2,\n]);\n\n// CONVERTING UNICODE-CHAR-COUNT-BASED TO NATIVE JS INDEXES\n// 𝌆 - \\uD834\\uDF06\n\nassert.deepEqual(unicodeToNative(\"\\uD834\\uDF06aa\", [0, 1, 2]), [0, 2, 3]);\n\nassert.deepEqual(unicodeToNative(\"\\uD834\\uDF06aa\", [1, 0, 2]), [2, 0, 3]);\n\nassert.throws(() => unicodeToNative(\"\\uD834\\uDF06aa\", [1, 0, 2, 3]));\n// throws an error!\n// that's because there's no character (counting Unicode characters) with index 3\n// we have only three Unicode characters, so indexes go only up until 2"}},"string-extract-class-names":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; extract &#x7D; from \"string-extract-class-names\";\n\n// extracts classes and/or id's\nconst str = \"div#brambles.nushes#croodles\";\nconst &#x7B; res, ranges &#x7D; = extract(str);\nassert.deepEqual(res, [\"#brambles\", \".nushes\", \"#croodles\"]);\nassert.deepEqual(ranges, [\n  [3, 12],\n  [12, 19],\n  [19, 28],\n]);\n\n// `res` can be produced by slicing `ranges`:\nassert.deepEqual(\n  res,\n  ranges.map(([from, to]) => str.slice(from, to))\n);"},"bracket-notation.js":{"title":"Supports legacy bracket notation emails used to use","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; extract &#x7D; from \"string-extract-class-names\";\n\n// Yahoo has changed many years ago so email template\n// must be really arcane to contain this notation\n// https://github.com/hteumeuleu/email-bugs/issues/49\n\nassert.deepEqual(extract(`td[id=\" abc-def \"]`), &#x7B;\n  res: [\"#abc-def\"],\n  ranges: [[8, 15]],\n&#x7D;);\n\n// notice the hash # is not covered by range indexes!"},"contrived-complex.js":{"title":"Non-parsing algorithm can tackle really dodgy CSS","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; extract &#x7D; from \"string-extract-class-names\";\n\n// probably invalid input, but works anyway:\nassert.deepEqual(extract(\"?#id1#id2? #id3#id4> p > #id5#id6\").res, [\n  \"#id1\",\n  \"#id2\",\n  \"#id3\",\n  \"#id4\",\n  \"#id5\",\n  \"#id6\",\n]);"},"with-space.js":{"title":"Processes whole CSS selectors","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; extract &#x7D; from \"string-extract-class-names\";\n\nassert.deepEqual(extract(\"div.first.second#third a[target=_blank]\").res, [\n  \".first\",\n  \".second\",\n  \"#third\",\n]);"}},"string-extract-sass-vars":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; extractVars &#x7D; from \"string-extract-sass-vars\";\n\nassert.deepEqual(\n  extractVars(`// all variables are here!!!\n// ------------------------------------------\n$red: #ff6565; // this is red\n// $green: #63ffbd; // no green here\n$yellow: #ffff65; // this is yellow\n$blue: #08f0fd; // this is blue\n$fontfamily: Helvetica, sans-serif;\n$border: 1px solid #dedede;\n$borderroundedness: 3px;\n$customValue1: tralala;\n$customValue2: tralala;\n// don't mind this comment about #ff6565;\n$customValue3: 10;`),\n  &#x7B;\n    red: \"#ff6565\",\n    yellow: \"#ffff65\",\n    blue: \"#08f0fd\",\n    fontfamily: \"Helvetica, sans-serif\",\n    border: \"1px solid #dedede\",\n    borderroundedness: \"3px\",\n    customValue1: \"tralala\",\n    customValue2: \"tralala\",\n    customValue3: 10,\n  &#x7D;\n);"},"opts-cb.js":{"title":"Convert 3-digit color hex codes to 6-digit","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; extractVars &#x7D; from \"string-extract-sass-vars\";\n// import \"color-shorthand-hex-to-six-digit\" to convert three-digit colour hex\n// codes to six-digit:\nimport &#x7B; conv &#x7D; from \"color-shorthand-hex-to-six-digit\";\n\nassert.deepEqual(\n  extractVars(\"$blue: #2af;\", &#x7B;\n    throwIfEmpty: true,\n    cb: (val) => conv(val), // converts hex codes only, bypasses the rest\n  &#x7D;),\n  &#x7B; blue: \"#22aaff\" &#x7D;\n);"},"throw-if-empty.js":{"title":"Raises alarm if variables file has been wiped","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; extractVars &#x7D; from \"string-extract-sass-vars\";\n\nassert.throws(() =>\n  extractVars(\"\", &#x7B;\n    throwIfEmpty: true,\n  &#x7D;)\n);"}},"string-find-heads-tails":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; strFindHeadsTails &#x7D; from \"string-find-heads-tails\";\n\n// processing an arbitrary, custom templating markup:\nassert.deepEqual(\n  strFindHeadsTails(\n    \"some text %%_var1-%% more text %%_var2_%%\",\n    [\"%%_\", \"%%-\"], // two flavours of heads\n    [\"-%%\", \"_%%\"] // two flavours of tails\n  ),\n  [\n    &#x7B;\n      headsStartAt: 10,\n      headsEndAt: 13,\n      tailsStartAt: 17,\n      tailsEndAt: 20,\n    &#x7D;,\n    &#x7B;\n      headsStartAt: 31,\n      headsEndAt: 34,\n      tailsStartAt: 38,\n      tailsEndAt: 41,\n    &#x7D;,\n  ]\n);"}},"string-find-malformed":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; findMalformed &#x7D; from \"string-find-malformed\";\n\n// Below, we look for dodgy cases of `<!--`\nconst gathered = [];\nfindMalformed(\n  \"<div><!-something--></div>\",\n  \"<!--\",\n  // your callback function:\n  (obj) => &#x7B;\n    gathered.push(obj);\n  &#x7D;,\n  &#x7B;\n    maxDistance: 1, // Levenshtein distance\n  &#x7D;\n);\nassert.deepEqual(gathered, [\n  &#x7B;\n    idxFrom: 5,\n    idxTo: 8,\n  &#x7D;,\n]);"}},"string-fix-broken-named-entities":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fixEnt &#x7D; from \"string-fix-broken-named-entities\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\n\nconst source = \"&nsp;x&nsp;y&nsp;\";\n\n// returns Ranges notation, see codsen.com/ranges/\nassert.deepEqual(fixEnt(source), [\n  [0, 5, \"&nbsp;\"],\n  [6, 11, \"&nbsp;\"],\n  [12, 17, \"&nbsp;\"],\n]);\n\n// render result from ranges using \"ranges-apply\":\nassert.equal(rApply(source, fixEnt(source)), \"&nbsp;x&nbsp;y&nbsp;\");"},"sift-raw-ampersands-from-entities.js":{"title":"Sift raw ampersands in a string from broken character references","content":"// encode those raw ampersands and fix broken character references\n\nimport &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; fixEnt &#x7D; from \"string-fix-broken-named-entities\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\n\nconst source = \"&&nsp;&&nsp;&\";\n\nconst finalRanges = [];\nconst indexesOfRawAmpersands = [];\n\n// fixEnt() returns Ranges (see codsen.com/ranges/)\nconst resultRanges = fixEnt(source, &#x7B;\n  textAmpersandCatcherCb: (idx) => indexesOfRawAmpersands.push(idx),\n&#x7D;);\n\n// check the ranges - all broken NBSP's were fixed:\nassert.deepEqual(resultRanges, [\n  [1, 6, \"&nbsp;\"],\n  [7, 12, \"&nbsp;\"],\n]);\n\n// don't apply the ranges yet, dump them into the \"finalRanges\" array\n// it's because applying them onto a string,\n// rApply(source, resultRanges);\n// will mess up the index positions, we'll need to calculate again.\n// The whole point of Ranges is they're COMPOSABLE.\n\nresultRanges.forEach((range) => &#x7B;\n  finalRanges.push(range);\n&#x7D;);\n\n// check the positions of reported raw ampersands:\nassert.deepEqual(indexesOfRawAmpersands, [0, 6, 12]);\n\n// replace each character at these positions: 0, 6 and 12\n// with string \"&amp;\" - in terms of Ranges, it's a matter\n// of building a Ranges array:\nconst replacementRanges = indexesOfRawAmpersands.map((idx) => [\n  idx,\n  idx + 1,\n  \"&amp;\",\n]);\n// this is Ranges notation, array of arrays: [from index, to index, what-to-replace]\nassert.deepEqual(replacementRanges, [\n  [0, 1, \"&amp;\"], // we're saying, replace indexes from 0 to 1 with &amp;\n  [6, 7, \"&amp;\"],\n  [12, 13, \"&amp;\"],\n]);\n\n// push them into resultRanges as well:\nreplacementRanges.forEach((range) => &#x7B;\n  resultRanges.push(range);\n&#x7D;);\n\n// check what's been gathered so far:\nassert.deepEqual(resultRanges, [\n  [1, 6, \"&nbsp;\"],\n  [7, 12, \"&nbsp;\"],\n  [0, 1, \"&amp;\"],\n  [6, 7, \"&amp;\"],\n  [12, 13, \"&amp;\"],\n]);\n\n// apply Ranges onto a string - all amendments at once!\nconst finalResultStr = rApply(source, resultRanges);\n\n// check result\nassert.equal(finalResultStr, \"&amp;&nbsp;&amp;&nbsp;&amp;\");\n\n// Voilà! We fixed broken entities and encoded raw ampersands"}},"string-left-right":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  left,\n  right,\n  leftSeq,\n  rightSeq,\n  chompLeft,\n  chompRight,\n  leftStopAtNewLines,\n  rightStopAtNewLines,\n&#x7D; from \"string-left-right\";\n\n// get the closest non-whitespace character to the left of \"d\" (which itself\n// is at string index 6)\nconst str = \"abc   def\";\n//             |   |\n//           012345678\n\nassert.equal(\n  `next non-whitespace character to the left of $&#x7B;str[6]&#x7D; (index 6) is $&#x7B;\n    str[left(str, 6)]\n  &#x7D; (index $&#x7B;left(str, 6)&#x7D;)`,\n  \"next non-whitespace character to the left of d (index 6) is c (index 2)\"\n);"}},"string-match-left-right":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  matchLeftIncl,\n  matchRightIncl,\n  matchLeft,\n  matchRight,\n&#x7D; from \"string-match-left-right\";\n\n// 3rd character is \"d\" because indexes start from zero.\n// We're checking the string to the left of it, \"bcd\", inclusive of current character (\"d\").\n// This means, \"bcd\" has to end with existing character and the other chars to the left\n// must match exactly:\nassert.equal(matchLeftIncl(\"abcdefghi\", 3, [\"bcd\"]), \"bcd\");\n\n// neither \"ab\" nor \"zz\" are to the left of 3rd index, \"d\":\nassert.equal(matchLeft(\"abcdefghi\", 3, [\"ab\", `zz`]), false);\n\n// \"def\" is to the right of 3rd index (including it), \"d\":\nassert.equal(matchRightIncl(\"abcdefghi\", 3, [\"def\", `zzz`]), \"def\");\n\n// One of values, \"ef\" is exactly to the right of 3rd index, \"d\":\nassert.equal(matchRight(\"abcdefghi\", 3, [\"ef\", `zz`]), \"ef\");"},"cb.js":{"title":"The Callback Use","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  matchLeftIncl,\n  matchRightIncl,\n  matchLeft,\n  matchRight,\n&#x7D; from \"string-match-left-right\";\n\n// imagine you looped the string and wanted to catch where does attribute \"class\" start\n// and end (not to mention to ensure that it's a real attribute, not something ending with this\n// string \"class\").\n// You catch \"=\", an index number 8.\n// This library can check, is \"class\" to the left of it and feed what's to the left of it\n// to your supplied callback function, which happens to be a checker \"is it a space\":\nfunction isSpace(char) &#x7B;\n  return typeof char === \"string\" && char.trim() === \"\";\n&#x7D;\n\nassert.equal(\n  matchLeft('<a class=\"something\">', 8, \"class\", &#x7B; cb: isSpace &#x7D;),\n  \"class\"\n);"}},"string-overlap-one-on-another":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; overlap &#x7D; from \"string-overlap-one-on-another\";\n\nassert.equal(overlap(\"aaa\", \"bbb\", &#x7B; offset: -2 &#x7D;), \"bbbaa\");"},"empty-str.js":{"title":"Empty Strings","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; overlap &#x7D; from \"string-overlap-one-on-another\";\n\nassert.equal(\n  overlap(\"\", \"456\", &#x7B; offset: 99, offsetFillerCharacter: \"zzzz\" &#x7D;),\n  \"456\"\n);\n// even though offset is long enough to warrant the filler, no characters\n// are added to the \"456\" because the first argument string is empty."}},"string-process-comma-separated":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; processCommaSep &#x7D; from \"string-process-comma-separated\";\n\nconst gatheredChunks = [];\nconst gatheredErrors = [];\nconst rawnbsp = \"\\u00a0\";\n\n// it's a callback-interface:\nprocessCommaSep(`<FRAMESET rows=\" ,,\\t50% ,$&#x7B;rawnbsp&#x7D; 50% ,\\t\\t,\">`, &#x7B;\n  from: 16, // <- beginning of the attribute's value\n  to: 35, // <- ending of the attribute's value\n  separator: \",\",\n  cb: (idxFrom, idxTo) => &#x7B;\n    gatheredChunks.push([idxFrom, idxTo]);\n  &#x7D;,\n  errCb: (ranges, message) => &#x7B;\n    gatheredErrors.push(&#x7B; ranges, message &#x7D;);\n  &#x7D;,\n&#x7D;);\n\nassert.deepEqual(gatheredChunks, [\n  [20, 23],\n  [27, 30],\n]);\n\nassert.deepEqual(gatheredErrors, [\n  &#x7B; ranges: [[16, 17]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[17, 18]], message: \"Remove separator.\" &#x7D;,\n  &#x7B; ranges: [[18, 19]], message: \"Remove separator.\" &#x7D;,\n  &#x7B; ranges: [[19, 20]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[23, 24]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[25, 27]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[30, 31]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[32, 34]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[31, 32]], message: \"Remove separator.\" &#x7D;,\n  &#x7B; ranges: [[34, 35]], message: \"Remove separator.\" &#x7D;,\n]);"}},"string-range-expander":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; expander &#x7D; from \"string-range-expander\";\n\n// let's say we have picked the \"zzzz\" index range - [16, 20]\n// \"something>\\n\\t    zzzz <here\"\n//                    |   |\n//                  from  to\n//\n// PS. \"\\n\" and \"\\t\" take up a single character's length\n\nassert.deepEqual(\n  expander(&#x7B;\n    str: \"something>\\n\\t    zzzz <here\",\n    from: 16,\n    to: 20,\n    ifRightSideIncludesThisThenCropTightly: \"<\",\n  &#x7D;),\n  [10, 21]\n);"}},"string-remove-duplicate-heads-tails":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; remDup &#x7D; from \"string-remove-duplicate-heads-tails\";\n\nassert.equal(\n  remDup(\"&#x7B;&#x7B; Hi &#x7B;&#x7B; first_name &#x7D;&#x7D;! &#x7D;&#x7D;\", &#x7B;\n    heads: \"&#x7B;&#x7B; \",\n    tails: \" &#x7D;&#x7D;\",\n  &#x7D;),\n  \"Hi &#x7B;&#x7B; first_name &#x7D;&#x7D;!\"\n);"}},"string-remove-thousand-separators":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; remSep &#x7D; from \"string-remove-thousand-separators\";\n\n// 🇬🇧 🇺🇸 thousand separators:\nassert.equal(remSep(\"1,000,000.00\"), \"1000000.00\");\n\n// 🇷🇺  thousand separators:\nassert.equal(remSep(\"1 000 000,00\"), \"1000000,00\");\n// (if you want it converted to Western notation with dot,\n// set opts.forceUKStyle = true\n\n// 🇨🇭 thousand separators:\nassert.equal(remSep(\"1'000'000.00\"), \"1000000.00\");\n\n// IT'S SMART TOO:\n\n// will not delete if the thousand separators are mixed:\nconst input = \"100,000,000.000\";\nassert.equal(remSep(input), input);\n// ^ does nothing\n\n// but will remove empty space, even if there is no decimal separator:\n// (that's to cope with Russian notation integers that use thousand separators)\nassert.equal(remSep(\"100 000 000 000\"), \"100000000000\");\n\n// while removing thousand separators, it will also pad the digits to two decimal places\n// (optional, on by default, to turn it off set opts.padSingleDecimalPlaceNumbers to `false`):\nassert.equal(remSep(\"100,000.2\"), \"100000.20\");\nconsole.log();\n// ^ Western notation\n\nassert.equal(remSep(\"100 000,2\"), \"100000,20\");\n// ^ Russian notation\n\nassert.equal(remSep(\"100'000.2\"), \"100000.20\");\n// ^ Swiss notation"}},"string-remove-widows":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; removeWidows &#x7D; from \"string-remove-widows\";\n\nconst &#x7B; ranges, res &#x7D; = removeWidows(\"Some text with many words on one line.\");\n\n// see codsen.com/ranges/\nassert.deepEqual(ranges, [[32, 33, \"&nbsp;\"]]);\n\nassert.equal(res, \"Some text with many words on one&nbsp;line.\");"},"widow-word-removal-from-html.js":{"title":"Widow word removal from text within HTML","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\nimport &#x7B; removeWidows &#x7D; from \"string-remove-widows\";\n\nconst someHtml = `The quick brown fox jumps of the lazy dog.<div class=\"a\">`;\n\n// default widow word removal libs are not aware of HTML:\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  removeWidows(someHtml).res,\n  `The quick brown fox jumps of the lazy dog.<div&nbsp;class=\"a\">` // 😱\n);\n\n// luckily, removeWidows() consumes optional HTML tag locations\nassert.equal(\n  removeWidows(someHtml, &#x7B;\n    tagRanges: stripHtml(someHtml)\n      // remove the third argument, what to insert (\"&nbsp;\" string in these cases)\n      .ranges.map(([from, to]) => [from, to]),\n  &#x7D;).res,\n  `The quick brown fox jumps of the lazy&nbsp;dog.<div class=\"a\">` // ✅\n);"}},"string-split-by-whitespace":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; splitByW &#x7D; from \"string-split-by-whitespace\";\n\n// Split by whitespace is easy - use native String.prototype.split()\nassert.deepEqual(\"abc  def ghi\".split(/\\s+/), [\"abc\", \"def\", \"ghi\"]);\n\nconst source = `\\n     \\n    a\\t \\nb    \\n      \\t`;\n\n// this program is nearly equivalent to regex-based split:\nassert.deepEqual(source.split(/\\s+/), [\"\", \"a\", \"b\", \"\"]);\nassert.deepEqual(splitByW(source), [\"a\", \"b\"]);\n// regex-based split needs more filtration but it's native solution\n\n// ADDITIONALLY...\n\n// this program allows to exclude certain index ranges:\nassert.deepEqual(\n  splitByW(\"a b c d e\", &#x7B;\n    ignoreRanges: [[0, 2]], // that's \"a\" and space after it\n  &#x7D;),\n  [\"b\", \"c\", \"d\", \"e\"]\n);"}},"string-strip-html":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nassert.equal(\n  stripHtml(`Some text <b>and</b> text.`).result,\n  `Some text and text.`\n);\n\n// prevents accidental string concatenation\nassert.equal(stripHtml(`aaa<div>bbb</div>ccc`).result, `aaa bbb ccc`);\n\n// tag pairs with content, upon request\nassert.equal(\n  stripHtml(`a <pre><code>void a;</code></pre> b`, &#x7B;\n    stripTogetherWithTheirContents: [\n      \"script\", // default\n      \"style\", // default\n      \"xml\", // default\n      \"pre\", // <-- custom-added\n    ],\n  &#x7D;).result,\n  `a b`\n);\n\n// detects raw, legit brackets:\nassert.equal(stripHtml(`a < b and c > d`).result, `a < b and c > d`);"},"cb-which-does-nothing.js":{"title":"A Bypass Callback and a Do-Nothing Callback","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\n// this callback just pushes proposed result to \"rangesArr\",\n// that's what gets used in the result calculation:\nconst cb1 = (&#x7B;\n  tag,\n  deleteFrom,\n  deleteTo,\n  insert,\n  rangesArr,\n  proposedReturn,\n&#x7D;) => &#x7B;\n  rangesArr.push(deleteFrom, deleteTo, insert);\n&#x7D;;\nconst result1 = stripHtml(\"abc<hr>def\", &#x7B; cb: cb1 &#x7D;).result;\nassert.equal(result1, `abc def`);\n\n// to prove it works, don't do anything:\nconst cb2 = (&#x7B;\n  tag,\n  deleteFrom,\n  deleteTo,\n  insert,\n  rangesArr,\n  proposedReturn,\n&#x7D;) => &#x7B;\n  // nothing here 🙈\n&#x7D;;\nconst result2 = stripHtml(\"abc<hr>def\", &#x7B; cb: cb2 &#x7D;).result;\nassert.equal(result2, \"abc<hr>def\");"},"extract-html-head-contents.js":{"title":"Extract HTML `<head>` contents","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>\n  <body>\n    the content\n  </body>\n</html>`;\n\n// The task asks not to include <head...> and </head>.\n// First, extract head tag-to-head tag, including contents\nconst headWithHeadTags = stripHtml(someHtml, &#x7B;\n  onlyStripTags: [\"head\"],\n  stripTogetherWithTheirContents: [\"head\"],\n&#x7D;)\n  .filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  )\n  .trim();\n\nassert.equal(\n  headWithHeadTags,\n  `<head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>`\n);\n\nconst headContents = headWithHeadTags.replace(/<\\/?head>/g, \"\").trim();\nassert.equal(\n  headContents,\n  `<meta charset=\"utf-8\">\n    <title>the title</title>`\n);"},"inline-tags.js":{"title":"Just deletes inline tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `This has an <b>un</b>bold word.`;\n\n// default behaviour:\nassert.equal(stripHtml(someHtml).result, `This has an un bold word.`);\n\n// let's tackle inline tags:\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr &#x7D;) => &#x7B;\n      if ([\"b\", \"strong\"].includes(tag.name)) &#x7B;\n        rangesArr.push(tag.lastOpeningBracketAt, tag.lastClosingBracketAt + 1);\n      &#x7D; else &#x7B;\n        rangesArr.push(deleteFrom, deleteTo, insert);\n      &#x7D;\n    &#x7D;,\n  &#x7D;).result,\n  `This has an unbold word.`\n);"},"leave-href-and-label.js":{"title":"Retain href and link label","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<a href=\"https://twitter.com/loretparisi\">twitter:loretparisi&nbsp;&oslash;</a>`;\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    skipHtmlDecoding: true,\n  &#x7D;).result,\n  `twitter:loretparisi&nbsp;&oslash;`\n);\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    skipHtmlDecoding: true,\n    cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n      let temp;\n      if (\n        tag.name === \"a\" &&\n        tag.attributes &&\n        tag.attributes.some((attr) => &#x7B;\n          if (attr.name === \"href\") &#x7B;\n            temp = attr.value;\n            return true;\n          &#x7D;\n        &#x7D;)\n      ) &#x7B;\n        rangesArr.push([deleteFrom, deleteTo, `$&#x7B;temp&#x7D; $&#x7B;insert&#x7D;`]);\n      &#x7D; else &#x7B;\n        rangesArr.push(proposedReturn);\n      &#x7D;\n    &#x7D;,\n  &#x7D;).result,\n  `https://twitter.com/loretparisi twitter:loretparisi&nbsp;&oslash;`\n);"},"leave-only-html.js":{"title":"Leave only HTML","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(\n  stripHtml(someHtml).allTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<!DOCTYPE html><html lang=\"en\" dir=\"ltr\"><head><meta charset=\"utf-8\"><title></title></head><body><h1></h1></body></html>`\n);"},"leave-only-opening-td.js":{"title":"Leave only opening `td` tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\n// the first way\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    // notice there's no: onlyStripTags: [\"td\"]\n    // we operate purely via callback\n    cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n      if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n        rangesArr.push(proposedReturn);\n      &#x7D;\n    &#x7D;,\n  &#x7D;).ranges.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to).trim()&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);\n\n// the second way:\n// -----------------------------------------------------------------------------\n\nlet resultStr = \"\";\n// notice we don't even assign stripHtml() output to anything - we rely only\n// on the callback, it mutates the \"resultStr\" in the upper scope\nstripHtml(someHtml, &#x7B;\n  // notice there's no: onlyStripTags: [\"td\"]\n  // we operate purely via callback\n  cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n    if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n      resultStr += someHtml.slice(deleteFrom, deleteTo).trim();\n    &#x7D;\n  &#x7D;,\n&#x7D;);\nassert.equal(\n  resultStr,\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);"},"leave-only-td.js":{"title":"Leave only `td` tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    onlyStripTags: [\"td\"],\n  &#x7D;).filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"></td><td class=\"col2\"></td><td class=\"col3\"></td><td class=\"col4\"></td>`\n);"},"minimal-ranges.js":{"title":"Minimal example using Ranges","content":"// We strip tags and fix apostrophes\n// that's part of what https://codsen.com/os/detergent/ does\n\nimport &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\nimport &#x7B; convertAll &#x7D; from \"string-apostrophes\";\n\nfunction stripAndFixApos(str) &#x7B;\n  if (!str || typeof str !== \"string\") &#x7B;\n    return \"\";\n  &#x7D;\n  // Keep in mind, Ranges are array of 2-3 element arrays.\n  // But absent Ranges are marked as null, not empty array.\n  // It's so that we could test in \"if-else\" easily - null\n  // is falsy but empty array is truthy.\n  // That's why below we take precautions with \"|| []\".\n  return rApply(\n    str,\n    (stripHtml(str).ranges || []).concat(convertAll(str).ranges || [])\n  );\n&#x7D;\n\n// strips tags and fixes apostrophes:\nassert.equal(\n  stripAndFixApos(`Let's Go <strong>Larval</strong>`),\n  `Let’s Go Larval`\n);\n\n// no tags, no apostrophes:\nassert.equal(stripAndFixApos(`zzz`), `zzz`);"},"remove-html.js":{"title":"Remove all HTML from a string","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(stripHtml(someHtml).result, `Title\\nSome text.`);"},"strip-from-json.js":{"title":"Strip HTML from a raw JSON string","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\nimport &#x7B; traverse &#x7D; from \"ast-monkey-traverse\";\n\nconst stripFromJsonStr = (str) => &#x7B;\n  return traverse(JSON.parse(str), (key, val) => &#x7B;\n    // if currently an object is traversed, you get both \"key\" and \"val\"\n    // if it's array, only \"key\" is present, \"val\" is undefined\n    const current = val !== undefined ? val : key;\n    if (\n      // ensure it's a plain object, not array (monkey will report only \"key\" in\n      // arrays and \"val\" will be undefined)\n      // also ensure object's value a string, not boolean or number, because we\n      // don't strip HTML from booleans or numbers or anything else than strings\n      typeof val === \"string\"\n    ) &#x7B;\n      // monkey's callback is like Array.map - whatever you return gets written:\n      return stripHtml(val).result;\n    &#x7D;\n    // default return, do nothing:\n    return current;\n  &#x7D;);\n&#x7D;;\n\n// nothing to strip, \"<\" is false alarm:\nassert.equal(\n  JSON.stringify(stripFromJsonStr(`&#x7B;\"Operator\":\"<\",\"IsValid\":true&#x7D;`), null, 0),\n  `&#x7B;\"Operator\":\"<\",\"IsValid\":true&#x7D;`\n);\n\n// some HTML within one of key values, monkey will skip the boolean:\nassert.equal(\n  JSON.stringify(\n    stripFromJsonStr(`&#x7B;\"Operator\":\"a <div>b</div> c\",\"IsValid\":true&#x7D;`),\n    null,\n    0\n  ),\n  `&#x7B;\"Operator\":\"a b c\",\"IsValid\":true&#x7D;`\n);"},"title-case-with-tag-skipping.js":{"title":"Set the title case using `title` package","content":"// This program will not touch any single tags (<br class=\"z\"/> for example)\n// or in case of paired tags, paired tags and content between\n\nimport &#x7B; strict as assert &#x7D; from \"assert\";\nimport title from \"title\";\nimport &#x7B; rInvert &#x7D; from \"ranges-invert\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nfunction tagAwareTitle(str) &#x7B;\n  const whitelist = [\"eslint\", \"readme\", \"npm\"];\n  const &#x7B; filteredTagLocations &#x7D; = stripHtml(str, &#x7B;\n    stripTogetherWithTheirContents: [\"*\"],\n  &#x7D;);\n  const inverted = rInvert(\n    filteredTagLocations.concat(\n      whitelist.reduce((acc, curr) => &#x7B;\n        const rangesFindings = rRegex(new RegExp(curr, \"gi\"), str);\n        if (rangesFindings) &#x7B;\n          return acc.concat(rangesFindings);\n        &#x7D;\n        return acc;\n      &#x7D;, [])\n    ),\n    str.length\n  );\n\n  if (Array.isArray(inverted) && inverted.length) &#x7B;\n    // take inverted ranges, for example, [[3, 4], [10, 15]]\n    // and add third element, replacement, which is same character\n    // indexes only processed through \"title\":\n    return rApply(\n      str,\n      inverted.map(([from, to]) => [from, to, title(str.slice(from, to))])\n    );\n  &#x7D;\n  // otherwise, just apply title() on the whole string:\n  return title(str);\n&#x7D;\n\n// middle:\nassert.equal(\n  tagAwareTitle(`This is a title with some <code>code</code> in it`),\n  `This Is a Title with Some <code>code</code> In It`\n);\n\n// leading:\nassert.equal(\n  tagAwareTitle(`<span class=\"xyz\">abc<span> defgh ESLint`),\n  `<span class=\"xyz\">abc<span> Defgh ESLint`\n);"},"widow-word-removal-from-html.js":{"title":"Widow word removal from text within HTML","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\nimport &#x7B; removeWidows &#x7D; from \"string-remove-widows\";\n\nconst someHtml = `The quick brown fox jumps of the lazy dog.<div class=\"a\">`;\n\n// default widow word removal libs are not aware of HTML:\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  removeWidows(someHtml).res,\n  `The quick brown fox jumps of the lazy dog.<div&nbsp;class=\"a\">` // 😱\n);\n\n// luckily, removeWidows() consumes optional HTML tag locations\nassert.equal(\n  removeWidows(someHtml, &#x7B;\n    tagRanges: stripHtml(someHtml)\n      // remove the third argument, what to insert (\"&nbsp;\" string in these cases)\n      .ranges.map(([from, to]) => [from, to]),\n  &#x7D;).res,\n  `The quick brown fox jumps of the lazy&nbsp;dog.<div class=\"a\">` // ✅\n);"}},"string-trim-spaces-only":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; trimSpaces &#x7D; from \"string-trim-spaces-only\";\n\nassert.deepEqual(trimSpaces(\"  aaa   \"), &#x7B;\n  res: \"aaa\",\n  ranges: [\n    [0, 2],\n    [5, 8],\n  ],\n&#x7D;);\n\nassert.deepEqual(trimSpaces(\"   \\t  zz   \\n    \"), &#x7B;\n  res: \"\\t  zz   \\n\",\n  ranges: [\n    [0, 3],\n    [12, 16],\n  ],\n&#x7D;);"}},"string-uglify":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; uglifyById, uglifyArr, version &#x7D; from \"string-uglify\";\n\n// notice we put dots and hashes for classes and id's but algorithm will work\n// fine too if you won't.\nconst names = [\n  \".module-promo-all\",\n  \".module-promo-main\",\n  \".module-promo-second\",\n  \"#zzz\",\n];\n\n// notice we put dots and hashes for classes and id's but algorithm will work\n// fine too if you won't.\nassert.deepEqual(uglifyArr(names), [\".o\", \".s\", \".z\", \"#l\"]);\n\n// uglify a particular id number (inefficient):\nassert.equal(uglifyById(names, 3), \"#l\");"}},"string-unfancy":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; unfancy &#x7D; from \"string-unfancy\";\n\n// U+2019\n// https://www.fileformat.info/info/unicode/char/2019/index.htm\n// https://mothereff.in/js-escapes\nconst rightSingleQuote = \"\\u2019\";\n\nassert.equal(unfancy(`someone$&#x7B;rightSingleQuote&#x7D;s`), \"someone's\");\n\n// works with encoded HTML:\nassert.equal(unfancy(\"someone&rsquo;s\"), \"someone's\");"}},"stristri":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stri &#x7D; from \"stristri\";\n\n// strips both HTML and Nunjucks, leaves text only:\nassert.equal(\n  stri(\n    `<html><div>The price is&#x7B;% if data.price > 100 %&#x7D; high&#x7B;% endif %&#x7D;</div>`,\n    &#x7B;\n      html: true,\n      css: true,\n      text: false,\n      templatingTags: true,\n    &#x7D;\n  ).result,\n  \"The price is high\"\n);"}},"tap-parse-string-to-object":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; parseTap &#x7D; from \"tap-parse-string-to-object\";\n\n// synchronous parsing (there's also async, see in examples)\nassert.deepEqual(\n  parseTap(`TAP version 13\nok 1 - test/test.js # time=22.582ms &#x7B; # Subtest: 01.01 - string input\nok 1 - 01.01.01\nok 2 - 01.01.02\n1..2\nok 1 - 01.01 - string input # time=7.697ms\n\n # Subtest: 01.02 - non-string input\nok 1 - 01.02.01\nok 2 - 01.02.02\nok 3 - 01.02.03\nok 4 - 01.02.04\nok 5 - 01.02.05\n1..5\nok 2 - 01.02 - non-string input # time=2.791ms\n\n 1..2 # time=22.582ms\n&#x7D;\n\nok 2 - test/umd-test.js # time=16.522ms &#x7B; # Subtest: UMD build works fine\nok 1 - should be equivalent\n1..1\nok 1 - UMD build works fine # time=10.033ms\n\n 1..1 # time=16.522ms\n&#x7D;\n\n1..2\n\n# time=1816.082ms\n`),\n  &#x7B;\n    ok: true,\n    assertsTotal: 8,\n    assertsPassed: 8,\n    assertsFailed: 0,\n    suitesTotal: 2,\n    suitesPassed: 2,\n    suitesFailed: 0,\n  &#x7D;\n);"}},"test-mixer":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; mixer &#x7D; from \"test-mixer\";\n\n// check all possible combinations of all boolean opts:\nconst defaultOpts = &#x7B;\n  scrapeWindshield: true,\n  checkOil: true,\n  inflateTires: false,\n  extinguishersCount: 1, // as non-boolean will be ignored\n&#x7D;;\n\n// generates 2^3 = 8 combinations all possible bools\nassert.deepEqual(\n  mixer(\n    &#x7B;\n      // empty first arg object means you want all combinations\n    &#x7D;,\n    defaultOpts\n  ),\n  [\n    &#x7B;\n      scrapeWindshield: false,\n      checkOil: false,\n      inflateTires: false,\n      extinguishersCount: 1,\n    &#x7D;,\n    &#x7B;\n      scrapeWindshield: true,\n      checkOil: false,\n      inflateTires: false,\n      extinguishersCount: 1,\n    &#x7D;,\n    &#x7B;\n      scrapeWindshield: false,\n      checkOil: true,\n      inflateTires: false,\n      extinguishersCount: 1,\n    &#x7D;,\n    &#x7B;\n      scrapeWindshield: true,\n      checkOil: true,\n      inflateTires: false,\n      extinguishersCount: 1,\n    &#x7D;,\n    &#x7B;\n      scrapeWindshield: false,\n      checkOil: false,\n      inflateTires: true,\n      extinguishersCount: 1,\n    &#x7D;,\n    &#x7B;\n      scrapeWindshield: true,\n      checkOil: false,\n      inflateTires: true,\n      extinguishersCount: 1,\n    &#x7D;,\n    &#x7B;\n      scrapeWindshield: false,\n      checkOil: true,\n      inflateTires: true,\n      extinguishersCount: 1,\n    &#x7D;,\n    &#x7B;\n      scrapeWindshield: true,\n      checkOil: true,\n      inflateTires: true,\n      extinguishersCount: 1,\n    &#x7D;,\n  ]\n);\n\n// let's \"pin\" a value, prepare two sets of options objects,\n// one where scrapeWindshield === true and another with \"false\"\n\n// you'll get 2 ^ (3-1) = 4 variations:\nconst variationsWithScrapeWindshieldOn = mixer(\n  &#x7B;\n    scrapeWindshield: true,\n  &#x7D;,\n  defaultOpts\n);\nassert.deepEqual(variationsWithScrapeWindshieldOn, [\n  &#x7B;\n    scrapeWindshield: true, // <--- pinned\n    checkOil: false,\n    inflateTires: false,\n    extinguishersCount: 1,\n  &#x7D;,\n  &#x7B;\n    scrapeWindshield: true, // <--- pinned\n    checkOil: true,\n    inflateTires: false,\n    extinguishersCount: 1,\n  &#x7D;,\n  &#x7B;\n    scrapeWindshield: true, // <--- pinned\n    checkOil: false,\n    inflateTires: true,\n    extinguishersCount: 1,\n  &#x7D;,\n  &#x7B;\n    scrapeWindshield: true, // <--- pinned\n    checkOil: true,\n    inflateTires: true,\n    extinguishersCount: 1,\n  &#x7D;,\n]);\n\n// also 4 variations, similar but with scrapeWindshield === false pinned:\nconst variationsWithScrapeWindshieldOff = mixer(\n  &#x7B;\n    scrapeWindshield: false,\n  &#x7D;,\n  defaultOpts\n);\nassert.equal(variationsWithScrapeWindshieldOff.length, 4);"}},"util-array-object-or-both":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; arrObjOrBoth &#x7D; from \"util-array-object-or-both\";\n\n// normalises string, a user preference:\n\nassert.equal(arrObjOrBoth(\"arrays\"), \"array\");\nassert.equal(arrObjOrBoth(\"array\"), \"array\");\nassert.equal(arrObjOrBoth(\"arr\"), \"array\");\nassert.equal(arrObjOrBoth(\"a\"), \"array\");\n\nassert.equal(arrObjOrBoth(\"objects\"), \"object\");\nassert.equal(arrObjOrBoth(\"object\"), \"object\");\nassert.equal(arrObjOrBoth(\"obj\"), \"object\");\nassert.equal(arrObjOrBoth(\"o\"), \"object\");\n\nassert.equal(arrObjOrBoth(\"whatever\"), \"any\");\nassert.equal(arrObjOrBoth(\"either\"), \"any\");\nassert.equal(arrObjOrBoth(\"both\"), \"any\");\nassert.equal(arrObjOrBoth(\"any\"), \"any\");\nassert.equal(arrObjOrBoth(\"all\"), \"any\");\nassert.equal(arrObjOrBoth(\"e\"), \"any\");"}},"util-nonempty":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; nonEmpty &#x7D; from \"util-nonempty\";\n\nassert.equal(nonEmpty(\"z\"), true);\nassert.equal(nonEmpty(\"\"), false);\nassert.equal(nonEmpty([\"a\"]), true);\nassert.equal(nonEmpty([123]), true);\nassert.equal(nonEmpty([[[[[[[[[[[]]]]]]]]]]]), true);\nassert.equal(nonEmpty(&#x7B; a: \"\" &#x7D;), true);\nassert.equal(nonEmpty(&#x7B; a: \"a\" &#x7D;), true);\nassert.equal(nonEmpty(&#x7B;&#x7D;), false);\n\nconst f = () => &#x7B;\n  return \"z\";\n&#x7D;;\nassert.equal(nonEmpty(f), false);\n// (answer is instantly false if input is not array, plain object or string)"}}}