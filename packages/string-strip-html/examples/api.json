{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nassert.equal(\n  stripHtml(`Some text <b>and</b> text.`).result,\n  `Some text and text.`\n);\n\n// prevents accidental string concatenation\nassert.equal(stripHtml(`aaa<div>bbb</div>ccc`).result, `aaa bbb ccc`);\n\n// tag pairs with content, upon request\nassert.equal(\n  stripHtml(`a <pre><code>void a;</code></pre> b`, &#x7B;\n    stripTogetherWithTheirContents: [\n      \"script\", // default\n      \"style\", // default\n      \"xml\", // default\n      \"pre\", // <-- custom-added\n    ],\n  &#x7D;).result,\n  `a b`\n);\n\n// detects raw, legit brackets:\nassert.equal(stripHtml(`a < b and c > d`).result, `a < b and c > d`);"},"extract-html-head-contents.js":{"title":"Extract HTML head contents","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>\n  <body>\n    the content\n  </body>\n</html>`;\n\n// The task asks not to include <head...> and </head>.\n// First, extract head tag-to-head tag, including contents\nconst headWithHeadTags = stripHtml(someHtml, &#x7B;\n  onlyStripTags: [\"head\"],\n  stripTogetherWithTheirContents: [\"head\"],\n&#x7D;)\n  .filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  )\n  .trim();\n\nassert.equal(\n  headWithHeadTags,\n  `<head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>`\n);\n\nconst headContents = headWithHeadTags.replace(/<\\/?head>/g, \"\").trim();\nassert.equal(\n  headContents,\n  `<meta charset=\"utf-8\">\n    <title>the title</title>`\n);"},"leave-only-html.js":{"title":"Leave only HTML","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(\n  stripHtml(someHtml).allTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<!DOCTYPE html><html lang=\"en\" dir=\"ltr\"><head><meta charset=\"utf-8\"><title></title></head><body><h1></h1></body></html>`\n);"},"leave-only-opening-td.js":{"title":"Leave only opening td tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\n// the first way\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    // notice there's no: onlyStripTags: [\"td\"]\n    // we operate purely via callback\n    cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n      if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n        rangesArr.push(proposedReturn);\n      &#x7D;\n    &#x7D;,\n  &#x7D;).ranges.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to).trim()&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);\n\n// the second way:\n// -----------------------------------------------------------------------------\n\nlet resultStr = \"\";\n// notice we don't even assign stripHtml() output to anything - we rely only\n// on the callback, it mutates the \"resultStr\" in the upper scope\nstripHtml(someHtml, &#x7B;\n  // notice there's no: onlyStripTags: [\"td\"]\n  // we operate purely via callback\n  cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n    if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n      resultStr += someHtml.slice(deleteFrom, deleteTo).trim();\n    &#x7D;\n  &#x7D;,\n&#x7D;);\nassert.equal(\n  resultStr,\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);"},"leave-only-td.js":{"title":"Leave only td tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    onlyStripTags: [\"td\"],\n  &#x7D;).filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"></td><td class=\"col2\"></td><td class=\"col3\"></td><td class=\"col4\"></td>`\n);"},"remove-html.js":{"title":"Remove all HTML from a string","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(stripHtml(someHtml).result, `Title\\nSome text.`);"},"strip-from-json.js":{"title":"Strip HTML from a raw JSON string","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\nimport traverse from \"ast-monkey-traverse\";\n\nconst stripFromJsonStr = (str) => &#x7B;\n  return traverse(JSON.parse(str), (key, val) => &#x7B;\n    // if currently an object is traversed, you get both \"key\" and \"val\"\n    // if it's array, only \"key\" is present, \"val\" is undefined\n    const current = val !== undefined ? val : key;\n    if (\n      // ensure it's a plain object, not array (monkey will report only \"key\" in\n      // arrays and \"val\" will be undefined)\n      // also ensure object's value a string, not boolean or number, because we\n      // don't strip HTML from booleans or numbers or anything else than strings\n      typeof val === \"string\"\n    ) &#x7B;\n      // monkey's callback is like Array.map - whatever you return gets written:\n      return stripHtml(val).result;\n    &#x7D;\n    // default return, do nothing:\n    return current;\n  &#x7D;);\n&#x7D;;\n\n// nothing to strip, \"<\" is false alarm:\nassert.equal(\n  JSON.stringify(stripFromJsonStr(`&#x7B;\"Operator\":\"<\",\"IsValid\":true&#x7D;`), null, 0),\n  `&#x7B;\"Operator\":\"<\",\"IsValid\":true&#x7D;`\n);\n\n// some HTML within one of key values, monkey will skip the boolean:\nassert.equal(\n  JSON.stringify(\n    stripFromJsonStr(`&#x7B;\"Operator\":\"a <div>b</div> c\",\"IsValid\":true&#x7D;`),\n    null,\n    0\n  ),\n  `&#x7B;\"Operator\":\"a b c\",\"IsValid\":true&#x7D;`\n);"},"title-case-with-tag-skipping.js":{"title":"Set the title case using `title` package","content":"// https://www.npmjs.com/package/title\n\n// This program will not touch any single tags (<br class=\"z\"/> for example)\n// or in case of paired tags, paired tags and content between\n\nimport &#x7B; strict as assert &#x7D; from \"assert\";\nimport title from \"title\";\nimport invertRanges from \"ranges-invert\";\nimport applyRanges from \"ranges-apply\";\nimport stripHtml from \"string-strip-html\";\n\nconst rangesRegex = require(\"ranges-regex\");\n\nfunction tagAwareTitle(str) &#x7B;\n  const whitelist = [\"eslint\", \"readme\", \"npm\"];\n  const &#x7B; filteredTagLocations &#x7D; = stripHtml(str, &#x7B;\n    stripTogetherWithTheirContents: [\"*\"],\n  &#x7D;);\n  // console.log(\n  //   `020 tagAwareTitle(): $&#x7B;`\\u001b[$&#x7B;33&#x7D;m$&#x7B;`filteredTagLocations`&#x7D;\\u001b[$&#x7B;39&#x7D;m`&#x7D; = $&#x7B;JSON.stringify(\n  //     filteredTagLocations,\n  //     null,\n  //     4\n  //   )&#x7D;`\n  // );\n  const inverted = invertRanges(\n    filteredTagLocations.concat(\n      whitelist.reduce((acc, curr) => &#x7B;\n        const rangesFindings = rangesRegex(new RegExp(curr, \"gi\"), str);\n        if (rangesFindings) &#x7B;\n          return acc.concat(rangesFindings);\n        &#x7D;\n        return acc;\n      &#x7D;, [])\n    ),\n    str.length\n  );\n  // console.log(\n  //   `028 tagAwareTitle(): $&#x7B;`\\u001b[$&#x7B;33&#x7D;m$&#x7B;`inverted`&#x7D;\\u001b[$&#x7B;39&#x7D;m`&#x7D; = $&#x7B;JSON.stringify(\n  //     inverted,\n  //     null,\n  //     4\n  //   )&#x7D;`\n  // );\n\n  if (Array.isArray(inverted) && inverted.length) &#x7B;\n    // take inverted ranges, for example, [[3, 4], [10, 15]]\n    // and add third element, replacement, which is same character\n    // indexes only processed through \"title\":\n    return applyRanges(\n      str,\n      inverted.map(([from, to]) => [from, to, title(str.slice(from, to))])\n    );\n  &#x7D;\n  // otherwise, just apply title() on the whole string:\n  return title(str);\n&#x7D;\n\n// middle:\nassert.equal(\n  tagAwareTitle(`This is a title with some <code>code</code> in it`),\n  `This Is a Title with Some <code>code</code> In It`\n);\n\n// leading:\nassert.equal(\n  tagAwareTitle(`<span class=\"xyz\">abc<span> defgh ESLint`),\n  `<span class=\"xyz\">abc<span> Defgh ESLint`\n);"}}