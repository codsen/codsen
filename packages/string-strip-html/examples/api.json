{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nassert.equal(\n  stripHtml(`Some text <b>and</b> text.`).result,\n  `Some text and text.`\n);\n\n// prevents accidental string concatenation\nassert.equal(stripHtml(`aaa<div>bbb</div>ccc`).result, `aaa bbb ccc`);\n\n// tag pairs with content, upon request\nassert.equal(\n  stripHtml(`a <pre><code>void a;</code></pre> b`, &#x7B;\n    stripTogetherWithTheirContents: [\n      \"script\", // default\n      \"style\", // default\n      \"xml\", // default\n      \"pre\", // <-- custom-added\n    ],\n  &#x7D;).result,\n  `a b`\n);\n\n// detects raw, legit brackets:\nassert.equal(stripHtml(`a < b and c > d`).result, `a < b and c > d`);"},"c-plus-plus.js":{"title":"Ignores code tags and their contents","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<code>#include <stdio.h>;</code> and <code>#include &lt;stdio.h&gt;</code>`;\n\n// default behaviour:\nassert.equal(stripHtml(someHtml).result, `#include; and #include`);\n\n// ignore <code> tag pairs\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    ignoreTagsWithTheirContents: [\"code\"],\n    skipHtmlDecoding: true,\n  &#x7D;).result,\n  someHtml\n);"},"cb-which-does-nothing.js":{"title":"A Bypass Callback and a Do-Nothing Callback","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\n// this callback just pushes proposed result to \"rangesArr\",\n// that's what gets used in the result calculation:\nconst cb1 = (&#x7B;\n  tag,\n  deleteFrom,\n  deleteTo,\n  insert,\n  rangesArr,\n  proposedReturn,\n&#x7D;) => &#x7B;\n  rangesArr.push(deleteFrom, deleteTo, insert);\n&#x7D;;\nconst result1 = stripHtml(\"abc<hr>def\", &#x7B; cb: cb1 &#x7D;).result;\nassert.equal(result1, `abc def`);\n\n// to prove it works, don't do anything:\nconst cb2 = (&#x7B;\n  tag,\n  deleteFrom,\n  deleteTo,\n  insert,\n  rangesArr,\n  proposedReturn,\n&#x7D;) => &#x7B;\n  // nothing here ðŸ™ˆ\n&#x7D;;\nconst result2 = stripHtml(\"abc<hr>def\", &#x7B; cb: cb2 &#x7D;).result;\nassert.equal(result2, \"abc<hr>def\");"},"extract-html-head-contents.js":{"title":"Extract HTML `<head>` contents","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>\n  <body>\n    the content\n  </body>\n</html>`;\n\n// The task asks not to include <head...> and </head>.\n// First, extract head tag-to-head tag, including contents\nconst headWithHeadTags = stripHtml(someHtml, &#x7B;\n  onlyStripTags: [\"head\"],\n  stripTogetherWithTheirContents: [\"head\"],\n&#x7D;)\n  .filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  )\n  .trim();\n\nassert.equal(\n  headWithHeadTags,\n  `<head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>`\n);\n\nconst headContents = headWithHeadTags.replace(/<\\/?head>/g, \"\").trim();\nassert.equal(\n  headContents,\n  `<meta charset=\"utf-8\">\n    <title>the title</title>`\n);"},"inline-tags.js":{"title":"Just deletes inline tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `This has an <b>un</b>bold word.`;\n\n// default behaviour:\nassert.equal(stripHtml(someHtml).result, `This has an un bold word.`);\n\n// let's tackle inline tags:\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr &#x7D;) => &#x7B;\n      if ([\"b\", \"strong\"].includes(tag.name)) &#x7B;\n        rangesArr.push(tag.lastOpeningBracketAt, tag.lastClosingBracketAt + 1);\n      &#x7D; else &#x7B;\n        rangesArr.push(deleteFrom, deleteTo, insert);\n      &#x7D;\n    &#x7D;,\n  &#x7D;).result,\n  `This has an unbold word.`\n);"},"leave-href-and-label.js":{"title":"Retain href and link label","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<a href=\"https://twitter.com/loretparisi\">twitter:loretparisi&nbsp;&oslash;</a>`;\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    skipHtmlDecoding: true,\n  &#x7D;).result,\n  `twitter:loretparisi&nbsp;&oslash;`\n);\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    skipHtmlDecoding: true,\n    cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n      let temp;\n      if (\n        tag.name === \"a\" &&\n        tag.attributes &&\n        tag.attributes.some((attr) => &#x7B;\n          if (attr.name === \"href\") &#x7B;\n            temp = attr.value;\n            return true;\n          &#x7D;\n        &#x7D;)\n      ) &#x7B;\n        rangesArr.push([deleteFrom, deleteTo, `$&#x7B;temp&#x7D; $&#x7B;insert&#x7D;`]);\n      &#x7D; else &#x7B;\n        rangesArr.push(proposedReturn);\n      &#x7D;\n    &#x7D;,\n  &#x7D;).result,\n  `https://twitter.com/loretparisi twitter:loretparisi&nbsp;&oslash;`\n);"},"leave-only-html.js":{"title":"Leave only HTML","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(\n  stripHtml(someHtml).allTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<!DOCTYPE html><html lang=\"en\" dir=\"ltr\"><head><meta charset=\"utf-8\"><title></title></head><body><h1></h1></body></html>`\n);"},"leave-only-opening-td.js":{"title":"Leave only opening `td` tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\n// the first way\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    // notice there's no: onlyStripTags: [\"td\"]\n    // we operate purely via callback\n    cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n      if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n        rangesArr.push(proposedReturn);\n      &#x7D;\n    &#x7D;,\n  &#x7D;).ranges.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to).trim()&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);\n\n// the second way:\n// -----------------------------------------------------------------------------\n\nlet resultStr = \"\";\n// notice we don't even assign stripHtml() output to anything - we rely only\n// on the callback, it mutates the \"resultStr\" in the upper scope\nstripHtml(someHtml, &#x7B;\n  // notice there's no: onlyStripTags: [\"td\"]\n  // we operate purely via callback\n  cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n    if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n      resultStr += someHtml.slice(deleteFrom, deleteTo).trim();\n    &#x7D;\n  &#x7D;,\n&#x7D;);\nassert.equal(\n  resultStr,\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);"},"leave-only-td.js":{"title":"Leave only `td` tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    onlyStripTags: [\"td\"],\n  &#x7D;).filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"></td><td class=\"col2\"></td><td class=\"col3\"></td><td class=\"col4\"></td>`\n);"},"minimal-ranges.js":{"title":"Minimal example using Ranges","content":"// We strip tags and fix apostrophes\n// that's part of what https://codsen.com/os/detergent/ does\n\nimport &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\nimport &#x7B; convertAll &#x7D; from \"string-apostrophes\";\n\nfunction stripAndFixApos(str) &#x7B;\n  if (!str || typeof str !== \"string\") &#x7B;\n    return \"\";\n  &#x7D;\n  // Keep in mind, Ranges are array of 2-3 element arrays.\n  // But absent Ranges are marked as null, not empty array.\n  // It's so that we could test in \"if-else\" easily - null\n  // is falsy but empty array is truthy.\n  // That's why below we take precautions with \"|| []\".\n  return rApply(\n    str,\n    (stripHtml(str).ranges || []).concat(convertAll(str).ranges || [])\n  );\n&#x7D;\n\n// strips tags and fixes apostrophes:\nassert.equal(\n  stripAndFixApos(`Let's Go <strong>Larval</strong>`),\n  `Letâ€™s Go Larval`\n);\n\n// no tags, no apostrophes:\nassert.equal(stripAndFixApos(`zzz`), `zzz`);"},"remove-html.js":{"title":"Remove all HTML from a string","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(stripHtml(someHtml).result, `Title\\nSome text.`);"},"strip-from-json.js":{"title":"Strip HTML from a raw JSON string","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\nimport &#x7B; traverse &#x7D; from \"ast-monkey-traverse\";\n\nconst stripFromJsonStr = (str) => &#x7B;\n  return traverse(JSON.parse(str), (key, val) => &#x7B;\n    // if currently an object is traversed, you get both \"key\" and \"val\"\n    // if it's array, only \"key\" is present, \"val\" is undefined\n    const current = val !== undefined ? val : key;\n    if (\n      // ensure it's a plain object, not array (monkey will report only \"key\" in\n      // arrays and \"val\" will be undefined)\n      // also ensure object's value a string, not boolean or number, because we\n      // don't strip HTML from booleans or numbers or anything else than strings\n      typeof val === \"string\"\n    ) &#x7B;\n      // monkey's callback is like Array.map - whatever you return gets written:\n      return stripHtml(val).result;\n    &#x7D;\n    // default return, do nothing:\n    return current;\n  &#x7D;);\n&#x7D;;\n\n// nothing to strip, \"<\" is false alarm:\nassert.equal(\n  JSON.stringify(stripFromJsonStr(`&#x7B;\"Operator\":\"<\",\"IsValid\":true&#x7D;`), null, 0),\n  `&#x7B;\"Operator\":\"<\",\"IsValid\":true&#x7D;`\n);\n\n// some HTML within one of key values, monkey will skip the boolean:\nassert.equal(\n  JSON.stringify(\n    stripFromJsonStr(`&#x7B;\"Operator\":\"a <div>b</div> c\",\"IsValid\":true&#x7D;`),\n    null,\n    0\n  ),\n  `&#x7B;\"Operator\":\"a b c\",\"IsValid\":true&#x7D;`\n);"},"title-case-with-tag-skipping.js":{"title":"Set the title case using `title` package","content":"// This program will not touch any single tags (<br class=\"z\"/> for example)\n// or in case of paired tags, paired tags and content between\n\nimport &#x7B; strict as assert &#x7D; from \"assert\";\nimport title from \"title\";\nimport &#x7B; rInvert &#x7D; from \"ranges-invert\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\n\nfunction tagAwareTitle(str) &#x7B;\n  const whitelist = [\"eslint\", \"readme\", \"npm\"];\n  const &#x7B; filteredTagLocations &#x7D; = stripHtml(str, &#x7B;\n    stripTogetherWithTheirContents: [\"*\"],\n  &#x7D;);\n  const inverted = rInvert(\n    filteredTagLocations.concat(\n      whitelist.reduce((acc, curr) => &#x7B;\n        const rangesFindings = rRegex(new RegExp(curr, \"gi\"), str);\n        if (rangesFindings) &#x7B;\n          return acc.concat(rangesFindings);\n        &#x7D;\n        return acc;\n      &#x7D;, [])\n    ),\n    str.length\n  );\n\n  if (Array.isArray(inverted) && inverted.length) &#x7B;\n    // take inverted ranges, for example, [[3, 4], [10, 15]]\n    // and add third element, replacement, which is same character\n    // indexes only processed through \"title\":\n    return rApply(\n      str,\n      inverted.map(([from, to]) => [from, to, title(str.slice(from, to))])\n    );\n  &#x7D;\n  // otherwise, just apply title() on the whole string:\n  return title(str);\n&#x7D;\n\n// middle:\nassert.equal(\n  tagAwareTitle(`This is a title with some <code>code</code> in it`),\n  `This Is a Title with Some <code>code</code> In It`\n);\n\n// leading:\nassert.equal(\n  tagAwareTitle(`<span class=\"xyz\">abc</span> defgh ESLint`),\n  `<span class=\"xyz\">abc</span> Defgh ESLint`\n);"},"widow-word-removal-from-html.js":{"title":"Widow word removal from text within HTML","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; stripHtml &#x7D; from \"string-strip-html\";\nimport &#x7B; removeWidows &#x7D; from \"string-remove-widows\";\n\nconst someHtml = `The quick brown fox jumps of the lazy dog.<div class=\"a\">`;\n\n// default widow word removal libs are not aware of HTML:\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  removeWidows(someHtml).res,\n  `The quick brown fox jumps of the lazy dog.<div&nbsp;class=\"a\">` // ðŸ˜±\n);\n\n// luckily, removeWidows() consumes optional HTML tag locations\nassert.equal(\n  removeWidows(someHtml, &#x7B;\n    tagRanges: stripHtml(someHtml)\n      // remove the third argument, what to insert (\"&nbsp;\" string in these cases)\n      .ranges.map(([from, to]) => [from, to]),\n  &#x7D;).res,\n  `The quick brown fox jumps of the lazy&nbsp;dog.<div class=\"a\">` // âœ…\n);"}}