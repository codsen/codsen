/**
 * string-remove-duplicate-heads-tails
 * Detect and (recursively) remove head and tail wrappings around the input string
 * Version: 3.0.49
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-remove-duplicate-heads-tails
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).stringRemoveDuplicateHeadsTails=t()}(this,(function(){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}var t,r,n=Function.prototype,i=Object.prototype,s=n.toString,o=i.hasOwnProperty,a=s.call(Object),l=i.toString,h=(t=Object.getPrototypeOf,r=Object,function(e){return t(r(e))});var u=function(e){if(!function(e){return!!e&&"object"==typeof e}(e)||"[object Object]"!=l.call(e)||function(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(e){}return t}(e))return!1;var t=h(e);if(null===t)return!0;var r=o.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&s.call(r)==a};function g(e){return"string"==typeof e?e.length>0?[e]:[]:e}function f(e){if("string"==typeof e)return 0!==e.length&&(e.charCodeAt(0)>=55296&&e.charCodeAt(0)<=56319);if(void 0===e)return!1;throw new TypeError(`string-character-is-astral-surrogate/isHighSurrogate(): the input is not string but ${typeof e}`)}function c(e){if("string"==typeof e)return 0!==e.length&&(e.charCodeAt(0)>=56320&&e.charCodeAt(0)<=57343);if(void 0===e)return!1;throw new TypeError(`string-character-is-astral-surrogate/isLowSurrogate(): the input is not string but ${typeof e}`)}function p(e){return null!=e}function y(e){return"string"==typeof e&&(e.charCodeAt(0)>=55296&&e.charCodeAt(0)<=57343)}function m(e,t,r,n,i){const s="function"==typeof r?r():r;if(t>=e.length&&i&&"EOL"===s)return s;if(!(t<=e.length)){if(n.relaxedApi)return!1;throw new Error(`string-match-left-right/marchForward(): [THROW_ID_102] second argument, fromIndexInclusive is ${t} beyond the input string length, ${e.length}.`)}{let o=i?1:r.length;for(let i=t,s=e.length;i<s;i++){let t=e[i];if(f(e[i])&&c(e[i+1])&&(t=e[i]+e[i+1]),c(e[i])&&f(e[i-1])&&(t=e[i-1]+e[i]),n.trimBeforeMatching&&""===e[i].trim())continue;if(!n.i&&n.trimCharsBeforeMatching.includes(t)||n.i&&n.trimCharsBeforeMatching.map(e=>e.toLowerCase()).includes(t.toLowerCase())){2===t.length&&(i+=1);continue}let s=r[r.length-o];if(f(s)&&p(r[r.length-o+1])&&c(r[r.length-o+1])&&(s=r[r.length-o]+r[r.length-o+1]),!(!n.i&&t===s||n.i&&t.toLowerCase()===s.toLowerCase()))return!1;if(o-=t.length,o<1){let n=i-r.length+t.length;return n>=0&&c(e[n])&&p(e[n-1])&&f(e[n-1])&&(n-=1),n>=0?n:0}2===t.length&&f(e[i])&&(i+=1)}if(o>0)return!(!i||"EOL"!==s)}}function d(e,t,r,n,i){const s="function"==typeof r?r():r;if(t<0&&i&&"EOL"===s)return s;if(t>=e.length){if(n.relaxedApi)return!1;throw new Error(`string-match-left-right/marchBackward(): [THROW_ID_203] second argument, starting index, should not be beyond the last character of the input string! Currently the first argument's last character's index is ${e.length} but the second argument is beyond it:\n${JSON.stringify(t,null,4)}`)}let o=i?1:r.length;for(let s=t+1;s--;){if(n.trimBeforeMatching&&""===e[s].trim()){if(0===s&&i&&"EOL"===r)return!0;continue}let t=e[s];if(c(e[s])&&f(e[s-1])?t=e[s-1]+e[s]:f(e[s])&&c(e[s+1])&&(t=e[s]+e[s+1]),!n.i&&n.trimCharsBeforeMatching.includes(t)||n.i&&n.trimCharsBeforeMatching.map(e=>e.toLowerCase()).includes(t.toLowerCase())){if(2===t.length&&(s-=1),i&&"EOL"===r&&0===s)return!0;continue}let a=r[o-1];if(c(a)&&(a=`${r[o-2]}${r[o-1]}`,o-=1,s-=1),!(!n.i&&t===a||n.i&&t.toLowerCase()===a.toLowerCase()))return!1;if(o-=1,o<1)return s>=0?s:0}return o>0?!(!i||"EOL"!==s):void 0}function w(e,t,r,n,i){if("object"==typeof i&&null!==i&&Object.prototype.hasOwnProperty.call(i,"trimBeforeMatching")&&"boolean"!=typeof i.trimBeforeMatching)throw new Error(`string-match-left-right/${e}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(i.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);const s=Object.assign({},{i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],relaxedApi:!1},i);let o,a,l,h;if(s.trimCharsBeforeMatching=g(s.trimCharsBeforeMatching),s.trimCharsBeforeMatching=s.trimCharsBeforeMatching.map(e=>"string"==typeof e?e:String(e)),s.trimCharsBeforeMatching.some((e,t)=>e.length>1&&!y(e)&&(o=t,a=e,!0)))throw new Error(`string-match-left-right/${e}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${o} is longer than 1 character, ${a.length} (equals to ${a}). Please split it into separate characters and put into array as separate elements.`);if("string"!=typeof t){if(s.relaxedApi)return!1;throw new Error(`string-match-left-right/${e}(): [THROW_ID_01] the first argument should be a string. Currently it's of a type: ${typeof t}, equal to:\n${JSON.stringify(t,null,4)}`)}if(0===t.length){if(s.relaxedApi)return!1;throw new Error(`string-match-left-right/${e}(): [THROW_ID_02] the first argument should be a non-empty string. Currently it's empty!`)}if(!(Number.isInteger(r)&&r>=0)){if(s.relaxedApi)return!1;throw new Error(`string-match-left-right/${e}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof r}, equal to:\n${JSON.stringify(r,null,4)}`)}if("string"==typeof n)l=[n];else if(Array.isArray(n))l=n;else if(p(n)){if("function"!=typeof n)throw new Error(`string-match-left-right/${e}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof n}, equal to:\n${JSON.stringify(n,null,4)}`);l=[],l.push(n)}else l=n;if(p(i)&&"object"!=typeof i)throw new Error(`string-match-left-right/${e}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof i}", and equal to:\n${JSON.stringify(i,null,4)}`);if(!p(l)||!Array.isArray(l)||Array.isArray(l)&&!l.length||Array.isArray(l)&&1===l.length&&"string"==typeof l[0]&&0===l[0].trim().length){if("function"==typeof s.cb){let n,i=r;if("matchRight"===e&&f(t[r])&&c(t[r+1])&&(i+=1),"matchLeftIncl"!==e&&"matchRight"!==e||(i+=1),e.startsWith("matchLeft"))for(let e=i;e--;){if(c(t[e])&&f(t[e-1]))continue;let r=t[e];if(f(t[e])&&c(t[e+1])&&(r=t[e]+t[e+1]),(!s.trimBeforeMatching||s.trimBeforeMatching&&void 0!==r&&""!==r.trim())&&(0===s.trimCharsBeforeMatching.length||void 0!==r&&!s.trimCharsBeforeMatching.includes(r))){n=e;break}c(t[e-1])&&f(t[e-2])&&(e-=1)}else if(e.startsWith("matchRight"))for(let e=i;e<t.length;e++){let r=t[e];if(f(t[e])&&c(t[e+1])&&(r=t[e]+t[e+1]),(!s.trimBeforeMatching||s.trimBeforeMatching&&""!==r.trim())&&(0===s.trimCharsBeforeMatching.length||!s.trimCharsBeforeMatching.includes(r))){n=e;break}f(t[e])&&c(t[e+1])&&(e+=1)}if(void 0===n)return!1;let o=t[n];f(t[n])&&c(t[n+1])&&(o=t[n]+t[n+1]),c(t[n])&&f(t[n-1])&&(o=t[n-1]+t[n],n-=1);let a,l=n+1;return f(t[n])&&c(t[n+1])&&(l+=1),l&&l>0&&(a=t.slice(0,l)),e.startsWith("matchLeft")?s.cb(o,a,n):(n&&n>0&&(a=t.slice(n)),s.cb(o,a,n))}let n="";throw p(i)||(n=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${e}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${n}`)}if(e.startsWith("matchLeft")){for(let n=0,i=l.length;n<i;n++){h="function"==typeof l[n];const i=l[n];let o,a,u="",g=r;"matchLeft"===e&&(y(t[n-1])&&y(t[n-2])?g-=2:g-=1);const m=d(t,g,i,s,h);if(m&&h&&"function"==typeof i&&"EOL"===i())return!(!i()||s.cb&&!s.cb(o,u,a))&&i();if(p(m)&&m>0&&(a=m-1,o=t[a],u=t.slice(0,m)),c(t[a])&&p(t[a-1])&&f(t[a-1])&&(a-=1,o=t[a-1]+t[a]),f(t[a])&&p(t[a+1])&&c(t[a+1])&&(o=t[a]+t[a+1],u=t.slice(0,a+2)),!1!==m&&(!s.cb||s.cb(o,u,a)))return i}return!1}for(let n=0,i=l.length;n<i;n++){h="function"==typeof l[n];const i=l[n];let o=r+("matchRight"===e?1:0);"matchRight"===e&&f(t[o-1])&&c(t[o])&&(o+=1);const a=m(t,o,i,s,h);if(a&&h&&"function"==typeof i&&"EOL"===i()){let e,t,r;return!(!i()||s.cb&&!s.cb(e,t,r))&&i()}let u,g,y;if(p(a)&&p(t[a+i.length-1])&&(u=a+i.length,g=t[u],f(t[u])&&c(t[u+1])&&(g=t[u]+t[u+1])),p(u)&&u>=0&&(y=t.slice(u)),!1!==a&&(!s.cb||s.cb(g,y,u)))return i}return!1}function T(e,t,r,n){return w("matchLeftIncl",e,t,r,n)}function b(e,t,r,n){return w("matchRightIncl",e,t,r,n)}function O(e,t=!0,r){if(!(r.trim().length||e.length&&"\n"!==r&&" "!==r&&" "===(t?e[e.length-1]:e[0])||e.length&&"\n"===(t?e[e.length-1]:e[0])&&"\n"!==r&&" "!==r))if(t){if(("\n"===r||" "===r)&&e.length&&" "===e[e.length-1])for(;e.length&&" "===e[e.length-1];)e.pop();e.push(" "===r||"\n"===r?r:" ")}else{if(("\n"===r||" "===r)&&e.length&&" "===e[0])for(;e.length&&" "===e[0];)e.shift();e.unshift(" "===r||"\n"===r?r:" ")}}function $(e,t){if("string"==typeof e&&e.length){let r,n,i=!1;if(e.includes("\r\n")&&(i=!0),r=t&&"number"==typeof t?t:1,""===e.trim()){const t=[];for(n=r,Array.from(e).forEach(e=>{("\n"!==e||n)&&("\n"===e&&n--,O(t,!0,e))});t.length>1&&" "===t[t.length-1];)t.pop();return t.join("")}const s=[];if(n=r,""===e[0].trim())for(let t=0,r=e.length;t<r&&0===e[t].trim().length;t++)("\n"!==e[t]||n)&&("\n"===e[t]&&n--,O(s,!0,e[t]));const o=[];if(n=r,""===e.slice(-1).trim())for(let t=e.length;t--&&0===e[t].trim().length;)("\n"!==e[t]||n)&&("\n"===e[t]&&n--,O(o,!1,e[t]));return i?`${s.join("")}${e.trim()}${o.join("")}`.replace(/\n/g,"\r\n"):s.join("")+e.trim()+o.join("")}return e}function _(e,t){if(!Array.isArray(e))throw new TypeError(`ranges-sort: [THROW_ID_01] Input must be an array, consisting of range arrays! Currently its type is: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(0===e.length)return e;const r=Object.assign({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null},t);let n,i;if(r.strictlyTwoElementsInRangeArrays&&!e.every((e,t)=>2===e.length||(n=t,i=e.length,!1)))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) has not two but ${i} elements!`);if(!e.every((e,t)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(n=t,!1)))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) does not consist of only natural numbers!`);const s=e.length*e.length;let o=0;return Array.from(e).sort((e,t)=>(r.progressFn&&(o++,r.progressFn(Math.floor(100*o/s))),e[0]===t[0]?e[1]<t[1]?-1:e[1]>t[1]?1:0:e[0]<t[0]?-1:1))}function A(e,t){function r(e){return"string"==typeof e}function n(e){return e&&"object"==typeof e&&!Array.isArray(e)}if(!Array.isArray(e))return e;const i={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};let s;if(t){if(!n(t))throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n${JSON.stringify(t,null,4)} (type ${typeof t})`);if(s=Object.assign({},i,t),s.progressFn&&n(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&"function"!=typeof s.progressFn)throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof s.progressFn}", equal to ${JSON.stringify(s.progressFn,null,4)}`);if(s.mergeType&&1!==s.mergeType&&2!==s.mergeType)if(r(s.mergeType)&&"1"===s.mergeType.trim())s.mergeType=1;else{if(!r(s.mergeType)||"2"!==s.mergeType.trim())throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof s.mergeType}", equal to ${JSON.stringify(s.mergeType,null,4)}`);s.mergeType=2}if("boolean"!=typeof s.joinRangesThatTouchEdges)throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof s.joinRangesThatTouchEdges}", equal to ${JSON.stringify(s.joinRangesThatTouchEdges,null,4)}`)}else s=Object.assign({},i);const o=e.map(e=>[...e]).filter(e=>void 0!==e[2]||e[0]!==e[1]);let a,l,h;a=s.progressFn?_(o,{progressFn:e=>{h=Math.floor(e/5),h!==l&&(l=h,s.progressFn(h))}}):_(o);const u=a.length-1;for(let e=u;e>0;e--)s.progressFn&&(h=Math.floor(78*(1-e/u))+21,h!==l&&h>l&&(l=h,s.progressFn(h))),(a[e][0]<=a[e-1][0]||!s.joinRangesThatTouchEdges&&a[e][0]<a[e-1][1]||s.joinRangesThatTouchEdges&&a[e][0]<=a[e-1][1])&&(a[e-1][0]=Math.min(a[e][0],a[e-1][0]),a[e-1][1]=Math.max(a[e][1],a[e-1][1]),void 0!==a[e][2]&&(a[e-1][0]>=a[e][0]||a[e-1][1]<=a[e][1])&&null!==a[e-1][2]&&(null===a[e][2]&&null!==a[e-1][2]?a[e-1][2]=null:void 0!==a[e-1][2]?2===s.mergeType&&a[e-1][0]===a[e][0]?a[e-1][2]=a[e][2]:a[e-1][2]+=a[e][2]:a[e-1][2]=a[e][2]),a.splice(e,1),e=a.length);return a}function I(e){return null!=e}function v(e){return Number.isInteger(e)&&e>=0}function R(e){return"string"==typeof e}function E(e){return/^\d*$/.test(e)?parseInt(e,10):e}class W{constructor(e){const t=Object.assign({},{limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},e);if(t.mergeType&&1!==t.mergeType&&2!==t.mergeType)if(R(t.mergeType)&&"1"===t.mergeType.trim())t.mergeType=1;else{if(!R(t.mergeType)||"2"!==t.mergeType.trim())throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof t.mergeType}", equal to ${JSON.stringify(t.mergeType,null,4)}`);t.mergeType=2}this.opts=t}add(e,t,r,...n){if(n.length>0)throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_03] Please don't overload the add() method. From the 4th input argument onwards we see these redundant arguments: ${JSON.stringify(n,null,4)}`);if(!I(e)&&!I(t))return;if(I(e)&&!I(t)){if(Array.isArray(e)){if(e.length){if(e.some(e=>Array.isArray(e)))return void e.forEach(e=>{Array.isArray(e)&&this.add(...e)});e.length>1&&v(E(e[0]))&&v(E(e[1]))&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(t,null,0)})`)}if(!I(e)&&I(t))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(t,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);const i=/^\d*$/.test(e)?parseInt(e,10):e,s=/^\d*$/.test(t)?parseInt(t,10):t;if(v(r)&&(r=String(r)),!v(i)||!v(s))throw v(i)&&i>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof s}" equal to: ${JSON.stringify(s,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof i}" equal to: ${JSON.stringify(i,null,4)}`);if(I(r)&&!R(r)&&!v(r))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof r}, equal to:\n${JSON.stringify(r,null,4)}`);if(I(this.slices)&&Array.isArray(this.last())&&i===this.last()[1]){if(this.last()[1]=s,this.last()[2],null!==this.last()[2]&&I(r)){let e=!(I(this.last()[2])&&this.last()[2].length>0)||this.opts&&this.opts.mergeType&&1!==this.opts.mergeType?r:this.last()[2]+r;this.opts.limitToBeAddedWhitespace&&(e=$(e,this.opts.limitLinebreaksCount)),R(e)&&!e.length||(this.last()[2]=e)}}else{this.slices||(this.slices=[]);const e=void 0===r||R(r)&&!r.length?[i,s]:[i,s,this.opts.limitToBeAddedWhitespace?$(r,this.opts.limitLinebreaksCount):r];this.slices.push(e)}}push(e,t,r,...n){this.add(e,t,r,...n)}current(){return null!=this.slices?(this.slices=A(this.slices,{mergeType:this.opts.mergeType}),this.opts.limitToBeAddedWhitespace?this.slices.map(e=>I(e[2])?[e[0],e[1],$(e[2],this.opts.limitLinebreaksCount)]:e):this.slices):null}wipe(){this.slices=void 0}replace(e){if(Array.isArray(e)&&e.length){if(!Array.isArray(e[0])||!v(e[0][0]))throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);this.slices=Array.from(e)}else this.slices=void 0}last(){return void 0!==this.slices&&Array.isArray(this.slices)?this.slices[this.slices.length-1]:null}}function C(e){return null!=e}function M(e){return"string"==typeof e}function B(e,t,r){let n=0,i=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(!M(e))throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(null===t)return e;if(!Array.isArray(t))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);if(r&&"function"!=typeof r)throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof r}, equal to: ${JSON.stringify(r,null,4)}`);Array.isArray(t)&&(Number.isInteger(t[0])&&t[0]>=0||/^\d*$/.test(t[0]))&&(Number.isInteger(t[1])&&t[1]>=0||/^\d*$/.test(t[1]))&&(t=[t]);const s=t.length;let o=0;t.forEach((e,a)=>{if(r&&(n=Math.floor(o/s*10),n!==i&&(i=n,r(n))),!Array.isArray(e))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${a}th element not an array: ${JSON.stringify(e,null,4)}, which is ${typeof e}`);if(!Number.isInteger(e[0])||e[0]<0){if(!/^\d*$/.test(e[0]))throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${a}th element, array [${e[0]},${e[1]}]. That array has first element not an integer, but ${typeof e[0]}, equal to: ${JSON.stringify(e[0],null,4)}. Computer doesn't like this.`);t[a][0]=Number.parseInt(t[a][0],10)}if(!Number.isInteger(e[1])){if(!/^\d*$/.test(e[1]))throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${a}th element, array [${e[0]},${e[1]}]. That array has second element not an integer, but ${typeof e[1]}, equal to: ${JSON.stringify(e[1],null,4)}. Computer doesn't like this.`);t[a][1]=Number.parseInt(t[a][1],10)}o++});const a=A(t,{progressFn:e=>{r&&(n=10+Math.floor(e/10),n!==i&&(i=n,r(n)))}}),l=a.length;if(l>0){const t=e.slice(a[l-1][1]);e=a.reduce((t,s,o,a)=>{r&&(n=20+Math.floor(o/l*80),n!==i&&(i=n,r(n)));const h=0===o?0:a[o-1][1],u=a[o][0];return t+e.slice(h,u)+(C(a[o][2])?a[o][2]:"")},""),e+=t}return e}function S(e,t){if("string"!=typeof e)throw new Error(`string-trim-spaces-only: [THROW_ID_01] input must be string! It was given as ${typeof e}, equal to:\n${JSON.stringify(e,null,4)}`);const r=Object.assign({},{classicTrim:!1,cr:!1,lf:!1,tab:!1,space:!0,nbsp:!1},t);function n(e){return r.classicTrim&&0===e.trim().length||!r.classicTrim&&(r.space&&" "===e||r.cr&&"\r"===e||r.lf&&"\n"===e||r.tab&&"\t"===e||r.nbsp&&" "===e)}let i,s;if(e.length>0){if(n(e[0]))for(let t=0,r=e.length;t<r;t++){if(!n(e[t])){i=t;break}if(t===e.length-1)return{res:"",ranges:[[0,e.length]]}}if(n(e[e.length-1]))for(let t=e.length;t--;)if(!n(e[t])){s=t+1;break}return i?s?{res:e.slice(i,s),ranges:[[0,i],[s,e.length]]}:{res:e.slice(i),ranges:[[0,i]]}:s?{res:e.slice(0,s),ranges:[[s,e.length]]}:{res:e,ranges:[]}}return{res:"",ranges:[]}}return function(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function n(e){return null!=e}var i=Object.prototype.hasOwnProperty;function s(e){return"string"==typeof e}if(void 0===t)throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_01] The input is missing!");if("string"!=typeof t)return t;if(n(r)&&!u(r))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_03] The given options are not a plain object but ".concat(e(r),"!"));if(n(r)&&i.call(r,"heads")){if(!g(r.heads).every((function(e){return s(e)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_04] The opts.heads contains elements which are not string-type!");s(r.heads)&&(r.heads=g(r.heads))}if(n(r)&&i.call(r,"tails")){if(!g(r.tails).every((function(e){return s(e)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_05] The opts.tails contains elements which are not string-type!");s(r.tails)&&(r.tails=g(r.tails))}var o=S(t).res;if(0===o.length)return t;t=o;var a={heads:["{{"],tails:["}}"]},l=Object.assign({},a,r);l.heads=l.heads.map((function(e){return e.trim()})),l.tails=l.tails.map((function(e){return e.trim()}));var h=!1,f=!1,c=new W({limitToBeAddedWhitespace:!0}),p=new W({limitToBeAddedWhitespace:!0}),y=!0,m=!0,d="";function w(e,t){var r;return b(e,0,t.heads,{trimBeforeMatching:!0,cb:function(e,t,n){return r=n,!0},relaxedApi:!0})&&b(e,r,t.tails,{trimBeforeMatching:!0,cb:function(e,t,n){return r=n,!0},relaxedApi:!0})?e.slice(r):e}for(;t!==w(t,l);)t=S(w(t,l)).res;function O(e,t){var r;return T(e,e.length-1,t.tails,{trimBeforeMatching:!0,cb:function(e,t,n){return r=n,!0},relaxedApi:!0})&&T(e,r,t.heads,{trimBeforeMatching:!0,cb:function(e,t,n){return r=n,!0},relaxedApi:!0})?e.slice(0,r+1):e}for(;t!==O(t,l);)t=S(O(t,l)).res;if(!(l.heads.length&&b(t,0,l.heads,{trimBeforeMatching:!0,relaxedApi:!0})&&l.tails.length&&T(t,t.length-1,l.tails,{trimBeforeMatching:!0,relaxedApi:!0})))return S(t).res;for(var $=0,_=t.length;$<_;$++)if(""===t[$].trim());else{var A=void 0,I=b(t,$,l.heads,{trimBeforeMatching:!0,cb:function(e,t,r){return A=r,!0},relaxedApi:!0});if(I){m=!0,y&&(y=!0);var v=void 0,R=b(t,A,l.tails,{trimBeforeMatching:!0,cb:function(e,t,r){return v=r,!0},relaxedApi:!0});R&&c.push($,v),p.current()&&h&&"tails"!==d&&c.push(p.current()),h?p.push($,A):(p.current()&&(c.push(p.current()),p.wipe()),p.push($,A)),d="heads",$=A-1;continue}var E=b(t,$,l.tails,{trimBeforeMatching:!0,cb:function(e,r,i){return A=n(i)?i:t.length,!0},relaxedApi:!0});if(E){m=!0,y?("heads"===d&&p.wipe(),y=!1):p.push($,A),d="tails",$=A-1;continue}y&&(y=!0),m&&!h?(h=!0,m=!1):m&&!f?(f=!0,y=!0,m=!1,"heads"===d&&p.wipe()):m&&f&&p.wipe()}return p.current()&&c.push(p.current()),c.current()?B(t,c.current()).trim():t.trim()}}));
