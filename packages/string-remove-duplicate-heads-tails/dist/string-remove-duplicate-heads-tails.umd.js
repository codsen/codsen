/**
 * string-remove-duplicate-heads-tails
 * Detect and (recursively) remove head and tail wrappings around the input string
 * Version: 3.0.74
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/string-remove-duplicate-heads-tails/
 */

!function(r,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(r="undefined"!=typeof globalThis?globalThis:r||self).stringRemoveDuplicateHeadsTails=t()}(this,(function(){"use strict";function r(t){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(r){return typeof r}:function(r){return r&&"function"==typeof Symbol&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r})(t)}function t(r,t){for(var e=0;e<t.length;e++){var n=t[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(r,n.key,n)}}function e(r,t,e){return t in r?Object.defineProperty(r,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):r[t]=e,r}function n(r,t){var e=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(r,t).enumerable}))),e.push.apply(e,n)}return e}function i(r){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?n(Object(i),!0).forEach((function(t){e(r,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(i)):n(Object(i)).forEach((function(t){Object.defineProperty(r,t,Object.getOwnPropertyDescriptor(i,t))}))}return r}function a(r){return function(r){if(Array.isArray(r))return o(r)}(r)||function(r){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(r))return Array.from(r)}(r)||function(r,t){if(!r)return;if("string"==typeof r)return o(r,t);var e=Object.prototype.toString.call(r).slice(8,-1);"Object"===e&&r.constructor&&(e=r.constructor.name);if("Map"===e||"Set"===e)return Array.from(r);if("Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))return o(r,t)}(r)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(r,t){(null==t||t>r.length)&&(t=r.length);for(var e=0,n=new Array(t);e<t;e++)n[e]=r[e];return n}var s,c,u=Function.prototype,l=Object.prototype,f=u.toString,h=l.hasOwnProperty,g=f.call(Object),p=l.toString,y=(s=Object.getPrototypeOf,c=Object,function(r){return s(c(r))});var m=function(t){if(!function(t){return!!t&&"object"==r(t)}(t)||"[object Object]"!=p.call(t)||function(r){var t=!1;if(null!=r&&"function"!=typeof r.toString)try{t=!!(r+"")}catch(r){}return t}(t))return!1;var e=y(t);if(null===e)return!0;var n=h.call(e,"constructor")&&e.constructor;return"function"==typeof n&&n instanceof n&&f.call(n)==g};function d(r){return"string"==typeof r?r.length>0?[r]:[]:r}function b(t){return t&&"object"===r(t)&&!Array.isArray(t)}function v(r){return"string"==typeof r}function w(r,t,e,n,i,a){var o="function"==typeof e?e():e;if(t<0&&i&&"EOL"===o)return o;if(t>=r.length&&!i)return!1;for(var s=i?1:e.length,c=!1,u=!1,l=n.maxMismatches,f=t,h=!1,g=!1,p=!1;r[f];){var y=a(f);if(n.trimBeforeMatching&&""===r[f].trim()){if(!r[y]&&i&&"EOL"===e)return!0;f=a(f)}else if(!n.i&&n.trimCharsBeforeMatching.includes(r[f])||n.i&&n.trimCharsBeforeMatching.map((function(r){return r.toLowerCase()})).includes(r[f].toLowerCase())){if(i&&"EOL"===e&&!r[y])return!0;f=a(f)}else{var m=y>f?e[e.length-s]:e[s-1];if(!n.i&&r[f]===m||n.i&&r[f].toLowerCase()===m.toLowerCase()){if(h||(h=!0),u||(u=!0),s===e.length?g=!0:1===s&&(p=!0),(s-=1)<1)return f}else{if(!(n.maxMismatches&&l&&f))return!(0!==f||1!==s||n.lastMustMatch||!u)&&0;l-=1;for(var d=0;d<=l;d++){var b=y>f?e[e.length-s+1+d]:e[s-2-d],v=r[a(f)];if(b&&(!n.i&&r[f]===b||n.i&&r[f].toLowerCase()===b.toLowerCase())&&(!n.firstMustMatch||s!==e.length)){s-=2,h=!0;break}if(v&&b&&(!n.i&&v===b||n.i&&v.toLowerCase()===b.toLowerCase())&&(!n.firstMustMatch||s!==e.length)){s-=1,h=!0;break}if(void 0===b&&l>=0&&h&&(!n.firstMustMatch||g)&&(!n.lastMustMatch||p))return f}h||(c=f)}if(!1!==c&&c!==f&&(c=!1),s<1)return f;f=a(f)}}return s>0?!(!i||"EOL"!==o)||!!(n.maxMismatches>=s&&u)&&(c||0):void 0}function T(t,e,n,a,o){var s={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1};if(b(o)&&Object.prototype.hasOwnProperty.call(o,"trimBeforeMatching")&&"boolean"!=typeof o.trimBeforeMatching)throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!").concat(Array.isArray(o.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""));var c,u,l,f,h=i(i({},s),o);if(h.trimCharsBeforeMatching=d(h.trimCharsBeforeMatching),h.trimCharsBeforeMatching=h.trimCharsBeforeMatching.map((function(r){return v(r)?r:String(r)})),!v(e))return!1;if(!e.length)return!1;if(!Number.isInteger(n)||n<0)throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ").concat(r(n),", equal to:\n").concat(JSON.stringify(n,null,4)));if(v(a))c=[a];else if(Array.isArray(a))c=a;else if(a){if("function"!=typeof a)throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ").concat(r(a),", equal to:\n").concat(JSON.stringify(a,null,4)));(c=[]).push(a)}else c=a;if(o&&!b(o))throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \"").concat(r(o),'", and equal to:\n').concat(JSON.stringify(o,null,4)));if(h.trimCharsBeforeMatching.some((function(r,t){return r.length>1&&(l=t,f=r,!0)})))throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ").concat(l," is longer than 1 character, ").concat(f.length," (equals to ").concat(f,"). Please split it into separate characters and put into array as separate elements."));if(!c||!Array.isArray(c)||Array.isArray(c)&&!c.length||Array.isArray(c)&&1===c.length&&v(c[0])&&!c[0].trim()){if("function"==typeof h.cb){var g,p=n;if("matchLeftIncl"!==t&&"matchRight"!==t||(p+=1),"L"===t[5])for(var y=p;y--;){var m=e[y];if((!h.trimBeforeMatching||h.trimBeforeMatching&&void 0!==m&&m.trim())&&(!h.trimCharsBeforeMatching.length||void 0!==m&&!h.trimCharsBeforeMatching.includes(m))){g=y;break}}else if(t.startsWith("matchRight"))for(var T=p;T<e.length;T++){var O=e[T];if((!h.trimBeforeMatching||h.trimBeforeMatching&&O.trim())&&(!h.trimCharsBeforeMatching.length||!h.trimCharsBeforeMatching.includes(O))){g=T;break}}if(void 0===g)return!1;var A=e[g],I=g+1,M="";return I&&I>0&&(M=e.slice(0,I)),"L"===t[5]?h.cb(A,M,g):(g&&g>0&&(M=e.slice(g)),h.cb(A,M,g))}var _="";throw o||(_=" More so, the whole options object, the fourth input argument, is missing!"),new Error("string-match-left-right/".concat(t,'(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!').concat(_))}for(var R=0,E=c.length;R<E;R++){u="function"==typeof c[R];var j=c[R],S=void 0,W=void 0,B="",N=n;"matchRight"===t?N+=1:"matchLeft"===t&&(N-=1);var D=w(e,N,j,h,u,(function(r){return"L"===t[5]?r-1:r+1}));if(D&&u&&"function"==typeof j&&"EOL"===j())return!(!j()||h.cb&&!h.cb(S,B,W))&&j();if(Number.isInteger(D)&&(W=t.startsWith("matchLeft")?D-1:D+1,B="L"===t[5]?e.slice(0,D):e.slice(W)),W<0&&(W=void 0),e[W]&&(S=e[W]),Number.isInteger(D)&&(!h.cb||h.cb(S,B,W)))return j}return!1}function O(r,t,e,n){return T("matchLeftIncl",r,t,e,n)}function A(r,t,e,n){return T("matchRightIncl",r,t,e,n)}var I=" ";function M(r){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;function e(r){return Array.from(r).reverse().join("")}function n(r,t,e){var n=e?"\n":"\r",i=e?"\r":"\n";if(!r)return r;for(var a=0,o="",s=0,c=r.length;s<c;s++)(r[s]===n||r[s]===i&&r[s-1]!==n)&&a++,"\r\n".includes(r[s])||r[s]===I?r[s]===I?o+=r[s]:r[s]===n?a<=t&&(o+=r[s],r[s+1]===i&&(o+=r[s+1],s++)):r[s]===i&&(!r[s-1]||r[s-1]!==n)&&a<=t&&(o+=r[s]):r[s+1]||a||(o+=" ");return o}if("string"==typeof r&&r.length){var i=1;"number"==typeof+t&&Number.isInteger(+t)&&+t>=0&&(i=+t);var a="",o="";if(r.trim()){if(!r[0].trim())for(var s=0,c=r.length;s<c;s++)if(r[s].trim()){a=r.slice(0,s);break}}else a=r;if(r.trim()&&(""===r.slice(-1).trim()||r.slice(-1)===I))for(var u=r.length;u--;)if(r[u].trim()){o=r.slice(u+1);break}return"".concat(n(a,i,!1)).concat(r.trim()).concat(e(n(e(o),i,!0)))}return r}function _(r,t){if(!Array.isArray(r)||!r.length)return r;var e,n,a=i(i({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null}),t);if(a.strictlyTwoElementsInRangeArrays&&!r.filter((function(r){return r})).every((function(r,t){return 2===r.length||(e=t,n=r.length,!1)})))throw new TypeError("ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ".concat(e,"th range (").concat(JSON.stringify(r[e],null,4),") has not two but ").concat(n," elements!"));if(!r.filter((function(r){return r})).every((function(r,t){return!(!Number.isInteger(r[0])||r[0]<0||!Number.isInteger(r[1])||r[1]<0)||(e=t,!1)})))throw new TypeError("ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ".concat(e,"th range (").concat(JSON.stringify(r[e],null,4),") does not consist of only natural numbers!"));var o=Math.pow(r.filter((function(r){return r})).length,2),s=0;return Array.from(r).filter((function(r){return r})).sort((function(r,t){return a.progressFn&&(s+=1,a.progressFn(Math.floor(100*s/o))),r[0]===t[0]?r[1]<t[1]?-1:r[1]>t[1]?1:0:r[0]<t[0]?-1:1}))}function R(t,e){function n(r){return"string"==typeof r}function o(t){return t&&"object"===r(t)&&!Array.isArray(t)}if(!Array.isArray(t)||!t.length)return null;var s,c={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};if(e){if(!o(e))throw new Error("emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n".concat(JSON.stringify(e,null,4)," (type ").concat(r(e),")"));if((s=i(i({},c),e)).progressFn&&o(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&"function"!=typeof s.progressFn)throw new Error('ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "'.concat(r(s.progressFn),'", equal to ').concat(JSON.stringify(s.progressFn,null,4)));if(s.mergeType&&1!==s.mergeType&&2!==s.mergeType)if(n(s.mergeType)&&"1"===s.mergeType.trim())s.mergeType=1;else{if(!n(s.mergeType)||"2"!==s.mergeType.trim())throw new Error('ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(r(s.mergeType),'", equal to ').concat(JSON.stringify(s.mergeType,null,4)));s.mergeType=2}if("boolean"!=typeof s.joinRangesThatTouchEdges)throw new Error('ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "'.concat(r(s.joinRangesThatTouchEdges),'", equal to ').concat(JSON.stringify(s.joinRangesThatTouchEdges,null,4)))}else s=i({},c);for(var u,l,f,h=t.filter((function(r){return r})).map((function(r){return a(r)})).filter((function(r){return void 0!==r[2]||r[0]!==r[1]})),g=(u=s.progressFn?_(h,{progressFn:function(r){(f=Math.floor(r/5))!==l&&(l=f,s.progressFn(f))}}):_(h)).length-1,p=g;p>0;p--)s.progressFn&&(f=Math.floor(78*(1-p/g))+21)!==l&&f>l&&(l=f,s.progressFn(f)),(u[p][0]<=u[p-1][0]||!s.joinRangesThatTouchEdges&&u[p][0]<u[p-1][1]||s.joinRangesThatTouchEdges&&u[p][0]<=u[p-1][1])&&(u[p-1][0]=Math.min(u[p][0],u[p-1][0]),u[p-1][1]=Math.max(u[p][1],u[p-1][1]),void 0!==u[p][2]&&(u[p-1][0]>=u[p][0]||u[p-1][1]<=u[p][1])&&null!==u[p-1][2]&&(null===u[p][2]&&null!==u[p-1][2]?u[p-1][2]=null:void 0!==u[p-1][2]?2===s.mergeType&&u[p-1][0]===u[p][0]?u[p-1][2]=u[p][2]:u[p-1][2]+=u[p][2]:u[p-1][2]=u[p][2]),u.splice(p,1),p=u.length);return u.length?u:null}function E(r){return null!=r}function j(r){return Number.isInteger(r)&&r>=0}function S(r){return"string"==typeof r}function W(r){return/^\d*$/.test(r)?parseInt(r,10):r}var B=function(){function e(t){!function(r,t){if(!(r instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e);var n=i(i({},{limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1}),t);if(n.mergeType&&1!==n.mergeType&&2!==n.mergeType)if(S(n.mergeType)&&"1"===n.mergeType.trim())n.mergeType=1;else{if(!S(n.mergeType)||"2"!==n.mergeType.trim())throw new Error('ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(r(n.mergeType),'", equal to ').concat(JSON.stringify(n.mergeType,null,4)));n.mergeType=2}this.opts=n}var n,o,s;return n=e,(o=[{key:"add",value:function(t,e,n){for(var i=this,o=arguments.length,s=new Array(o>3?o-3:0),c=3;c<o;c++)s[c-3]=arguments[c];if(s.length>0)throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_03] Please don't overload the add() method. From the 4th input argument onwards we see these redundant arguments: ".concat(JSON.stringify(s,null,4)));if(E(t)||E(e)){if(E(t)&&!E(e)){if(Array.isArray(t)){if(t.length){if(t.some((function(r){return Array.isArray(r)})))return void t.forEach((function(r){Array.isArray(r)&&i.add.apply(i,a(r))}));t.length>1&&j(W(t[0]))&&j(W(t[1]))&&this.add.apply(this,a(t))}return}throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set ('.concat(JSON.stringify(t,null,0),') but second-one, "to" is not (').concat(JSON.stringify(e,null,0),")"))}if(!E(t)&&E(e))throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set ('.concat(JSON.stringify(e,null,0),') but first-one, "from" is not (').concat(JSON.stringify(t,null,0),")"));var u=/^\d*$/.test(t)?parseInt(t,10):t,l=/^\d*$/.test(e)?parseInt(e,10):e;if(j(n)&&(n=String(n)),!j(u)||!j(l))throw j(u)&&u>=0?new TypeError('ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(r(l),'" equal to: ').concat(JSON.stringify(l,null,4))):new TypeError('ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(r(u),'" equal to: ').concat(JSON.stringify(u,null,4)));if(E(n)&&!S(n)&&!j(n))throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ".concat(r(n),", equal to:\n").concat(JSON.stringify(n,null,4)));if(E(this.ranges)&&Array.isArray(this.last())&&u===this.last()[1]){if(this.last()[1]=l,this.last()[2],null!==this.last()[2]&&E(n)){var f=!(E(this.last()[2])&&this.last()[2].length>0)||this.opts&&this.opts.mergeType&&1!==this.opts.mergeType?n:this.last()[2]+n;this.opts.limitToBeAddedWhitespace&&(f=M(f,this.opts.limitLinebreaksCount)),S(f)&&!f.length||(this.last()[2]=f)}}else{this.ranges||(this.ranges=[]);var h=void 0===n||S(n)&&!n.length?[u,l]:[u,l,this.opts.limitToBeAddedWhitespace?M(n,this.opts.limitLinebreaksCount):n];this.ranges.push(h)}}}},{key:"push",value:function(r,t,e){for(var n=arguments.length,i=new Array(n>3?n-3:0),a=3;a<n;a++)i[a-3]=arguments[a];this.add.apply(this,[r,t,e].concat(i))}},{key:"current",value:function(){var r=this;return null!=this.ranges?(this.ranges=R(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map((function(t){return E(t[2])?[t[0],t[1],M(t[2],r.opts.limitLinebreaksCount)]:t})):this.ranges):null}},{key:"wipe",value:function(){this.ranges=void 0}},{key:"replace",value:function(r){if(Array.isArray(r)&&r.length){if(!Array.isArray(r[0])||!j(r[0][0]))throw new Error("ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ".concat(JSON.stringify(r[0],null,4)," should be an array and its first element should be an integer, a string index."));this.ranges=Array.from(r)}else this.ranges=void 0}},{key:"last",value:function(){return void 0!==this.ranges&&Array.isArray(this.ranges)?this.ranges[this.ranges.length-1]:null}}])&&t(n.prototype,o),s&&t(n,s),e}();function N(r){return null!=r}function D(r){return"string"==typeof r}function C(t,e,n){var i,a=0,o=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(!D(t))throw new TypeError("ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ".concat(r(t),", equal to: ").concat(JSON.stringify(t,null,4)));if(e&&!Array.isArray(e))throw new TypeError("ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ".concat(r(e),", equal to: ").concat(JSON.stringify(e,null,4)));if(n&&"function"!=typeof n)throw new TypeError("ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ".concat(r(n),", equal to: ").concat(JSON.stringify(n,null,4)));if(!e||!e.filter((function(r){return r})).length)return t;var s=(i=Array.isArray(e)&&(Number.isInteger(e[0])&&e[0]>=0||/^\d*$/.test(e[0]))&&(Number.isInteger(e[1])&&e[1]>=0||/^\d*$/.test(e[1]))?[Array.from(e)]:Array.from(e)).length,c=0;i.filter((function(r){return r})).forEach((function(t,e){if(n&&(a=Math.floor(c/s*10))!==o&&(o=a,n(a)),!Array.isArray(t))throw new TypeError("ranges-apply: [THROW_ID_05] ranges array, second input arg., has ".concat(e,"th element not an array: ").concat(JSON.stringify(t,null,4),", which is ").concat(r(t)));if(!Number.isInteger(t[0])||t[0]<0){if(!/^\d*$/.test(t[0]))throw new TypeError("ranges-apply: [THROW_ID_06] ranges array, second input arg. has ".concat(e,"th element, array [").concat(t[0],",").concat(t[1],"]. That array has first element not an integer, but ").concat(r(t[0]),", equal to: ").concat(JSON.stringify(t[0],null,4),". Computer doesn't like this."));i[e][0]=Number.parseInt(i[e][0],10)}if(!Number.isInteger(t[1])){if(!/^\d*$/.test(t[1]))throw new TypeError("ranges-apply: [THROW_ID_07] ranges array, second input arg. has ".concat(e,"th element, array [").concat(t[0],",").concat(t[1],"]. That array has second element not an integer, but ").concat(r(t[1]),", equal to: ").concat(JSON.stringify(t[1],null,4),". Computer doesn't like this."));i[e][1]=Number.parseInt(i[e][1],10)}c+=1}));var u=R(i,{progressFn:function(r){n&&(a=10+Math.floor(r/10))!==o&&(o=a,n(a))}});if(!u)return t;var l=u.length;if(l>0){var f=t.slice(u[l-1][1]);t=u.reduce((function(r,e,i,s){n&&(a=20+Math.floor(i/l*80))!==o&&(o=a,n(a));var c=0===i?0:s[i-1][1],u=s[i][0];return r+t.slice(c,u)+(N(s[i][2])?s[i][2]:"")}),""),t+=f}return t}function H(t,e){if("string"!=typeof t)throw new Error("string-trim-spaces-only: [THROW_ID_01] input must be string! It was given as ".concat(r(t),", equal to:\n").concat(JSON.stringify(t,null,4)));var n,a,o=i(i({},{classicTrim:!1,cr:!1,lf:!1,tab:!1,space:!0,nbsp:!1}),e);function s(r){return o.classicTrim&&!r.trim()||!o.classicTrim&&(o.space&&" "===r||o.cr&&"\r"===r||o.lf&&"\n"===r||o.tab&&"\t"===r||o.nbsp&&" "===r)}if(t.length){if(s(t[0]))for(var c=0,u=t.length;c<u;c++){if(!s(t[c])){n=c;break}if(c===t.length-1)return{res:"",ranges:[[0,t.length]]}}if(s(t[t.length-1]))for(var l=t.length;l--;)if(!s(t[l])){a=l+1;break}return n?a?{res:t.slice(n,a),ranges:[[0,n],[a,t.length]]}:{res:t.slice(n),ranges:[[0,n]]}:a?{res:t.slice(0,a),ranges:[[a,t.length]]}:{res:t,ranges:[]}}return{res:"",ranges:[]}}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function n(r){return null!=r}var a=Object.prototype.hasOwnProperty;function o(r){return"string"==typeof r}if(void 0===t)throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_01] The input is missing!");if("string"!=typeof t)return t;if(n(e)&&!m(e))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_03] The given options are not a plain object but ".concat(r(e),"!"));if(n(e)&&a.call(e,"heads")){if(!d(e.heads).every((function(r){return o(r)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_04] The opts.heads contains elements which are not string-type!");o(e.heads)&&(e.heads=d(e.heads))}if(n(e)&&a.call(e,"tails")){if(!d(e.tails).every((function(r){return o(r)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_05] The opts.tails contains elements which are not string-type!");o(e.tails)&&(e.tails=d(e.tails))}var s=H(t).res;if(0===s.length)return t;t=s;var c={heads:["{{"],tails:["}}"]},u=i(i({},c),e);u.heads=u.heads.map((function(r){return r.trim()})),u.tails=u.tails.map((function(r){return r.trim()}));var l=!1,f=!1,h=new B({limitToBeAddedWhitespace:!0}),g=new B({limitToBeAddedWhitespace:!0}),p=!0,y=!0,b="";function v(r,t){var e;return A(r,0,t.heads,{trimBeforeMatching:!0,cb:function(r,t,n){return e=n,!0},relaxedApi:!0})&&A(r,e,t.tails,{trimBeforeMatching:!0,cb:function(r,t,n){return e=n,!0},relaxedApi:!0})?r.slice(e):r}for(;t!==v(t,u);)t=H(v(t,u)).res;function w(r,t){var e;return O(r,r.length-1,t.tails,{trimBeforeMatching:!0,cb:function(r,t,n){return e=n,!0},relaxedApi:!0})&&O(r,e,t.heads,{trimBeforeMatching:!0,cb:function(r,t,n){return e=n,!0},relaxedApi:!0})?r.slice(0,e+1):r}for(;t!==w(t,u);)t=H(w(t,u)).res;if(!(u.heads.length&&A(t,0,u.heads,{trimBeforeMatching:!0,relaxedApi:!0})&&u.tails.length&&O(t,t.length-1,u.tails,{trimBeforeMatching:!0,relaxedApi:!0})))return H(t).res;for(var T=0,I=t.length;T<I;T++)if(""===t[T].trim());else{var M=void 0,_=A(t,T,u.heads,{trimBeforeMatching:!0,cb:function(r,t,e){return M=e,!0},relaxedApi:!0});if(_){y=!0,p&&(p=!0);var R=void 0,E=A(t,M,u.tails,{trimBeforeMatching:!0,cb:function(r,t,e){return R=e,!0},relaxedApi:!0});E&&h.push(T,R),g.current()&&l&&"tails"!==b&&h.push(g.current()),l||g.current()&&(h.push(g.current()),g.wipe()),g.push(T,M),b="heads",T=M-1;continue}var j=A(t,T,u.tails,{trimBeforeMatching:!0,cb:function(r,e,i){return M=n(i)?i:t.length,!0},relaxedApi:!0});if(j){y=!0,p?("heads"===b&&g.wipe(),p=!1):g.push(T,M),b="tails",T=M-1;continue}p&&(p=!0),y&&!l?(l=!0,y=!1):y&&!f?(f=!0,p=!0,y=!1,"heads"===b&&g.wipe()):y&&f&&g.wipe()}return g.current()&&h.push(g.current()),h.current()?C(t,h.current()).trim():t.trim()}}));
