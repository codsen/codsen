/**
 * string-remove-duplicate-heads-tails
 * Detect and (recursively) remove head and tail wrappings around the input string
 * Version: 4.0.2
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/string-remove-duplicate-heads-tails/
 */

!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(t="undefined"!=typeof globalThis?globalThis:t||self).stringRemoveDuplicateHeadsTails=r()}(this,(function(){"use strict";function t(r){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(r)}function r(t,r){for(var e=0;e<r.length;e++){var n=r[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function e(t,r,e){return r in t?Object.defineProperty(t,r,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[r]=e,t}function n(t,r){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(t,r).enumerable}))),e.push.apply(e,n)}return e}function i(t){for(var r=1;r<arguments.length;r++){var i=null!=arguments[r]?arguments[r]:{};r%2?n(Object(i),!0).forEach((function(r){e(t,r,i[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):n(Object(i)).forEach((function(r){Object.defineProperty(t,r,Object.getOwnPropertyDescriptor(i,r))}))}return t}function a(t){return function(t){if(Array.isArray(t))return o(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,r){if(!t)return;if("string"==typeof t)return o(t,r);var e=Object.prototype.toString.call(t).slice(8,-1);"Object"===e&&t.constructor&&(e=t.constructor.name);if("Map"===e||"Set"===e)return Array.from(t);if("Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))return o(t,r)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(t,r){(null==r||r>t.length)&&(r=t.length);for(var e=0,n=new Array(r);e<r;e++)n[e]=t[e];return n}var s,c,u=Function.prototype,l=Object.prototype,f=u.toString,h=l.hasOwnProperty,g=f.call(Object),p=l.toString,y=(s=Object.getPrototypeOf,c=Object,function(t){return s(c(t))});var m=function(r){if(!function(r){return!!r&&"object"==t(r)}(r)||"[object Object]"!=p.call(r)||function(t){var r=!1;if(null!=t&&"function"!=typeof t.toString)try{r=!!(t+"")}catch(t){}return r}(r))return!1;var e=y(r);if(null===e)return!0;var n=h.call(e,"constructor")&&e.constructor;return"function"==typeof n&&n instanceof n&&f.call(n)==g};function d(t){return"string"==typeof t?t.length>0?[t]:[]:t}function b(r){return r&&"object"===t(r)&&!Array.isArray(r)}function v(t){return"string"==typeof t}function w(t,r,e,n,i,a){var o="function"==typeof e?e():e;if(r<0&&i&&"EOL"===o)return o;if(r>=t.length&&!i)return!1;for(var s=i?1:e.length,c=!1,u=!1,l=n.maxMismatches,f=r,h=!1,g=!1,p=!1;t[f];){var y=a(f);if(n.trimBeforeMatching&&""===t[f].trim()){if(!t[y]&&i&&"EOL"===e)return!0;f=a(f)}else if(!n.i&&n.trimCharsBeforeMatching.includes(t[f])||n.i&&n.trimCharsBeforeMatching.map((function(t){return t.toLowerCase()})).includes(t[f].toLowerCase())){if(i&&"EOL"===e&&!t[y])return!0;f=a(f)}else{var m=y>f?e[e.length-s]:e[s-1];if(!n.i&&t[f]===m||n.i&&t[f].toLowerCase()===m.toLowerCase()){if(h||(h=!0),u||(u=!0),s===e.length?g=!0:1===s&&(p=!0),(s-=1)<1)return f}else{if(!(n.maxMismatches&&l&&f))return!(0!==f||1!==s||n.lastMustMatch||!u)&&0;l-=1;for(var d=0;d<=l;d++){var b=y>f?e[e.length-s+1+d]:e[s-2-d],v=t[a(f)];if(b&&(!n.i&&t[f]===b||n.i&&t[f].toLowerCase()===b.toLowerCase())&&(!n.firstMustMatch||s!==e.length)){s-=2,h=!0;break}if(v&&b&&(!n.i&&v===b||n.i&&v.toLowerCase()===b.toLowerCase())&&(!n.firstMustMatch||s!==e.length)){s-=1,h=!0;break}if(void 0===b&&l>=0&&h&&(!n.firstMustMatch||g)&&(!n.lastMustMatch||p))return f}h||(c=f)}if(!1!==c&&c!==f&&(c=!1),s<1)return f;f=a(f)}}return s>0?!(!i||"EOL"!==o)||!!(n.maxMismatches>=s&&u)&&(c||0):void 0}function T(r,e,n,a,o){var s={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1};if(b(o)&&Object.prototype.hasOwnProperty.call(o,"trimBeforeMatching")&&"boolean"!=typeof o.trimBeforeMatching)throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!").concat(Array.isArray(o.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""));var c,u,l,f,h=i(i({},s),o);if(h.trimCharsBeforeMatching=d(h.trimCharsBeforeMatching),h.trimCharsBeforeMatching=h.trimCharsBeforeMatching.map((function(t){return v(t)?t:String(t)})),!v(e))return!1;if(!e.length)return!1;if(!Number.isInteger(n)||n<0)throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ").concat(t(n),", equal to:\n").concat(JSON.stringify(n,null,4)));if(v(a))c=[a];else if(Array.isArray(a))c=a;else if(a){if("function"!=typeof a)throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ").concat(t(a),", equal to:\n").concat(JSON.stringify(a,null,4)));(c=[]).push(a)}else c=a;if(o&&!b(o))throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \"").concat(t(o),'", and equal to:\n').concat(JSON.stringify(o,null,4)));if(h.trimCharsBeforeMatching.some((function(t,r){return t.length>1&&(l=r,f=t,!0)})))throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ").concat(l," is longer than 1 character, ").concat(f.length," (equals to ").concat(f,"). Please split it into separate characters and put into array as separate elements."));if(!c||!Array.isArray(c)||Array.isArray(c)&&!c.length||Array.isArray(c)&&1===c.length&&v(c[0])&&!c[0].trim()){if("function"==typeof h.cb){var g,p=n;if("matchLeftIncl"!==r&&"matchRight"!==r||(p+=1),"L"===r[5])for(var y=p;y--;){var m=e[y];if((!h.trimBeforeMatching||h.trimBeforeMatching&&void 0!==m&&m.trim())&&(!h.trimCharsBeforeMatching.length||void 0!==m&&!h.trimCharsBeforeMatching.includes(m))){g=y;break}}else if(r.startsWith("matchRight"))for(var T=p;T<e.length;T++){var O=e[T];if((!h.trimBeforeMatching||h.trimBeforeMatching&&O.trim())&&(!h.trimCharsBeforeMatching.length||!h.trimCharsBeforeMatching.includes(O))){g=T;break}}if(void 0===g)return!1;var A=e[g],I=g+1,M="";return I&&I>0&&(M=e.slice(0,I)),"L"===r[5]?h.cb(A,M,g):(g&&g>0&&(M=e.slice(g)),h.cb(A,M,g))}var _="";throw o||(_=" More so, the whole options object, the fourth input argument, is missing!"),new Error("string-match-left-right/".concat(r,'(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!').concat(_))}for(var R=0,E=c.length;R<E;R++){u="function"==typeof c[R];var j=c[R],S=void 0,W=void 0,B="",N=n;"matchRight"===r?N+=1:"matchLeft"===r&&(N-=1);var D=w(e,N,j,h,u,(function(t){return"L"===r[5]?t-1:t+1}));if(D&&u&&"function"==typeof j&&"EOL"===j())return!(!j()||h.cb&&!h.cb(S,B,W))&&j();if(Number.isInteger(D)&&(W=r.startsWith("matchLeft")?D-1:D+1,B="L"===r[5]?e.slice(0,D):e.slice(W)),W<0&&(W=void 0),e[W]&&(S=e[W]),Number.isInteger(D)&&(!h.cb||h.cb(S,B,W)))return j}return!1}function O(t,r,e,n){return T("matchLeftIncl",t,r,e,n)}function A(t,r,e,n){return T("matchRightIncl",t,r,e,n)}var I=" ";function M(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;function e(t){return Array.from(t).reverse().join("")}function n(t,r,e){var n=e?"\n":"\r",i=e?"\r":"\n";if(!t)return t;for(var a=0,o="",s=0,c=t.length;s<c;s++)(t[s]===n||t[s]===i&&t[s-1]!==n)&&a++,"\r\n".includes(t[s])||t[s]===I?t[s]===I?o+=t[s]:t[s]===n?a<=r&&(o+=t[s],t[s+1]===i&&(o+=t[s+1],s++)):t[s]===i&&(!t[s-1]||t[s-1]!==n)&&a<=r&&(o+=t[s]):t[s+1]||a||(o+=" ");return o}if("string"==typeof t&&t.length){var i=1;"number"==typeof+r&&Number.isInteger(+r)&&+r>=0&&(i=+r);var a="",o="";if(t.trim()){if(!t[0].trim())for(var s=0,c=t.length;s<c;s++)if(t[s].trim()){a=t.slice(0,s);break}}else a=t;if(t.trim()&&(""===t.slice(-1).trim()||t.slice(-1)===I))for(var u=t.length;u--;)if(t[u].trim()){o=t.slice(u+1);break}return"".concat(n(a,i,!1)).concat(t.trim()).concat(e(n(e(o),i,!0)))}return t}function _(t,r){if(!Array.isArray(t)||!t.length)return t;var e,n,a=i(i({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null}),r);if(a.strictlyTwoElementsInRangeArrays&&!t.filter((function(t){return t})).every((function(t,r){return 2===t.length||(e=r,n=t.length,!1)})))throw new TypeError("ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ".concat(e,"th range (").concat(JSON.stringify(t[e],null,4),") has not two but ").concat(n," elements!"));if(!t.filter((function(t){return t})).every((function(t,r){return!(!Number.isInteger(t[0])||t[0]<0||!Number.isInteger(t[1])||t[1]<0)||(e=r,!1)})))throw new TypeError("ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ".concat(e,"th range (").concat(JSON.stringify(t[e],null,4),") does not consist of only natural numbers!"));var o=Math.pow(t.filter((function(t){return t})).length,2),s=0;return Array.from(t).filter((function(t){return t})).sort((function(t,r){return a.progressFn&&(s+=1,a.progressFn(Math.floor(100*s/o))),t[0]===r[0]?t[1]<r[1]?-1:t[1]>r[1]?1:0:t[0]<r[0]?-1:1}))}function R(r,e){function n(r){return r&&"object"===t(r)&&!Array.isArray(r)}if(!Array.isArray(r)||!r.length)return null;var o,s={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};if(e){if(!n(e))throw new Error("emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n".concat(JSON.stringify(e,null,4)," (type ").concat(t(e),")"));if((o=i(i({},s),e)).progressFn&&n(o.progressFn)&&!Object.keys(o.progressFn).length)o.progressFn=null;else if(o.progressFn&&"function"!=typeof o.progressFn)throw new Error('ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "'.concat(t(o.progressFn),'", equal to ').concat(JSON.stringify(o.progressFn,null,4)));if(o.mergeType&&1!=+o.mergeType&&2!=+o.mergeType)throw new Error('ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(t(o.mergeType),'", equal to ').concat(JSON.stringify(o.mergeType,null,4)));if("boolean"!=typeof o.joinRangesThatTouchEdges)throw new Error('ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "'.concat(t(o.joinRangesThatTouchEdges),'", equal to ').concat(JSON.stringify(o.joinRangesThatTouchEdges,null,4)))}else o=i({},s);for(var c,u,l,f=r.filter((function(t){return t})).map((function(t){return a(t)})).filter((function(t){return void 0!==t[2]||t[0]!==t[1]})),h=(c=o.progressFn?_(f,{progressFn:function(t){(l=Math.floor(t/5))!==u&&(u=l,o.progressFn(l))}}):_(f)).length-1,g=h;g>0;g--)o.progressFn&&(l=Math.floor(78*(1-g/h))+21)!==u&&l>u&&(u=l,o.progressFn(l)),(c[g][0]<=c[g-1][0]||!o.joinRangesThatTouchEdges&&c[g][0]<c[g-1][1]||o.joinRangesThatTouchEdges&&c[g][0]<=c[g-1][1])&&(c[g-1][0]=Math.min(c[g][0],c[g-1][0]),c[g-1][1]=Math.max(c[g][1],c[g-1][1]),void 0!==c[g][2]&&(c[g-1][0]>=c[g][0]||c[g-1][1]<=c[g][1])&&null!==c[g-1][2]&&(null===c[g][2]&&null!==c[g-1][2]?c[g-1][2]=null:void 0!==c[g-1][2]?2==+o.mergeType&&c[g-1][0]===c[g][0]?c[g-1][2]=c[g][2]:c[g-1][2]+=c[g][2]:c[g-1][2]=c[g][2]),c.splice(g,1),g=c.length);return c.length?c:null}function E(t){return null!=t}function j(t){return Number.isInteger(t)&&t>=0}function S(t){return"string"==typeof t}function W(t){return/^\d*$/.test(t)?parseInt(t,10):t}var B=function(){function e(r){!function(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,e);var n=i(i({},{limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1}),r);if(n.mergeType&&1!==n.mergeType&&2!==n.mergeType)if(S(n.mergeType)&&"1"===n.mergeType.trim())n.mergeType=1;else{if(!S(n.mergeType)||"2"!==n.mergeType.trim())throw new Error('ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(t(n.mergeType),'", equal to ').concat(JSON.stringify(n.mergeType,null,4)));n.mergeType=2}this.opts=n}var n,o,s;return n=e,(o=[{key:"add",value:function(r,e,n){for(var i=this,o=arguments.length,s=new Array(o>3?o-3:0),c=3;c<o;c++)s[c-3]=arguments[c];if(s.length>0)throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_03] Please don't overload the add() method. From the 4th input argument onwards we see these redundant arguments: ".concat(JSON.stringify(s,null,4)));if(E(r)||E(e)){if(E(r)&&!E(e)){if(Array.isArray(r)){if(r.length){if(r.some((function(t){return Array.isArray(t)})))return void r.forEach((function(t){Array.isArray(t)&&i.add.apply(i,a(t))}));r.length>1&&j(W(r[0]))&&j(W(r[1]))&&this.add.apply(this,a(r))}return}throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set ('.concat(JSON.stringify(r,null,0),') but second-one, "to" is not (').concat(JSON.stringify(e,null,0),")"))}if(!E(r)&&E(e))throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set ('.concat(JSON.stringify(e,null,0),') but first-one, "from" is not (').concat(JSON.stringify(r,null,0),")"));var u=/^\d*$/.test(r)?parseInt(r,10):r,l=/^\d*$/.test(e)?parseInt(e,10):e;if(j(n)&&(n=String(n)),!j(u)||!j(l))throw j(u)&&u>=0?new TypeError('ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(t(l),'" equal to: ').concat(JSON.stringify(l,null,4))):new TypeError('ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(t(u),'" equal to: ').concat(JSON.stringify(u,null,4)));if(E(n)&&!S(n)&&!j(n))throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ".concat(t(n),", equal to:\n").concat(JSON.stringify(n,null,4)));if(E(this.ranges)&&Array.isArray(this.last())&&u===this.last()[1]){if(this.last()[1]=l,this.last()[2],null!==this.last()[2]&&E(n)){var f=!(E(this.last()[2])&&this.last()[2].length>0)||this.opts&&this.opts.mergeType&&1!==this.opts.mergeType?n:this.last()[2]+n;this.opts.limitToBeAddedWhitespace&&(f=M(f,this.opts.limitLinebreaksCount)),S(f)&&!f.length||(this.last()[2]=f)}}else{this.ranges||(this.ranges=[]);var h=void 0===n||S(n)&&!n.length?[u,l]:[u,l,this.opts.limitToBeAddedWhitespace?M(n,this.opts.limitLinebreaksCount):n];this.ranges.push(h)}}}},{key:"push",value:function(t,r,e){for(var n=arguments.length,i=new Array(n>3?n-3:0),a=3;a<n;a++)i[a-3]=arguments[a];this.add.apply(this,[t,r,e].concat(i))}},{key:"current",value:function(){var t=this;return null!=this.ranges?(this.ranges=R(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map((function(r){return E(r[2])?[r[0],r[1],M(r[2],t.opts.limitLinebreaksCount)]:r})):this.ranges):null}},{key:"wipe",value:function(){this.ranges=void 0}},{key:"replace",value:function(t){if(Array.isArray(t)&&t.length){if(!Array.isArray(t[0])||!j(t[0][0]))throw new Error("ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ".concat(JSON.stringify(t[0],null,4)," should be an array and its first element should be an integer, a string index."));this.ranges=Array.from(t)}else this.ranges=void 0}},{key:"last",value:function(){return void 0!==this.ranges&&Array.isArray(this.ranges)?this.ranges[this.ranges.length-1]:null}}])&&r(n.prototype,o),s&&r(n,s),e}();function N(t){return null!=t}function D(t){return"string"==typeof t}function C(r,e,n){var i,a=0,o=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(!D(r))throw new TypeError("ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ".concat(t(r),", equal to: ").concat(JSON.stringify(r,null,4)));if(e&&!Array.isArray(e))throw new TypeError("ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ".concat(t(e),", equal to: ").concat(JSON.stringify(e,null,4)));if(n&&"function"!=typeof n)throw new TypeError("ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ".concat(t(n),", equal to: ").concat(JSON.stringify(n,null,4)));if(!e||!e.filter((function(t){return t})).length)return r;var s=(i=Array.isArray(e)&&(Number.isInteger(e[0])&&e[0]>=0||/^\d*$/.test(e[0]))&&(Number.isInteger(e[1])&&e[1]>=0||/^\d*$/.test(e[1]))?[Array.from(e)]:Array.from(e)).length,c=0;i.filter((function(t){return t})).forEach((function(r,e){if(n&&(a=Math.floor(c/s*10))!==o&&(o=a,n(a)),!Array.isArray(r))throw new TypeError("ranges-apply: [THROW_ID_05] ranges array, second input arg., has ".concat(e,"th element not an array: ").concat(JSON.stringify(r,null,4),", which is ").concat(t(r)));if(!Number.isInteger(r[0])||r[0]<0){if(!/^\d*$/.test(r[0]))throw new TypeError("ranges-apply: [THROW_ID_06] ranges array, second input arg. has ".concat(e,"th element, array [").concat(r[0],",").concat(r[1],"]. That array has first element not an integer, but ").concat(t(r[0]),", equal to: ").concat(JSON.stringify(r[0],null,4),". Computer doesn't like this."));i[e][0]=Number.parseInt(i[e][0],10)}if(!Number.isInteger(r[1])){if(!/^\d*$/.test(r[1]))throw new TypeError("ranges-apply: [THROW_ID_07] ranges array, second input arg. has ".concat(e,"th element, array [").concat(r[0],",").concat(r[1],"]. That array has second element not an integer, but ").concat(t(r[1]),", equal to: ").concat(JSON.stringify(r[1],null,4),". Computer doesn't like this."));i[e][1]=Number.parseInt(i[e][1],10)}c+=1}));var u=R(i,{progressFn:function(t){n&&(a=10+Math.floor(t/10))!==o&&(o=a,n(a))}});if(!u)return r;var l=u.length;if(l>0){var f=r.slice(u[l-1][1]);r=u.reduce((function(t,e,i,s){n&&(a=20+Math.floor(i/l*80))!==o&&(o=a,n(a));var c=0===i?0:s[i-1][1],u=s[i][0];return t+r.slice(c,u)+(N(s[i][2])?s[i][2]:"")}),""),r+=f}return r}function H(r,e){if("string"!=typeof r)throw new Error("string-trim-spaces-only: [THROW_ID_01] input must be string! It was given as ".concat(t(r),", equal to:\n").concat(JSON.stringify(r,null,4)));var n,a,o=i(i({},{classicTrim:!1,cr:!1,lf:!1,tab:!1,space:!0,nbsp:!1}),e);function s(t){return o.classicTrim&&!t.trim()||!o.classicTrim&&(o.space&&" "===t||o.cr&&"\r"===t||o.lf&&"\n"===t||o.tab&&"\t"===t||o.nbsp&&" "===t)}if(r.length){if(s(r[0]))for(var c=0,u=r.length;c<u;c++){if(!s(r[c])){n=c;break}if(c===r.length-1)return{res:"",ranges:[[0,r.length]]}}if(s(r[r.length-1]))for(var l=r.length;l--;)if(!s(r[l])){a=l+1;break}return n?a?{res:r.slice(n,a),ranges:[[0,n],[a,r.length]]}:{res:r.slice(n),ranges:[[0,n]]}:a?{res:r.slice(0,a),ranges:[[a,r.length]]}:{res:r,ranges:[]}}return{res:"",ranges:[]}}return function(r){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function n(t){return null!=t}var a=Object.prototype.hasOwnProperty;function o(t){return"string"==typeof t}if(void 0===r)throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_01] The input is missing!");if("string"!=typeof r)return r;if(n(e)&&!m(e))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_03] The given options are not a plain object but ".concat(t(e),"!"));if(n(e)&&a.call(e,"heads")){if(!d(e.heads).every((function(t){return o(t)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_04] The opts.heads contains elements which are not string-type!");o(e.heads)&&(e.heads=d(e.heads))}if(n(e)&&a.call(e,"tails")){if(!d(e.tails).every((function(t){return o(t)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_05] The opts.tails contains elements which are not string-type!");o(e.tails)&&(e.tails=d(e.tails))}var s=H(r).res;if(0===s.length)return r;r=s;var c={heads:["{{"],tails:["}}"]},u=i(i({},c),e);u.heads=u.heads.map((function(t){return t.trim()})),u.tails=u.tails.map((function(t){return t.trim()}));var l=!1,f=!1,h=new B({limitToBeAddedWhitespace:!0}),g=new B({limitToBeAddedWhitespace:!0}),p=!0,y=!0,b="";function v(t,r){var e;return A(t,0,r.heads,{trimBeforeMatching:!0,cb:function(t,r,n){return e=n,!0},relaxedApi:!0})&&A(t,e,r.tails,{trimBeforeMatching:!0,cb:function(t,r,n){return e=n,!0},relaxedApi:!0})?t.slice(e):t}for(;r!==v(r,u);)r=H(v(r,u)).res;function w(t,r){var e;return O(t,t.length-1,r.tails,{trimBeforeMatching:!0,cb:function(t,r,n){return e=n,!0},relaxedApi:!0})&&O(t,e,r.heads,{trimBeforeMatching:!0,cb:function(t,r,n){return e=n,!0},relaxedApi:!0})?t.slice(0,e+1):t}for(;r!==w(r,u);)r=H(w(r,u)).res;if(!(u.heads.length&&A(r,0,u.heads,{trimBeforeMatching:!0,relaxedApi:!0})&&u.tails.length&&O(r,r.length-1,u.tails,{trimBeforeMatching:!0,relaxedApi:!0})))return H(r).res;for(var T=0,I=r.length;T<I;T++)if(""===r[T].trim());else{var M=void 0,_=A(r,T,u.heads,{trimBeforeMatching:!0,cb:function(t,r,e){return M=e,!0},relaxedApi:!0});if(_){y=!0,p&&(p=!0);var R=void 0,E=A(r,M,u.tails,{trimBeforeMatching:!0,cb:function(t,r,e){return R=e,!0},relaxedApi:!0});E&&h.push(T,R),g.current()&&l&&"tails"!==b&&h.push(g.current()),l||g.current()&&(h.push(g.current()),g.wipe()),g.push(T,M),b="heads",T=M-1;continue}var j=A(r,T,u.tails,{trimBeforeMatching:!0,cb:function(t,e,i){return M=n(i)?i:r.length,!0},relaxedApi:!0});if(j){y=!0,p?("heads"===b&&g.wipe(),p=!1):g.push(T,M),b="tails",T=M-1;continue}p&&(p=!0),y&&!l?(l=!0,y=!1):y&&!f?(f=!0,p=!0,y=!1,"heads"===b&&g.wipe()):y&&f&&g.wipe()}return g.current()&&h.push(g.current()),h.current()?C(r,h.current()).trim():r.trim()}}));
