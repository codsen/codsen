/**
 * emlint
 * Pluggable email template code linter
 * Version: 2.16.0
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/emlint
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.emlint = {}));
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    return function () {
      var Super = _getPrototypeOf(Derived),
          result;

      if (_isNativeReflectConstruct()) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** `Object#toString` result references. */
  var objectTag = '[object Object]';
  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */

  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;

    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }

    return result;
  }
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */


  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  /** Used for built-in method references. */


  var funcProto = Function.prototype,
      objectProto = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /** Used to infer the `Object` constructor. */

  var objectCtorString = funcToString.call(Object);
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var objectToString = objectProto.toString;
  /** Built-in value references. */

  var getPrototype = overArg(Object.getPrototypeOf, Object);
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */

  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */


  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }

    var proto = getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }

  var lodash_isplainobject = isPlainObject;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  var lodash_clonedeep = createCommonjsModule(function (module, exports) {
    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER = 9007199254740991;
    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */

    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to match `RegExp` flags from their coerced string values. */

    var reFlags = /\w*$/;
    /** Used to detect host constructors (Safari). */

    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values supported by `_.clone`. */

    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    /** Detect free variable `global` from Node.js. */

    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */

    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */

    var freeExports =  exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /**
     * Adds the key-value `pair` to `map`.
     *
     * @private
     * @param {Object} map The map to modify.
     * @param {Array} pair The key-value pair to add.
     * @returns {Object} Returns `map`.
     */

    function addMapEntry(map, pair) {
      // Don't return `map.set` because it's not chainable in IE 11.
      map.set(pair[0], pair[1]);
      return map;
    }
    /**
     * Adds `value` to `set`.
     *
     * @private
     * @param {Object} set The set to modify.
     * @param {*} value The value to add.
     * @returns {Object} Returns `set`.
     */


    function addSetEntry(set, value) {
      // Don't return `set.add` because it's not chainable in IE 11.
      set.add(value);
      return set;
    }
    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */


    function arrayEach(array, iteratee) {
      var index = -1,
          length = array ? array.length : 0;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }

      return array;
    }
    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */


    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }

      return array;
    }
    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */


    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array ? array.length : 0;

      if (initAccum && length) {
        accumulator = array[++index];
      }

      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }

      return accumulator;
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */


    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */


    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */


    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;

      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }

      return result;
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */


    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */


    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */


    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }
    /** Used for built-in method references. */


    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */

    var coreJsData = root['__core-js_shared__'];
    /** Used to detect methods masquerading as native. */

    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();
    /** Used to resolve the decompiled source of functions. */


    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var objectToString = objectProto.toString;
    /** Used to detect if a method is native. */

    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */

    var Buffer = moduleExports ? root.Buffer : undefined,
        Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeKeys = overArg(Object.keys, Object);
    /* Built-in method references that are verified to be native. */

    var DataView = getNative(root, 'DataView'),
        Map = getNative(root, 'Map'),
        Promise = getNative(root, 'Promise'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    /** Used to detect maps, sets, and weakmaps. */

    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */

    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Hash(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */


    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function hashGet(key) {
      var data = this.__data__;

      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }

      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */


    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    } // Add methods to `Hash`.


    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function ListCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */


    function listCacheClear() {
      this.__data__ = [];
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }

      var lastIndex = data.length - 1;

      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }

      return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */


    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }

      return this;
    } // Add methods to `ListCache`.


    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function MapCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */


    function mapCacheClear() {
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function mapCacheDelete(key) {
      return getMapData(this, key)['delete'](key);
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */


    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    } // Add methods to `MapCache`.


    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */


    function stackClear() {
      this.__data__ = new ListCache();
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function stackDelete(key) {
      return this.__data__['delete'](key);
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function stackGet(key) {
      return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function stackHas(key) {
      return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */


    function stackSet(key, value) {
      var cache = this.__data__;

      if (cache instanceof ListCache) {
        var pairs = cache.__data__;

        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }

        cache = this.__data__ = new MapCache(pairs);
      }

      cache.set(key, value);
      return this;
    } // Add methods to `Stack`.


    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      // Safari 9 makes `arguments.length` enumerable in strict mode.
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length,
          skipIndexes = !!length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */


    function assignValue(object, key, value) {
      var objValue = object[key];

      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        object[key] = value;
      }
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function assocIndexOf(array, key) {
      var length = array.length;

      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */


    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {boolean} [isFull] Specify a clone including symbols.
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */


    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }

      if (result !== undefined) {
        return result;
      }

      if (!isObject(value)) {
        return value;
      }

      var isArr = isArray(value);

      if (isArr) {
        result = initCloneArray(value);

        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }

        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }

          result = initCloneObject(isFunc ? {} : value);

          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }

          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      } // Check for circular references and return its corresponding clone.


      stack || (stack = new Stack());
      var stacked = stack.get(value);

      if (stacked) {
        return stacked;
      }

      stack.set(value, result);

      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }

      arrayEach(props || value, function (subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        } // Recursively populate clone (susceptible to call stack limits).


        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
      });
      return result;
    }
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */


    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    /**
     * The base implementation of `getTag`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */


    function baseGetTag(value) {
      return objectToString.call(value);
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */


    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }

      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */


    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */


    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }

      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */


    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */


    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    /**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */


    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */


    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    /**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */


    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */


    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */


    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */


    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }
    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */


    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
      }

      return object;
    }
    /**
     * Copies own symbol properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */


    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */


    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */


    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    /**
     * Creates an array of the own enumerable symbol properties of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */


    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
    // for data views in Edge < 14, and promises in Node.js.

    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function (value) {
        var result = objectToString.call(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : undefined;

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;

            case mapCtorString:
              return mapTag;

            case promiseCtorString:
              return promiseTag;

            case setCtorString:
              return setTag;

            case weakMapCtorString:
              return weakMapTag;
          }
        }

        return result;
      };
    }
    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */


    function initCloneArray(array) {
      var length = array.length,
          result = array.constructor(length); // Add properties assigned by `RegExp#exec`.

      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }

      return result;
    }
    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */


    function initCloneObject(object) {
      return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */


    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;

      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return cloneSet(object, isDeep, cloneFunc);

        case symbolTag:
          return cloneSymbol(object);
      }
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */


    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */


    function isKeyable(value) {
      var type = typeof value;
      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */


    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */


    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */


    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}

        try {
          return func + '';
        } catch (e) {}
      }

      return '';
    }
    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */


    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */


    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */


    function isArguments(value) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */


    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */


    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */


    var isBuffer = nativeIsBuffer || stubFalse;
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */

    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8-9 which returns 'object' for typed array and other constructors.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */


    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */


    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */


    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */


    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */


    function stubArray() {
      return [];
    }
    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */


    function stubFalse() {
      return false;
    }

    module.exports = cloneDeep;
  });

  /**
   * all-named-html-entities
   * List of all named HTML entities
   * Version: 1.2.17
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/all-named-html-entities
   */
  var Aacute = "";
  var aacute = "";
  var Abreve = "";
  var abreve = "";
  var ac = "";
  var acd = "";
  var acE = "";
  var Acirc = "";
  var acirc = "";
  var acute = "";
  var Acy = "";
  var acy = "";
  var AElig = "";
  var aelig = "";
  var af = "";
  var Afr = "";
  var afr = "";
  var Agrave = "";
  var agrave = "";
  var alefsym = "";
  var aleph = "";
  var Alpha = "";
  var alpha = "";
  var Amacr = "";
  var amacr = "";
  var amalg = "";
  var AMP = "&";
  var amp = "&";
  var And = "";
  var and = "";
  var andand = "";
  var andd = "";
  var andslope = "";
  var andv = "";
  var ang = "";
  var ange = "";
  var angle = "";
  var angmsd = "";
  var angmsdaa = "";
  var angmsdab = "";
  var angmsdac = "";
  var angmsdad = "";
  var angmsdae = "";
  var angmsdaf = "";
  var angmsdag = "";
  var angmsdah = "";
  var angrt = "";
  var angrtvb = "";
  var angrtvbd = "";
  var angsph = "";
  var angst = "";
  var angzarr = "";
  var Aogon = "";
  var aogon = "";
  var Aopf = "";
  var aopf = "";
  var ap = "";
  var apacir = "";
  var apE = "";
  var ape = "";
  var apid = "";
  var apos = "'";
  var ApplyFunction = "";
  var approx = "";
  var approxeq = "";
  var Aring = "";
  var aring = "";
  var Ascr = "";
  var ascr = "";
  var Assign = "";
  var ast = "*";
  var asymp = "";
  var asympeq = "";
  var Atilde = "";
  var atilde = "";
  var Auml = "";
  var auml = "";
  var awconint = "";
  var awint = "";
  var backcong = "";
  var backepsilon = "";
  var backprime = "";
  var backsim = "";
  var backsimeq = "";
  var Backslash = "";
  var Barv = "";
  var barvee = "";
  var Barwed = "";
  var barwed = "";
  var barwedge = "";
  var bbrk = "";
  var bbrktbrk = "";
  var bcong = "";
  var Bcy = "";
  var bcy = "";
  var bdquo = "";
  var becaus = "";
  var Because = "";
  var because = "";
  var bemptyv = "";
  var bepsi = "";
  var bernou = "";
  var Bernoullis = "";
  var Beta = "";
  var beta = "";
  var beth = "";
  var between = "";
  var Bfr = "";
  var bfr = "";
  var bigcap = "";
  var bigcirc = "";
  var bigcup = "";
  var bigodot = "";
  var bigoplus = "";
  var bigotimes = "";
  var bigsqcup = "";
  var bigstar = "";
  var bigtriangledown = "";
  var bigtriangleup = "";
  var biguplus = "";
  var bigvee = "";
  var bigwedge = "";
  var bkarow = "";
  var blacklozenge = "";
  var blacksquare = "";
  var blacktriangle = "";
  var blacktriangledown = "";
  var blacktriangleleft = "";
  var blacktriangleright = "";
  var blank = "";
  var blk12 = "";
  var blk14 = "";
  var blk34 = "";
  var block = "";
  var bne = "=";
  var bnequiv = "";
  var bNot = "";
  var bnot = "";
  var Bopf = "";
  var bopf = "";
  var bot = "";
  var bottom = "";
  var bowtie = "";
  var boxbox = "";
  var boxDL = "";
  var boxDl = "";
  var boxdL = "";
  var boxdl = "";
  var boxDR = "";
  var boxDr = "";
  var boxdR = "";
  var boxdr = "";
  var boxH = "";
  var boxh = "";
  var boxHD = "";
  var boxHd = "";
  var boxhD = "";
  var boxhd = "";
  var boxHU = "";
  var boxHu = "";
  var boxhU = "";
  var boxhu = "";
  var boxminus = "";
  var boxplus = "";
  var boxtimes = "";
  var boxUL = "";
  var boxUl = "";
  var boxuL = "";
  var boxul = "";
  var boxUR = "";
  var boxUr = "";
  var boxuR = "";
  var boxur = "";
  var boxV = "";
  var boxv = "";
  var boxVH = "";
  var boxVh = "";
  var boxvH = "";
  var boxvh = "";
  var boxVL = "";
  var boxVl = "";
  var boxvL = "";
  var boxvl = "";
  var boxVR = "";
  var boxVr = "";
  var boxvR = "";
  var boxvr = "";
  var bprime = "";
  var Breve = "";
  var breve = "";
  var brvbar = "";
  var Bscr = "";
  var bscr = "";
  var bsemi = "";
  var bsim = "";
  var bsime = "";
  var bsol = "\\";
  var bsolb = "";
  var bsolhsub = "";
  var bull = "";
  var bullet = "";
  var bump = "";
  var bumpE = "";
  var bumpe = "";
  var Bumpeq = "";
  var bumpeq = "";
  var Cacute = "";
  var cacute = "";
  var Cap = "";
  var cap = "";
  var capand = "";
  var capbrcup = "";
  var capcap = "";
  var capcup = "";
  var capdot = "";
  var CapitalDifferentialD = "";
  var caps = "";
  var caret = "";
  var caron = "";
  var Cayleys = "";
  var ccaps = "";
  var Ccaron = "";
  var ccaron = "";
  var Ccedil = "";
  var ccedil = "";
  var Ccirc = "";
  var ccirc = "";
  var Cconint = "";
  var ccups = "";
  var ccupssm = "";
  var Cdot = "";
  var cdot = "";
  var cedil = "";
  var Cedilla = "";
  var cemptyv = "";
  var cent = "";
  var CenterDot = "";
  var centerdot = "";
  var Cfr = "";
  var cfr = "";
  var CHcy = "";
  var chcy = "";
  var check = "";
  var checkmark = "";
  var Chi = "";
  var chi = "";
  var cir = "";
  var circ = "";
  var circeq = "";
  var circlearrowleft = "";
  var circlearrowright = "";
  var circledast = "";
  var circledcirc = "";
  var circleddash = "";
  var CircleDot = "";
  var circledR = "";
  var circledS = "";
  var CircleMinus = "";
  var CirclePlus = "";
  var CircleTimes = "";
  var cirE = "";
  var cire = "";
  var cirfnint = "";
  var cirmid = "";
  var cirscir = "";
  var ClockwiseContourIntegral = "";
  var CloseCurlyDoubleQuote = "";
  var CloseCurlyQuote = "";
  var clubs = "";
  var clubsuit = "";
  var Colon = "";
  var colon = ":";
  var Colone = "";
  var colone = "";
  var coloneq = "";
  var comma = ",";
  var commat = "@";
  var comp = "";
  var compfn = "";
  var complement = "";
  var complexes = "";
  var cong = "";
  var congdot = "";
  var Congruent = "";
  var Conint = "";
  var conint = "";
  var ContourIntegral = "";
  var Copf = "";
  var copf = "";
  var coprod = "";
  var Coproduct = "";
  var COPY = "";
  var copy = "";
  var copysr = "";
  var CounterClockwiseContourIntegral = "";
  var crarr = "";
  var Cross = "";
  var cross = "";
  var Cscr = "";
  var cscr = "";
  var csub = "";
  var csube = "";
  var csup = "";
  var csupe = "";
  var ctdot = "";
  var cudarrl = "";
  var cudarrr = "";
  var cuepr = "";
  var cuesc = "";
  var cularr = "";
  var cularrp = "";
  var Cup = "";
  var cup = "";
  var cupbrcap = "";
  var CupCap = "";
  var cupcap = "";
  var cupcup = "";
  var cupdot = "";
  var cupor = "";
  var cups = "";
  var curarr = "";
  var curarrm = "";
  var curlyeqprec = "";
  var curlyeqsucc = "";
  var curlyvee = "";
  var curlywedge = "";
  var curren = "";
  var curvearrowleft = "";
  var curvearrowright = "";
  var cuvee = "";
  var cuwed = "";
  var cwconint = "";
  var cwint = "";
  var cylcty = "";
  var Dagger = "";
  var dagger = "";
  var daleth = "";
  var Darr = "";
  var dArr = "";
  var darr = "";
  var dash = "";
  var Dashv = "";
  var dashv = "";
  var dbkarow = "";
  var dblac = "";
  var Dcaron = "";
  var dcaron = "";
  var Dcy = "";
  var dcy = "";
  var DD = "";
  var dd = "";
  var ddagger = "";
  var ddarr = "";
  var DDotrahd = "";
  var ddotseq = "";
  var deg = "";
  var Del = "";
  var Delta = "";
  var delta = "";
  var demptyv = "";
  var dfisht = "";
  var Dfr = "";
  var dfr = "";
  var dHar = "";
  var dharl = "";
  var dharr = "";
  var DiacriticalAcute = "";
  var DiacriticalDot = "";
  var DiacriticalDoubleAcute = "";
  var DiacriticalGrave = "`";
  var DiacriticalTilde = "";
  var diam = "";
  var Diamond = "";
  var diamond = "";
  var diamondsuit = "";
  var diams = "";
  var die = "";
  var DifferentialD = "";
  var digamma = "";
  var disin = "";
  var div = "";
  var divide = "";
  var divideontimes = "";
  var divonx = "";
  var DJcy = "";
  var djcy = "";
  var dlcorn = "";
  var dlcrop = "";
  var dollar = "$";
  var Dopf = "";
  var dopf = "";
  var Dot = "";
  var dot = "";
  var DotDot = "";
  var doteq = "";
  var doteqdot = "";
  var DotEqual = "";
  var dotminus = "";
  var dotplus = "";
  var dotsquare = "";
  var doublebarwedge = "";
  var DoubleContourIntegral = "";
  var DoubleDot = "";
  var DoubleDownArrow = "";
  var DoubleLeftArrow = "";
  var DoubleLeftRightArrow = "";
  var DoubleLeftTee = "";
  var DoubleLongLeftArrow = "";
  var DoubleLongLeftRightArrow = "";
  var DoubleLongRightArrow = "";
  var DoubleRightArrow = "";
  var DoubleRightTee = "";
  var DoubleUpArrow = "";
  var DoubleUpDownArrow = "";
  var DoubleVerticalBar = "";
  var DownArrow = "";
  var Downarrow = "";
  var downarrow = "";
  var DownArrowBar = "";
  var DownArrowUpArrow = "";
  var DownBreve = "";
  var downdownarrows = "";
  var downharpoonleft = "";
  var downharpoonright = "";
  var DownLeftRightVector = "";
  var DownLeftTeeVector = "";
  var DownLeftVector = "";
  var DownLeftVectorBar = "";
  var DownRightTeeVector = "";
  var DownRightVector = "";
  var DownRightVectorBar = "";
  var DownTee = "";
  var DownTeeArrow = "";
  var drbkarow = "";
  var drcorn = "";
  var drcrop = "";
  var Dscr = "";
  var dscr = "";
  var DScy = "";
  var dscy = "";
  var dsol = "";
  var Dstrok = "";
  var dstrok = "";
  var dtdot = "";
  var dtri = "";
  var dtrif = "";
  var duarr = "";
  var duhar = "";
  var dwangle = "";
  var DZcy = "";
  var dzcy = "";
  var dzigrarr = "";
  var Eacute = "";
  var eacute = "";
  var easter = "";
  var Ecaron = "";
  var ecaron = "";
  var ecir = "";
  var Ecirc = "";
  var ecirc = "";
  var ecolon = "";
  var Ecy = "";
  var ecy = "";
  var eDDot = "";
  var Edot = "";
  var eDot = "";
  var edot = "";
  var ee = "";
  var efDot = "";
  var Efr = "";
  var efr = "";
  var eg = "";
  var Egrave = "";
  var egrave = "";
  var egs = "";
  var egsdot = "";
  var el = "";
  var Element = "";
  var elinters = "";
  var ell = "";
  var els = "";
  var elsdot = "";
  var Emacr = "";
  var emacr = "";
  var empty = "";
  var emptyset = "";
  var EmptySmallSquare = "";
  var emptyv = "";
  var EmptyVerySmallSquare = "";
  var emsp = "";
  var emsp13 = "";
  var emsp14 = "";
  var ENG = "";
  var eng = "";
  var ensp = "";
  var Eogon = "";
  var eogon = "";
  var Eopf = "";
  var eopf = "";
  var epar = "";
  var eparsl = "";
  var eplus = "";
  var epsi = "";
  var Epsilon = "";
  var epsilon = "";
  var epsiv = "";
  var eqcirc = "";
  var eqcolon = "";
  var eqsim = "";
  var eqslantgtr = "";
  var eqslantless = "";
  var Equal = "";
  var equals = "=";
  var EqualTilde = "";
  var equest = "";
  var Equilibrium = "";
  var equiv = "";
  var equivDD = "";
  var eqvparsl = "";
  var erarr = "";
  var erDot = "";
  var Escr = "";
  var escr = "";
  var esdot = "";
  var Esim = "";
  var esim = "";
  var Eta = "";
  var eta = "";
  var ETH = "";
  var eth = "";
  var Euml = "";
  var euml = "";
  var euro = "";
  var excl = "!";
  var exist = "";
  var Exists = "";
  var expectation = "";
  var ExponentialE = "";
  var exponentiale = "";
  var fallingdotseq = "";
  var Fcy = "";
  var fcy = "";
  var female = "";
  var ffilig = "";
  var fflig = "";
  var ffllig = "";
  var Ffr = "";
  var ffr = "";
  var filig = "";
  var FilledSmallSquare = "";
  var FilledVerySmallSquare = "";
  var fjlig = "fj";
  var flat = "";
  var fllig = "";
  var fltns = "";
  var fnof = "";
  var Fopf = "";
  var fopf = "";
  var ForAll = "";
  var forall = "";
  var fork = "";
  var forkv = "";
  var Fouriertrf = "";
  var fpartint = "";
  var frac12 = "";
  var frac13 = "";
  var frac14 = "";
  var frac15 = "";
  var frac16 = "";
  var frac18 = "";
  var frac23 = "";
  var frac25 = "";
  var frac34 = "";
  var frac35 = "";
  var frac38 = "";
  var frac45 = "";
  var frac56 = "";
  var frac58 = "";
  var frac78 = "";
  var frasl = "";
  var frown = "";
  var Fscr = "";
  var fscr = "";
  var gacute = "";
  var Gamma = "";
  var gamma = "";
  var Gammad = "";
  var gammad = "";
  var gap = "";
  var Gbreve = "";
  var gbreve = "";
  var Gcedil = "";
  var Gcirc = "";
  var gcirc = "";
  var Gcy = "";
  var gcy = "";
  var Gdot = "";
  var gdot = "";
  var gE = "";
  var ge = "";
  var gEl = "";
  var gel = "";
  var geq = "";
  var geqq = "";
  var geqslant = "";
  var ges = "";
  var gescc = "";
  var gesdot = "";
  var gesdoto = "";
  var gesdotol = "";
  var gesl = "";
  var gesles = "";
  var Gfr = "";
  var gfr = "";
  var Gg = "";
  var gg = "";
  var ggg = "";
  var gimel = "";
  var GJcy = "";
  var gjcy = "";
  var gl = "";
  var gla = "";
  var glE = "";
  var glj = "";
  var gnap = "";
  var gnapprox = "";
  var gnE = "";
  var gne = "";
  var gneq = "";
  var gneqq = "";
  var gnsim = "";
  var Gopf = "";
  var gopf = "";
  var grave = "`";
  var GreaterEqual = "";
  var GreaterEqualLess = "";
  var GreaterFullEqual = "";
  var GreaterGreater = "";
  var GreaterLess = "";
  var GreaterSlantEqual = "";
  var GreaterTilde = "";
  var Gscr = "";
  var gscr = "";
  var gsim = "";
  var gsime = "";
  var gsiml = "";
  var GT = ">";
  var Gt = "";
  var gt = ">";
  var gtcc = "";
  var gtcir = "";
  var gtdot = "";
  var gtlPar = "";
  var gtquest = "";
  var gtrapprox = "";
  var gtrarr = "";
  var gtrdot = "";
  var gtreqless = "";
  var gtreqqless = "";
  var gtrless = "";
  var gtrsim = "";
  var gvertneqq = "";
  var gvnE = "";
  var Hacek = "";
  var hairsp = "";
  var half = "";
  var hamilt = "";
  var HARDcy = "";
  var hardcy = "";
  var hArr = "";
  var harr = "";
  var harrcir = "";
  var harrw = "";
  var Hat = "^";
  var hbar = "";
  var Hcirc = "";
  var hcirc = "";
  var hearts = "";
  var heartsuit = "";
  var hellip = "";
  var hercon = "";
  var Hfr = "";
  var hfr = "";
  var HilbertSpace = "";
  var hksearow = "";
  var hkswarow = "";
  var hoarr = "";
  var homtht = "";
  var hookleftarrow = "";
  var hookrightarrow = "";
  var Hopf = "";
  var hopf = "";
  var horbar = "";
  var HorizontalLine = "";
  var Hscr = "";
  var hscr = "";
  var hslash = "";
  var Hstrok = "";
  var hstrok = "";
  var HumpDownHump = "";
  var HumpEqual = "";
  var hybull = "";
  var hyphen = "";
  var Iacute = "";
  var iacute = "";
  var ic = "";
  var Icirc = "";
  var icirc = "";
  var Icy = "";
  var icy = "";
  var Idot = "";
  var IEcy = "";
  var iecy = "";
  var iexcl = "";
  var iff = "";
  var Ifr = "";
  var ifr = "";
  var Igrave = "";
  var igrave = "";
  var ii = "";
  var iiiint = "";
  var iiint = "";
  var iinfin = "";
  var iiota = "";
  var IJlig = "";
  var ijlig = "";
  var Im = "";
  var Imacr = "";
  var imacr = "";
  var image = "";
  var ImaginaryI = "";
  var imagline = "";
  var imagpart = "";
  var imath = "";
  var imof = "";
  var imped = "";
  var Implies = "";
  var incare = "";
  var infin = "";
  var infintie = "";
  var inodot = "";
  var Int = "";
  var int = "";
  var intcal = "";
  var integers = "";
  var Integral = "";
  var intercal = "";
  var Intersection = "";
  var intlarhk = "";
  var intprod = "";
  var InvisibleComma = "";
  var InvisibleTimes = "";
  var IOcy = "";
  var iocy = "";
  var Iogon = "";
  var iogon = "";
  var Iopf = "";
  var iopf = "";
  var Iota = "";
  var iota = "";
  var iprod = "";
  var iquest = "";
  var Iscr = "";
  var iscr = "";
  var isin = "";
  var isindot = "";
  var isinE = "";
  var isins = "";
  var isinsv = "";
  var isinv = "";
  var it = "";
  var Itilde = "";
  var itilde = "";
  var Iukcy = "";
  var iukcy = "";
  var Iuml = "";
  var iuml = "";
  var Jcirc = "";
  var jcirc = "";
  var Jcy = "";
  var jcy = "";
  var Jfr = "";
  var jfr = "";
  var jmath = "";
  var Jopf = "";
  var jopf = "";
  var Jscr = "";
  var jscr = "";
  var Jsercy = "";
  var jsercy = "";
  var Jukcy = "";
  var jukcy = "";
  var Kappa = "";
  var kappa = "";
  var kappav = "";
  var Kcedil = "";
  var kcedil = "";
  var Kcy = "";
  var kcy = "";
  var Kfr = "";
  var kfr = "";
  var kgreen = "";
  var KHcy = "";
  var khcy = "";
  var KJcy = "";
  var kjcy = "";
  var Kopf = "";
  var kopf = "";
  var Kscr = "";
  var kscr = "";
  var lAarr = "";
  var Lacute = "";
  var lacute = "";
  var laemptyv = "";
  var lagran = "";
  var Lambda = "";
  var lambda = "";
  var Lang = "";
  var lang = "";
  var langd = "";
  var langle = "";
  var lap = "";
  var Laplacetrf = "";
  var laquo = "";
  var Larr = "";
  var lArr = "";
  var larr = "";
  var larrb = "";
  var larrbfs = "";
  var larrfs = "";
  var larrhk = "";
  var larrlp = "";
  var larrpl = "";
  var larrsim = "";
  var larrtl = "";
  var lat = "";
  var lAtail = "";
  var latail = "";
  var late = "";
  var lates = "";
  var lBarr = "";
  var lbarr = "";
  var lbbrk = "";
  var lbrace = "{";
  var lbrack = "[";
  var lbrke = "";
  var lbrksld = "";
  var lbrkslu = "";
  var Lcaron = "";
  var lcaron = "";
  var Lcedil = "";
  var lcedil = "";
  var lceil = "";
  var lcub = "{";
  var Lcy = "";
  var lcy = "";
  var ldca = "";
  var ldquo = "";
  var ldquor = "";
  var ldrdhar = "";
  var ldrushar = "";
  var ldsh = "";
  var lE = "";
  var le = "";
  var LeftAngleBracket = "";
  var LeftArrow = "";
  var Leftarrow = "";
  var leftarrow = "";
  var LeftArrowBar = "";
  var LeftArrowRightArrow = "";
  var leftarrowtail = "";
  var LeftCeiling = "";
  var LeftDoubleBracket = "";
  var LeftDownTeeVector = "";
  var LeftDownVector = "";
  var LeftDownVectorBar = "";
  var LeftFloor = "";
  var leftharpoondown = "";
  var leftharpoonup = "";
  var leftleftarrows = "";
  var LeftRightArrow = "";
  var Leftrightarrow = "";
  var leftrightarrow = "";
  var leftrightarrows = "";
  var leftrightharpoons = "";
  var leftrightsquigarrow = "";
  var LeftRightVector = "";
  var LeftTee = "";
  var LeftTeeArrow = "";
  var LeftTeeVector = "";
  var leftthreetimes = "";
  var LeftTriangle = "";
  var LeftTriangleBar = "";
  var LeftTriangleEqual = "";
  var LeftUpDownVector = "";
  var LeftUpTeeVector = "";
  var LeftUpVector = "";
  var LeftUpVectorBar = "";
  var LeftVector = "";
  var LeftVectorBar = "";
  var lEg = "";
  var leg = "";
  var leq = "";
  var leqq = "";
  var leqslant = "";
  var les = "";
  var lescc = "";
  var lesdot = "";
  var lesdoto = "";
  var lesdotor = "";
  var lesg = "";
  var lesges = "";
  var lessapprox = "";
  var lessdot = "";
  var lesseqgtr = "";
  var lesseqqgtr = "";
  var LessEqualGreater = "";
  var LessFullEqual = "";
  var LessGreater = "";
  var lessgtr = "";
  var LessLess = "";
  var lesssim = "";
  var LessSlantEqual = "";
  var LessTilde = "";
  var lfisht = "";
  var lfloor = "";
  var Lfr = "";
  var lfr = "";
  var lg = "";
  var lgE = "";
  var lHar = "";
  var lhard = "";
  var lharu = "";
  var lharul = "";
  var lhblk = "";
  var LJcy = "";
  var ljcy = "";
  var Ll = "";
  var ll = "";
  var llarr = "";
  var llcorner = "";
  var Lleftarrow = "";
  var llhard = "";
  var lltri = "";
  var Lmidot = "";
  var lmidot = "";
  var lmoust = "";
  var lmoustache = "";
  var lnap = "";
  var lnapprox = "";
  var lnE = "";
  var lne = "";
  var lneq = "";
  var lneqq = "";
  var lnsim = "";
  var loang = "";
  var loarr = "";
  var lobrk = "";
  var LongLeftArrow = "";
  var Longleftarrow = "";
  var longleftarrow = "";
  var LongLeftRightArrow = "";
  var Longleftrightarrow = "";
  var longleftrightarrow = "";
  var longmapsto = "";
  var LongRightArrow = "";
  var Longrightarrow = "";
  var longrightarrow = "";
  var looparrowleft = "";
  var looparrowright = "";
  var lopar = "";
  var Lopf = "";
  var lopf = "";
  var loplus = "";
  var lotimes = "";
  var lowast = "";
  var lowbar = "_";
  var LowerLeftArrow = "";
  var LowerRightArrow = "";
  var loz = "";
  var lozenge = "";
  var lozf = "";
  var lpar = "(";
  var lparlt = "";
  var lrarr = "";
  var lrcorner = "";
  var lrhar = "";
  var lrhard = "";
  var lrm = "";
  var lrtri = "";
  var lsaquo = "";
  var Lscr = "";
  var lscr = "";
  var Lsh = "";
  var lsh = "";
  var lsim = "";
  var lsime = "";
  var lsimg = "";
  var lsqb = "[";
  var lsquo = "";
  var lsquor = "";
  var Lstrok = "";
  var lstrok = "";
  var LT = "<";
  var Lt = "";
  var lt = "<";
  var ltcc = "";
  var ltcir = "";
  var ltdot = "";
  var lthree = "";
  var ltimes = "";
  var ltlarr = "";
  var ltquest = "";
  var ltri = "";
  var ltrie = "";
  var ltrif = "";
  var ltrPar = "";
  var lurdshar = "";
  var luruhar = "";
  var lvertneqq = "";
  var lvnE = "";
  var macr = "";
  var male = "";
  var malt = "";
  var maltese = "";
  var map = "";
  var mapsto = "";
  var mapstodown = "";
  var mapstoleft = "";
  var mapstoup = "";
  var marker = "";
  var mcomma = "";
  var Mcy = "";
  var mcy = "";
  var mdash = "";
  var mDDot = "";
  var measuredangle = "";
  var MediumSpace = "";
  var Mellintrf = "";
  var Mfr = "";
  var mfr = "";
  var mho = "";
  var micro = "";
  var mid = "";
  var midast = "*";
  var midcir = "";
  var middot = "";
  var minus = "";
  var minusb = "";
  var minusd = "";
  var minusdu = "";
  var MinusPlus = "";
  var mlcp = "";
  var mldr = "";
  var mnplus = "";
  var models = "";
  var Mopf = "";
  var mopf = "";
  var mp = "";
  var Mscr = "";
  var mscr = "";
  var mstpos = "";
  var Mu = "";
  var mu = "";
  var multimap = "";
  var mumap = "";
  var nabla = "";
  var Nacute = "";
  var nacute = "";
  var nang = "";
  var nap = "";
  var napE = "";
  var napid = "";
  var napos = "";
  var napprox = "";
  var natur = "";
  var natural = "";
  var naturals = "";
  var nbsp = "";
  var nbump = "";
  var nbumpe = "";
  var ncap = "";
  var Ncaron = "";
  var ncaron = "";
  var Ncedil = "";
  var ncedil = "";
  var ncong = "";
  var ncongdot = "";
  var ncup = "";
  var Ncy = "";
  var ncy = "";
  var ndash = "";
  var ne = "";
  var nearhk = "";
  var neArr = "";
  var nearr = "";
  var nearrow = "";
  var nedot = "";
  var NegativeMediumSpace = "";
  var NegativeThickSpace = "";
  var NegativeThinSpace = "";
  var NegativeVeryThinSpace = "";
  var nequiv = "";
  var nesear = "";
  var nesim = "";
  var NestedGreaterGreater = "";
  var NestedLessLess = "";
  var NewLine = "\n";
  var nexist = "";
  var nexists = "";
  var Nfr = "";
  var nfr = "";
  var ngE = "";
  var nge = "";
  var ngeq = "";
  var ngeqq = "";
  var ngeqslant = "";
  var nges = "";
  var nGg = "";
  var ngsim = "";
  var nGt = "";
  var ngt = "";
  var ngtr = "";
  var nGtv = "";
  var nhArr = "";
  var nharr = "";
  var nhpar = "";
  var ni = "";
  var nis = "";
  var nisd = "";
  var niv = "";
  var NJcy = "";
  var njcy = "";
  var nlArr = "";
  var nlarr = "";
  var nldr = "";
  var nlE = "";
  var nle = "";
  var nLeftarrow = "";
  var nleftarrow = "";
  var nLeftrightarrow = "";
  var nleftrightarrow = "";
  var nleq = "";
  var nleqq = "";
  var nleqslant = "";
  var nles = "";
  var nless = "";
  var nLl = "";
  var nlsim = "";
  var nLt = "";
  var nlt = "";
  var nltri = "";
  var nltrie = "";
  var nLtv = "";
  var nmid = "";
  var NoBreak = "";
  var NonBreakingSpace = "";
  var Nopf = "";
  var nopf = "";
  var Not = "";
  var not = "";
  var NotCongruent = "";
  var NotCupCap = "";
  var NotDoubleVerticalBar = "";
  var NotElement = "";
  var NotEqual = "";
  var NotEqualTilde = "";
  var NotExists = "";
  var NotGreater = "";
  var NotGreaterEqual = "";
  var NotGreaterFullEqual = "";
  var NotGreaterGreater = "";
  var NotGreaterLess = "";
  var NotGreaterSlantEqual = "";
  var NotGreaterTilde = "";
  var NotHumpDownHump = "";
  var NotHumpEqual = "";
  var notin = "";
  var notindot = "";
  var notinE = "";
  var notinva = "";
  var notinvb = "";
  var notinvc = "";
  var NotLeftTriangle = "";
  var NotLeftTriangleBar = "";
  var NotLeftTriangleEqual = "";
  var NotLess = "";
  var NotLessEqual = "";
  var NotLessGreater = "";
  var NotLessLess = "";
  var NotLessSlantEqual = "";
  var NotLessTilde = "";
  var NotNestedGreaterGreater = "";
  var NotNestedLessLess = "";
  var notni = "";
  var notniva = "";
  var notnivb = "";
  var notnivc = "";
  var NotPrecedes = "";
  var NotPrecedesEqual = "";
  var NotPrecedesSlantEqual = "";
  var NotReverseElement = "";
  var NotRightTriangle = "";
  var NotRightTriangleBar = "";
  var NotRightTriangleEqual = "";
  var NotSquareSubset = "";
  var NotSquareSubsetEqual = "";
  var NotSquareSuperset = "";
  var NotSquareSupersetEqual = "";
  var NotSubset = "";
  var NotSubsetEqual = "";
  var NotSucceeds = "";
  var NotSucceedsEqual = "";
  var NotSucceedsSlantEqual = "";
  var NotSucceedsTilde = "";
  var NotSuperset = "";
  var NotSupersetEqual = "";
  var NotTilde = "";
  var NotTildeEqual = "";
  var NotTildeFullEqual = "";
  var NotTildeTilde = "";
  var NotVerticalBar = "";
  var npar = "";
  var nparallel = "";
  var nparsl = "";
  var npart = "";
  var npolint = "";
  var npr = "";
  var nprcue = "";
  var npre = "";
  var nprec = "";
  var npreceq = "";
  var nrArr = "";
  var nrarr = "";
  var nrarrc = "";
  var nrarrw = "";
  var nRightarrow = "";
  var nrightarrow = "";
  var nrtri = "";
  var nrtrie = "";
  var nsc = "";
  var nsccue = "";
  var nsce = "";
  var Nscr = "";
  var nscr = "";
  var nshortmid = "";
  var nshortparallel = "";
  var nsim = "";
  var nsime = "";
  var nsimeq = "";
  var nsmid = "";
  var nspar = "";
  var nsqsube = "";
  var nsqsupe = "";
  var nsub = "";
  var nsubE = "";
  var nsube = "";
  var nsubset = "";
  var nsubseteq = "";
  var nsubseteqq = "";
  var nsucc = "";
  var nsucceq = "";
  var nsup = "";
  var nsupE = "";
  var nsupe = "";
  var nsupset = "";
  var nsupseteq = "";
  var nsupseteqq = "";
  var ntgl = "";
  var Ntilde = "";
  var ntilde = "";
  var ntlg = "";
  var ntriangleleft = "";
  var ntrianglelefteq = "";
  var ntriangleright = "";
  var ntrianglerighteq = "";
  var Nu = "";
  var nu = "";
  var num = "#";
  var numero = "";
  var numsp = "";
  var nvap = "";
  var nVDash = "";
  var nVdash = "";
  var nvDash = "";
  var nvdash = "";
  var nvge = "";
  var nvgt = ">";
  var nvHarr = "";
  var nvinfin = "";
  var nvlArr = "";
  var nvle = "";
  var nvlt = "<";
  var nvltrie = "";
  var nvrArr = "";
  var nvrtrie = "";
  var nvsim = "";
  var nwarhk = "";
  var nwArr = "";
  var nwarr = "";
  var nwarrow = "";
  var nwnear = "";
  var Oacute = "";
  var oacute = "";
  var oast = "";
  var ocir = "";
  var Ocirc = "";
  var ocirc = "";
  var Ocy = "";
  var ocy = "";
  var odash = "";
  var Odblac = "";
  var odblac = "";
  var odiv = "";
  var odot = "";
  var odsold = "";
  var OElig = "";
  var oelig = "";
  var ofcir = "";
  var Ofr = "";
  var ofr = "";
  var ogon = "";
  var Ograve = "";
  var ograve = "";
  var ogt = "";
  var ohbar = "";
  var ohm = "";
  var oint = "";
  var olarr = "";
  var olcir = "";
  var olcross = "";
  var oline = "";
  var olt = "";
  var Omacr = "";
  var omacr = "";
  var Omega = "";
  var omega = "";
  var Omicron = "";
  var omicron = "";
  var omid = "";
  var ominus = "";
  var Oopf = "";
  var oopf = "";
  var opar = "";
  var OpenCurlyDoubleQuote = "";
  var OpenCurlyQuote = "";
  var operp = "";
  var oplus = "";
  var Or = "";
  var or = "";
  var orarr = "";
  var ord = "";
  var order = "";
  var orderof = "";
  var ordf = "";
  var ordm = "";
  var origof = "";
  var oror = "";
  var orslope = "";
  var orv = "";
  var oS = "";
  var Oscr = "";
  var oscr = "";
  var Oslash = "";
  var oslash = "";
  var osol = "";
  var Otilde = "";
  var otilde = "";
  var Otimes = "";
  var otimes = "";
  var otimesas = "";
  var Ouml = "";
  var ouml = "";
  var ovbar = "";
  var OverBar = "";
  var OverBrace = "";
  var OverBracket = "";
  var OverParenthesis = "";
  var par = "";
  var para = "";
  var parallel = "";
  var parsim = "";
  var parsl = "";
  var part = "";
  var PartialD = "";
  var Pcy = "";
  var pcy = "";
  var percnt = "%";
  var period = ".";
  var permil = "";
  var perp = "";
  var pertenk = "";
  var Pfr = "";
  var pfr = "";
  var Phi = "";
  var phi = "";
  var phiv = "";
  var phmmat = "";
  var phone = "";
  var Pi = "";
  var pi = "";
  var pitchfork = "";
  var piv = "";
  var planck = "";
  var planckh = "";
  var plankv = "";
  var plus = "+";
  var plusacir = "";
  var plusb = "";
  var pluscir = "";
  var plusdo = "";
  var plusdu = "";
  var pluse = "";
  var PlusMinus = "";
  var plusmn = "";
  var plussim = "";
  var plustwo = "";
  var pm = "";
  var Poincareplane = "";
  var pointint = "";
  var Popf = "";
  var popf = "";
  var pound = "";
  var Pr = "";
  var pr = "";
  var prap = "";
  var prcue = "";
  var prE = "";
  var pre = "";
  var prec = "";
  var precapprox = "";
  var preccurlyeq = "";
  var Precedes = "";
  var PrecedesEqual = "";
  var PrecedesSlantEqual = "";
  var PrecedesTilde = "";
  var preceq = "";
  var precnapprox = "";
  var precneqq = "";
  var precnsim = "";
  var precsim = "";
  var Prime = "";
  var prime = "";
  var primes = "";
  var prnap = "";
  var prnE = "";
  var prnsim = "";
  var prod = "";
  var Product = "";
  var profalar = "";
  var profline = "";
  var profsurf = "";
  var prop = "";
  var Proportion = "";
  var Proportional = "";
  var propto = "";
  var prsim = "";
  var prurel = "";
  var Pscr = "";
  var pscr = "";
  var Psi = "";
  var psi = "";
  var puncsp = "";
  var Qfr = "";
  var qfr = "";
  var qint = "";
  var Qopf = "";
  var qopf = "";
  var qprime = "";
  var Qscr = "";
  var qscr = "";
  var quaternions = "";
  var quatint = "";
  var quest = "?";
  var questeq = "";
  var QUOT = "\"";
  var quot = "\"";
  var rAarr = "";
  var race = "";
  var Racute = "";
  var racute = "";
  var radic = "";
  var raemptyv = "";
  var Rang = "";
  var rang = "";
  var rangd = "";
  var range = "";
  var rangle = "";
  var raquo = "";
  var Rarr = "";
  var rArr = "";
  var rarr = "";
  var rarrap = "";
  var rarrb = "";
  var rarrbfs = "";
  var rarrc = "";
  var rarrfs = "";
  var rarrhk = "";
  var rarrlp = "";
  var rarrpl = "";
  var rarrsim = "";
  var Rarrtl = "";
  var rarrtl = "";
  var rarrw = "";
  var rAtail = "";
  var ratail = "";
  var ratio = "";
  var rationals = "";
  var RBarr = "";
  var rBarr = "";
  var rbarr = "";
  var rbbrk = "";
  var rbrace = "}";
  var rbrack = "]";
  var rbrke = "";
  var rbrksld = "";
  var rbrkslu = "";
  var Rcaron = "";
  var rcaron = "";
  var Rcedil = "";
  var rcedil = "";
  var rceil = "";
  var rcub = "}";
  var Rcy = "";
  var rcy = "";
  var rdca = "";
  var rdldhar = "";
  var rdquo = "";
  var rdquor = "";
  var rdsh = "";
  var Re = "";
  var real = "";
  var realine = "";
  var realpart = "";
  var reals = "";
  var rect = "";
  var REG = "";
  var reg = "";
  var ReverseElement = "";
  var ReverseEquilibrium = "";
  var ReverseUpEquilibrium = "";
  var rfisht = "";
  var rfloor = "";
  var Rfr = "";
  var rfr = "";
  var rHar = "";
  var rhard = "";
  var rharu = "";
  var rharul = "";
  var Rho = "";
  var rho = "";
  var rhov = "";
  var RightAngleBracket = "";
  var RightArrow = "";
  var Rightarrow = "";
  var rightarrow = "";
  var RightArrowBar = "";
  var RightArrowLeftArrow = "";
  var rightarrowtail = "";
  var RightCeiling = "";
  var RightDoubleBracket = "";
  var RightDownTeeVector = "";
  var RightDownVector = "";
  var RightDownVectorBar = "";
  var RightFloor = "";
  var rightharpoondown = "";
  var rightharpoonup = "";
  var rightleftarrows = "";
  var rightleftharpoons = "";
  var rightrightarrows = "";
  var rightsquigarrow = "";
  var RightTee = "";
  var RightTeeArrow = "";
  var RightTeeVector = "";
  var rightthreetimes = "";
  var RightTriangle = "";
  var RightTriangleBar = "";
  var RightTriangleEqual = "";
  var RightUpDownVector = "";
  var RightUpTeeVector = "";
  var RightUpVector = "";
  var RightUpVectorBar = "";
  var RightVector = "";
  var RightVectorBar = "";
  var ring = "";
  var risingdotseq = "";
  var rlarr = "";
  var rlhar = "";
  var rlm = "";
  var rmoust = "";
  var rmoustache = "";
  var rnmid = "";
  var roang = "";
  var roarr = "";
  var robrk = "";
  var ropar = "";
  var Ropf = "";
  var ropf = "";
  var roplus = "";
  var rotimes = "";
  var RoundImplies = "";
  var rpar = ")";
  var rpargt = "";
  var rppolint = "";
  var rrarr = "";
  var Rrightarrow = "";
  var rsaquo = "";
  var Rscr = "";
  var rscr = "";
  var Rsh = "";
  var rsh = "";
  var rsqb = "]";
  var rsquo = "";
  var rsquor = "";
  var rthree = "";
  var rtimes = "";
  var rtri = "";
  var rtrie = "";
  var rtrif = "";
  var rtriltri = "";
  var RuleDelayed = "";
  var ruluhar = "";
  var rx = "";
  var Sacute = "";
  var sacute = "";
  var sbquo = "";
  var Sc = "";
  var sc = "";
  var scap = "";
  var Scaron = "";
  var scaron = "";
  var sccue = "";
  var scE = "";
  var sce = "";
  var Scedil = "";
  var scedil = "";
  var Scirc = "";
  var scirc = "";
  var scnap = "";
  var scnE = "";
  var scnsim = "";
  var scpolint = "";
  var scsim = "";
  var Scy = "";
  var scy = "";
  var sdot = "";
  var sdotb = "";
  var sdote = "";
  var searhk = "";
  var seArr = "";
  var searr = "";
  var searrow = "";
  var sect = "";
  var semi = ";";
  var seswar = "";
  var setminus = "";
  var setmn = "";
  var sext = "";
  var Sfr = "";
  var sfr = "";
  var sfrown = "";
  var sharp = "";
  var SHCHcy = "";
  var shchcy = "";
  var SHcy = "";
  var shcy = "";
  var ShortDownArrow = "";
  var ShortLeftArrow = "";
  var shortmid = "";
  var shortparallel = "";
  var ShortRightArrow = "";
  var ShortUpArrow = "";
  var shy = "";
  var Sigma = "";
  var sigma = "";
  var sigmaf = "";
  var sigmav = "";
  var sim = "";
  var simdot = "";
  var sime = "";
  var simeq = "";
  var simg = "";
  var simgE = "";
  var siml = "";
  var simlE = "";
  var simne = "";
  var simplus = "";
  var simrarr = "";
  var slarr = "";
  var SmallCircle = "";
  var smallsetminus = "";
  var smashp = "";
  var smeparsl = "";
  var smid = "";
  var smile = "";
  var smt = "";
  var smte = "";
  var smtes = "";
  var SOFTcy = "";
  var softcy = "";
  var sol = "/";
  var solb = "";
  var solbar = "";
  var Sopf = "";
  var sopf = "";
  var spades = "";
  var spadesuit = "";
  var spar = "";
  var sqcap = "";
  var sqcaps = "";
  var sqcup = "";
  var sqcups = "";
  var Sqrt = "";
  var sqsub = "";
  var sqsube = "";
  var sqsubset = "";
  var sqsubseteq = "";
  var sqsup = "";
  var sqsupe = "";
  var sqsupset = "";
  var sqsupseteq = "";
  var squ = "";
  var Square = "";
  var square = "";
  var SquareIntersection = "";
  var SquareSubset = "";
  var SquareSubsetEqual = "";
  var SquareSuperset = "";
  var SquareSupersetEqual = "";
  var SquareUnion = "";
  var squarf = "";
  var squf = "";
  var srarr = "";
  var Sscr = "";
  var sscr = "";
  var ssetmn = "";
  var ssmile = "";
  var sstarf = "";
  var Star = "";
  var star = "";
  var starf = "";
  var straightepsilon = "";
  var straightphi = "";
  var strns = "";
  var Sub = "";
  var sub = "";
  var subdot = "";
  var subE = "";
  var sube = "";
  var subedot = "";
  var submult = "";
  var subnE = "";
  var subne = "";
  var subplus = "";
  var subrarr = "";
  var Subset = "";
  var subset = "";
  var subseteq = "";
  var subseteqq = "";
  var SubsetEqual = "";
  var subsetneq = "";
  var subsetneqq = "";
  var subsim = "";
  var subsub = "";
  var subsup = "";
  var succ = "";
  var succapprox = "";
  var succcurlyeq = "";
  var Succeeds = "";
  var SucceedsEqual = "";
  var SucceedsSlantEqual = "";
  var SucceedsTilde = "";
  var succeq = "";
  var succnapprox = "";
  var succneqq = "";
  var succnsim = "";
  var succsim = "";
  var SuchThat = "";
  var Sum = "";
  var sum = "";
  var sung = "";
  var Sup = "";
  var sup = "";
  var sup1 = "";
  var sup2 = "";
  var sup3 = "";
  var supdot = "";
  var supdsub = "";
  var supE = "";
  var supe = "";
  var supedot = "";
  var Superset = "";
  var SupersetEqual = "";
  var suphsol = "";
  var suphsub = "";
  var suplarr = "";
  var supmult = "";
  var supnE = "";
  var supne = "";
  var supplus = "";
  var Supset = "";
  var supset = "";
  var supseteq = "";
  var supseteqq = "";
  var supsetneq = "";
  var supsetneqq = "";
  var supsim = "";
  var supsub = "";
  var supsup = "";
  var swarhk = "";
  var swArr = "";
  var swarr = "";
  var swarrow = "";
  var swnwar = "";
  var szlig = "";
  var Tab = "\t";
  var target = "";
  var Tau = "";
  var tau = "";
  var tbrk = "";
  var Tcaron = "";
  var tcaron = "";
  var Tcedil = "";
  var tcedil = "";
  var Tcy = "";
  var tcy = "";
  var tdot = "";
  var telrec = "";
  var Tfr = "";
  var tfr = "";
  var there4 = "";
  var Therefore = "";
  var therefore = "";
  var Theta = "";
  var theta = "";
  var thetasym = "";
  var thetav = "";
  var thickapprox = "";
  var thicksim = "";
  var ThickSpace = "";
  var thinsp = "";
  var ThinSpace = "";
  var thkap = "";
  var thksim = "";
  var THORN = "";
  var thorn = "";
  var Tilde = "";
  var tilde = "";
  var TildeEqual = "";
  var TildeFullEqual = "";
  var TildeTilde = "";
  var times = "";
  var timesb = "";
  var timesbar = "";
  var timesd = "";
  var tint = "";
  var toea = "";
  var top = "";
  var topbot = "";
  var topcir = "";
  var Topf = "";
  var topf = "";
  var topfork = "";
  var tosa = "";
  var tprime = "";
  var TRADE = "";
  var trade = "";
  var triangle = "";
  var triangledown = "";
  var triangleleft = "";
  var trianglelefteq = "";
  var triangleq = "";
  var triangleright = "";
  var trianglerighteq = "";
  var tridot = "";
  var trie = "";
  var triminus = "";
  var TripleDot = "";
  var triplus = "";
  var trisb = "";
  var tritime = "";
  var trpezium = "";
  var Tscr = "";
  var tscr = "";
  var TScy = "";
  var tscy = "";
  var TSHcy = "";
  var tshcy = "";
  var Tstrok = "";
  var tstrok = "";
  var twixt = "";
  var twoheadleftarrow = "";
  var twoheadrightarrow = "";
  var Uacute = "";
  var uacute = "";
  var Uarr = "";
  var uArr = "";
  var uarr = "";
  var Uarrocir = "";
  var Ubrcy = "";
  var ubrcy = "";
  var Ubreve = "";
  var ubreve = "";
  var Ucirc = "";
  var ucirc = "";
  var Ucy = "";
  var ucy = "";
  var udarr = "";
  var Udblac = "";
  var udblac = "";
  var udhar = "";
  var ufisht = "";
  var Ufr = "";
  var ufr = "";
  var Ugrave = "";
  var ugrave = "";
  var uHar = "";
  var uharl = "";
  var uharr = "";
  var uhblk = "";
  var ulcorn = "";
  var ulcorner = "";
  var ulcrop = "";
  var ultri = "";
  var Umacr = "";
  var umacr = "";
  var uml = "";
  var UnderBar = "_";
  var UnderBrace = "";
  var UnderBracket = "";
  var UnderParenthesis = "";
  var Union = "";
  var UnionPlus = "";
  var Uogon = "";
  var uogon = "";
  var Uopf = "";
  var uopf = "";
  var UpArrow = "";
  var Uparrow = "";
  var uparrow = "";
  var UpArrowBar = "";
  var UpArrowDownArrow = "";
  var UpDownArrow = "";
  var Updownarrow = "";
  var updownarrow = "";
  var UpEquilibrium = "";
  var upharpoonleft = "";
  var upharpoonright = "";
  var uplus = "";
  var UpperLeftArrow = "";
  var UpperRightArrow = "";
  var Upsi = "";
  var upsi = "";
  var upsih = "";
  var Upsilon = "";
  var upsilon = "";
  var UpTee = "";
  var UpTeeArrow = "";
  var upuparrows = "";
  var urcorn = "";
  var urcorner = "";
  var urcrop = "";
  var Uring = "";
  var uring = "";
  var urtri = "";
  var Uscr = "";
  var uscr = "";
  var utdot = "";
  var Utilde = "";
  var utilde = "";
  var utri = "";
  var utrif = "";
  var uuarr = "";
  var Uuml = "";
  var uuml = "";
  var uwangle = "";
  var vangrt = "";
  var varepsilon = "";
  var varkappa = "";
  var varnothing = "";
  var varphi = "";
  var varpi = "";
  var varpropto = "";
  var vArr = "";
  var varr = "";
  var varrho = "";
  var varsigma = "";
  var varsubsetneq = "";
  var varsubsetneqq = "";
  var varsupsetneq = "";
  var varsupsetneqq = "";
  var vartheta = "";
  var vartriangleleft = "";
  var vartriangleright = "";
  var Vbar = "";
  var vBar = "";
  var vBarv = "";
  var Vcy = "";
  var vcy = "";
  var VDash = "";
  var Vdash = "";
  var vDash = "";
  var vdash = "";
  var Vdashl = "";
  var Vee = "";
  var vee = "";
  var veebar = "";
  var veeeq = "";
  var vellip = "";
  var Verbar = "";
  var verbar = "|";
  var Vert = "";
  var vert = "|";
  var VerticalBar = "";
  var VerticalLine = "|";
  var VerticalSeparator = "";
  var VerticalTilde = "";
  var VeryThinSpace = "";
  var Vfr = "";
  var vfr = "";
  var vltri = "";
  var vnsub = "";
  var vnsup = "";
  var Vopf = "";
  var vopf = "";
  var vprop = "";
  var vrtri = "";
  var Vscr = "";
  var vscr = "";
  var vsubnE = "";
  var vsubne = "";
  var vsupnE = "";
  var vsupne = "";
  var Vvdash = "";
  var vzigzag = "";
  var Wcirc = "";
  var wcirc = "";
  var wedbar = "";
  var Wedge = "";
  var wedge = "";
  var wedgeq = "";
  var weierp = "";
  var Wfr = "";
  var wfr = "";
  var Wopf = "";
  var wopf = "";
  var wp = "";
  var wr = "";
  var wreath = "";
  var Wscr = "";
  var wscr = "";
  var xcap = "";
  var xcirc = "";
  var xcup = "";
  var xdtri = "";
  var Xfr = "";
  var xfr = "";
  var xhArr = "";
  var xharr = "";
  var Xi = "";
  var xi = "";
  var xlArr = "";
  var xlarr = "";
  var xmap = "";
  var xnis = "";
  var xodot = "";
  var Xopf = "";
  var xopf = "";
  var xoplus = "";
  var xotime = "";
  var xrArr = "";
  var xrarr = "";
  var Xscr = "";
  var xscr = "";
  var xsqcup = "";
  var xuplus = "";
  var xutri = "";
  var xvee = "";
  var xwedge = "";
  var Yacute = "";
  var yacute = "";
  var YAcy = "";
  var yacy = "";
  var Ycirc = "";
  var ycirc = "";
  var Ycy = "";
  var ycy = "";
  var yen = "";
  var Yfr = "";
  var yfr = "";
  var YIcy = "";
  var yicy = "";
  var Yopf = "";
  var yopf = "";
  var Yscr = "";
  var yscr = "";
  var YUcy = "";
  var yucy = "";
  var Yuml = "";
  var yuml = "";
  var Zacute = "";
  var zacute = "";
  var Zcaron = "";
  var zcaron = "";
  var Zcy = "";
  var zcy = "";
  var Zdot = "";
  var zdot = "";
  var zeetrf = "";
  var ZeroWidthSpace = "";
  var Zeta = "";
  var zeta = "";
  var Zfr = "";
  var zfr = "";
  var ZHcy = "";
  var zhcy = "";
  var zigrarr = "";
  var Zopf = "";
  var zopf = "";
  var Zscr = "";
  var zscr = "";
  var zwj = "";
  var zwnj = "";
  var allNamedEntities = {
    Aacute: Aacute,
    aacute: aacute,
    Abreve: Abreve,
    abreve: abreve,
    ac: ac,
    acd: acd,
    acE: acE,
    Acirc: Acirc,
    acirc: acirc,
    acute: acute,
    Acy: Acy,
    acy: acy,
    AElig: AElig,
    aelig: aelig,
    af: af,
    Afr: Afr,
    afr: afr,
    Agrave: Agrave,
    agrave: agrave,
    alefsym: alefsym,
    aleph: aleph,
    Alpha: Alpha,
    alpha: alpha,
    Amacr: Amacr,
    amacr: amacr,
    amalg: amalg,
    AMP: AMP,
    amp: amp,
    And: And,
    and: and,
    andand: andand,
    andd: andd,
    andslope: andslope,
    andv: andv,
    ang: ang,
    ange: ange,
    angle: angle,
    angmsd: angmsd,
    angmsdaa: angmsdaa,
    angmsdab: angmsdab,
    angmsdac: angmsdac,
    angmsdad: angmsdad,
    angmsdae: angmsdae,
    angmsdaf: angmsdaf,
    angmsdag: angmsdag,
    angmsdah: angmsdah,
    angrt: angrt,
    angrtvb: angrtvb,
    angrtvbd: angrtvbd,
    angsph: angsph,
    angst: angst,
    angzarr: angzarr,
    Aogon: Aogon,
    aogon: aogon,
    Aopf: Aopf,
    aopf: aopf,
    ap: ap,
    apacir: apacir,
    apE: apE,
    ape: ape,
    apid: apid,
    apos: apos,
    ApplyFunction: ApplyFunction,
    approx: approx,
    approxeq: approxeq,
    Aring: Aring,
    aring: aring,
    Ascr: Ascr,
    ascr: ascr,
    Assign: Assign,
    ast: ast,
    asymp: asymp,
    asympeq: asympeq,
    Atilde: Atilde,
    atilde: atilde,
    Auml: Auml,
    auml: auml,
    awconint: awconint,
    awint: awint,
    backcong: backcong,
    backepsilon: backepsilon,
    backprime: backprime,
    backsim: backsim,
    backsimeq: backsimeq,
    Backslash: Backslash,
    Barv: Barv,
    barvee: barvee,
    Barwed: Barwed,
    barwed: barwed,
    barwedge: barwedge,
    bbrk: bbrk,
    bbrktbrk: bbrktbrk,
    bcong: bcong,
    Bcy: Bcy,
    bcy: bcy,
    bdquo: bdquo,
    becaus: becaus,
    Because: Because,
    because: because,
    bemptyv: bemptyv,
    bepsi: bepsi,
    bernou: bernou,
    Bernoullis: Bernoullis,
    Beta: Beta,
    beta: beta,
    beth: beth,
    between: between,
    Bfr: Bfr,
    bfr: bfr,
    bigcap: bigcap,
    bigcirc: bigcirc,
    bigcup: bigcup,
    bigodot: bigodot,
    bigoplus: bigoplus,
    bigotimes: bigotimes,
    bigsqcup: bigsqcup,
    bigstar: bigstar,
    bigtriangledown: bigtriangledown,
    bigtriangleup: bigtriangleup,
    biguplus: biguplus,
    bigvee: bigvee,
    bigwedge: bigwedge,
    bkarow: bkarow,
    blacklozenge: blacklozenge,
    blacksquare: blacksquare,
    blacktriangle: blacktriangle,
    blacktriangledown: blacktriangledown,
    blacktriangleleft: blacktriangleleft,
    blacktriangleright: blacktriangleright,
    blank: blank,
    blk12: blk12,
    blk14: blk14,
    blk34: blk34,
    block: block,
    bne: bne,
    bnequiv: bnequiv,
    bNot: bNot,
    bnot: bnot,
    Bopf: Bopf,
    bopf: bopf,
    bot: bot,
    bottom: bottom,
    bowtie: bowtie,
    boxbox: boxbox,
    boxDL: boxDL,
    boxDl: boxDl,
    boxdL: boxdL,
    boxdl: boxdl,
    boxDR: boxDR,
    boxDr: boxDr,
    boxdR: boxdR,
    boxdr: boxdr,
    boxH: boxH,
    boxh: boxh,
    boxHD: boxHD,
    boxHd: boxHd,
    boxhD: boxhD,
    boxhd: boxhd,
    boxHU: boxHU,
    boxHu: boxHu,
    boxhU: boxhU,
    boxhu: boxhu,
    boxminus: boxminus,
    boxplus: boxplus,
    boxtimes: boxtimes,
    boxUL: boxUL,
    boxUl: boxUl,
    boxuL: boxuL,
    boxul: boxul,
    boxUR: boxUR,
    boxUr: boxUr,
    boxuR: boxuR,
    boxur: boxur,
    boxV: boxV,
    boxv: boxv,
    boxVH: boxVH,
    boxVh: boxVh,
    boxvH: boxvH,
    boxvh: boxvh,
    boxVL: boxVL,
    boxVl: boxVl,
    boxvL: boxvL,
    boxvl: boxvl,
    boxVR: boxVR,
    boxVr: boxVr,
    boxvR: boxvR,
    boxvr: boxvr,
    bprime: bprime,
    Breve: Breve,
    breve: breve,
    brvbar: brvbar,
    Bscr: Bscr,
    bscr: bscr,
    bsemi: bsemi,
    bsim: bsim,
    bsime: bsime,
    bsol: bsol,
    bsolb: bsolb,
    bsolhsub: bsolhsub,
    bull: bull,
    bullet: bullet,
    bump: bump,
    bumpE: bumpE,
    bumpe: bumpe,
    Bumpeq: Bumpeq,
    bumpeq: bumpeq,
    Cacute: Cacute,
    cacute: cacute,
    Cap: Cap,
    cap: cap,
    capand: capand,
    capbrcup: capbrcup,
    capcap: capcap,
    capcup: capcup,
    capdot: capdot,
    CapitalDifferentialD: CapitalDifferentialD,
    caps: caps,
    caret: caret,
    caron: caron,
    Cayleys: Cayleys,
    ccaps: ccaps,
    Ccaron: Ccaron,
    ccaron: ccaron,
    Ccedil: Ccedil,
    ccedil: ccedil,
    Ccirc: Ccirc,
    ccirc: ccirc,
    Cconint: Cconint,
    ccups: ccups,
    ccupssm: ccupssm,
    Cdot: Cdot,
    cdot: cdot,
    cedil: cedil,
    Cedilla: Cedilla,
    cemptyv: cemptyv,
    cent: cent,
    CenterDot: CenterDot,
    centerdot: centerdot,
    Cfr: Cfr,
    cfr: cfr,
    CHcy: CHcy,
    chcy: chcy,
    check: check,
    checkmark: checkmark,
    Chi: Chi,
    chi: chi,
    cir: cir,
    circ: circ,
    circeq: circeq,
    circlearrowleft: circlearrowleft,
    circlearrowright: circlearrowright,
    circledast: circledast,
    circledcirc: circledcirc,
    circleddash: circleddash,
    CircleDot: CircleDot,
    circledR: circledR,
    circledS: circledS,
    CircleMinus: CircleMinus,
    CirclePlus: CirclePlus,
    CircleTimes: CircleTimes,
    cirE: cirE,
    cire: cire,
    cirfnint: cirfnint,
    cirmid: cirmid,
    cirscir: cirscir,
    ClockwiseContourIntegral: ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
    CloseCurlyQuote: CloseCurlyQuote,
    clubs: clubs,
    clubsuit: clubsuit,
    Colon: Colon,
    colon: colon,
    Colone: Colone,
    colone: colone,
    coloneq: coloneq,
    comma: comma,
    commat: commat,
    comp: comp,
    compfn: compfn,
    complement: complement,
    complexes: complexes,
    cong: cong,
    congdot: congdot,
    Congruent: Congruent,
    Conint: Conint,
    conint: conint,
    ContourIntegral: ContourIntegral,
    Copf: Copf,
    copf: copf,
    coprod: coprod,
    Coproduct: Coproduct,
    COPY: COPY,
    copy: copy,
    copysr: copysr,
    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
    crarr: crarr,
    Cross: Cross,
    cross: cross,
    Cscr: Cscr,
    cscr: cscr,
    csub: csub,
    csube: csube,
    csup: csup,
    csupe: csupe,
    ctdot: ctdot,
    cudarrl: cudarrl,
    cudarrr: cudarrr,
    cuepr: cuepr,
    cuesc: cuesc,
    cularr: cularr,
    cularrp: cularrp,
    Cup: Cup,
    cup: cup,
    cupbrcap: cupbrcap,
    CupCap: CupCap,
    cupcap: cupcap,
    cupcup: cupcup,
    cupdot: cupdot,
    cupor: cupor,
    cups: cups,
    curarr: curarr,
    curarrm: curarrm,
    curlyeqprec: curlyeqprec,
    curlyeqsucc: curlyeqsucc,
    curlyvee: curlyvee,
    curlywedge: curlywedge,
    curren: curren,
    curvearrowleft: curvearrowleft,
    curvearrowright: curvearrowright,
    cuvee: cuvee,
    cuwed: cuwed,
    cwconint: cwconint,
    cwint: cwint,
    cylcty: cylcty,
    Dagger: Dagger,
    dagger: dagger,
    daleth: daleth,
    Darr: Darr,
    dArr: dArr,
    darr: darr,
    dash: dash,
    Dashv: Dashv,
    dashv: dashv,
    dbkarow: dbkarow,
    dblac: dblac,
    Dcaron: Dcaron,
    dcaron: dcaron,
    Dcy: Dcy,
    dcy: dcy,
    DD: DD,
    dd: dd,
    ddagger: ddagger,
    ddarr: ddarr,
    DDotrahd: DDotrahd,
    ddotseq: ddotseq,
    deg: deg,
    Del: Del,
    Delta: Delta,
    delta: delta,
    demptyv: demptyv,
    dfisht: dfisht,
    Dfr: Dfr,
    dfr: dfr,
    dHar: dHar,
    dharl: dharl,
    dharr: dharr,
    DiacriticalAcute: DiacriticalAcute,
    DiacriticalDot: DiacriticalDot,
    DiacriticalDoubleAcute: DiacriticalDoubleAcute,
    DiacriticalGrave: DiacriticalGrave,
    DiacriticalTilde: DiacriticalTilde,
    diam: diam,
    Diamond: Diamond,
    diamond: diamond,
    diamondsuit: diamondsuit,
    diams: diams,
    die: die,
    DifferentialD: DifferentialD,
    digamma: digamma,
    disin: disin,
    div: div,
    divide: divide,
    divideontimes: divideontimes,
    divonx: divonx,
    DJcy: DJcy,
    djcy: djcy,
    dlcorn: dlcorn,
    dlcrop: dlcrop,
    dollar: dollar,
    Dopf: Dopf,
    dopf: dopf,
    Dot: Dot,
    dot: dot,
    DotDot: DotDot,
    doteq: doteq,
    doteqdot: doteqdot,
    DotEqual: DotEqual,
    dotminus: dotminus,
    dotplus: dotplus,
    dotsquare: dotsquare,
    doublebarwedge: doublebarwedge,
    DoubleContourIntegral: DoubleContourIntegral,
    DoubleDot: DoubleDot,
    DoubleDownArrow: DoubleDownArrow,
    DoubleLeftArrow: DoubleLeftArrow,
    DoubleLeftRightArrow: DoubleLeftRightArrow,
    DoubleLeftTee: DoubleLeftTee,
    DoubleLongLeftArrow: DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
    DoubleLongRightArrow: DoubleLongRightArrow,
    DoubleRightArrow: DoubleRightArrow,
    DoubleRightTee: DoubleRightTee,
    DoubleUpArrow: DoubleUpArrow,
    DoubleUpDownArrow: DoubleUpDownArrow,
    DoubleVerticalBar: DoubleVerticalBar,
    DownArrow: DownArrow,
    Downarrow: Downarrow,
    downarrow: downarrow,
    DownArrowBar: DownArrowBar,
    DownArrowUpArrow: DownArrowUpArrow,
    DownBreve: DownBreve,
    downdownarrows: downdownarrows,
    downharpoonleft: downharpoonleft,
    downharpoonright: downharpoonright,
    DownLeftRightVector: DownLeftRightVector,
    DownLeftTeeVector: DownLeftTeeVector,
    DownLeftVector: DownLeftVector,
    DownLeftVectorBar: DownLeftVectorBar,
    DownRightTeeVector: DownRightTeeVector,
    DownRightVector: DownRightVector,
    DownRightVectorBar: DownRightVectorBar,
    DownTee: DownTee,
    DownTeeArrow: DownTeeArrow,
    drbkarow: drbkarow,
    drcorn: drcorn,
    drcrop: drcrop,
    Dscr: Dscr,
    dscr: dscr,
    DScy: DScy,
    dscy: dscy,
    dsol: dsol,
    Dstrok: Dstrok,
    dstrok: dstrok,
    dtdot: dtdot,
    dtri: dtri,
    dtrif: dtrif,
    duarr: duarr,
    duhar: duhar,
    dwangle: dwangle,
    DZcy: DZcy,
    dzcy: dzcy,
    dzigrarr: dzigrarr,
    Eacute: Eacute,
    eacute: eacute,
    easter: easter,
    Ecaron: Ecaron,
    ecaron: ecaron,
    ecir: ecir,
    Ecirc: Ecirc,
    ecirc: ecirc,
    ecolon: ecolon,
    Ecy: Ecy,
    ecy: ecy,
    eDDot: eDDot,
    Edot: Edot,
    eDot: eDot,
    edot: edot,
    ee: ee,
    efDot: efDot,
    Efr: Efr,
    efr: efr,
    eg: eg,
    Egrave: Egrave,
    egrave: egrave,
    egs: egs,
    egsdot: egsdot,
    el: el,
    Element: Element,
    elinters: elinters,
    ell: ell,
    els: els,
    elsdot: elsdot,
    Emacr: Emacr,
    emacr: emacr,
    empty: empty,
    emptyset: emptyset,
    EmptySmallSquare: EmptySmallSquare,
    emptyv: emptyv,
    EmptyVerySmallSquare: EmptyVerySmallSquare,
    emsp: emsp,
    emsp13: emsp13,
    emsp14: emsp14,
    ENG: ENG,
    eng: eng,
    ensp: ensp,
    Eogon: Eogon,
    eogon: eogon,
    Eopf: Eopf,
    eopf: eopf,
    epar: epar,
    eparsl: eparsl,
    eplus: eplus,
    epsi: epsi,
    Epsilon: Epsilon,
    epsilon: epsilon,
    epsiv: epsiv,
    eqcirc: eqcirc,
    eqcolon: eqcolon,
    eqsim: eqsim,
    eqslantgtr: eqslantgtr,
    eqslantless: eqslantless,
    Equal: Equal,
    equals: equals,
    EqualTilde: EqualTilde,
    equest: equest,
    Equilibrium: Equilibrium,
    equiv: equiv,
    equivDD: equivDD,
    eqvparsl: eqvparsl,
    erarr: erarr,
    erDot: erDot,
    Escr: Escr,
    escr: escr,
    esdot: esdot,
    Esim: Esim,
    esim: esim,
    Eta: Eta,
    eta: eta,
    ETH: ETH,
    eth: eth,
    Euml: Euml,
    euml: euml,
    euro: euro,
    excl: excl,
    exist: exist,
    Exists: Exists,
    expectation: expectation,
    ExponentialE: ExponentialE,
    exponentiale: exponentiale,
    fallingdotseq: fallingdotseq,
    Fcy: Fcy,
    fcy: fcy,
    female: female,
    ffilig: ffilig,
    fflig: fflig,
    ffllig: ffllig,
    Ffr: Ffr,
    ffr: ffr,
    filig: filig,
    FilledSmallSquare: FilledSmallSquare,
    FilledVerySmallSquare: FilledVerySmallSquare,
    fjlig: fjlig,
    flat: flat,
    fllig: fllig,
    fltns: fltns,
    fnof: fnof,
    Fopf: Fopf,
    fopf: fopf,
    ForAll: ForAll,
    forall: forall,
    fork: fork,
    forkv: forkv,
    Fouriertrf: Fouriertrf,
    fpartint: fpartint,
    frac12: frac12,
    frac13: frac13,
    frac14: frac14,
    frac15: frac15,
    frac16: frac16,
    frac18: frac18,
    frac23: frac23,
    frac25: frac25,
    frac34: frac34,
    frac35: frac35,
    frac38: frac38,
    frac45: frac45,
    frac56: frac56,
    frac58: frac58,
    frac78: frac78,
    frasl: frasl,
    frown: frown,
    Fscr: Fscr,
    fscr: fscr,
    gacute: gacute,
    Gamma: Gamma,
    gamma: gamma,
    Gammad: Gammad,
    gammad: gammad,
    gap: gap,
    Gbreve: Gbreve,
    gbreve: gbreve,
    Gcedil: Gcedil,
    Gcirc: Gcirc,
    gcirc: gcirc,
    Gcy: Gcy,
    gcy: gcy,
    Gdot: Gdot,
    gdot: gdot,
    gE: gE,
    ge: ge,
    gEl: gEl,
    gel: gel,
    geq: geq,
    geqq: geqq,
    geqslant: geqslant,
    ges: ges,
    gescc: gescc,
    gesdot: gesdot,
    gesdoto: gesdoto,
    gesdotol: gesdotol,
    gesl: gesl,
    gesles: gesles,
    Gfr: Gfr,
    gfr: gfr,
    Gg: Gg,
    gg: gg,
    ggg: ggg,
    gimel: gimel,
    GJcy: GJcy,
    gjcy: gjcy,
    gl: gl,
    gla: gla,
    glE: glE,
    glj: glj,
    gnap: gnap,
    gnapprox: gnapprox,
    gnE: gnE,
    gne: gne,
    gneq: gneq,
    gneqq: gneqq,
    gnsim: gnsim,
    Gopf: Gopf,
    gopf: gopf,
    grave: grave,
    GreaterEqual: GreaterEqual,
    GreaterEqualLess: GreaterEqualLess,
    GreaterFullEqual: GreaterFullEqual,
    GreaterGreater: GreaterGreater,
    GreaterLess: GreaterLess,
    GreaterSlantEqual: GreaterSlantEqual,
    GreaterTilde: GreaterTilde,
    Gscr: Gscr,
    gscr: gscr,
    gsim: gsim,
    gsime: gsime,
    gsiml: gsiml,
    GT: GT,
    Gt: Gt,
    gt: gt,
    gtcc: gtcc,
    gtcir: gtcir,
    gtdot: gtdot,
    gtlPar: gtlPar,
    gtquest: gtquest,
    gtrapprox: gtrapprox,
    gtrarr: gtrarr,
    gtrdot: gtrdot,
    gtreqless: gtreqless,
    gtreqqless: gtreqqless,
    gtrless: gtrless,
    gtrsim: gtrsim,
    gvertneqq: gvertneqq,
    gvnE: gvnE,
    Hacek: Hacek,
    hairsp: hairsp,
    half: half,
    hamilt: hamilt,
    HARDcy: HARDcy,
    hardcy: hardcy,
    hArr: hArr,
    harr: harr,
    harrcir: harrcir,
    harrw: harrw,
    Hat: Hat,
    hbar: hbar,
    Hcirc: Hcirc,
    hcirc: hcirc,
    hearts: hearts,
    heartsuit: heartsuit,
    hellip: hellip,
    hercon: hercon,
    Hfr: Hfr,
    hfr: hfr,
    HilbertSpace: HilbertSpace,
    hksearow: hksearow,
    hkswarow: hkswarow,
    hoarr: hoarr,
    homtht: homtht,
    hookleftarrow: hookleftarrow,
    hookrightarrow: hookrightarrow,
    Hopf: Hopf,
    hopf: hopf,
    horbar: horbar,
    HorizontalLine: HorizontalLine,
    Hscr: Hscr,
    hscr: hscr,
    hslash: hslash,
    Hstrok: Hstrok,
    hstrok: hstrok,
    HumpDownHump: HumpDownHump,
    HumpEqual: HumpEqual,
    hybull: hybull,
    hyphen: hyphen,
    Iacute: Iacute,
    iacute: iacute,
    ic: ic,
    Icirc: Icirc,
    icirc: icirc,
    Icy: Icy,
    icy: icy,
    Idot: Idot,
    IEcy: IEcy,
    iecy: iecy,
    iexcl: iexcl,
    iff: iff,
    Ifr: Ifr,
    ifr: ifr,
    Igrave: Igrave,
    igrave: igrave,
    ii: ii,
    iiiint: iiiint,
    iiint: iiint,
    iinfin: iinfin,
    iiota: iiota,
    IJlig: IJlig,
    ijlig: ijlig,
    Im: Im,
    Imacr: Imacr,
    imacr: imacr,
    image: image,
    ImaginaryI: ImaginaryI,
    imagline: imagline,
    imagpart: imagpart,
    imath: imath,
    imof: imof,
    imped: imped,
    Implies: Implies,
    "in": "",
    incare: incare,
    infin: infin,
    infintie: infintie,
    inodot: inodot,
    Int: Int,
    int: int,
    intcal: intcal,
    integers: integers,
    Integral: Integral,
    intercal: intercal,
    Intersection: Intersection,
    intlarhk: intlarhk,
    intprod: intprod,
    InvisibleComma: InvisibleComma,
    InvisibleTimes: InvisibleTimes,
    IOcy: IOcy,
    iocy: iocy,
    Iogon: Iogon,
    iogon: iogon,
    Iopf: Iopf,
    iopf: iopf,
    Iota: Iota,
    iota: iota,
    iprod: iprod,
    iquest: iquest,
    Iscr: Iscr,
    iscr: iscr,
    isin: isin,
    isindot: isindot,
    isinE: isinE,
    isins: isins,
    isinsv: isinsv,
    isinv: isinv,
    it: it,
    Itilde: Itilde,
    itilde: itilde,
    Iukcy: Iukcy,
    iukcy: iukcy,
    Iuml: Iuml,
    iuml: iuml,
    Jcirc: Jcirc,
    jcirc: jcirc,
    Jcy: Jcy,
    jcy: jcy,
    Jfr: Jfr,
    jfr: jfr,
    jmath: jmath,
    Jopf: Jopf,
    jopf: jopf,
    Jscr: Jscr,
    jscr: jscr,
    Jsercy: Jsercy,
    jsercy: jsercy,
    Jukcy: Jukcy,
    jukcy: jukcy,
    Kappa: Kappa,
    kappa: kappa,
    kappav: kappav,
    Kcedil: Kcedil,
    kcedil: kcedil,
    Kcy: Kcy,
    kcy: kcy,
    Kfr: Kfr,
    kfr: kfr,
    kgreen: kgreen,
    KHcy: KHcy,
    khcy: khcy,
    KJcy: KJcy,
    kjcy: kjcy,
    Kopf: Kopf,
    kopf: kopf,
    Kscr: Kscr,
    kscr: kscr,
    lAarr: lAarr,
    Lacute: Lacute,
    lacute: lacute,
    laemptyv: laemptyv,
    lagran: lagran,
    Lambda: Lambda,
    lambda: lambda,
    Lang: Lang,
    lang: lang,
    langd: langd,
    langle: langle,
    lap: lap,
    Laplacetrf: Laplacetrf,
    laquo: laquo,
    Larr: Larr,
    lArr: lArr,
    larr: larr,
    larrb: larrb,
    larrbfs: larrbfs,
    larrfs: larrfs,
    larrhk: larrhk,
    larrlp: larrlp,
    larrpl: larrpl,
    larrsim: larrsim,
    larrtl: larrtl,
    lat: lat,
    lAtail: lAtail,
    latail: latail,
    late: late,
    lates: lates,
    lBarr: lBarr,
    lbarr: lbarr,
    lbbrk: lbbrk,
    lbrace: lbrace,
    lbrack: lbrack,
    lbrke: lbrke,
    lbrksld: lbrksld,
    lbrkslu: lbrkslu,
    Lcaron: Lcaron,
    lcaron: lcaron,
    Lcedil: Lcedil,
    lcedil: lcedil,
    lceil: lceil,
    lcub: lcub,
    Lcy: Lcy,
    lcy: lcy,
    ldca: ldca,
    ldquo: ldquo,
    ldquor: ldquor,
    ldrdhar: ldrdhar,
    ldrushar: ldrushar,
    ldsh: ldsh,
    lE: lE,
    le: le,
    LeftAngleBracket: LeftAngleBracket,
    LeftArrow: LeftArrow,
    Leftarrow: Leftarrow,
    leftarrow: leftarrow,
    LeftArrowBar: LeftArrowBar,
    LeftArrowRightArrow: LeftArrowRightArrow,
    leftarrowtail: leftarrowtail,
    LeftCeiling: LeftCeiling,
    LeftDoubleBracket: LeftDoubleBracket,
    LeftDownTeeVector: LeftDownTeeVector,
    LeftDownVector: LeftDownVector,
    LeftDownVectorBar: LeftDownVectorBar,
    LeftFloor: LeftFloor,
    leftharpoondown: leftharpoondown,
    leftharpoonup: leftharpoonup,
    leftleftarrows: leftleftarrows,
    LeftRightArrow: LeftRightArrow,
    Leftrightarrow: Leftrightarrow,
    leftrightarrow: leftrightarrow,
    leftrightarrows: leftrightarrows,
    leftrightharpoons: leftrightharpoons,
    leftrightsquigarrow: leftrightsquigarrow,
    LeftRightVector: LeftRightVector,
    LeftTee: LeftTee,
    LeftTeeArrow: LeftTeeArrow,
    LeftTeeVector: LeftTeeVector,
    leftthreetimes: leftthreetimes,
    LeftTriangle: LeftTriangle,
    LeftTriangleBar: LeftTriangleBar,
    LeftTriangleEqual: LeftTriangleEqual,
    LeftUpDownVector: LeftUpDownVector,
    LeftUpTeeVector: LeftUpTeeVector,
    LeftUpVector: LeftUpVector,
    LeftUpVectorBar: LeftUpVectorBar,
    LeftVector: LeftVector,
    LeftVectorBar: LeftVectorBar,
    lEg: lEg,
    leg: leg,
    leq: leq,
    leqq: leqq,
    leqslant: leqslant,
    les: les,
    lescc: lescc,
    lesdot: lesdot,
    lesdoto: lesdoto,
    lesdotor: lesdotor,
    lesg: lesg,
    lesges: lesges,
    lessapprox: lessapprox,
    lessdot: lessdot,
    lesseqgtr: lesseqgtr,
    lesseqqgtr: lesseqqgtr,
    LessEqualGreater: LessEqualGreater,
    LessFullEqual: LessFullEqual,
    LessGreater: LessGreater,
    lessgtr: lessgtr,
    LessLess: LessLess,
    lesssim: lesssim,
    LessSlantEqual: LessSlantEqual,
    LessTilde: LessTilde,
    lfisht: lfisht,
    lfloor: lfloor,
    Lfr: Lfr,
    lfr: lfr,
    lg: lg,
    lgE: lgE,
    lHar: lHar,
    lhard: lhard,
    lharu: lharu,
    lharul: lharul,
    lhblk: lhblk,
    LJcy: LJcy,
    ljcy: ljcy,
    Ll: Ll,
    ll: ll,
    llarr: llarr,
    llcorner: llcorner,
    Lleftarrow: Lleftarrow,
    llhard: llhard,
    lltri: lltri,
    Lmidot: Lmidot,
    lmidot: lmidot,
    lmoust: lmoust,
    lmoustache: lmoustache,
    lnap: lnap,
    lnapprox: lnapprox,
    lnE: lnE,
    lne: lne,
    lneq: lneq,
    lneqq: lneqq,
    lnsim: lnsim,
    loang: loang,
    loarr: loarr,
    lobrk: lobrk,
    LongLeftArrow: LongLeftArrow,
    Longleftarrow: Longleftarrow,
    longleftarrow: longleftarrow,
    LongLeftRightArrow: LongLeftRightArrow,
    Longleftrightarrow: Longleftrightarrow,
    longleftrightarrow: longleftrightarrow,
    longmapsto: longmapsto,
    LongRightArrow: LongRightArrow,
    Longrightarrow: Longrightarrow,
    longrightarrow: longrightarrow,
    looparrowleft: looparrowleft,
    looparrowright: looparrowright,
    lopar: lopar,
    Lopf: Lopf,
    lopf: lopf,
    loplus: loplus,
    lotimes: lotimes,
    lowast: lowast,
    lowbar: lowbar,
    LowerLeftArrow: LowerLeftArrow,
    LowerRightArrow: LowerRightArrow,
    loz: loz,
    lozenge: lozenge,
    lozf: lozf,
    lpar: lpar,
    lparlt: lparlt,
    lrarr: lrarr,
    lrcorner: lrcorner,
    lrhar: lrhar,
    lrhard: lrhard,
    lrm: lrm,
    lrtri: lrtri,
    lsaquo: lsaquo,
    Lscr: Lscr,
    lscr: lscr,
    Lsh: Lsh,
    lsh: lsh,
    lsim: lsim,
    lsime: lsime,
    lsimg: lsimg,
    lsqb: lsqb,
    lsquo: lsquo,
    lsquor: lsquor,
    Lstrok: Lstrok,
    lstrok: lstrok,
    LT: LT,
    Lt: Lt,
    lt: lt,
    ltcc: ltcc,
    ltcir: ltcir,
    ltdot: ltdot,
    lthree: lthree,
    ltimes: ltimes,
    ltlarr: ltlarr,
    ltquest: ltquest,
    ltri: ltri,
    ltrie: ltrie,
    ltrif: ltrif,
    ltrPar: ltrPar,
    lurdshar: lurdshar,
    luruhar: luruhar,
    lvertneqq: lvertneqq,
    lvnE: lvnE,
    macr: macr,
    male: male,
    malt: malt,
    maltese: maltese,
    "Map": "",
    map: map,
    mapsto: mapsto,
    mapstodown: mapstodown,
    mapstoleft: mapstoleft,
    mapstoup: mapstoup,
    marker: marker,
    mcomma: mcomma,
    Mcy: Mcy,
    mcy: mcy,
    mdash: mdash,
    mDDot: mDDot,
    measuredangle: measuredangle,
    MediumSpace: MediumSpace,
    Mellintrf: Mellintrf,
    Mfr: Mfr,
    mfr: mfr,
    mho: mho,
    micro: micro,
    mid: mid,
    midast: midast,
    midcir: midcir,
    middot: middot,
    minus: minus,
    minusb: minusb,
    minusd: minusd,
    minusdu: minusdu,
    MinusPlus: MinusPlus,
    mlcp: mlcp,
    mldr: mldr,
    mnplus: mnplus,
    models: models,
    Mopf: Mopf,
    mopf: mopf,
    mp: mp,
    Mscr: Mscr,
    mscr: mscr,
    mstpos: mstpos,
    Mu: Mu,
    mu: mu,
    multimap: multimap,
    mumap: mumap,
    nabla: nabla,
    Nacute: Nacute,
    nacute: nacute,
    nang: nang,
    nap: nap,
    napE: napE,
    napid: napid,
    napos: napos,
    napprox: napprox,
    natur: natur,
    natural: natural,
    naturals: naturals,
    nbsp: nbsp,
    nbump: nbump,
    nbumpe: nbumpe,
    ncap: ncap,
    Ncaron: Ncaron,
    ncaron: ncaron,
    Ncedil: Ncedil,
    ncedil: ncedil,
    ncong: ncong,
    ncongdot: ncongdot,
    ncup: ncup,
    Ncy: Ncy,
    ncy: ncy,
    ndash: ndash,
    ne: ne,
    nearhk: nearhk,
    neArr: neArr,
    nearr: nearr,
    nearrow: nearrow,
    nedot: nedot,
    NegativeMediumSpace: NegativeMediumSpace,
    NegativeThickSpace: NegativeThickSpace,
    NegativeThinSpace: NegativeThinSpace,
    NegativeVeryThinSpace: NegativeVeryThinSpace,
    nequiv: nequiv,
    nesear: nesear,
    nesim: nesim,
    NestedGreaterGreater: NestedGreaterGreater,
    NestedLessLess: NestedLessLess,
    NewLine: NewLine,
    nexist: nexist,
    nexists: nexists,
    Nfr: Nfr,
    nfr: nfr,
    ngE: ngE,
    nge: nge,
    ngeq: ngeq,
    ngeqq: ngeqq,
    ngeqslant: ngeqslant,
    nges: nges,
    nGg: nGg,
    ngsim: ngsim,
    nGt: nGt,
    ngt: ngt,
    ngtr: ngtr,
    nGtv: nGtv,
    nhArr: nhArr,
    nharr: nharr,
    nhpar: nhpar,
    ni: ni,
    nis: nis,
    nisd: nisd,
    niv: niv,
    NJcy: NJcy,
    njcy: njcy,
    nlArr: nlArr,
    nlarr: nlarr,
    nldr: nldr,
    nlE: nlE,
    nle: nle,
    nLeftarrow: nLeftarrow,
    nleftarrow: nleftarrow,
    nLeftrightarrow: nLeftrightarrow,
    nleftrightarrow: nleftrightarrow,
    nleq: nleq,
    nleqq: nleqq,
    nleqslant: nleqslant,
    nles: nles,
    nless: nless,
    nLl: nLl,
    nlsim: nlsim,
    nLt: nLt,
    nlt: nlt,
    nltri: nltri,
    nltrie: nltrie,
    nLtv: nLtv,
    nmid: nmid,
    NoBreak: NoBreak,
    NonBreakingSpace: NonBreakingSpace,
    Nopf: Nopf,
    nopf: nopf,
    Not: Not,
    not: not,
    NotCongruent: NotCongruent,
    NotCupCap: NotCupCap,
    NotDoubleVerticalBar: NotDoubleVerticalBar,
    NotElement: NotElement,
    NotEqual: NotEqual,
    NotEqualTilde: NotEqualTilde,
    NotExists: NotExists,
    NotGreater: NotGreater,
    NotGreaterEqual: NotGreaterEqual,
    NotGreaterFullEqual: NotGreaterFullEqual,
    NotGreaterGreater: NotGreaterGreater,
    NotGreaterLess: NotGreaterLess,
    NotGreaterSlantEqual: NotGreaterSlantEqual,
    NotGreaterTilde: NotGreaterTilde,
    NotHumpDownHump: NotHumpDownHump,
    NotHumpEqual: NotHumpEqual,
    notin: notin,
    notindot: notindot,
    notinE: notinE,
    notinva: notinva,
    notinvb: notinvb,
    notinvc: notinvc,
    NotLeftTriangle: NotLeftTriangle,
    NotLeftTriangleBar: NotLeftTriangleBar,
    NotLeftTriangleEqual: NotLeftTriangleEqual,
    NotLess: NotLess,
    NotLessEqual: NotLessEqual,
    NotLessGreater: NotLessGreater,
    NotLessLess: NotLessLess,
    NotLessSlantEqual: NotLessSlantEqual,
    NotLessTilde: NotLessTilde,
    NotNestedGreaterGreater: NotNestedGreaterGreater,
    NotNestedLessLess: NotNestedLessLess,
    notni: notni,
    notniva: notniva,
    notnivb: notnivb,
    notnivc: notnivc,
    NotPrecedes: NotPrecedes,
    NotPrecedesEqual: NotPrecedesEqual,
    NotPrecedesSlantEqual: NotPrecedesSlantEqual,
    NotReverseElement: NotReverseElement,
    NotRightTriangle: NotRightTriangle,
    NotRightTriangleBar: NotRightTriangleBar,
    NotRightTriangleEqual: NotRightTriangleEqual,
    NotSquareSubset: NotSquareSubset,
    NotSquareSubsetEqual: NotSquareSubsetEqual,
    NotSquareSuperset: NotSquareSuperset,
    NotSquareSupersetEqual: NotSquareSupersetEqual,
    NotSubset: NotSubset,
    NotSubsetEqual: NotSubsetEqual,
    NotSucceeds: NotSucceeds,
    NotSucceedsEqual: NotSucceedsEqual,
    NotSucceedsSlantEqual: NotSucceedsSlantEqual,
    NotSucceedsTilde: NotSucceedsTilde,
    NotSuperset: NotSuperset,
    NotSupersetEqual: NotSupersetEqual,
    NotTilde: NotTilde,
    NotTildeEqual: NotTildeEqual,
    NotTildeFullEqual: NotTildeFullEqual,
    NotTildeTilde: NotTildeTilde,
    NotVerticalBar: NotVerticalBar,
    npar: npar,
    nparallel: nparallel,
    nparsl: nparsl,
    npart: npart,
    npolint: npolint,
    npr: npr,
    nprcue: nprcue,
    npre: npre,
    nprec: nprec,
    npreceq: npreceq,
    nrArr: nrArr,
    nrarr: nrarr,
    nrarrc: nrarrc,
    nrarrw: nrarrw,
    nRightarrow: nRightarrow,
    nrightarrow: nrightarrow,
    nrtri: nrtri,
    nrtrie: nrtrie,
    nsc: nsc,
    nsccue: nsccue,
    nsce: nsce,
    Nscr: Nscr,
    nscr: nscr,
    nshortmid: nshortmid,
    nshortparallel: nshortparallel,
    nsim: nsim,
    nsime: nsime,
    nsimeq: nsimeq,
    nsmid: nsmid,
    nspar: nspar,
    nsqsube: nsqsube,
    nsqsupe: nsqsupe,
    nsub: nsub,
    nsubE: nsubE,
    nsube: nsube,
    nsubset: nsubset,
    nsubseteq: nsubseteq,
    nsubseteqq: nsubseteqq,
    nsucc: nsucc,
    nsucceq: nsucceq,
    nsup: nsup,
    nsupE: nsupE,
    nsupe: nsupe,
    nsupset: nsupset,
    nsupseteq: nsupseteq,
    nsupseteqq: nsupseteqq,
    ntgl: ntgl,
    Ntilde: Ntilde,
    ntilde: ntilde,
    ntlg: ntlg,
    ntriangleleft: ntriangleleft,
    ntrianglelefteq: ntrianglelefteq,
    ntriangleright: ntriangleright,
    ntrianglerighteq: ntrianglerighteq,
    Nu: Nu,
    nu: nu,
    num: num,
    numero: numero,
    numsp: numsp,
    nvap: nvap,
    nVDash: nVDash,
    nVdash: nVdash,
    nvDash: nvDash,
    nvdash: nvdash,
    nvge: nvge,
    nvgt: nvgt,
    nvHarr: nvHarr,
    nvinfin: nvinfin,
    nvlArr: nvlArr,
    nvle: nvle,
    nvlt: nvlt,
    nvltrie: nvltrie,
    nvrArr: nvrArr,
    nvrtrie: nvrtrie,
    nvsim: nvsim,
    nwarhk: nwarhk,
    nwArr: nwArr,
    nwarr: nwarr,
    nwarrow: nwarrow,
    nwnear: nwnear,
    Oacute: Oacute,
    oacute: oacute,
    oast: oast,
    ocir: ocir,
    Ocirc: Ocirc,
    ocirc: ocirc,
    Ocy: Ocy,
    ocy: ocy,
    odash: odash,
    Odblac: Odblac,
    odblac: odblac,
    odiv: odiv,
    odot: odot,
    odsold: odsold,
    OElig: OElig,
    oelig: oelig,
    ofcir: ofcir,
    Ofr: Ofr,
    ofr: ofr,
    ogon: ogon,
    Ograve: Ograve,
    ograve: ograve,
    ogt: ogt,
    ohbar: ohbar,
    ohm: ohm,
    oint: oint,
    olarr: olarr,
    olcir: olcir,
    olcross: olcross,
    oline: oline,
    olt: olt,
    Omacr: Omacr,
    omacr: omacr,
    Omega: Omega,
    omega: omega,
    Omicron: Omicron,
    omicron: omicron,
    omid: omid,
    ominus: ominus,
    Oopf: Oopf,
    oopf: oopf,
    opar: opar,
    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
    OpenCurlyQuote: OpenCurlyQuote,
    operp: operp,
    oplus: oplus,
    Or: Or,
    or: or,
    orarr: orarr,
    ord: ord,
    order: order,
    orderof: orderof,
    ordf: ordf,
    ordm: ordm,
    origof: origof,
    oror: oror,
    orslope: orslope,
    orv: orv,
    oS: oS,
    Oscr: Oscr,
    oscr: oscr,
    Oslash: Oslash,
    oslash: oslash,
    osol: osol,
    Otilde: Otilde,
    otilde: otilde,
    Otimes: Otimes,
    otimes: otimes,
    otimesas: otimesas,
    Ouml: Ouml,
    ouml: ouml,
    ovbar: ovbar,
    OverBar: OverBar,
    OverBrace: OverBrace,
    OverBracket: OverBracket,
    OverParenthesis: OverParenthesis,
    par: par,
    para: para,
    parallel: parallel,
    parsim: parsim,
    parsl: parsl,
    part: part,
    PartialD: PartialD,
    Pcy: Pcy,
    pcy: pcy,
    percnt: percnt,
    period: period,
    permil: permil,
    perp: perp,
    pertenk: pertenk,
    Pfr: Pfr,
    pfr: pfr,
    Phi: Phi,
    phi: phi,
    phiv: phiv,
    phmmat: phmmat,
    phone: phone,
    Pi: Pi,
    pi: pi,
    pitchfork: pitchfork,
    piv: piv,
    planck: planck,
    planckh: planckh,
    plankv: plankv,
    plus: plus,
    plusacir: plusacir,
    plusb: plusb,
    pluscir: pluscir,
    plusdo: plusdo,
    plusdu: plusdu,
    pluse: pluse,
    PlusMinus: PlusMinus,
    plusmn: plusmn,
    plussim: plussim,
    plustwo: plustwo,
    pm: pm,
    Poincareplane: Poincareplane,
    pointint: pointint,
    Popf: Popf,
    popf: popf,
    pound: pound,
    Pr: Pr,
    pr: pr,
    prap: prap,
    prcue: prcue,
    prE: prE,
    pre: pre,
    prec: prec,
    precapprox: precapprox,
    preccurlyeq: preccurlyeq,
    Precedes: Precedes,
    PrecedesEqual: PrecedesEqual,
    PrecedesSlantEqual: PrecedesSlantEqual,
    PrecedesTilde: PrecedesTilde,
    preceq: preceq,
    precnapprox: precnapprox,
    precneqq: precneqq,
    precnsim: precnsim,
    precsim: precsim,
    Prime: Prime,
    prime: prime,
    primes: primes,
    prnap: prnap,
    prnE: prnE,
    prnsim: prnsim,
    prod: prod,
    Product: Product,
    profalar: profalar,
    profline: profline,
    profsurf: profsurf,
    prop: prop,
    Proportion: Proportion,
    Proportional: Proportional,
    propto: propto,
    prsim: prsim,
    prurel: prurel,
    Pscr: Pscr,
    pscr: pscr,
    Psi: Psi,
    psi: psi,
    puncsp: puncsp,
    Qfr: Qfr,
    qfr: qfr,
    qint: qint,
    Qopf: Qopf,
    qopf: qopf,
    qprime: qprime,
    Qscr: Qscr,
    qscr: qscr,
    quaternions: quaternions,
    quatint: quatint,
    quest: quest,
    questeq: questeq,
    QUOT: QUOT,
    quot: quot,
    rAarr: rAarr,
    race: race,
    Racute: Racute,
    racute: racute,
    radic: radic,
    raemptyv: raemptyv,
    Rang: Rang,
    rang: rang,
    rangd: rangd,
    range: range,
    rangle: rangle,
    raquo: raquo,
    Rarr: Rarr,
    rArr: rArr,
    rarr: rarr,
    rarrap: rarrap,
    rarrb: rarrb,
    rarrbfs: rarrbfs,
    rarrc: rarrc,
    rarrfs: rarrfs,
    rarrhk: rarrhk,
    rarrlp: rarrlp,
    rarrpl: rarrpl,
    rarrsim: rarrsim,
    Rarrtl: Rarrtl,
    rarrtl: rarrtl,
    rarrw: rarrw,
    rAtail: rAtail,
    ratail: ratail,
    ratio: ratio,
    rationals: rationals,
    RBarr: RBarr,
    rBarr: rBarr,
    rbarr: rbarr,
    rbbrk: rbbrk,
    rbrace: rbrace,
    rbrack: rbrack,
    rbrke: rbrke,
    rbrksld: rbrksld,
    rbrkslu: rbrkslu,
    Rcaron: Rcaron,
    rcaron: rcaron,
    Rcedil: Rcedil,
    rcedil: rcedil,
    rceil: rceil,
    rcub: rcub,
    Rcy: Rcy,
    rcy: rcy,
    rdca: rdca,
    rdldhar: rdldhar,
    rdquo: rdquo,
    rdquor: rdquor,
    rdsh: rdsh,
    Re: Re,
    real: real,
    realine: realine,
    realpart: realpart,
    reals: reals,
    rect: rect,
    REG: REG,
    reg: reg,
    ReverseElement: ReverseElement,
    ReverseEquilibrium: ReverseEquilibrium,
    ReverseUpEquilibrium: ReverseUpEquilibrium,
    rfisht: rfisht,
    rfloor: rfloor,
    Rfr: Rfr,
    rfr: rfr,
    rHar: rHar,
    rhard: rhard,
    rharu: rharu,
    rharul: rharul,
    Rho: Rho,
    rho: rho,
    rhov: rhov,
    RightAngleBracket: RightAngleBracket,
    RightArrow: RightArrow,
    Rightarrow: Rightarrow,
    rightarrow: rightarrow,
    RightArrowBar: RightArrowBar,
    RightArrowLeftArrow: RightArrowLeftArrow,
    rightarrowtail: rightarrowtail,
    RightCeiling: RightCeiling,
    RightDoubleBracket: RightDoubleBracket,
    RightDownTeeVector: RightDownTeeVector,
    RightDownVector: RightDownVector,
    RightDownVectorBar: RightDownVectorBar,
    RightFloor: RightFloor,
    rightharpoondown: rightharpoondown,
    rightharpoonup: rightharpoonup,
    rightleftarrows: rightleftarrows,
    rightleftharpoons: rightleftharpoons,
    rightrightarrows: rightrightarrows,
    rightsquigarrow: rightsquigarrow,
    RightTee: RightTee,
    RightTeeArrow: RightTeeArrow,
    RightTeeVector: RightTeeVector,
    rightthreetimes: rightthreetimes,
    RightTriangle: RightTriangle,
    RightTriangleBar: RightTriangleBar,
    RightTriangleEqual: RightTriangleEqual,
    RightUpDownVector: RightUpDownVector,
    RightUpTeeVector: RightUpTeeVector,
    RightUpVector: RightUpVector,
    RightUpVectorBar: RightUpVectorBar,
    RightVector: RightVector,
    RightVectorBar: RightVectorBar,
    ring: ring,
    risingdotseq: risingdotseq,
    rlarr: rlarr,
    rlhar: rlhar,
    rlm: rlm,
    rmoust: rmoust,
    rmoustache: rmoustache,
    rnmid: rnmid,
    roang: roang,
    roarr: roarr,
    robrk: robrk,
    ropar: ropar,
    Ropf: Ropf,
    ropf: ropf,
    roplus: roplus,
    rotimes: rotimes,
    RoundImplies: RoundImplies,
    rpar: rpar,
    rpargt: rpargt,
    rppolint: rppolint,
    rrarr: rrarr,
    Rrightarrow: Rrightarrow,
    rsaquo: rsaquo,
    Rscr: Rscr,
    rscr: rscr,
    Rsh: Rsh,
    rsh: rsh,
    rsqb: rsqb,
    rsquo: rsquo,
    rsquor: rsquor,
    rthree: rthree,
    rtimes: rtimes,
    rtri: rtri,
    rtrie: rtrie,
    rtrif: rtrif,
    rtriltri: rtriltri,
    RuleDelayed: RuleDelayed,
    ruluhar: ruluhar,
    rx: rx,
    Sacute: Sacute,
    sacute: sacute,
    sbquo: sbquo,
    Sc: Sc,
    sc: sc,
    scap: scap,
    Scaron: Scaron,
    scaron: scaron,
    sccue: sccue,
    scE: scE,
    sce: sce,
    Scedil: Scedil,
    scedil: scedil,
    Scirc: Scirc,
    scirc: scirc,
    scnap: scnap,
    scnE: scnE,
    scnsim: scnsim,
    scpolint: scpolint,
    scsim: scsim,
    Scy: Scy,
    scy: scy,
    sdot: sdot,
    sdotb: sdotb,
    sdote: sdote,
    searhk: searhk,
    seArr: seArr,
    searr: searr,
    searrow: searrow,
    sect: sect,
    semi: semi,
    seswar: seswar,
    setminus: setminus,
    setmn: setmn,
    sext: sext,
    Sfr: Sfr,
    sfr: sfr,
    sfrown: sfrown,
    sharp: sharp,
    SHCHcy: SHCHcy,
    shchcy: shchcy,
    SHcy: SHcy,
    shcy: shcy,
    ShortDownArrow: ShortDownArrow,
    ShortLeftArrow: ShortLeftArrow,
    shortmid: shortmid,
    shortparallel: shortparallel,
    ShortRightArrow: ShortRightArrow,
    ShortUpArrow: ShortUpArrow,
    shy: shy,
    Sigma: Sigma,
    sigma: sigma,
    sigmaf: sigmaf,
    sigmav: sigmav,
    sim: sim,
    simdot: simdot,
    sime: sime,
    simeq: simeq,
    simg: simg,
    simgE: simgE,
    siml: siml,
    simlE: simlE,
    simne: simne,
    simplus: simplus,
    simrarr: simrarr,
    slarr: slarr,
    SmallCircle: SmallCircle,
    smallsetminus: smallsetminus,
    smashp: smashp,
    smeparsl: smeparsl,
    smid: smid,
    smile: smile,
    smt: smt,
    smte: smte,
    smtes: smtes,
    SOFTcy: SOFTcy,
    softcy: softcy,
    sol: sol,
    solb: solb,
    solbar: solbar,
    Sopf: Sopf,
    sopf: sopf,
    spades: spades,
    spadesuit: spadesuit,
    spar: spar,
    sqcap: sqcap,
    sqcaps: sqcaps,
    sqcup: sqcup,
    sqcups: sqcups,
    Sqrt: Sqrt,
    sqsub: sqsub,
    sqsube: sqsube,
    sqsubset: sqsubset,
    sqsubseteq: sqsubseteq,
    sqsup: sqsup,
    sqsupe: sqsupe,
    sqsupset: sqsupset,
    sqsupseteq: sqsupseteq,
    squ: squ,
    Square: Square,
    square: square,
    SquareIntersection: SquareIntersection,
    SquareSubset: SquareSubset,
    SquareSubsetEqual: SquareSubsetEqual,
    SquareSuperset: SquareSuperset,
    SquareSupersetEqual: SquareSupersetEqual,
    SquareUnion: SquareUnion,
    squarf: squarf,
    squf: squf,
    srarr: srarr,
    Sscr: Sscr,
    sscr: sscr,
    ssetmn: ssetmn,
    ssmile: ssmile,
    sstarf: sstarf,
    Star: Star,
    star: star,
    starf: starf,
    straightepsilon: straightepsilon,
    straightphi: straightphi,
    strns: strns,
    Sub: Sub,
    sub: sub,
    subdot: subdot,
    subE: subE,
    sube: sube,
    subedot: subedot,
    submult: submult,
    subnE: subnE,
    subne: subne,
    subplus: subplus,
    subrarr: subrarr,
    Subset: Subset,
    subset: subset,
    subseteq: subseteq,
    subseteqq: subseteqq,
    SubsetEqual: SubsetEqual,
    subsetneq: subsetneq,
    subsetneqq: subsetneqq,
    subsim: subsim,
    subsub: subsub,
    subsup: subsup,
    succ: succ,
    succapprox: succapprox,
    succcurlyeq: succcurlyeq,
    Succeeds: Succeeds,
    SucceedsEqual: SucceedsEqual,
    SucceedsSlantEqual: SucceedsSlantEqual,
    SucceedsTilde: SucceedsTilde,
    succeq: succeq,
    succnapprox: succnapprox,
    succneqq: succneqq,
    succnsim: succnsim,
    succsim: succsim,
    SuchThat: SuchThat,
    Sum: Sum,
    sum: sum,
    sung: sung,
    Sup: Sup,
    sup: sup,
    sup1: sup1,
    sup2: sup2,
    sup3: sup3,
    supdot: supdot,
    supdsub: supdsub,
    supE: supE,
    supe: supe,
    supedot: supedot,
    Superset: Superset,
    SupersetEqual: SupersetEqual,
    suphsol: suphsol,
    suphsub: suphsub,
    suplarr: suplarr,
    supmult: supmult,
    supnE: supnE,
    supne: supne,
    supplus: supplus,
    Supset: Supset,
    supset: supset,
    supseteq: supseteq,
    supseteqq: supseteqq,
    supsetneq: supsetneq,
    supsetneqq: supsetneqq,
    supsim: supsim,
    supsub: supsub,
    supsup: supsup,
    swarhk: swarhk,
    swArr: swArr,
    swarr: swarr,
    swarrow: swarrow,
    swnwar: swnwar,
    szlig: szlig,
    Tab: Tab,
    target: target,
    Tau: Tau,
    tau: tau,
    tbrk: tbrk,
    Tcaron: Tcaron,
    tcaron: tcaron,
    Tcedil: Tcedil,
    tcedil: tcedil,
    Tcy: Tcy,
    tcy: tcy,
    tdot: tdot,
    telrec: telrec,
    Tfr: Tfr,
    tfr: tfr,
    there4: there4,
    Therefore: Therefore,
    therefore: therefore,
    Theta: Theta,
    theta: theta,
    thetasym: thetasym,
    thetav: thetav,
    thickapprox: thickapprox,
    thicksim: thicksim,
    ThickSpace: ThickSpace,
    thinsp: thinsp,
    ThinSpace: ThinSpace,
    thkap: thkap,
    thksim: thksim,
    THORN: THORN,
    thorn: thorn,
    Tilde: Tilde,
    tilde: tilde,
    TildeEqual: TildeEqual,
    TildeFullEqual: TildeFullEqual,
    TildeTilde: TildeTilde,
    times: times,
    timesb: timesb,
    timesbar: timesbar,
    timesd: timesd,
    tint: tint,
    toea: toea,
    top: top,
    topbot: topbot,
    topcir: topcir,
    Topf: Topf,
    topf: topf,
    topfork: topfork,
    tosa: tosa,
    tprime: tprime,
    TRADE: TRADE,
    trade: trade,
    triangle: triangle,
    triangledown: triangledown,
    triangleleft: triangleleft,
    trianglelefteq: trianglelefteq,
    triangleq: triangleq,
    triangleright: triangleright,
    trianglerighteq: trianglerighteq,
    tridot: tridot,
    trie: trie,
    triminus: triminus,
    TripleDot: TripleDot,
    triplus: triplus,
    trisb: trisb,
    tritime: tritime,
    trpezium: trpezium,
    Tscr: Tscr,
    tscr: tscr,
    TScy: TScy,
    tscy: tscy,
    TSHcy: TSHcy,
    tshcy: tshcy,
    Tstrok: Tstrok,
    tstrok: tstrok,
    twixt: twixt,
    twoheadleftarrow: twoheadleftarrow,
    twoheadrightarrow: twoheadrightarrow,
    Uacute: Uacute,
    uacute: uacute,
    Uarr: Uarr,
    uArr: uArr,
    uarr: uarr,
    Uarrocir: Uarrocir,
    Ubrcy: Ubrcy,
    ubrcy: ubrcy,
    Ubreve: Ubreve,
    ubreve: ubreve,
    Ucirc: Ucirc,
    ucirc: ucirc,
    Ucy: Ucy,
    ucy: ucy,
    udarr: udarr,
    Udblac: Udblac,
    udblac: udblac,
    udhar: udhar,
    ufisht: ufisht,
    Ufr: Ufr,
    ufr: ufr,
    Ugrave: Ugrave,
    ugrave: ugrave,
    uHar: uHar,
    uharl: uharl,
    uharr: uharr,
    uhblk: uhblk,
    ulcorn: ulcorn,
    ulcorner: ulcorner,
    ulcrop: ulcrop,
    ultri: ultri,
    Umacr: Umacr,
    umacr: umacr,
    uml: uml,
    UnderBar: UnderBar,
    UnderBrace: UnderBrace,
    UnderBracket: UnderBracket,
    UnderParenthesis: UnderParenthesis,
    Union: Union,
    UnionPlus: UnionPlus,
    Uogon: Uogon,
    uogon: uogon,
    Uopf: Uopf,
    uopf: uopf,
    UpArrow: UpArrow,
    Uparrow: Uparrow,
    uparrow: uparrow,
    UpArrowBar: UpArrowBar,
    UpArrowDownArrow: UpArrowDownArrow,
    UpDownArrow: UpDownArrow,
    Updownarrow: Updownarrow,
    updownarrow: updownarrow,
    UpEquilibrium: UpEquilibrium,
    upharpoonleft: upharpoonleft,
    upharpoonright: upharpoonright,
    uplus: uplus,
    UpperLeftArrow: UpperLeftArrow,
    UpperRightArrow: UpperRightArrow,
    Upsi: Upsi,
    upsi: upsi,
    upsih: upsih,
    Upsilon: Upsilon,
    upsilon: upsilon,
    UpTee: UpTee,
    UpTeeArrow: UpTeeArrow,
    upuparrows: upuparrows,
    urcorn: urcorn,
    urcorner: urcorner,
    urcrop: urcrop,
    Uring: Uring,
    uring: uring,
    urtri: urtri,
    Uscr: Uscr,
    uscr: uscr,
    utdot: utdot,
    Utilde: Utilde,
    utilde: utilde,
    utri: utri,
    utrif: utrif,
    uuarr: uuarr,
    Uuml: Uuml,
    uuml: uuml,
    uwangle: uwangle,
    vangrt: vangrt,
    varepsilon: varepsilon,
    varkappa: varkappa,
    varnothing: varnothing,
    varphi: varphi,
    varpi: varpi,
    varpropto: varpropto,
    vArr: vArr,
    varr: varr,
    varrho: varrho,
    varsigma: varsigma,
    varsubsetneq: varsubsetneq,
    varsubsetneqq: varsubsetneqq,
    varsupsetneq: varsupsetneq,
    varsupsetneqq: varsupsetneqq,
    vartheta: vartheta,
    vartriangleleft: vartriangleleft,
    vartriangleright: vartriangleright,
    Vbar: Vbar,
    vBar: vBar,
    vBarv: vBarv,
    Vcy: Vcy,
    vcy: vcy,
    VDash: VDash,
    Vdash: Vdash,
    vDash: vDash,
    vdash: vdash,
    Vdashl: Vdashl,
    Vee: Vee,
    vee: vee,
    veebar: veebar,
    veeeq: veeeq,
    vellip: vellip,
    Verbar: Verbar,
    verbar: verbar,
    Vert: Vert,
    vert: vert,
    VerticalBar: VerticalBar,
    VerticalLine: VerticalLine,
    VerticalSeparator: VerticalSeparator,
    VerticalTilde: VerticalTilde,
    VeryThinSpace: VeryThinSpace,
    Vfr: Vfr,
    vfr: vfr,
    vltri: vltri,
    vnsub: vnsub,
    vnsup: vnsup,
    Vopf: Vopf,
    vopf: vopf,
    vprop: vprop,
    vrtri: vrtri,
    Vscr: Vscr,
    vscr: vscr,
    vsubnE: vsubnE,
    vsubne: vsubne,
    vsupnE: vsupnE,
    vsupne: vsupne,
    Vvdash: Vvdash,
    vzigzag: vzigzag,
    Wcirc: Wcirc,
    wcirc: wcirc,
    wedbar: wedbar,
    Wedge: Wedge,
    wedge: wedge,
    wedgeq: wedgeq,
    weierp: weierp,
    Wfr: Wfr,
    wfr: wfr,
    Wopf: Wopf,
    wopf: wopf,
    wp: wp,
    wr: wr,
    wreath: wreath,
    Wscr: Wscr,
    wscr: wscr,
    xcap: xcap,
    xcirc: xcirc,
    xcup: xcup,
    xdtri: xdtri,
    Xfr: Xfr,
    xfr: xfr,
    xhArr: xhArr,
    xharr: xharr,
    Xi: Xi,
    xi: xi,
    xlArr: xlArr,
    xlarr: xlarr,
    xmap: xmap,
    xnis: xnis,
    xodot: xodot,
    Xopf: Xopf,
    xopf: xopf,
    xoplus: xoplus,
    xotime: xotime,
    xrArr: xrArr,
    xrarr: xrarr,
    Xscr: Xscr,
    xscr: xscr,
    xsqcup: xsqcup,
    xuplus: xuplus,
    xutri: xutri,
    xvee: xvee,
    xwedge: xwedge,
    Yacute: Yacute,
    yacute: yacute,
    YAcy: YAcy,
    yacy: yacy,
    Ycirc: Ycirc,
    ycirc: ycirc,
    Ycy: Ycy,
    ycy: ycy,
    yen: yen,
    Yfr: Yfr,
    yfr: yfr,
    YIcy: YIcy,
    yicy: yicy,
    Yopf: Yopf,
    yopf: yopf,
    Yscr: Yscr,
    yscr: yscr,
    YUcy: YUcy,
    yucy: yucy,
    Yuml: Yuml,
    yuml: yuml,
    Zacute: Zacute,
    zacute: zacute,
    Zcaron: Zcaron,
    zcaron: zcaron,
    Zcy: Zcy,
    zcy: zcy,
    Zdot: Zdot,
    zdot: zdot,
    zeetrf: zeetrf,
    ZeroWidthSpace: ZeroWidthSpace,
    Zeta: Zeta,
    zeta: zeta,
    Zfr: Zfr,
    zfr: zfr,
    ZHcy: ZHcy,
    zhcy: zhcy,
    zigrarr: zigrarr,
    Zopf: Zopf,
    zopf: zopf,
    Zscr: Zscr,
    zscr: zscr,
    zwj: zwj,
    zwnj: zwnj
  };
  var ound = "pound";
  var pond = "pound";
  var poubd = "pound";
  var poud = "pound";
  var poumd = "pound";
  var poun = "pound";
  var pund = "pound";
  var zvbj = "zwnj";
  var zvhj = "zwnj";
  var zvjb = "zwnj";
  var zvjh = "zwnj";
  var zvjm = "zwnj";
  var zvjn = "zwnj";
  var zvmj = "zwnj";
  var zvng = "zwnj";
  var zvnh = "zwnj";
  var zvnj = "zwnj";
  var zvnk = "zwnj";
  var zvnm = "zwnj";
  var zwbj = "zwnj";
  var zwhj = "zwnj";
  var zwjb = "zwnj";
  var zwjh = "zwnj";
  var zwjm = "zwnj";
  var zwjn = "zwnj";
  var zwmj = "zwnj";
  var zwng = "zwnj";
  var zwnh = "zwnj";
  var zwnk = "zwnj";
  var zwnm = "zwnj";
  var brokenNamedEntities = {
    ound: ound,
    pond: pond,
    poubd: poubd,
    poud: poud,
    poumd: poumd,
    poun: poun,
    pund: pund,
    zvbj: zvbj,
    zvhj: zvhj,
    zvjb: zvjb,
    zvjh: zvjh,
    zvjm: zvjm,
    zvjn: zvjn,
    zvmj: zvmj,
    zvng: zvng,
    zvnh: zvnh,
    zvnj: zvnj,
    zvnk: zvnk,
    zvnm: zvnm,
    zwbj: zwbj,
    zwhj: zwhj,
    zwjb: zwjb,
    zwjh: zwjh,
    zwjm: zwjm,
    zwjn: zwjn,
    zwmj: zwmj,
    zwng: zwng,
    zwnh: zwnh,
    zwnk: zwnk,
    zwnm: zwnm
  };
  var A = {
    a: ["Aacute"],
    b: ["Abreve"],
    c: ["Acirc", "Acy"],
    E: ["AElig"],
    f: ["Afr"],
    g: ["Agrave"],
    l: ["Alpha"],
    m: ["Amacr"],
    M: ["AMP"],
    n: ["And"],
    o: ["Aogon", "Aopf"],
    p: ["ApplyFunction"],
    r: ["Aring"],
    s: ["Ascr", "Assign"],
    t: ["Atilde"],
    u: ["Auml"]
  };
  var a = {
    a: ["aacute"],
    b: ["abreve"],
    c: ["ac", "acd", "acE", "acirc", "acute", "acy"],
    e: ["aelig"],
    f: ["af", "afr"],
    g: ["agrave"],
    l: ["alefsym", "aleph", "alpha"],
    m: ["amacr", "amalg", "amp"],
    n: ["and", "andand", "andd", "andslope", "andv", "ang", "ange", "angle", "angmsd", "angmsdaa", "angmsdab", "angmsdac", "angmsdad", "angmsdae", "angmsdaf", "angmsdag", "angmsdah", "angrt", "angrtvb", "angrtvbd", "angsph", "angst", "angzarr"],
    o: ["aogon", "aopf"],
    p: ["ap", "apacir", "apE", "ape", "apid", "apos", "approx", "approxeq"],
    r: ["aring"],
    s: ["ascr", "ast", "asymp", "asympeq"],
    t: ["atilde"],
    u: ["auml"],
    w: ["awconint", "awint"]
  };
  var b = {
    a: ["backcong", "backepsilon", "backprime", "backsim", "backsimeq", "barvee", "barwed", "barwedge"],
    b: ["bbrk", "bbrktbrk"],
    c: ["bcong", "bcy"],
    d: ["bdquo"],
    e: ["becaus", "because", "bemptyv", "bepsi", "bernou", "beta", "beth", "between"],
    f: ["bfr"],
    i: ["bigcap", "bigcirc", "bigcup", "bigodot", "bigoplus", "bigotimes", "bigsqcup", "bigstar", "bigtriangledown", "bigtriangleup", "biguplus", "bigvee", "bigwedge"],
    k: ["bkarow"],
    l: ["blacklozenge", "blacksquare", "blacktriangle", "blacktriangledown", "blacktriangleleft", "blacktriangleright", "blank", "blk12", "blk14", "blk34", "block"],
    n: ["bne", "bnequiv", "bnot"],
    N: ["bNot"],
    o: ["bopf", "bot", "bottom", "bowtie", "boxbox", "boxDL", "boxDl", "boxdL", "boxdl", "boxDR", "boxDr", "boxdR", "boxdr", "boxH", "boxh", "boxHD", "boxHd", "boxhD", "boxhd", "boxHU", "boxHu", "boxhU", "boxhu", "boxminus", "boxplus", "boxtimes", "boxUL", "boxUl", "boxuL", "boxul", "boxUR", "boxUr", "boxuR", "boxur", "boxV", "boxv", "boxVH", "boxVh", "boxvH", "boxvh", "boxVL", "boxVl", "boxvL", "boxvl", "boxVR", "boxVr", "boxvR", "boxvr"],
    p: ["bprime"],
    r: ["breve", "brvbar"],
    s: ["bscr", "bsemi", "bsim", "bsime", "bsol", "bsolb", "bsolhsub"],
    u: ["bull", "bullet", "bump", "bumpE", "bumpe", "bumpeq"]
  };
  var B = {
    a: ["Backslash", "Barv", "Barwed"],
    c: ["Bcy"],
    e: ["Because", "Bernoullis", "Beta"],
    f: ["Bfr"],
    o: ["Bopf"],
    r: ["Breve"],
    s: ["Bscr"],
    u: ["Bumpeq"]
  };
  var C = {
    a: ["Cacute", "Cap", "CapitalDifferentialD", "Cayleys"],
    c: ["Ccaron", "Ccedil", "Ccirc", "Cconint"],
    d: ["Cdot"],
    e: ["Cedilla", "CenterDot"],
    f: ["Cfr"],
    H: ["CHcy"],
    h: ["Chi"],
    i: ["CircleDot", "CircleMinus", "CirclePlus", "CircleTimes"],
    l: ["ClockwiseContourIntegral", "CloseCurlyDoubleQuote", "CloseCurlyQuote"],
    o: ["Colon", "Colone", "Congruent", "Conint", "ContourIntegral", "Copf", "Coproduct", "CounterClockwiseContourIntegral"],
    O: ["COPY"],
    r: ["Cross"],
    s: ["Cscr"],
    u: ["Cup", "CupCap"]
  };
  var c = {
    a: ["cacute", "cap", "capand", "capbrcup", "capcap", "capcup", "capdot", "caps", "caret", "caron"],
    c: ["ccaps", "ccaron", "ccedil", "ccirc", "ccups", "ccupssm"],
    d: ["cdot"],
    e: ["cedil", "cemptyv", "cent", "centerdot"],
    f: ["cfr"],
    h: ["chcy", "check", "checkmark", "chi"],
    i: ["cir", "circ", "circeq", "circlearrowleft", "circlearrowright", "circledast", "circledcirc", "circleddash", "circledR", "circledS", "cirE", "cire", "cirfnint", "cirmid", "cirscir"],
    l: ["clubs", "clubsuit"],
    o: ["colon", "colone", "coloneq", "comma", "commat", "comp", "compfn", "complement", "complexes", "cong", "congdot", "conint", "copf", "coprod", "copy", "copysr"],
    r: ["crarr", "cross"],
    s: ["cscr", "csub", "csube", "csup", "csupe"],
    t: ["ctdot"],
    u: ["cudarrl", "cudarrr", "cuepr", "cuesc", "cularr", "cularrp", "cup", "cupbrcap", "cupcap", "cupcup", "cupdot", "cupor", "cups", "curarr", "curarrm", "curlyeqprec", "curlyeqsucc", "curlyvee", "curlywedge", "curren", "curvearrowleft", "curvearrowright", "cuvee", "cuwed"],
    w: ["cwconint", "cwint"],
    y: ["cylcty"]
  };
  var D = {
    a: ["Dagger", "Darr", "Dashv"],
    c: ["Dcaron", "Dcy"],
    D: ["DD", "DDotrahd"],
    e: ["Del", "Delta"],
    f: ["Dfr"],
    i: ["DiacriticalAcute", "DiacriticalDot", "DiacriticalDoubleAcute", "DiacriticalGrave", "DiacriticalTilde", "Diamond", "DifferentialD"],
    J: ["DJcy"],
    o: ["Dopf", "Dot", "DotDot", "DotEqual", "DoubleContourIntegral", "DoubleDot", "DoubleDownArrow", "DoubleLeftArrow", "DoubleLeftRightArrow", "DoubleLeftTee", "DoubleLongLeftArrow", "DoubleLongLeftRightArrow", "DoubleLongRightArrow", "DoubleRightArrow", "DoubleRightTee", "DoubleUpArrow", "DoubleUpDownArrow", "DoubleVerticalBar", "DownArrow", "Downarrow", "DownArrowBar", "DownArrowUpArrow", "DownBreve", "DownLeftRightVector", "DownLeftTeeVector", "DownLeftVector", "DownLeftVectorBar", "DownRightTeeVector", "DownRightVector", "DownRightVectorBar", "DownTee", "DownTeeArrow"],
    s: ["Dscr", "Dstrok"],
    S: ["DScy"],
    Z: ["DZcy"]
  };
  var d = {
    a: ["dagger", "daleth", "darr", "dash", "dashv"],
    A: ["dArr"],
    b: ["dbkarow", "dblac"],
    c: ["dcaron", "dcy"],
    d: ["dd", "ddagger", "ddarr", "ddotseq"],
    e: ["deg", "delta", "demptyv"],
    f: ["dfisht", "dfr"],
    H: ["dHar"],
    h: ["dharl", "dharr"],
    i: ["diam", "diamond", "diamondsuit", "diams", "die", "digamma", "disin", "div", "divide", "divideontimes", "divonx"],
    j: ["djcy"],
    l: ["dlcorn", "dlcrop"],
    o: ["dollar", "dopf", "dot", "doteq", "doteqdot", "dotminus", "dotplus", "dotsquare", "doublebarwedge", "downarrow", "downdownarrows", "downharpoonleft", "downharpoonright"],
    r: ["drbkarow", "drcorn", "drcrop"],
    s: ["dscr", "dscy", "dsol", "dstrok"],
    t: ["dtdot", "dtri", "dtrif"],
    u: ["duarr", "duhar"],
    w: ["dwangle"],
    z: ["dzcy", "dzigrarr"]
  };
  var E = {
    a: ["Eacute"],
    c: ["Ecaron", "Ecirc", "Ecy"],
    d: ["Edot"],
    f: ["Efr"],
    g: ["Egrave"],
    l: ["Element"],
    m: ["Emacr", "EmptySmallSquare", "EmptyVerySmallSquare"],
    N: ["ENG"],
    o: ["Eogon", "Eopf"],
    p: ["Epsilon"],
    q: ["Equal", "EqualTilde", "Equilibrium"],
    s: ["Escr", "Esim"],
    t: ["Eta"],
    T: ["ETH"],
    u: ["Euml"],
    x: ["Exists", "ExponentialE"]
  };
  var e = {
    a: ["eacute", "easter"],
    c: ["ecaron", "ecir", "ecirc", "ecolon", "ecy"],
    D: ["eDDot", "eDot"],
    d: ["edot"],
    e: ["ee"],
    f: ["efDot", "efr"],
    g: ["eg", "egrave", "egs", "egsdot"],
    l: ["el", "elinters", "ell", "els", "elsdot"],
    m: ["emacr", "empty", "emptyset", "emptyv", "emsp", "emsp13", "emsp14"],
    n: ["eng", "ensp"],
    o: ["eogon", "eopf"],
    p: ["epar", "eparsl", "eplus", "epsi", "epsilon", "epsiv"],
    q: ["eqcirc", "eqcolon", "eqsim", "eqslantgtr", "eqslantless", "equals", "equest", "equiv", "equivDD", "eqvparsl"],
    r: ["erarr", "erDot"],
    s: ["escr", "esdot", "esim"],
    t: ["eta", "eth"],
    u: ["euml", "euro"],
    x: ["excl", "exist", "expectation", "exponentiale"]
  };
  var f = {
    a: ["fallingdotseq"],
    c: ["fcy"],
    e: ["female"],
    f: ["ffilig", "fflig", "ffllig", "ffr"],
    i: ["filig"],
    j: ["fjlig"],
    l: ["flat", "fllig", "fltns"],
    n: ["fnof"],
    o: ["fopf", "forall", "fork", "forkv"],
    p: ["fpartint"],
    r: ["frac12", "frac13", "frac14", "frac15", "frac16", "frac18", "frac23", "frac25", "frac34", "frac35", "frac38", "frac45", "frac56", "frac58", "frac78", "frasl", "frown"],
    s: ["fscr"]
  };
  var F = {
    c: ["Fcy"],
    f: ["Ffr"],
    i: ["FilledSmallSquare", "FilledVerySmallSquare"],
    o: ["Fopf", "ForAll", "Fouriertrf"],
    s: ["Fscr"]
  };
  var g = {
    a: ["gacute", "gamma", "gammad", "gap"],
    b: ["gbreve"],
    c: ["gcirc", "gcy"],
    d: ["gdot"],
    E: ["gE", "gEl"],
    e: ["ge", "gel", "geq", "geqq", "geqslant", "ges", "gescc", "gesdot", "gesdoto", "gesdotol", "gesl", "gesles"],
    f: ["gfr"],
    g: ["gg", "ggg"],
    i: ["gimel"],
    j: ["gjcy"],
    l: ["gl", "gla", "glE", "glj"],
    n: ["gnap", "gnapprox", "gnE", "gne", "gneq", "gneqq", "gnsim"],
    o: ["gopf"],
    r: ["grave"],
    s: ["gscr", "gsim", "gsime", "gsiml"],
    t: ["gt", "gtcc", "gtcir", "gtdot", "gtlPar", "gtquest", "gtrapprox", "gtrarr", "gtrdot", "gtreqless", "gtreqqless", "gtrless", "gtrsim"],
    v: ["gvertneqq", "gvnE"]
  };
  var G = {
    a: ["Gamma", "Gammad"],
    b: ["Gbreve"],
    c: ["Gcedil", "Gcirc", "Gcy"],
    d: ["Gdot"],
    f: ["Gfr"],
    g: ["Gg"],
    J: ["GJcy"],
    o: ["Gopf"],
    r: ["GreaterEqual", "GreaterEqualLess", "GreaterFullEqual", "GreaterGreater", "GreaterLess", "GreaterSlantEqual", "GreaterTilde"],
    s: ["Gscr"],
    T: ["GT"],
    t: ["Gt"]
  };
  var H = {
    a: ["Hacek", "Hat"],
    A: ["HARDcy"],
    c: ["Hcirc"],
    f: ["Hfr"],
    i: ["HilbertSpace"],
    o: ["Hopf", "HorizontalLine"],
    s: ["Hscr", "Hstrok"],
    u: ["HumpDownHump", "HumpEqual"]
  };
  var h = {
    a: ["hairsp", "half", "hamilt", "hardcy", "harr", "harrcir", "harrw"],
    A: ["hArr"],
    b: ["hbar"],
    c: ["hcirc"],
    e: ["hearts", "heartsuit", "hellip", "hercon"],
    f: ["hfr"],
    k: ["hksearow", "hkswarow"],
    o: ["hoarr", "homtht", "hookleftarrow", "hookrightarrow", "hopf", "horbar"],
    s: ["hscr", "hslash", "hstrok"],
    y: ["hybull", "hyphen"]
  };
  var I = {
    a: ["Iacute"],
    c: ["Icirc", "Icy"],
    d: ["Idot"],
    E: ["IEcy"],
    f: ["Ifr"],
    g: ["Igrave"],
    J: ["IJlig"],
    m: ["Im", "Imacr", "ImaginaryI", "Implies"],
    n: ["Int", "Integral", "Intersection", "InvisibleComma", "InvisibleTimes"],
    O: ["IOcy"],
    o: ["Iogon", "Iopf", "Iota"],
    s: ["Iscr"],
    t: ["Itilde"],
    u: ["Iukcy", "Iuml"]
  };
  var i = {
    a: ["iacute"],
    c: ["ic", "icirc", "icy"],
    e: ["iecy", "iexcl"],
    f: ["iff", "ifr"],
    g: ["igrave"],
    i: ["ii", "iiiint", "iiint", "iinfin", "iiota"],
    j: ["ijlig"],
    m: ["imacr", "image", "imagline", "imagpart", "imath", "imof", "imped"],
    n: ["in", "incare", "infin", "infintie", "inodot", "int", "intcal", "integers", "intercal", "intlarhk", "intprod"],
    o: ["iocy", "iogon", "iopf", "iota"],
    p: ["iprod"],
    q: ["iquest"],
    s: ["iscr", "isin", "isindot", "isinE", "isins", "isinsv", "isinv"],
    t: ["it", "itilde"],
    u: ["iukcy", "iuml"]
  };
  var J = {
    c: ["Jcirc", "Jcy"],
    f: ["Jfr"],
    o: ["Jopf"],
    s: ["Jscr", "Jsercy"],
    u: ["Jukcy"]
  };
  var j = {
    c: ["jcirc", "jcy"],
    f: ["jfr"],
    m: ["jmath"],
    o: ["jopf"],
    s: ["jscr", "jsercy"],
    u: ["jukcy"]
  };
  var K = {
    a: ["Kappa"],
    c: ["Kcedil", "Kcy"],
    f: ["Kfr"],
    H: ["KHcy"],
    J: ["KJcy"],
    o: ["Kopf"],
    s: ["Kscr"]
  };
  var k = {
    a: ["kappa", "kappav"],
    c: ["kcedil", "kcy"],
    f: ["kfr"],
    g: ["kgreen"],
    h: ["khcy"],
    j: ["kjcy"],
    o: ["kopf"],
    s: ["kscr"]
  };
  var l = {
    A: ["lAarr", "lArr", "lAtail"],
    a: ["lacute", "laemptyv", "lagran", "lambda", "lang", "langd", "langle", "lap", "laquo", "larr", "larrb", "larrbfs", "larrfs", "larrhk", "larrlp", "larrpl", "larrsim", "larrtl", "lat", "latail", "late", "lates"],
    B: ["lBarr"],
    b: ["lbarr", "lbbrk", "lbrace", "lbrack", "lbrke", "lbrksld", "lbrkslu"],
    c: ["lcaron", "lcedil", "lceil", "lcub", "lcy"],
    d: ["ldca", "ldquo", "ldquor", "ldrdhar", "ldrushar", "ldsh"],
    E: ["lE", "lEg"],
    e: ["le", "leftarrow", "leftarrowtail", "leftharpoondown", "leftharpoonup", "leftleftarrows", "leftrightarrow", "leftrightarrows", "leftrightharpoons", "leftrightsquigarrow", "leftthreetimes", "leg", "leq", "leqq", "leqslant", "les", "lescc", "lesdot", "lesdoto", "lesdotor", "lesg", "lesges", "lessapprox", "lessdot", "lesseqgtr", "lesseqqgtr", "lessgtr", "lesssim"],
    f: ["lfisht", "lfloor", "lfr"],
    g: ["lg", "lgE"],
    H: ["lHar"],
    h: ["lhard", "lharu", "lharul", "lhblk"],
    j: ["ljcy"],
    l: ["ll", "llarr", "llcorner", "llhard", "lltri"],
    m: ["lmidot", "lmoust", "lmoustache"],
    n: ["lnap", "lnapprox", "lnE", "lne", "lneq", "lneqq", "lnsim"],
    o: ["loang", "loarr", "lobrk", "longleftarrow", "longleftrightarrow", "longmapsto", "longrightarrow", "looparrowleft", "looparrowright", "lopar", "lopf", "loplus", "lotimes", "lowast", "lowbar", "loz", "lozenge", "lozf"],
    p: ["lpar", "lparlt"],
    r: ["lrarr", "lrcorner", "lrhar", "lrhard", "lrm", "lrtri"],
    s: ["lsaquo", "lscr", "lsh", "lsim", "lsime", "lsimg", "lsqb", "lsquo", "lsquor", "lstrok"],
    t: ["lt", "ltcc", "ltcir", "ltdot", "lthree", "ltimes", "ltlarr", "ltquest", "ltri", "ltrie", "ltrif", "ltrPar"],
    u: ["lurdshar", "luruhar"],
    v: ["lvertneqq", "lvnE"]
  };
  var L = {
    a: ["Lacute", "Lambda", "Lang", "Laplacetrf", "Larr"],
    c: ["Lcaron", "Lcedil", "Lcy"],
    e: ["LeftAngleBracket", "LeftArrow", "Leftarrow", "LeftArrowBar", "LeftArrowRightArrow", "LeftCeiling", "LeftDoubleBracket", "LeftDownTeeVector", "LeftDownVector", "LeftDownVectorBar", "LeftFloor", "LeftRightArrow", "Leftrightarrow", "LeftRightVector", "LeftTee", "LeftTeeArrow", "LeftTeeVector", "LeftTriangle", "LeftTriangleBar", "LeftTriangleEqual", "LeftUpDownVector", "LeftUpTeeVector", "LeftUpVector", "LeftUpVectorBar", "LeftVector", "LeftVectorBar", "LessEqualGreater", "LessFullEqual", "LessGreater", "LessLess", "LessSlantEqual", "LessTilde"],
    f: ["Lfr"],
    J: ["LJcy"],
    l: ["Ll", "Lleftarrow"],
    m: ["Lmidot"],
    o: ["LongLeftArrow", "Longleftarrow", "LongLeftRightArrow", "Longleftrightarrow", "LongRightArrow", "Longrightarrow", "Lopf", "LowerLeftArrow", "LowerRightArrow"],
    s: ["Lscr", "Lsh", "Lstrok"],
    T: ["LT"],
    t: ["Lt"]
  };
  var m = {
    a: ["macr", "male", "malt", "maltese", "map", "mapsto", "mapstodown", "mapstoleft", "mapstoup", "marker"],
    c: ["mcomma", "mcy"],
    d: ["mdash"],
    D: ["mDDot"],
    e: ["measuredangle"],
    f: ["mfr"],
    h: ["mho"],
    i: ["micro", "mid", "midast", "midcir", "middot", "minus", "minusb", "minusd", "minusdu"],
    l: ["mlcp", "mldr"],
    n: ["mnplus"],
    o: ["models", "mopf"],
    p: ["mp"],
    s: ["mscr", "mstpos"],
    u: ["mu", "multimap", "mumap"]
  };
  var M = {
    a: ["Map"],
    c: ["Mcy"],
    e: ["MediumSpace", "Mellintrf"],
    f: ["Mfr"],
    i: ["MinusPlus"],
    o: ["Mopf"],
    s: ["Mscr"],
    u: ["Mu"]
  };
  var n = {
    a: ["nabla", "nacute", "nang", "nap", "napE", "napid", "napos", "napprox", "natur", "natural", "naturals"],
    b: ["nbsp", "nbump", "nbumpe"],
    c: ["ncap", "ncaron", "ncedil", "ncong", "ncongdot", "ncup", "ncy"],
    d: ["ndash"],
    e: ["ne", "nearhk", "neArr", "nearr", "nearrow", "nedot", "nequiv", "nesear", "nesim", "nexist", "nexists"],
    f: ["nfr"],
    g: ["ngE", "nge", "ngeq", "ngeqq", "ngeqslant", "nges", "ngsim", "ngt", "ngtr"],
    G: ["nGg", "nGt", "nGtv"],
    h: ["nhArr", "nharr", "nhpar"],
    i: ["ni", "nis", "nisd", "niv"],
    j: ["njcy"],
    l: ["nlArr", "nlarr", "nldr", "nlE", "nle", "nleftarrow", "nleftrightarrow", "nleq", "nleqq", "nleqslant", "nles", "nless", "nlsim", "nlt", "nltri", "nltrie"],
    L: ["nLeftarrow", "nLeftrightarrow", "nLl", "nLt", "nLtv"],
    m: ["nmid"],
    o: ["nopf", "not", "notin", "notindot", "notinE", "notinva", "notinvb", "notinvc", "notni", "notniva", "notnivb", "notnivc"],
    p: ["npar", "nparallel", "nparsl", "npart", "npolint", "npr", "nprcue", "npre", "nprec", "npreceq"],
    r: ["nrArr", "nrarr", "nrarrc", "nrarrw", "nrightarrow", "nrtri", "nrtrie"],
    R: ["nRightarrow"],
    s: ["nsc", "nsccue", "nsce", "nscr", "nshortmid", "nshortparallel", "nsim", "nsime", "nsimeq", "nsmid", "nspar", "nsqsube", "nsqsupe", "nsub", "nsubE", "nsube", "nsubset", "nsubseteq", "nsubseteqq", "nsucc", "nsucceq", "nsup", "nsupE", "nsupe", "nsupset", "nsupseteq", "nsupseteqq"],
    t: ["ntgl", "ntilde", "ntlg", "ntriangleleft", "ntrianglelefteq", "ntriangleright", "ntrianglerighteq"],
    u: ["nu", "num", "numero", "numsp"],
    v: ["nvap", "nvDash", "nvdash", "nvge", "nvgt", "nvHarr", "nvinfin", "nvlArr", "nvle", "nvlt", "nvltrie", "nvrArr", "nvrtrie", "nvsim"],
    V: ["nVDash", "nVdash"],
    w: ["nwarhk", "nwArr", "nwarr", "nwarrow", "nwnear"]
  };
  var N = {
    a: ["Nacute"],
    c: ["Ncaron", "Ncedil", "Ncy"],
    e: ["NegativeMediumSpace", "NegativeThickSpace", "NegativeThinSpace", "NegativeVeryThinSpace", "NestedGreaterGreater", "NestedLessLess", "NewLine"],
    f: ["Nfr"],
    J: ["NJcy"],
    o: ["NoBreak", "NonBreakingSpace", "Nopf", "Not", "NotCongruent", "NotCupCap", "NotDoubleVerticalBar", "NotElement", "NotEqual", "NotEqualTilde", "NotExists", "NotGreater", "NotGreaterEqual", "NotGreaterFullEqual", "NotGreaterGreater", "NotGreaterLess", "NotGreaterSlantEqual", "NotGreaterTilde", "NotHumpDownHump", "NotHumpEqual", "NotLeftTriangle", "NotLeftTriangleBar", "NotLeftTriangleEqual", "NotLess", "NotLessEqual", "NotLessGreater", "NotLessLess", "NotLessSlantEqual", "NotLessTilde", "NotNestedGreaterGreater", "NotNestedLessLess", "NotPrecedes", "NotPrecedesEqual", "NotPrecedesSlantEqual", "NotReverseElement", "NotRightTriangle", "NotRightTriangleBar", "NotRightTriangleEqual", "NotSquareSubset", "NotSquareSubsetEqual", "NotSquareSuperset", "NotSquareSupersetEqual", "NotSubset", "NotSubsetEqual", "NotSucceeds", "NotSucceedsEqual", "NotSucceedsSlantEqual", "NotSucceedsTilde", "NotSuperset", "NotSupersetEqual", "NotTilde", "NotTildeEqual", "NotTildeFullEqual", "NotTildeTilde", "NotVerticalBar"],
    s: ["Nscr"],
    t: ["Ntilde"],
    u: ["Nu"]
  };
  var O = {
    a: ["Oacute"],
    c: ["Ocirc", "Ocy"],
    d: ["Odblac"],
    E: ["OElig"],
    f: ["Ofr"],
    g: ["Ograve"],
    m: ["Omacr", "Omega", "Omicron"],
    o: ["Oopf"],
    p: ["OpenCurlyDoubleQuote", "OpenCurlyQuote"],
    r: ["Or"],
    s: ["Oscr", "Oslash"],
    t: ["Otilde", "Otimes"],
    u: ["Ouml"],
    v: ["OverBar", "OverBrace", "OverBracket", "OverParenthesis"]
  };
  var o = {
    a: ["oacute", "oast"],
    c: ["ocir", "ocirc", "ocy"],
    d: ["odash", "odblac", "odiv", "odot", "odsold"],
    e: ["oelig"],
    f: ["ofcir", "ofr"],
    g: ["ogon", "ograve", "ogt"],
    h: ["ohbar", "ohm"],
    i: ["oint"],
    l: ["olarr", "olcir", "olcross", "oline", "olt"],
    m: ["omacr", "omega", "omicron", "omid", "ominus"],
    o: ["oopf"],
    p: ["opar", "operp", "oplus"],
    r: ["or", "orarr", "ord", "order", "orderof", "ordf", "ordm", "origof", "oror", "orslope", "orv"],
    S: ["oS"],
    s: ["oscr", "oslash", "osol"],
    t: ["otilde", "otimes", "otimesas"],
    u: ["ouml"],
    v: ["ovbar"]
  };
  var p = {
    a: ["par", "para", "parallel", "parsim", "parsl", "part"],
    c: ["pcy"],
    e: ["percnt", "period", "permil", "perp", "pertenk"],
    f: ["pfr"],
    h: ["phi", "phiv", "phmmat", "phone"],
    i: ["pi", "pitchfork", "piv"],
    l: ["planck", "planckh", "plankv", "plus", "plusacir", "plusb", "pluscir", "plusdo", "plusdu", "pluse", "plusmn", "plussim", "plustwo"],
    m: ["pm"],
    o: ["pointint", "popf", "pound"],
    r: ["pr", "prap", "prcue", "prE", "pre", "prec", "precapprox", "preccurlyeq", "preceq", "precnapprox", "precneqq", "precnsim", "precsim", "prime", "primes", "prnap", "prnE", "prnsim", "prod", "profalar", "profline", "profsurf", "prop", "propto", "prsim", "prurel"],
    s: ["pscr", "psi"],
    u: ["puncsp"]
  };
  var P = {
    a: ["PartialD"],
    c: ["Pcy"],
    f: ["Pfr"],
    h: ["Phi"],
    i: ["Pi"],
    l: ["PlusMinus"],
    o: ["Poincareplane", "Popf"],
    r: ["Pr", "Precedes", "PrecedesEqual", "PrecedesSlantEqual", "PrecedesTilde", "Prime", "Product", "Proportion", "Proportional"],
    s: ["Pscr", "Psi"]
  };
  var Q = {
    f: ["Qfr"],
    o: ["Qopf"],
    s: ["Qscr"],
    U: ["QUOT"]
  };
  var q = {
    f: ["qfr"],
    i: ["qint"],
    o: ["qopf"],
    p: ["qprime"],
    s: ["qscr"],
    u: ["quaternions", "quatint", "quest", "questeq", "quot"]
  };
  var r = {
    A: ["rAarr", "rArr", "rAtail"],
    a: ["race", "racute", "radic", "raemptyv", "rang", "rangd", "range", "rangle", "raquo", "rarr", "rarrap", "rarrb", "rarrbfs", "rarrc", "rarrfs", "rarrhk", "rarrlp", "rarrpl", "rarrsim", "rarrtl", "rarrw", "ratail", "ratio", "rationals"],
    B: ["rBarr"],
    b: ["rbarr", "rbbrk", "rbrace", "rbrack", "rbrke", "rbrksld", "rbrkslu"],
    c: ["rcaron", "rcedil", "rceil", "rcub", "rcy"],
    d: ["rdca", "rdldhar", "rdquo", "rdquor", "rdsh"],
    e: ["real", "realine", "realpart", "reals", "rect", "reg"],
    f: ["rfisht", "rfloor", "rfr"],
    H: ["rHar"],
    h: ["rhard", "rharu", "rharul", "rho", "rhov"],
    i: ["rightarrow", "rightarrowtail", "rightharpoondown", "rightharpoonup", "rightleftarrows", "rightleftharpoons", "rightrightarrows", "rightsquigarrow", "rightthreetimes", "ring", "risingdotseq"],
    l: ["rlarr", "rlhar", "rlm"],
    m: ["rmoust", "rmoustache"],
    n: ["rnmid"],
    o: ["roang", "roarr", "robrk", "ropar", "ropf", "roplus", "rotimes"],
    p: ["rpar", "rpargt", "rppolint"],
    r: ["rrarr"],
    s: ["rsaquo", "rscr", "rsh", "rsqb", "rsquo", "rsquor"],
    t: ["rthree", "rtimes", "rtri", "rtrie", "rtrif", "rtriltri"],
    u: ["ruluhar"],
    x: ["rx"]
  };
  var R = {
    a: ["Racute", "Rang", "Rarr", "Rarrtl"],
    B: ["RBarr"],
    c: ["Rcaron", "Rcedil", "Rcy"],
    e: ["Re", "ReverseElement", "ReverseEquilibrium", "ReverseUpEquilibrium"],
    E: ["REG"],
    f: ["Rfr"],
    h: ["Rho"],
    i: ["RightAngleBracket", "RightArrow", "Rightarrow", "RightArrowBar", "RightArrowLeftArrow", "RightCeiling", "RightDoubleBracket", "RightDownTeeVector", "RightDownVector", "RightDownVectorBar", "RightFloor", "RightTee", "RightTeeArrow", "RightTeeVector", "RightTriangle", "RightTriangleBar", "RightTriangleEqual", "RightUpDownVector", "RightUpTeeVector", "RightUpVector", "RightUpVectorBar", "RightVector", "RightVectorBar"],
    o: ["Ropf", "RoundImplies"],
    r: ["Rrightarrow"],
    s: ["Rscr", "Rsh"],
    u: ["RuleDelayed"]
  };
  var S = {
    a: ["Sacute"],
    c: ["Sc", "Scaron", "Scedil", "Scirc", "Scy"],
    f: ["Sfr"],
    H: ["SHCHcy", "SHcy"],
    h: ["ShortDownArrow", "ShortLeftArrow", "ShortRightArrow", "ShortUpArrow"],
    i: ["Sigma"],
    m: ["SmallCircle"],
    O: ["SOFTcy"],
    o: ["Sopf"],
    q: ["Sqrt", "Square", "SquareIntersection", "SquareSubset", "SquareSubsetEqual", "SquareSuperset", "SquareSupersetEqual", "SquareUnion"],
    s: ["Sscr"],
    t: ["Star"],
    u: ["Sub", "Subset", "SubsetEqual", "Succeeds", "SucceedsEqual", "SucceedsSlantEqual", "SucceedsTilde", "SuchThat", "Sum", "Sup", "Superset", "SupersetEqual", "Supset"]
  };
  var s = {
    a: ["sacute"],
    b: ["sbquo"],
    c: ["sc", "scap", "scaron", "sccue", "scE", "sce", "scedil", "scirc", "scnap", "scnE", "scnsim", "scpolint", "scsim", "scy"],
    d: ["sdot", "sdotb", "sdote"],
    e: ["searhk", "seArr", "searr", "searrow", "sect", "semi", "seswar", "setminus", "setmn", "sext"],
    f: ["sfr", "sfrown"],
    h: ["sharp", "shchcy", "shcy", "shortmid", "shortparallel", "shy"],
    i: ["sigma", "sigmaf", "sigmav", "sim", "simdot", "sime", "simeq", "simg", "simgE", "siml", "simlE", "simne", "simplus", "simrarr"],
    l: ["slarr"],
    m: ["smallsetminus", "smashp", "smeparsl", "smid", "smile", "smt", "smte", "smtes"],
    o: ["softcy", "sol", "solb", "solbar", "sopf"],
    p: ["spades", "spadesuit", "spar"],
    q: ["sqcap", "sqcaps", "sqcup", "sqcups", "sqsub", "sqsube", "sqsubset", "sqsubseteq", "sqsup", "sqsupe", "sqsupset", "sqsupseteq", "squ", "square", "squarf", "squf"],
    r: ["srarr"],
    s: ["sscr", "ssetmn", "ssmile", "sstarf"],
    t: ["star", "starf", "straightepsilon", "straightphi", "strns"],
    u: ["sub", "subdot", "subE", "sube", "subedot", "submult", "subnE", "subne", "subplus", "subrarr", "subset", "subseteq", "subseteqq", "subsetneq", "subsetneqq", "subsim", "subsub", "subsup", "succ", "succapprox", "succcurlyeq", "succeq", "succnapprox", "succneqq", "succnsim", "succsim", "sum", "sung", "sup", "sup1", "sup2", "sup3", "supdot", "supdsub", "supE", "supe", "supedot", "suphsol", "suphsub", "suplarr", "supmult", "supnE", "supne", "supplus", "supset", "supseteq", "supseteqq", "supsetneq", "supsetneqq", "supsim", "supsub", "supsup"],
    w: ["swarhk", "swArr", "swarr", "swarrow", "swnwar"],
    z: ["szlig"]
  };
  var T = {
    a: ["Tab", "Tau"],
    c: ["Tcaron", "Tcedil", "Tcy"],
    f: ["Tfr"],
    h: ["Therefore", "Theta", "ThickSpace", "ThinSpace"],
    H: ["THORN"],
    i: ["Tilde", "TildeEqual", "TildeFullEqual", "TildeTilde"],
    o: ["Topf"],
    R: ["TRADE"],
    r: ["TripleDot"],
    s: ["Tscr", "Tstrok"],
    S: ["TScy", "TSHcy"]
  };
  var t = {
    a: ["target", "tau"],
    b: ["tbrk"],
    c: ["tcaron", "tcedil", "tcy"],
    d: ["tdot"],
    e: ["telrec"],
    f: ["tfr"],
    h: ["there4", "therefore", "theta", "thetasym", "thetav", "thickapprox", "thicksim", "thinsp", "thkap", "thksim", "thorn"],
    i: ["tilde", "times", "timesb", "timesbar", "timesd", "tint"],
    o: ["toea", "top", "topbot", "topcir", "topf", "topfork", "tosa"],
    p: ["tprime"],
    r: ["trade", "triangle", "triangledown", "triangleleft", "trianglelefteq", "triangleq", "triangleright", "trianglerighteq", "tridot", "trie", "triminus", "triplus", "trisb", "tritime", "trpezium"],
    s: ["tscr", "tscy", "tshcy", "tstrok"],
    w: ["twixt", "twoheadleftarrow", "twoheadrightarrow"]
  };
  var U = {
    a: ["Uacute", "Uarr", "Uarrocir"],
    b: ["Ubrcy", "Ubreve"],
    c: ["Ucirc", "Ucy"],
    d: ["Udblac"],
    f: ["Ufr"],
    g: ["Ugrave"],
    m: ["Umacr"],
    n: ["UnderBar", "UnderBrace", "UnderBracket", "UnderParenthesis", "Union", "UnionPlus"],
    o: ["Uogon", "Uopf"],
    p: ["UpArrow", "Uparrow", "UpArrowBar", "UpArrowDownArrow", "UpDownArrow", "Updownarrow", "UpEquilibrium", "UpperLeftArrow", "UpperRightArrow", "Upsi", "Upsilon", "UpTee", "UpTeeArrow"],
    r: ["Uring"],
    s: ["Uscr"],
    t: ["Utilde"],
    u: ["Uuml"]
  };
  var u = {
    a: ["uacute", "uarr"],
    A: ["uArr"],
    b: ["ubrcy", "ubreve"],
    c: ["ucirc", "ucy"],
    d: ["udarr", "udblac", "udhar"],
    f: ["ufisht", "ufr"],
    g: ["ugrave"],
    H: ["uHar"],
    h: ["uharl", "uharr", "uhblk"],
    l: ["ulcorn", "ulcorner", "ulcrop", "ultri"],
    m: ["umacr", "uml"],
    o: ["uogon", "uopf"],
    p: ["uparrow", "updownarrow", "upharpoonleft", "upharpoonright", "uplus", "upsi", "upsih", "upsilon", "upuparrows"],
    r: ["urcorn", "urcorner", "urcrop", "uring", "urtri"],
    s: ["uscr"],
    t: ["utdot", "utilde", "utri", "utrif"],
    u: ["uuarr", "uuml"],
    w: ["uwangle"]
  };
  var v = {
    a: ["vangrt", "varepsilon", "varkappa", "varnothing", "varphi", "varpi", "varpropto", "varr", "varrho", "varsigma", "varsubsetneq", "varsubsetneqq", "varsupsetneq", "varsupsetneqq", "vartheta", "vartriangleleft", "vartriangleright"],
    A: ["vArr"],
    B: ["vBar", "vBarv"],
    c: ["vcy"],
    D: ["vDash"],
    d: ["vdash"],
    e: ["vee", "veebar", "veeeq", "vellip", "verbar", "vert"],
    f: ["vfr"],
    l: ["vltri"],
    n: ["vnsub", "vnsup"],
    o: ["vopf"],
    p: ["vprop"],
    r: ["vrtri"],
    s: ["vscr", "vsubnE", "vsubne", "vsupnE", "vsupne"],
    z: ["vzigzag"]
  };
  var V = {
    b: ["Vbar"],
    c: ["Vcy"],
    D: ["VDash"],
    d: ["Vdash", "Vdashl"],
    e: ["Vee", "Verbar", "Vert", "VerticalBar", "VerticalLine", "VerticalSeparator", "VerticalTilde", "VeryThinSpace"],
    f: ["Vfr"],
    o: ["Vopf"],
    s: ["Vscr"],
    v: ["Vvdash"]
  };
  var W = {
    c: ["Wcirc"],
    e: ["Wedge"],
    f: ["Wfr"],
    o: ["Wopf"],
    s: ["Wscr"]
  };
  var w = {
    c: ["wcirc"],
    e: ["wedbar", "wedge", "wedgeq", "weierp"],
    f: ["wfr"],
    o: ["wopf"],
    p: ["wp"],
    r: ["wr", "wreath"],
    s: ["wscr"]
  };
  var x = {
    c: ["xcap", "xcirc", "xcup"],
    d: ["xdtri"],
    f: ["xfr"],
    h: ["xhArr", "xharr"],
    i: ["xi"],
    l: ["xlArr", "xlarr"],
    m: ["xmap"],
    n: ["xnis"],
    o: ["xodot", "xopf", "xoplus", "xotime"],
    r: ["xrArr", "xrarr"],
    s: ["xscr", "xsqcup"],
    u: ["xuplus", "xutri"],
    v: ["xvee"],
    w: ["xwedge"]
  };
  var X = {
    f: ["Xfr"],
    i: ["Xi"],
    o: ["Xopf"],
    s: ["Xscr"]
  };
  var Y = {
    a: ["Yacute"],
    A: ["YAcy"],
    c: ["Ycirc", "Ycy"],
    f: ["Yfr"],
    I: ["YIcy"],
    o: ["Yopf"],
    s: ["Yscr"],
    U: ["YUcy"],
    u: ["Yuml"]
  };
  var y = {
    a: ["yacute", "yacy"],
    c: ["ycirc", "ycy"],
    e: ["yen"],
    f: ["yfr"],
    i: ["yicy"],
    o: ["yopf"],
    s: ["yscr"],
    u: ["yucy", "yuml"]
  };
  var Z = {
    a: ["Zacute"],
    c: ["Zcaron", "Zcy"],
    d: ["Zdot"],
    e: ["ZeroWidthSpace", "Zeta"],
    f: ["Zfr"],
    H: ["ZHcy"],
    o: ["Zopf"],
    s: ["Zscr"]
  };
  var z = {
    a: ["zacute"],
    c: ["zcaron", "zcy"],
    d: ["zdot"],
    e: ["zeetrf", "zeta"],
    f: ["zfr"],
    h: ["zhcy"],
    i: ["zigrarr"],
    o: ["zopf"],
    s: ["zscr"],
    w: ["zwj", "zwnj"]
  };
  var startsWith = {
    A: A,
    a: a,
    b: b,
    B: B,
    C: C,
    c: c,
    D: D,
    d: d,
    E: E,
    e: e,
    f: f,
    F: F,
    g: g,
    G: G,
    H: H,
    h: h,
    I: I,
    i: i,
    J: J,
    j: j,
    K: K,
    k: k,
    l: l,
    L: L,
    m: m,
    M: M,
    n: n,
    N: N,
    O: O,
    o: o,
    p: p,
    P: P,
    Q: Q,
    q: q,
    r: r,
    R: R,
    S: S,
    s: s,
    T: T,
    t: t,
    U: U,
    u: u,
    v: v,
    V: V,
    W: W,
    w: w,
    x: x,
    X: X,
    Y: Y,
    y: y,
    Z: Z,
    z: z
  };
  var e$1 = {
    t: ["Aacute", "aacute", "acute", "Cacute", "cacute", "CloseCurlyDoubleQuote", "CloseCurlyQuote", "DiacriticalAcute", "DiacriticalDoubleAcute", "Eacute", "eacute", "gacute", "Iacute", "iacute", "Lacute", "lacute", "late", "Nacute", "nacute", "Oacute", "oacute", "OpenCurlyDoubleQuote", "OpenCurlyQuote", "Racute", "racute", "Sacute", "sacute", "sdote", "smte", "Uacute", "uacute", "Yacute", "yacute", "Zacute", "zacute"],
    v: ["Abreve", "abreve", "Agrave", "agrave", "Breve", "breve", "DiacriticalGrave", "DownBreve", "Egrave", "egrave", "Gbreve", "gbreve", "grave", "Igrave", "igrave", "Ograve", "ograve", "Ubreve", "ubreve", "Ugrave", "ugrave"],
    p: ["andslope", "ape", "bumpe", "csupe", "nbumpe", "nsqsupe", "nsupe", "orslope", "sqsupe", "supe"],
    g: ["ange", "barwedge", "bigwedge", "blacklozenge", "curlywedge", "doublebarwedge", "ge", "image", "lozenge", "nge", "nvge", "range", "Wedge", "wedge", "xwedge"],
    l: ["angle", "blacktriangle", "dwangle", "exponentiale", "female", "langle", "le", "LeftTriangle", "male", "measuredangle", "nle", "NotLeftTriangle", "NotRightTriangle", "nvle", "rangle", "RightTriangle", "SmallCircle", "smile", "ssmile", "triangle", "uwangle"],
    a: ["angmsdae"],
    d: ["Atilde", "atilde", "DiacriticalTilde", "divide", "EqualTilde", "GreaterTilde", "Itilde", "itilde", "LessTilde", "NotEqualTilde", "NotGreaterTilde", "NotLessTilde", "NotSucceedsTilde", "NotTilde", "NotTildeTilde", "Ntilde", "ntilde", "Otilde", "otilde", "PrecedesTilde", "SucceedsTilde", "Tilde", "tilde", "TildeTilde", "trade", "Utilde", "utilde", "VerticalTilde"],
    m: ["backprime", "bprime", "bsime", "gsime", "lsime", "nsime", "Prime", "prime", "qprime", "sime", "tprime", "tritime", "xotime"],
    e: ["barvee", "bigvee", "curlyvee", "cuvee", "DoubleLeftTee", "DoubleRightTee", "DownTee", "ee", "LeftTee", "lthree", "RightTee", "rthree", "UpTee", "Vee", "vee", "xvee"],
    s: ["Because", "because", "maltese", "pluse"],
    r: ["blacksquare", "cire", "dotsquare", "EmptySmallSquare", "EmptyVerySmallSquare", "FilledSmallSquare", "FilledVerySmallSquare", "incare", "npre", "pre", "Square", "square", "Therefore", "therefore"],
    n: ["bne", "Colone", "colone", "gne", "HorizontalLine", "imagline", "lne", "ne", "NewLine", "oline", "phone", "Poincareplane", "profline", "realine", "simne", "subne", "supne", "VerticalLine", "vsubne", "vsupne"],
    i: ["bowtie", "die", "infintie", "ltrie", "nltrie", "nrtrie", "nvltrie", "nvrtrie", "rtrie", "trie"],
    b: ["csube", "nsqsube", "nsube", "sqsube", "sube"],
    c: ["HilbertSpace", "lbrace", "MediumSpace", "NegativeMediumSpace", "NegativeThickSpace", "NegativeThinSpace", "NegativeVeryThinSpace", "NonBreakingSpace", "nsce", "OverBrace", "race", "rbrace", "sce", "ThickSpace", "ThinSpace", "UnderBrace", "VeryThinSpace", "ZeroWidthSpace"],
    k: ["lbrke", "rbrke"],
    h: ["lmoustache", "rmoustache"],
    u: ["nprcue", "nsccue", "prcue", "sccue"],
    R: ["Re"]
  };
  var c$1 = {
    a: ["ac", "angmsdac", "dblac", "Odblac", "odblac", "Udblac", "udblac"],
    r: ["Acirc", "acirc", "bigcirc", "Ccirc", "ccirc", "circ", "circledcirc", "Ecirc", "ecirc", "eqcirc", "Gcirc", "gcirc", "Hcirc", "hcirc", "Icirc", "icirc", "Jcirc", "jcirc", "nrarrc", "Ocirc", "ocirc", "rarrc", "Scirc", "scirc", "Ucirc", "ucirc", "Wcirc", "wcirc", "xcirc", "Ycirc", "ycirc"],
    s: ["cuesc", "nsc", "sc"],
    e: ["curlyeqprec", "nprec", "prec", "telrec"],
    c: ["curlyeqsucc", "gescc", "gtcc", "lescc", "ltcc", "nsucc", "succ"],
    i: ["ic", "radic"],
    v: ["notinvc", "notnivc"],
    S: ["Sc"]
  };
  var d$1 = {
    c: ["acd"],
    n: ["And", "and", "andand", "capand", "Diamond", "diamond", "pound"],
    d: ["andd", "dd"],
    s: ["angmsd", "minusd", "nisd", "timesd"],
    a: ["angmsdad", "Gammad", "gammad"],
    b: ["angrtvbd"],
    i: ["apid", "cirmid", "mid", "napid", "nmid", "nshortmid", "nsmid", "omid", "rnmid", "shortmid", "smid"],
    e: ["Barwed", "barwed", "cuwed", "imped", "RuleDelayed"],
    H: ["boxHd"],
    h: ["boxhd", "DDotrahd"],
    o: ["coprod", "intprod", "iprod", "period", "prod"],
    g: ["langd", "rangd"],
    l: ["lbrksld", "odsold", "rbrksld"],
    r: ["lhard", "llhard", "lrhard", "ord", "rhard"]
  };
  var E$1 = {
    c: ["acE", "scE"],
    p: ["apE", "bumpE", "napE", "nsupE", "supE"],
    r: ["cirE", "prE"],
    l: ["ExponentialE", "glE", "lE", "nlE", "simlE"],
    g: ["gE", "lgE", "ngE", "simgE"],
    n: ["gnE", "gvnE", "isinE", "lnE", "lvnE", "notinE", "prnE", "scnE", "subnE", "supnE", "vsubnE", "vsupnE"],
    b: ["nsubE", "subE"],
    D: ["TRADE"]
  };
  var y$1 = {
    c: ["Acy", "acy", "Bcy", "bcy", "CHcy", "chcy", "Dcy", "dcy", "DJcy", "djcy", "DScy", "dscy", "DZcy", "dzcy", "Ecy", "ecy", "Fcy", "fcy", "Gcy", "gcy", "GJcy", "gjcy", "HARDcy", "hardcy", "Icy", "icy", "IEcy", "iecy", "IOcy", "iocy", "Iukcy", "iukcy", "Jcy", "jcy", "Jsercy", "jsercy", "Jukcy", "jukcy", "Kcy", "kcy", "KHcy", "khcy", "KJcy", "kjcy", "Lcy", "lcy", "LJcy", "ljcy", "Mcy", "mcy", "Ncy", "ncy", "NJcy", "njcy", "Ocy", "ocy", "Pcy", "pcy", "Rcy", "rcy", "Scy", "scy", "SHCHcy", "shchcy", "SHcy", "shcy", "SOFTcy", "softcy", "Tcy", "tcy", "TScy", "tscy", "TSHcy", "tshcy", "Ubrcy", "ubrcy", "Ucy", "ucy", "Vcy", "vcy", "YAcy", "yacy", "Ycy", "ycy", "YIcy", "yicy", "YUcy", "yucy", "Zcy", "zcy", "ZHcy", "zhcy"],
    p: ["copy"],
    t: ["cylcty", "empty"],
    h: ["shy"]
  };
  var g$1 = {
    i: ["AElig", "aelig", "ffilig", "fflig", "ffllig", "filig", "fjlig", "fllig", "IJlig", "ijlig", "OElig", "oelig", "szlig"],
    l: ["amalg", "lg", "ntlg"],
    n: ["ang", "Aring", "aring", "backcong", "bcong", "cong", "eng", "Lang", "lang", "LeftCeiling", "loang", "nang", "ncong", "Rang", "rang", "RightCeiling", "ring", "roang", "sung", "Uring", "uring", "varnothing"],
    a: ["angmsdag", "vzigzag"],
    e: ["deg", "eg", "leg", "reg"],
    G: ["Gg", "nGg"],
    g: ["gg", "ggg"],
    E: ["lEg"],
    s: ["lesg"],
    m: ["lsimg", "simg"]
  };
  var f$1 = {
    a: ["af", "angmsdaf", "sigmaf"],
    p: ["Aopf", "aopf", "Bopf", "bopf", "Copf", "copf", "Dopf", "dopf", "Eopf", "eopf", "Fopf", "fopf", "Gopf", "gopf", "Hopf", "hopf", "Iopf", "iopf", "Jopf", "jopf", "Kopf", "kopf", "Lopf", "lopf", "Mopf", "mopf", "Nopf", "nopf", "Oopf", "oopf", "Popf", "popf", "Qopf", "qopf", "Ropf", "ropf", "Sopf", "sopf", "Topf", "topf", "Uopf", "uopf", "Vopf", "vopf", "Wopf", "wopf", "Xopf", "xopf", "Yopf", "yopf", "Zopf", "zopf"],
    i: ["dtrif", "ltrif", "rtrif", "utrif"],
    o: ["fnof", "imof", "orderof", "origof"],
    r: ["Fouriertrf", "Laplacetrf", "Mellintrf", "profsurf", "squarf", "sstarf", "starf", "zeetrf"],
    l: ["half"],
    f: ["iff"],
    z: ["lozf"],
    d: ["ordf"],
    u: ["squf"]
  };
  var r$1 = {
    f: ["Afr", "afr", "Bfr", "bfr", "Cfr", "cfr", "Dfr", "dfr", "Efr", "efr", "Ffr", "ffr", "Gfr", "gfr", "Hfr", "hfr", "Ifr", "ifr", "Jfr", "jfr", "Kfr", "kfr", "Lfr", "lfr", "Mfr", "mfr", "Nfr", "nfr", "Ofr", "ofr", "Pfr", "pfr", "Qfr", "qfr", "Rfr", "rfr", "Sfr", "sfr", "Tfr", "tfr", "Ufr", "ufr", "Vfr", "vfr", "Wfr", "wfr", "Xfr", "xfr", "Yfr", "yfr", "Zfr", "zfr"],
    c: ["Amacr", "amacr", "Ascr", "ascr", "Bscr", "bscr", "Cscr", "cscr", "Dscr", "dscr", "Emacr", "emacr", "Escr", "escr", "Fscr", "fscr", "Gscr", "gscr", "Hscr", "hscr", "Imacr", "imacr", "Iscr", "iscr", "Jscr", "jscr", "Kscr", "kscr", "Lscr", "lscr", "macr", "Mscr", "mscr", "Nscr", "nscr", "Omacr", "omacr", "Oscr", "oscr", "Pscr", "pscr", "Qscr", "qscr", "Rscr", "rscr", "Sscr", "sscr", "Tscr", "tscr", "Umacr", "umacr", "Uscr", "uscr", "Vscr", "vscr", "Wscr", "wscr", "Xscr", "xscr", "Yscr", "yscr", "Zscr", "zscr"],
    r: ["angzarr", "crarr", "cudarrr", "cularr", "curarr", "Darr", "dArr", "darr", "ddarr", "dharr", "duarr", "dzigrarr", "erarr", "gtrarr", "hArr", "harr", "hoarr", "lAarr", "Larr", "lArr", "larr", "lBarr", "lbarr", "llarr", "loarr", "lrarr", "ltlarr", "neArr", "nearr", "nhArr", "nharr", "nlArr", "nlarr", "nrArr", "nrarr", "nvHarr", "nvlArr", "nvrArr", "nwArr", "nwarr", "olarr", "orarr", "rAarr", "Rarr", "rArr", "rarr", "RBarr", "rBarr", "rbarr", "rlarr", "roarr", "rrarr", "seArr", "searr", "simrarr", "slarr", "srarr", "subrarr", "suplarr", "swArr", "swarr", "Uarr", "uArr", "uarr", "udarr", "uharr", "uuarr", "vArr", "varr", "xhArr", "xharr", "xlArr", "xlarr", "xrArr", "xrarr", "zigrarr"],
    i: ["apacir", "cir", "cirscir", "ecir", "gtcir", "harrcir", "ltcir", "midcir", "ocir", "ofcir", "olcir", "plusacir", "pluscir", "topcir", "Uarrocir"],
    a: ["bigstar", "brvbar", "dHar", "dollar", "DoubleVerticalBar", "DownArrowBar", "DownLeftVectorBar", "DownRightVectorBar", "duhar", "epar", "gtlPar", "hbar", "horbar", "ldrdhar", "ldrushar", "LeftArrowBar", "LeftDownVectorBar", "LeftTriangleBar", "LeftUpVectorBar", "LeftVectorBar", "lHar", "lopar", "lowbar", "lpar", "lrhar", "ltrPar", "lurdshar", "luruhar", "nesear", "nhpar", "NotDoubleVerticalBar", "NotLeftTriangleBar", "NotRightTriangleBar", "NotVerticalBar", "npar", "nspar", "nwnear", "ohbar", "opar", "ovbar", "OverBar", "par", "profalar", "rdldhar", "rHar", "RightArrowBar", "RightDownVectorBar", "RightTriangleBar", "RightUpVectorBar", "RightVectorBar", "rlhar", "ropar", "rpar", "ruluhar", "seswar", "solbar", "spar", "Star", "star", "swnwar", "timesbar", "udhar", "uHar", "UnderBar", "UpArrowBar", "Vbar", "vBar", "veebar", "Verbar", "verbar", "VerticalBar", "wedbar"],
    D: ["boxDr"],
    d: ["boxdr", "mldr", "nldr"],
    U: ["boxUr"],
    u: ["boxur", "natur"],
    V: ["boxVr"],
    v: ["boxvr"],
    s: ["copysr"],
    p: ["cuepr", "npr", "pr"],
    o: ["cupor", "DownLeftRightVector", "DownLeftTeeVector", "DownLeftVector", "DownRightTeeVector", "DownRightVector", "ldquor", "LeftDownTeeVector", "LeftDownVector", "LeftFloor", "LeftRightVector", "LeftTeeVector", "LeftUpDownVector", "LeftUpTeeVector", "LeftUpVector", "LeftVector", "lesdotor", "lfloor", "lsquor", "or", "oror", "rdquor", "rfloor", "RightDownTeeVector", "RightDownVector", "RightFloor", "RightTeeVector", "RightUpDownVector", "RightUpTeeVector", "RightUpVector", "RightVector", "rsquor", "VerticalSeparator"],
    e: ["Dagger", "dagger", "ddagger", "easter", "GreaterGreater", "LessEqualGreater", "LessGreater", "llcorner", "lrcorner", "marker", "NestedGreaterGreater", "NotGreater", "NotGreaterGreater", "NotLessGreater", "NotNestedGreaterGreater", "order", "ulcorner", "urcorner"],
    t: ["eqslantgtr", "lesseqgtr", "lesseqqgtr", "lessgtr", "ngtr"],
    O: ["Or"],
    P: ["Pr"],
    w: ["wr"]
  };
  var m$1 = {
    y: ["alefsym", "thetasym"],
    i: ["backsim", "bsim", "eqsim", "Esim", "esim", "gnsim", "gsim", "gtrsim", "larrsim", "lesssim", "lnsim", "lsim", "nesim", "ngsim", "nlsim", "nsim", "nvsim", "parsim", "plussim", "precnsim", "precsim", "prnsim", "prsim", "rarrsim", "scnsim", "scsim", "sim", "subsim", "succnsim", "succsim", "supsim", "thicksim", "thksim"],
    o: ["bottom"],
    s: ["ccupssm"],
    r: ["curarrm", "lrm"],
    a: ["diam"],
    u: ["Equilibrium", "num", "ReverseEquilibrium", "ReverseUpEquilibrium", "Sum", "sum", "trpezium", "UpEquilibrium"],
    I: ["Im"],
    h: ["ohm"],
    d: ["ordm"],
    p: ["pm"],
    l: ["rlm"]
  };
  var h$1 = {
    p: ["aleph", "angsph"],
    a: ["angmsdah"],
    s: ["Backslash", "circleddash", "dash", "hslash", "ldsh", "Lsh", "lsh", "mdash", "ndash", "nVDash", "nVdash", "nvDash", "nvdash", "odash", "Oslash", "oslash", "rdsh", "Rsh", "rsh", "VDash", "Vdash", "vDash", "vdash", "Vvdash"],
    t: ["beth", "daleth", "eth", "imath", "jmath", "wreath"],
    x: ["boxh"],
    V: ["boxVh"],
    v: ["boxvh"],
    k: ["planckh"],
    i: ["upsih"]
  };
  var a$1 = {
    h: ["Alpha", "alpha"],
    a: ["angmsdaa"],
    t: ["Beta", "beta", "Delta", "delta", "Eta", "eta", "iiota", "Iota", "iota", "Theta", "theta", "vartheta", "Zeta", "zeta"],
    l: ["Cedilla", "gla", "nabla"],
    m: ["comma", "digamma", "Gamma", "gamma", "InvisibleComma", "mcomma", "Sigma", "sigma", "varsigma"],
    p: ["Kappa", "kappa", "varkappa"],
    d: ["Lambda", "lambda"],
    c: ["ldca", "rdca"],
    v: ["notinva", "notniva"],
    g: ["Omega", "omega"],
    r: ["para"],
    e: ["toea"],
    s: ["tosa"]
  };
  var P$1 = {
    M: ["AMP"]
  };
  var p$1 = {
    m: ["amp", "asymp", "bump", "comp", "HumpDownHump", "mp", "nbump", "NotHumpDownHump"],
    a: ["ap", "bigcap", "Cap", "cap", "capcap", "cupbrcap", "CupCap", "cupcap", "gap", "gnap", "lap", "lnap", "Map", "map", "multimap", "mumap", "nap", "ncap", "NotCupCap", "nvap", "prap", "prnap", "rarrap", "scap", "scnap", "sqcap", "thkap", "xcap", "xmap"],
    u: ["bigcup", "bigsqcup", "bigtriangleup", "capbrcup", "capcup", "csup", "Cup", "cup", "cupcup", "leftharpoonup", "mapstoup", "ncup", "nsup", "rightharpoonup", "sqcup", "sqsup", "subsup", "Sup", "sup", "supsup", "vnsup", "xcup", "xsqcup"],
    r: ["cularrp", "operp", "perp", "sharp", "weierp"],
    o: ["dlcrop", "drcrop", "prop", "top", "ulcrop", "urcrop", "vprop"],
    s: ["emsp", "ensp", "hairsp", "nbsp", "numsp", "puncsp", "thinsp"],
    i: ["hellip", "vellip"],
    l: ["larrlp", "rarrlp"],
    c: ["mlcp"],
    h: ["smashp"],
    w: ["wp"]
  };
  var v$1 = {
    d: ["andv"],
    r: ["Barv", "orv", "vBarv"],
    y: ["bemptyv", "cemptyv", "demptyv", "emptyv", "laemptyv", "raemptyv"],
    i: ["bnequiv", "div", "epsiv", "equiv", "nequiv", "niv", "odiv", "phiv", "piv"],
    x: ["boxv"],
    h: ["Dashv", "dashv"],
    k: ["forkv", "plankv"],
    s: ["isinsv"],
    n: ["isinv"],
    a: ["kappav", "sigmav", "thetav"],
    t: ["nGtv", "nLtv"],
    o: ["rhov"]
  };
  var b$1 = {
    a: ["angmsdab", "Tab"],
    v: ["angrtvb", "notinvb", "notnivb"],
    l: ["bsolb", "solb"],
    u: ["bsolhsub", "csub", "lcub", "nsub", "rcub", "sqsub", "Sub", "sub", "subsub", "supdsub", "suphsub", "supsub", "vnsub"],
    r: ["larrb", "rarrb"],
    q: ["lsqb", "rsqb"],
    s: ["minusb", "plusb", "timesb", "trisb"],
    t: ["sdotb"]
  };
  var t$1 = {
    r: ["angrt", "imagpart", "npart", "part", "realpart", "Sqrt", "vangrt", "Vert", "vert"],
    s: ["angst", "ast", "circledast", "equest", "exist", "gtquest", "iquest", "lmoust", "lowast", "ltquest", "midast", "nexist", "oast", "quest", "rmoust"],
    n: ["awconint", "awint", "Cconint", "cent", "cirfnint", "complement", "Congruent", "Conint", "conint", "cwconint", "cwint", "Element", "fpartint", "geqslant", "iiiint", "iiint", "Int", "int", "leqslant", "ngeqslant", "nleqslant", "NotCongruent", "NotElement", "NotReverseElement", "npolint", "oint", "percnt", "pointint", "qint", "quatint", "ReverseElement", "rppolint", "scpolint", "tint"],
    o: ["bigodot", "bNot", "bnot", "bot", "capdot", "Cdot", "cdot", "CenterDot", "centerdot", "CircleDot", "congdot", "ctdot", "cupdot", "DiacriticalDot", "Dot", "dot", "DotDot", "doteqdot", "DoubleDot", "dtdot", "eDDot", "Edot", "eDot", "edot", "efDot", "egsdot", "elsdot", "erDot", "esdot", "Gdot", "gdot", "gesdot", "gtdot", "gtrdot", "Idot", "inodot", "isindot", "lesdot", "lessdot", "Lmidot", "lmidot", "ltdot", "mDDot", "middot", "ncongdot", "nedot", "Not", "not", "notindot", "odot", "quot", "sdot", "simdot", "subdot", "subedot", "supdot", "supedot", "tdot", "topbot", "tridot", "TripleDot", "utdot", "xodot", "Zdot", "zdot"],
    f: ["blacktriangleleft", "circlearrowleft", "curvearrowleft", "downharpoonleft", "looparrowleft", "mapstoleft", "ntriangleleft", "triangleleft", "upharpoonleft", "vartriangleleft"],
    h: ["blacktriangleright", "circlearrowright", "curvearrowright", "dfisht", "downharpoonright", "homtht", "lfisht", "looparrowright", "ntriangleright", "rfisht", "triangleright", "ufisht", "upharpoonright", "vartriangleright"],
    e: ["bullet", "caret", "emptyset", "LeftAngleBracket", "LeftDoubleBracket", "NotSquareSubset", "NotSquareSuperset", "NotSubset", "NotSuperset", "nsubset", "nsupset", "OverBracket", "RightAngleBracket", "RightDoubleBracket", "sqsubset", "sqsupset", "SquareSubset", "SquareSuperset", "Subset", "subset", "Superset", "Supset", "supset", "target", "UnderBracket"],
    i: ["clubsuit", "diamondsuit", "heartsuit", "it", "spadesuit"],
    a: ["commat", "flat", "Hat", "lat", "phmmat", "SuchThat"],
    c: ["Coproduct", "Product", "rect", "sect"],
    G: ["Gt", "nGt"],
    g: ["gt", "ngt", "nvgt", "ogt", "rpargt"],
    l: ["hamilt", "lparlt", "lt", "malt", "nlt", "nvlt", "olt", "submult", "supmult"],
    L: ["Lt", "nLt"],
    x: ["sext", "twixt"],
    m: ["smt"]
  };
  var n$1 = {
    o: ["Aogon", "aogon", "ApplyFunction", "backepsilon", "caron", "Ccaron", "ccaron", "Colon", "colon", "Dcaron", "dcaron", "Ecaron", "ecaron", "ecolon", "Eogon", "eogon", "Epsilon", "epsilon", "eqcolon", "expectation", "hercon", "Intersection", "Iogon", "iogon", "Lcaron", "lcaron", "Ncaron", "ncaron", "ogon", "Omicron", "omicron", "Proportion", "Rcaron", "rcaron", "Scaron", "scaron", "SquareIntersection", "SquareUnion", "straightepsilon", "Tcaron", "tcaron", "Union", "Uogon", "uogon", "Upsilon", "upsilon", "varepsilon", "Zcaron", "zcaron"],
    g: ["Assign"],
    e: ["between", "curren", "hyphen", "kgreen", "yen"],
    w: ["bigtriangledown", "blacktriangledown", "frown", "leftharpoondown", "mapstodown", "rightharpoondown", "sfrown", "triangledown"],
    f: ["compfn"],
    i: ["disin", "iinfin", "in", "infin", "isin", "notin", "nvinfin"],
    r: ["dlcorn", "drcorn", "thorn", "ulcorn", "urcorn"],
    a: ["lagran"],
    m: ["plusmn", "setmn", "ssetmn"]
  };
  var s$1 = {
    o: ["apos", "mstpos", "napos"],
    u: ["becaus", "bigoplus", "biguplus", "boxminus", "boxplus", "CircleMinus", "CirclePlus", "dotminus", "dotplus", "eplus", "loplus", "minus", "MinusPlus", "mnplus", "ominus", "oplus", "plus", "PlusMinus", "roplus", "setminus", "simplus", "smallsetminus", "subplus", "supplus", "triminus", "triplus", "UnionPlus", "uplus", "xoplus", "xuplus"],
    i: ["Bernoullis", "nis", "OverParenthesis", "UnderParenthesis", "xnis"],
    e: ["bigotimes", "boxtimes", "CircleTimes", "complexes", "divideontimes", "ges", "gesles", "Implies", "InvisibleTimes", "lates", "leftthreetimes", "les", "lesges", "lotimes", "ltimes", "nges", "nles", "NotPrecedes", "Otimes", "otimes", "Precedes", "primes", "rightthreetimes", "rotimes", "RoundImplies", "rtimes", "smtes", "spades", "times"],
    p: ["caps", "ccaps", "ccups", "cups", "sqcaps", "sqcups"],
    y: ["Cayleys"],
    b: ["clubs"],
    s: ["Cross", "cross", "eqslantless", "GreaterEqualLess", "GreaterLess", "gtreqless", "gtreqqless", "gtrless", "LessLess", "NestedLessLess", "nless", "NotGreaterLess", "NotLess", "NotLessLess", "NotNestedLessLess", "olcross"],
    m: ["diams"],
    w: ["downdownarrows", "leftleftarrows", "leftrightarrows", "rightleftarrows", "rightrightarrows", "upuparrows"],
    g: ["egs"],
    r: ["elinters", "integers"],
    l: ["els", "equals", "models", "naturals", "rationals", "reals"],
    t: ["Exists", "hearts", "nexists", "NotExists"],
    n: ["fltns", "isins", "leftrightharpoons", "quaternions", "rightleftharpoons", "strns"],
    f: ["larrbfs", "larrfs", "rarrbfs", "rarrfs"],
    d: ["NotSucceeds", "Succeeds"],
    a: ["otimesas"]
  };
  var x$1 = {
    o: ["approx", "boxbox", "gnapprox", "gtrapprox", "lessapprox", "lnapprox", "napprox", "precapprox", "precnapprox", "succapprox", "succnapprox", "thickapprox"],
    n: ["divonx"],
    r: ["rx"]
  };
  var q$1 = {
    e: ["approxeq", "asympeq", "backsimeq", "Bumpeq", "bumpeq", "circeq", "coloneq", "ddotseq", "doteq", "fallingdotseq", "geq", "gneq", "leq", "lneq", "ngeq", "nleq", "npreceq", "nsimeq", "nsubseteq", "nsucceq", "nsupseteq", "ntrianglelefteq", "ntrianglerighteq", "preccurlyeq", "preceq", "questeq", "risingdotseq", "simeq", "sqsubseteq", "sqsupseteq", "subseteq", "subsetneq", "succcurlyeq", "succeq", "supseteq", "supsetneq", "trianglelefteq", "triangleq", "trianglerighteq", "varsubsetneq", "varsupsetneq", "veeeq", "wedgeq"],
    q: ["geqq", "gneqq", "gvertneqq", "leqq", "lneqq", "lvertneqq", "ngeqq", "nleqq", "nsubseteqq", "nsupseteqq", "precneqq", "subseteqq", "subsetneqq", "succneqq", "supseteqq", "supsetneqq", "varsubsetneqq", "varsupsetneqq"]
  };
  var l$1 = {
    m: ["Auml", "auml", "Euml", "euml", "gsiml", "Iuml", "iuml", "Ouml", "ouml", "siml", "uml", "Uuml", "uuml", "Yuml", "yuml"],
    D: ["boxDl"],
    d: ["boxdl"],
    U: ["boxUl"],
    u: ["boxul", "lharul", "rharul"],
    V: ["boxVl"],
    v: ["boxvl"],
    o: ["bsol", "dsol", "gesdotol", "osol", "sol", "suphsol"],
    l: ["bull", "ell", "ForAll", "forall", "hybull", "ll"],
    i: ["Ccedil", "ccedil", "cedil", "Gcedil", "Kcedil", "kcedil", "lAtail", "latail", "Lcedil", "lcedil", "lceil", "leftarrowtail", "Ncedil", "ncedil", "permil", "rAtail", "ratail", "Rcedil", "rcedil", "rceil", "rightarrowtail", "Scedil", "scedil", "Tcedil", "tcedil"],
    a: ["ClockwiseContourIntegral", "ContourIntegral", "CounterClockwiseContourIntegral", "DotEqual", "DoubleContourIntegral", "Equal", "GreaterEqual", "GreaterFullEqual", "GreaterSlantEqual", "HumpEqual", "intcal", "Integral", "intercal", "LeftTriangleEqual", "LessFullEqual", "LessSlantEqual", "natural", "NotEqual", "NotGreaterEqual", "NotGreaterFullEqual", "NotGreaterSlantEqual", "NotHumpEqual", "NotLeftTriangleEqual", "NotLessEqual", "NotLessSlantEqual", "NotPrecedesEqual", "NotPrecedesSlantEqual", "NotRightTriangleEqual", "NotSquareSubsetEqual", "NotSquareSupersetEqual", "NotSubsetEqual", "NotSucceedsEqual", "NotSucceedsSlantEqual", "NotSupersetEqual", "NotTildeEqual", "NotTildeFullEqual", "PrecedesEqual", "PrecedesSlantEqual", "Proportional", "real", "RightTriangleEqual", "SquareSubsetEqual", "SquareSupersetEqual", "SubsetEqual", "SucceedsEqual", "SucceedsSlantEqual", "SupersetEqual", "TildeEqual", "TildeFullEqual"],
    r: ["cudarrl", "dharl", "uharl"],
    e: ["Del", "el", "gel", "gimel", "nparallel", "nshortparallel", "parallel", "prurel", "shortparallel"],
    s: ["eparsl", "eqvparsl", "frasl", "gesl", "nparsl", "parsl", "smeparsl"],
    c: ["excl", "iexcl"],
    E: ["gEl"],
    g: ["gl", "ntgl"],
    p: ["larrpl", "rarrpl"],
    t: ["larrtl", "Rarrtl", "rarrtl"],
    L: ["Ll", "nLl"],
    h: ["Vdashl"]
  };
  var k$1 = {
    r: ["bbrk", "bbrktbrk", "checkmark", "fork", "lbbrk", "lobrk", "pitchfork", "rbbrk", "robrk", "tbrk", "topfork"],
    n: ["blank", "pertenk"],
    c: ["block", "check", "lbrack", "planck", "rbrack"],
    o: ["Dstrok", "dstrok", "Hstrok", "hstrok", "Lstrok", "lstrok", "Tstrok", "tstrok"],
    e: ["Hacek"],
    h: ["intlarhk", "larrhk", "nearhk", "nwarhk", "rarrhk", "searhk", "swarhk"],
    l: ["lhblk", "uhblk"],
    a: ["NoBreak"]
  };
  var o$1 = {
    u: ["bdquo", "laquo", "ldquo", "lsaquo", "lsquo", "raquo", "rdquo", "rsaquo", "rsquo", "sbquo"],
    r: ["euro", "micro", "numero"],
    t: ["gesdoto", "lesdoto", "longmapsto", "mapsto", "propto", "varpropto"],
    h: ["mho", "Rho", "rho", "varrho"],
    d: ["plusdo"],
    w: ["plustwo"],
    i: ["ratio"]
  };
  var i$1 = {
    s: ["bepsi", "epsi", "Psi", "psi", "Upsi", "upsi"],
    m: ["bsemi", "semi"],
    h: ["Chi", "chi", "Phi", "phi", "straightphi", "varphi"],
    r: ["dtri", "lltri", "lrtri", "ltri", "nltri", "nrtri", "rtri", "rtriltri", "ultri", "urtri", "utri", "vltri", "vrtri", "xdtri", "xutri"],
    i: ["ii"],
    n: ["ni", "notni"],
    P: ["Pi"],
    p: ["pi", "varpi"],
    X: ["Xi"],
    x: ["xi"]
  };
  var u$1 = {
    o: ["bernou"],
    H: ["boxHu"],
    h: ["boxhu"],
    l: ["lbrkslu", "rbrkslu"],
    r: ["lharu", "rharu"],
    d: ["minusdu", "plusdu"],
    M: ["Mu"],
    m: ["mu"],
    N: ["Nu"],
    n: ["nu"],
    q: ["squ"],
    a: ["Tau", "tau"]
  };
  var w$1 = {
    o: ["bkarow", "dbkarow", "DoubleDownArrow", "DoubleLeftArrow", "DoubleLeftRightArrow", "DoubleLongLeftArrow", "DoubleLongLeftRightArrow", "DoubleLongRightArrow", "DoubleRightArrow", "DoubleUpArrow", "DoubleUpDownArrow", "DownArrow", "Downarrow", "downarrow", "DownArrowUpArrow", "DownTeeArrow", "drbkarow", "hksearow", "hkswarow", "hookleftarrow", "hookrightarrow", "LeftArrow", "Leftarrow", "leftarrow", "LeftArrowRightArrow", "LeftRightArrow", "Leftrightarrow", "leftrightarrow", "leftrightsquigarrow", "LeftTeeArrow", "Lleftarrow", "LongLeftArrow", "Longleftarrow", "longleftarrow", "LongLeftRightArrow", "Longleftrightarrow", "longleftrightarrow", "LongRightArrow", "Longrightarrow", "longrightarrow", "LowerLeftArrow", "LowerRightArrow", "nearrow", "nLeftarrow", "nleftarrow", "nLeftrightarrow", "nleftrightarrow", "nRightarrow", "nrightarrow", "nwarrow", "RightArrow", "Rightarrow", "rightarrow", "RightArrowLeftArrow", "rightsquigarrow", "RightTeeArrow", "Rrightarrow", "searrow", "ShortDownArrow", "ShortLeftArrow", "ShortRightArrow", "ShortUpArrow", "swarrow", "twoheadleftarrow", "twoheadrightarrow", "UpArrow", "Uparrow", "uparrow", "UpArrowDownArrow", "UpDownArrow", "Updownarrow", "updownarrow", "UpperLeftArrow", "UpperRightArrow", "UpTeeArrow"],
    r: ["harrw", "nrarrw", "rarrw"]
  };
  var L$1 = {
    D: ["boxDL"],
    d: ["boxdL"],
    U: ["boxUL"],
    u: ["boxuL"],
    V: ["boxVL"],
    v: ["boxvL"]
  };
  var R$1 = {
    D: ["boxDR"],
    d: ["boxdR", "circledR"],
    U: ["boxUR"],
    u: ["boxuR"],
    V: ["boxVR"],
    v: ["boxvR"]
  };
  var H$1 = {
    x: ["boxH"],
    V: ["boxVH"],
    v: ["boxvH"],
    T: ["ETH"]
  };
  var D$1 = {
    H: ["boxHD"],
    h: ["boxhD"],
    l: ["CapitalDifferentialD", "DifferentialD", "PartialD"],
    D: ["DD", "equivDD"]
  };
  var U$1 = {
    H: ["boxHU"],
    h: ["boxhU"]
  };
  var V$1 = {
    x: ["boxV"]
  };
  var S$1 = {
    d: ["circledS"],
    o: ["oS"]
  };
  var Y$1 = {
    P: ["COPY"]
  };
  var G$1 = {
    N: ["ENG"],
    E: ["REG"]
  };
  var j$1 = {
    l: ["glj"],
    w: ["zwj"],
    n: ["zwnj"]
  };
  var T$1 = {
    G: ["GT"],
    L: ["LT"],
    O: ["QUOT"]
  };
  var I$1 = {
    y: ["ImaginaryI"]
  };
  var z$1 = {
    o: ["loz"]
  };
  var N$1 = {
    R: ["THORN"]
  };
  var endsWith = {
    "1": {
      p: ["sup1"]
    },
    "2": {
      "1": ["blk12", "frac12"],
      p: ["sup2"]
    },
    "3": {
      "1": ["emsp13", "frac13"],
      "2": ["frac23"],
      p: ["sup3"]
    },
    "4": {
      "1": ["blk14", "emsp14", "frac14"],
      "3": ["blk34", "frac34"],
      e: ["there4"]
    },
    "5": {
      "1": ["frac15"],
      "2": ["frac25"],
      "3": ["frac35"],
      "4": ["frac45"]
    },
    "6": {
      "1": ["frac16"],
      "5": ["frac56"]
    },
    "8": {
      "1": ["frac18"],
      "3": ["frac38"],
      "5": ["frac58"],
      "7": ["frac78"]
    },
    e: e$1,
    c: c$1,
    d: d$1,
    E: E$1,
    y: y$1,
    g: g$1,
    f: f$1,
    r: r$1,
    m: m$1,
    h: h$1,
    a: a$1,
    P: P$1,
    p: p$1,
    v: v$1,
    b: b$1,
    t: t$1,
    n: n$1,
    s: s$1,
    x: x$1,
    q: q$1,
    l: l$1,
    k: k$1,
    o: o$1,
    i: i$1,
    u: u$1,
    w: w$1,
    L: L$1,
    R: R$1,
    H: H$1,
    D: D$1,
    U: U$1,
    V: V$1,
    S: S$1,
    Y: Y$1,
    G: G$1,
    j: j$1,
    T: T$1,
    I: I$1,
    z: z$1,
    N: N$1
  };
  var a$2 = {
    a: ["aacute"],
    b: ["abreve"],
    c: ["ac", "acd", "ace", "acirc", "acute", "acy"],
    e: ["aelig"],
    f: ["af", "afr"],
    g: ["agrave"],
    l: ["alefsym", "aleph", "alpha"],
    m: ["amacr", "amalg", "amp"],
    n: ["and", "andand", "andd", "andslope", "andv", "ang", "ange", "angle", "angmsd", "angmsdaa", "angmsdab", "angmsdac", "angmsdad", "angmsdae", "angmsdaf", "angmsdag", "angmsdah", "angrt", "angrtvb", "angrtvbd", "angsph", "angst", "angzarr"],
    o: ["aogon", "aopf"],
    p: ["ap", "apacir", "ape", "apid", "apos", "applyfunction", "approx", "approxeq"],
    r: ["aring"],
    s: ["ascr", "assign", "ast", "asymp", "asympeq"],
    t: ["atilde"],
    u: ["auml"],
    w: ["awconint", "awint"]
  };
  var b$2 = {
    a: ["backcong", "backepsilon", "backprime", "backsim", "backsimeq", "backslash", "barv", "barvee", "barwed", "barwedge"],
    b: ["bbrk", "bbrktbrk"],
    c: ["bcong", "bcy"],
    d: ["bdquo"],
    e: ["becaus", "because", "bemptyv", "bepsi", "bernou", "bernoullis", "beta", "beth", "between"],
    f: ["bfr"],
    i: ["bigcap", "bigcirc", "bigcup", "bigodot", "bigoplus", "bigotimes", "bigsqcup", "bigstar", "bigtriangledown", "bigtriangleup", "biguplus", "bigvee", "bigwedge"],
    k: ["bkarow"],
    l: ["blacklozenge", "blacksquare", "blacktriangle", "blacktriangledown", "blacktriangleleft", "blacktriangleright", "blank", "blk12", "blk14", "blk34", "block"],
    n: ["bne", "bnequiv", "bnot"],
    o: ["bopf", "bot", "bottom", "bowtie", "boxbox", "boxdl", "boxdr", "boxh", "boxhd", "boxhu", "boxminus", "boxplus", "boxtimes", "boxul", "boxur", "boxv", "boxvh", "boxvl", "boxvr"],
    p: ["bprime"],
    r: ["breve", "brvbar"],
    s: ["bscr", "bsemi", "bsim", "bsime", "bsol", "bsolb", "bsolhsub"],
    u: ["bull", "bullet", "bump", "bumpe", "bumpeq"]
  };
  var c$2 = {
    a: ["cacute", "cap", "capand", "capbrcup", "capcap", "capcup", "capdot", "capitaldifferentiald", "caps", "caret", "caron", "cayleys"],
    c: ["ccaps", "ccaron", "ccedil", "ccirc", "cconint", "ccups", "ccupssm"],
    d: ["cdot"],
    e: ["cedil", "cedilla", "cemptyv", "cent", "centerdot"],
    f: ["cfr"],
    h: ["chcy", "check", "checkmark", "chi"],
    i: ["cir", "circ", "circeq", "circlearrowleft", "circlearrowright", "circledast", "circledcirc", "circleddash", "circledot", "circledr", "circleds", "circleminus", "circleplus", "circletimes", "cire", "cirfnint", "cirmid", "cirscir"],
    l: ["clockwisecontourintegral", "closecurlydoublequote", "closecurlyquote", "clubs", "clubsuit"],
    o: ["colon", "colone", "coloneq", "comma", "commat", "comp", "compfn", "complement", "complexes", "cong", "congdot", "congruent", "conint", "contourintegral", "copf", "coprod", "coproduct", "copy", "copysr", "counterclockwisecontourintegral"],
    r: ["crarr", "cross"],
    s: ["cscr", "csub", "csube", "csup", "csupe"],
    t: ["ctdot"],
    u: ["cudarrl", "cudarrr", "cuepr", "cuesc", "cularr", "cularrp", "cup", "cupbrcap", "cupcap", "cupcup", "cupdot", "cupor", "cups", "curarr", "curarrm", "curlyeqprec", "curlyeqsucc", "curlyvee", "curlywedge", "curren", "curvearrowleft", "curvearrowright", "cuvee", "cuwed"],
    w: ["cwconint", "cwint"],
    y: ["cylcty"]
  };
  var d$2 = {
    a: ["dagger", "daleth", "darr", "dash", "dashv"],
    b: ["dbkarow", "dblac"],
    c: ["dcaron", "dcy"],
    d: ["dd", "ddagger", "ddarr", "ddotrahd", "ddotseq"],
    e: ["deg", "del", "delta", "demptyv"],
    f: ["dfisht", "dfr"],
    h: ["dhar", "dharl", "dharr"],
    i: ["diacriticalacute", "diacriticaldot", "diacriticaldoubleacute", "diacriticalgrave", "diacriticaltilde", "diam", "diamond", "diamondsuit", "diams", "die", "differentiald", "digamma", "disin", "div", "divide", "divideontimes", "divonx"],
    j: ["djcy"],
    l: ["dlcorn", "dlcrop"],
    o: ["dollar", "dopf", "dot", "dotdot", "doteq", "doteqdot", "dotequal", "dotminus", "dotplus", "dotsquare", "doublebarwedge", "doublecontourintegral", "doubledot", "doubledownarrow", "doubleleftarrow", "doubleleftrightarrow", "doublelefttee", "doublelongleftarrow", "doublelongleftrightarrow", "doublelongrightarrow", "doublerightarrow", "doublerighttee", "doubleuparrow", "doubleupdownarrow", "doubleverticalbar", "downarrow", "downarrowbar", "downarrowuparrow", "downbreve", "downdownarrows", "downharpoonleft", "downharpoonright", "downleftrightvector", "downleftteevector", "downleftvector", "downleftvectorbar", "downrightteevector", "downrightvector", "downrightvectorbar", "downtee", "downteearrow"],
    r: ["drbkarow", "drcorn", "drcrop"],
    s: ["dscr", "dscy", "dsol", "dstrok"],
    t: ["dtdot", "dtri", "dtrif"],
    u: ["duarr", "duhar"],
    w: ["dwangle"],
    z: ["dzcy", "dzigrarr"]
  };
  var e$2 = {
    a: ["eacute", "easter"],
    c: ["ecaron", "ecir", "ecirc", "ecolon", "ecy"],
    d: ["eddot", "edot"],
    e: ["ee"],
    f: ["efdot", "efr"],
    g: ["eg", "egrave", "egs", "egsdot"],
    l: ["el", "element", "elinters", "ell", "els", "elsdot"],
    m: ["emacr", "empty", "emptyset", "emptysmallsquare", "emptyv", "emptyverysmallsquare", "emsp", "emsp13", "emsp14"],
    n: ["eng", "ensp"],
    o: ["eogon", "eopf"],
    p: ["epar", "eparsl", "eplus", "epsi", "epsilon", "epsiv"],
    q: ["eqcirc", "eqcolon", "eqsim", "eqslantgtr", "eqslantless", "equal", "equals", "equaltilde", "equest", "equilibrium", "equiv", "equivdd", "eqvparsl"],
    r: ["erarr", "erdot"],
    s: ["escr", "esdot", "esim"],
    t: ["eta", "eth"],
    u: ["euml", "euro"],
    x: ["excl", "exist", "exists", "expectation", "exponentiale"]
  };
  var f$2 = {
    a: ["fallingdotseq"],
    c: ["fcy"],
    e: ["female"],
    f: ["ffilig", "fflig", "ffllig", "ffr"],
    i: ["filig", "filledsmallsquare", "filledverysmallsquare"],
    j: ["fjlig"],
    l: ["flat", "fllig", "fltns"],
    n: ["fnof"],
    o: ["fopf", "forall", "fork", "forkv", "fouriertrf"],
    p: ["fpartint"],
    r: ["frac12", "frac13", "frac14", "frac15", "frac16", "frac18", "frac23", "frac25", "frac34", "frac35", "frac38", "frac45", "frac56", "frac58", "frac78", "frasl", "frown"],
    s: ["fscr"]
  };
  var g$2 = {
    a: ["gacute", "gamma", "gammad", "gap"],
    b: ["gbreve"],
    c: ["gcedil", "gcirc", "gcy"],
    d: ["gdot"],
    e: ["ge", "gel", "geq", "geqq", "geqslant", "ges", "gescc", "gesdot", "gesdoto", "gesdotol", "gesl", "gesles"],
    f: ["gfr"],
    g: ["gg", "ggg"],
    i: ["gimel"],
    j: ["gjcy"],
    l: ["gl", "gla", "gle", "glj"],
    n: ["gnap", "gnapprox", "gne", "gneq", "gneqq", "gnsim"],
    o: ["gopf"],
    r: ["grave", "greaterequal", "greaterequalless", "greaterfullequal", "greatergreater", "greaterless", "greaterslantequal", "greatertilde"],
    s: ["gscr", "gsim", "gsime", "gsiml"],
    t: ["gt", "gtcc", "gtcir", "gtdot", "gtlpar", "gtquest", "gtrapprox", "gtrarr", "gtrdot", "gtreqless", "gtreqqless", "gtrless", "gtrsim"],
    v: ["gvertneqq", "gvne"]
  };
  var h$2 = {
    a: ["hacek", "hairsp", "half", "hamilt", "hardcy", "harr", "harrcir", "harrw", "hat"],
    b: ["hbar"],
    c: ["hcirc"],
    e: ["hearts", "heartsuit", "hellip", "hercon"],
    f: ["hfr"],
    i: ["hilbertspace"],
    k: ["hksearow", "hkswarow"],
    o: ["hoarr", "homtht", "hookleftarrow", "hookrightarrow", "hopf", "horbar", "horizontalline"],
    s: ["hscr", "hslash", "hstrok"],
    u: ["humpdownhump", "humpequal"],
    y: ["hybull", "hyphen"]
  };
  var i$2 = {
    a: ["iacute"],
    c: ["ic", "icirc", "icy"],
    d: ["idot"],
    e: ["iecy", "iexcl"],
    f: ["iff", "ifr"],
    g: ["igrave"],
    i: ["ii", "iiiint", "iiint", "iinfin", "iiota"],
    j: ["ijlig"],
    m: ["im", "imacr", "image", "imaginaryi", "imagline", "imagpart", "imath", "imof", "imped", "implies"],
    n: ["in", "incare", "infin", "infintie", "inodot", "int", "intcal", "integers", "integral", "intercal", "intersection", "intlarhk", "intprod", "invisiblecomma", "invisibletimes"],
    o: ["iocy", "iogon", "iopf", "iota"],
    p: ["iprod"],
    q: ["iquest"],
    s: ["iscr", "isin", "isindot", "isine", "isins", "isinsv", "isinv"],
    t: ["it", "itilde"],
    u: ["iukcy", "iuml"]
  };
  var j$2 = {
    c: ["jcirc", "jcy"],
    f: ["jfr"],
    m: ["jmath"],
    o: ["jopf"],
    s: ["jscr", "jsercy"],
    u: ["jukcy"]
  };
  var k$2 = {
    a: ["kappa", "kappav"],
    c: ["kcedil", "kcy"],
    f: ["kfr"],
    g: ["kgreen"],
    h: ["khcy"],
    j: ["kjcy"],
    o: ["kopf"],
    s: ["kscr"]
  };
  var l$2 = {
    a: ["laarr", "lacute", "laemptyv", "lagran", "lambda", "lang", "langd", "langle", "lap", "laplacetrf", "laquo", "larr", "larrb", "larrbfs", "larrfs", "larrhk", "larrlp", "larrpl", "larrsim", "larrtl", "lat", "latail", "late", "lates"],
    b: ["lbarr", "lbbrk", "lbrace", "lbrack", "lbrke", "lbrksld", "lbrkslu"],
    c: ["lcaron", "lcedil", "lceil", "lcub", "lcy"],
    d: ["ldca", "ldquo", "ldquor", "ldrdhar", "ldrushar", "ldsh"],
    e: ["le", "leftanglebracket", "leftarrow", "leftarrowbar", "leftarrowrightarrow", "leftarrowtail", "leftceiling", "leftdoublebracket", "leftdownteevector", "leftdownvector", "leftdownvectorbar", "leftfloor", "leftharpoondown", "leftharpoonup", "leftleftarrows", "leftrightarrow", "leftrightarrows", "leftrightharpoons", "leftrightsquigarrow", "leftrightvector", "lefttee", "leftteearrow", "leftteevector", "leftthreetimes", "lefttriangle", "lefttrianglebar", "lefttriangleequal", "leftupdownvector", "leftupteevector", "leftupvector", "leftupvectorbar", "leftvector", "leftvectorbar", "leg", "leq", "leqq", "leqslant", "les", "lescc", "lesdot", "lesdoto", "lesdotor", "lesg", "lesges", "lessapprox", "lessdot", "lesseqgtr", "lesseqqgtr", "lessequalgreater", "lessfullequal", "lessgreater", "lessgtr", "lessless", "lesssim", "lessslantequal", "lesstilde"],
    f: ["lfisht", "lfloor", "lfr"],
    g: ["lg", "lge"],
    h: ["lhar", "lhard", "lharu", "lharul", "lhblk"],
    j: ["ljcy"],
    l: ["ll", "llarr", "llcorner", "lleftarrow", "llhard", "lltri"],
    m: ["lmidot", "lmoust", "lmoustache"],
    n: ["lnap", "lnapprox", "lne", "lneq", "lneqq", "lnsim"],
    o: ["loang", "loarr", "lobrk", "longleftarrow", "longleftrightarrow", "longmapsto", "longrightarrow", "looparrowleft", "looparrowright", "lopar", "lopf", "loplus", "lotimes", "lowast", "lowbar", "lowerleftarrow", "lowerrightarrow", "loz", "lozenge", "lozf"],
    p: ["lpar", "lparlt"],
    r: ["lrarr", "lrcorner", "lrhar", "lrhard", "lrm", "lrtri"],
    s: ["lsaquo", "lscr", "lsh", "lsim", "lsime", "lsimg", "lsqb", "lsquo", "lsquor", "lstrok"],
    t: ["lt", "ltcc", "ltcir", "ltdot", "lthree", "ltimes", "ltlarr", "ltquest", "ltri", "ltrie", "ltrif", "ltrpar"],
    u: ["lurdshar", "luruhar"],
    v: ["lvertneqq", "lvne"]
  };
  var m$2 = {
    a: ["macr", "male", "malt", "maltese", "map", "mapsto", "mapstodown", "mapstoleft", "mapstoup", "marker"],
    c: ["mcomma", "mcy"],
    d: ["mdash", "mddot"],
    e: ["measuredangle", "mediumspace", "mellintrf"],
    f: ["mfr"],
    h: ["mho"],
    i: ["micro", "mid", "midast", "midcir", "middot", "minus", "minusb", "minusd", "minusdu", "minusplus"],
    l: ["mlcp", "mldr"],
    n: ["mnplus"],
    o: ["models", "mopf"],
    p: ["mp"],
    s: ["mscr", "mstpos"],
    u: ["mu", "multimap", "mumap"]
  };
  var n$2 = {
    a: ["nabla", "nacute", "nang", "nap", "nape", "napid", "napos", "napprox", "natur", "natural", "naturals"],
    b: ["nbsp", "nbump", "nbumpe"],
    c: ["ncap", "ncaron", "ncedil", "ncong", "ncongdot", "ncup", "ncy"],
    d: ["ndash"],
    e: ["ne", "nearhk", "nearr", "nearrow", "nedot", "negativemediumspace", "negativethickspace", "negativethinspace", "negativeverythinspace", "nequiv", "nesear", "nesim", "nestedgreatergreater", "nestedlessless", "newline", "nexist", "nexists"],
    f: ["nfr"],
    g: ["nge", "ngeq", "ngeqq", "ngeqslant", "nges", "ngg", "ngsim", "ngt", "ngtr", "ngtv"],
    h: ["nharr", "nhpar"],
    i: ["ni", "nis", "nisd", "niv"],
    j: ["njcy"],
    l: ["nlarr", "nldr", "nle", "nleftarrow", "nleftrightarrow", "nleq", "nleqq", "nleqslant", "nles", "nless", "nll", "nlsim", "nlt", "nltri", "nltrie", "nltv"],
    m: ["nmid"],
    o: ["nobreak", "nonbreakingspace", "nopf", "not", "notcongruent", "notcupcap", "notdoubleverticalbar", "notelement", "notequal", "notequaltilde", "notexists", "notgreater", "notgreaterequal", "notgreaterfullequal", "notgreatergreater", "notgreaterless", "notgreaterslantequal", "notgreatertilde", "nothumpdownhump", "nothumpequal", "notin", "notindot", "notine", "notinva", "notinvb", "notinvc", "notlefttriangle", "notlefttrianglebar", "notlefttriangleequal", "notless", "notlessequal", "notlessgreater", "notlessless", "notlessslantequal", "notlesstilde", "notnestedgreatergreater", "notnestedlessless", "notni", "notniva", "notnivb", "notnivc", "notprecedes", "notprecedesequal", "notprecedesslantequal", "notreverseelement", "notrighttriangle", "notrighttrianglebar", "notrighttriangleequal", "notsquaresubset", "notsquaresubsetequal", "notsquaresuperset", "notsquaresupersetequal", "notsubset", "notsubsetequal", "notsucceeds", "notsucceedsequal", "notsucceedsslantequal", "notsucceedstilde", "notsuperset", "notsupersetequal", "nottilde", "nottildeequal", "nottildefullequal", "nottildetilde", "notverticalbar"],
    p: ["npar", "nparallel", "nparsl", "npart", "npolint", "npr", "nprcue", "npre", "nprec", "npreceq"],
    r: ["nrarr", "nrarrc", "nrarrw", "nrightarrow", "nrtri", "nrtrie"],
    s: ["nsc", "nsccue", "nsce", "nscr", "nshortmid", "nshortparallel", "nsim", "nsime", "nsimeq", "nsmid", "nspar", "nsqsube", "nsqsupe", "nsub", "nsube", "nsubset", "nsubseteq", "nsubseteqq", "nsucc", "nsucceq", "nsup", "nsupe", "nsupset", "nsupseteq", "nsupseteqq"],
    t: ["ntgl", "ntilde", "ntlg", "ntriangleleft", "ntrianglelefteq", "ntriangleright", "ntrianglerighteq"],
    u: ["nu", "num", "numero", "numsp"],
    v: ["nvap", "nvdash", "nvge", "nvgt", "nvharr", "nvinfin", "nvlarr", "nvle", "nvlt", "nvltrie", "nvrarr", "nvrtrie", "nvsim"],
    w: ["nwarhk", "nwarr", "nwarrow", "nwnear"]
  };
  var o$2 = {
    a: ["oacute", "oast"],
    c: ["ocir", "ocirc", "ocy"],
    d: ["odash", "odblac", "odiv", "odot", "odsold"],
    e: ["oelig"],
    f: ["ofcir", "ofr"],
    g: ["ogon", "ograve", "ogt"],
    h: ["ohbar", "ohm"],
    i: ["oint"],
    l: ["olarr", "olcir", "olcross", "oline", "olt"],
    m: ["omacr", "omega", "omicron", "omid", "ominus"],
    o: ["oopf"],
    p: ["opar", "opencurlydoublequote", "opencurlyquote", "operp", "oplus"],
    r: ["or", "orarr", "ord", "order", "orderof", "ordf", "ordm", "origof", "oror", "orslope", "orv"],
    s: ["os", "oscr", "oslash", "osol"],
    t: ["otilde", "otimes", "otimesas"],
    u: ["ouml"],
    v: ["ovbar", "overbar", "overbrace", "overbracket", "overparenthesis"]
  };
  var p$2 = {
    a: ["par", "para", "parallel", "parsim", "parsl", "part", "partiald"],
    c: ["pcy"],
    e: ["percnt", "period", "permil", "perp", "pertenk"],
    f: ["pfr"],
    h: ["phi", "phiv", "phmmat", "phone"],
    i: ["pi", "pitchfork", "piv"],
    l: ["planck", "planckh", "plankv", "plus", "plusacir", "plusb", "pluscir", "plusdo", "plusdu", "pluse", "plusminus", "plusmn", "plussim", "plustwo"],
    m: ["pm"],
    o: ["poincareplane", "pointint", "popf", "pound"],
    r: ["pr", "prap", "prcue", "pre", "prec", "precapprox", "preccurlyeq", "precedes", "precedesequal", "precedesslantequal", "precedestilde", "preceq", "precnapprox", "precneqq", "precnsim", "precsim", "prime", "primes", "prnap", "prne", "prnsim", "prod", "product", "profalar", "profline", "profsurf", "prop", "proportion", "proportional", "propto", "prsim", "prurel"],
    s: ["pscr", "psi"],
    u: ["puncsp"]
  };
  var q$2 = {
    f: ["qfr"],
    i: ["qint"],
    o: ["qopf"],
    p: ["qprime"],
    s: ["qscr"],
    u: ["quaternions", "quatint", "quest", "questeq", "quot"]
  };
  var r$2 = {
    a: ["raarr", "race", "racute", "radic", "raemptyv", "rang", "rangd", "range", "rangle", "raquo", "rarr", "rarrap", "rarrb", "rarrbfs", "rarrc", "rarrfs", "rarrhk", "rarrlp", "rarrpl", "rarrsim", "rarrtl", "rarrw", "ratail", "ratio", "rationals"],
    b: ["rbarr", "rbbrk", "rbrace", "rbrack", "rbrke", "rbrksld", "rbrkslu"],
    c: ["rcaron", "rcedil", "rceil", "rcub", "rcy"],
    d: ["rdca", "rdldhar", "rdquo", "rdquor", "rdsh"],
    e: ["re", "real", "realine", "realpart", "reals", "rect", "reg", "reverseelement", "reverseequilibrium", "reverseupequilibrium"],
    f: ["rfisht", "rfloor", "rfr"],
    h: ["rhar", "rhard", "rharu", "rharul", "rho", "rhov"],
    i: ["rightanglebracket", "rightarrow", "rightarrowbar", "rightarrowleftarrow", "rightarrowtail", "rightceiling", "rightdoublebracket", "rightdownteevector", "rightdownvector", "rightdownvectorbar", "rightfloor", "rightharpoondown", "rightharpoonup", "rightleftarrows", "rightleftharpoons", "rightrightarrows", "rightsquigarrow", "righttee", "rightteearrow", "rightteevector", "rightthreetimes", "righttriangle", "righttrianglebar", "righttriangleequal", "rightupdownvector", "rightupteevector", "rightupvector", "rightupvectorbar", "rightvector", "rightvectorbar", "ring", "risingdotseq"],
    l: ["rlarr", "rlhar", "rlm"],
    m: ["rmoust", "rmoustache"],
    n: ["rnmid"],
    o: ["roang", "roarr", "robrk", "ropar", "ropf", "roplus", "rotimes", "roundimplies"],
    p: ["rpar", "rpargt", "rppolint"],
    r: ["rrarr", "rrightarrow"],
    s: ["rsaquo", "rscr", "rsh", "rsqb", "rsquo", "rsquor"],
    t: ["rthree", "rtimes", "rtri", "rtrie", "rtrif", "rtriltri"],
    u: ["ruledelayed", "ruluhar"],
    x: ["rx"]
  };
  var s$2 = {
    a: ["sacute"],
    b: ["sbquo"],
    c: ["sc", "scap", "scaron", "sccue", "sce", "scedil", "scirc", "scnap", "scne", "scnsim", "scpolint", "scsim", "scy"],
    d: ["sdot", "sdotb", "sdote"],
    e: ["searhk", "searr", "searrow", "sect", "semi", "seswar", "setminus", "setmn", "sext"],
    f: ["sfr", "sfrown"],
    h: ["sharp", "shchcy", "shcy", "shortdownarrow", "shortleftarrow", "shortmid", "shortparallel", "shortrightarrow", "shortuparrow", "shy"],
    i: ["sigma", "sigmaf", "sigmav", "sim", "simdot", "sime", "simeq", "simg", "simge", "siml", "simle", "simne", "simplus", "simrarr"],
    l: ["slarr"],
    m: ["smallcircle", "smallsetminus", "smashp", "smeparsl", "smid", "smile", "smt", "smte", "smtes"],
    o: ["softcy", "sol", "solb", "solbar", "sopf"],
    p: ["spades", "spadesuit", "spar"],
    q: ["sqcap", "sqcaps", "sqcup", "sqcups", "sqrt", "sqsub", "sqsube", "sqsubset", "sqsubseteq", "sqsup", "sqsupe", "sqsupset", "sqsupseteq", "squ", "square", "squareintersection", "squaresubset", "squaresubsetequal", "squaresuperset", "squaresupersetequal", "squareunion", "squarf", "squf"],
    r: ["srarr"],
    s: ["sscr", "ssetmn", "ssmile", "sstarf"],
    t: ["star", "starf", "straightepsilon", "straightphi", "strns"],
    u: ["sub", "subdot", "sube", "subedot", "submult", "subne", "subplus", "subrarr", "subset", "subseteq", "subseteqq", "subsetequal", "subsetneq", "subsetneqq", "subsim", "subsub", "subsup", "succ", "succapprox", "succcurlyeq", "succeeds", "succeedsequal", "succeedsslantequal", "succeedstilde", "succeq", "succnapprox", "succneqq", "succnsim", "succsim", "suchthat", "sum", "sung", "sup", "sup1", "sup2", "sup3", "supdot", "supdsub", "supe", "supedot", "superset", "supersetequal", "suphsol", "suphsub", "suplarr", "supmult", "supne", "supplus", "supset", "supseteq", "supseteqq", "supsetneq", "supsetneqq", "supsim", "supsub", "supsup"],
    w: ["swarhk", "swarr", "swarrow", "swnwar"],
    z: ["szlig"]
  };
  var t$2 = {
    a: ["tab", "target", "tau"],
    b: ["tbrk"],
    c: ["tcaron", "tcedil", "tcy"],
    d: ["tdot"],
    e: ["telrec"],
    f: ["tfr"],
    h: ["there4", "therefore", "theta", "thetasym", "thetav", "thickapprox", "thicksim", "thickspace", "thinsp", "thinspace", "thkap", "thksim", "thorn"],
    i: ["tilde", "tildeequal", "tildefullequal", "tildetilde", "times", "timesb", "timesbar", "timesd", "tint"],
    o: ["toea", "top", "topbot", "topcir", "topf", "topfork", "tosa"],
    p: ["tprime"],
    r: ["trade", "triangle", "triangledown", "triangleleft", "trianglelefteq", "triangleq", "triangleright", "trianglerighteq", "tridot", "trie", "triminus", "tripledot", "triplus", "trisb", "tritime", "trpezium"],
    s: ["tscr", "tscy", "tshcy", "tstrok"],
    w: ["twixt", "twoheadleftarrow", "twoheadrightarrow"]
  };
  var u$2 = {
    a: ["uacute", "uarr", "uarrocir"],
    b: ["ubrcy", "ubreve"],
    c: ["ucirc", "ucy"],
    d: ["udarr", "udblac", "udhar"],
    f: ["ufisht", "ufr"],
    g: ["ugrave"],
    h: ["uhar", "uharl", "uharr", "uhblk"],
    l: ["ulcorn", "ulcorner", "ulcrop", "ultri"],
    m: ["umacr", "uml"],
    n: ["underbar", "underbrace", "underbracket", "underparenthesis", "union", "unionplus"],
    o: ["uogon", "uopf"],
    p: ["uparrow", "uparrowbar", "uparrowdownarrow", "updownarrow", "upequilibrium", "upharpoonleft", "upharpoonright", "uplus", "upperleftarrow", "upperrightarrow", "upsi", "upsih", "upsilon", "uptee", "upteearrow", "upuparrows"],
    r: ["urcorn", "urcorner", "urcrop", "uring", "urtri"],
    s: ["uscr"],
    t: ["utdot", "utilde", "utri", "utrif"],
    u: ["uuarr", "uuml"],
    w: ["uwangle"]
  };
  var v$2 = {
    a: ["vangrt", "varepsilon", "varkappa", "varnothing", "varphi", "varpi", "varpropto", "varr", "varrho", "varsigma", "varsubsetneq", "varsubsetneqq", "varsupsetneq", "varsupsetneqq", "vartheta", "vartriangleleft", "vartriangleright"],
    b: ["vbar", "vbarv"],
    c: ["vcy"],
    d: ["vdash", "vdashl"],
    e: ["vee", "veebar", "veeeq", "vellip", "verbar", "vert", "verticalbar", "verticalline", "verticalseparator", "verticaltilde", "verythinspace"],
    f: ["vfr"],
    l: ["vltri"],
    n: ["vnsub", "vnsup"],
    o: ["vopf"],
    p: ["vprop"],
    r: ["vrtri"],
    s: ["vscr", "vsubne", "vsupne"],
    v: ["vvdash"],
    z: ["vzigzag"]
  };
  var w$2 = {
    c: ["wcirc"],
    e: ["wedbar", "wedge", "wedgeq", "weierp"],
    f: ["wfr"],
    o: ["wopf"],
    p: ["wp"],
    r: ["wr", "wreath"],
    s: ["wscr"]
  };
  var x$2 = {
    c: ["xcap", "xcirc", "xcup"],
    d: ["xdtri"],
    f: ["xfr"],
    h: ["xharr"],
    i: ["xi"],
    l: ["xlarr"],
    m: ["xmap"],
    n: ["xnis"],
    o: ["xodot", "xopf", "xoplus", "xotime"],
    r: ["xrarr"],
    s: ["xscr", "xsqcup"],
    u: ["xuplus", "xutri"],
    v: ["xvee"],
    w: ["xwedge"]
  };
  var y$2 = {
    a: ["yacute", "yacy"],
    c: ["ycirc", "ycy"],
    e: ["yen"],
    f: ["yfr"],
    i: ["yicy"],
    o: ["yopf"],
    s: ["yscr"],
    u: ["yucy", "yuml"]
  };
  var z$2 = {
    a: ["zacute"],
    c: ["zcaron", "zcy"],
    d: ["zdot"],
    e: ["zeetrf", "zerowidthspace", "zeta"],
    f: ["zfr"],
    h: ["zhcy"],
    i: ["zigrarr"],
    o: ["zopf"],
    s: ["zscr"],
    w: ["zwj", "zwnj"]
  };
  var startsWithCaseInsensitive = {
    a: a$2,
    b: b$2,
    c: c$2,
    d: d$2,
    e: e$2,
    f: f$2,
    g: g$2,
    h: h$2,
    i: i$2,
    j: j$2,
    k: k$2,
    l: l$2,
    m: m$2,
    n: n$2,
    o: o$2,
    p: p$2,
    q: q$2,
    r: r$2,
    s: s$2,
    t: t$2,
    u: u$2,
    v: v$2,
    w: w$2,
    x: x$2,
    y: y$2,
    z: z$2
  };
  var ac$1 = {
    addAmpIfSemiPresent: "edge only",
    addSemiIfAmpPresent: false
  };
  var acute$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Alpha$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var alpha$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var amp$1 = {
    addAmpIfSemiPresent: "edge only",
    addSemiIfAmpPresent: true
  };
  var And$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var and$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var ange$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var angle$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var angst$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var ap$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ape$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var approx$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Aring$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var aring$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var Ascr$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ascr$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Assign$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ast$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var atilde$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var Backslash$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var barwedge$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var becaus$1 = {
    addAmpIfSemiPresent: true,
    addSemiIfAmpPresent: "edge only"
  };
  var Because$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var because$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var bepsi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Bernoullis$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Beta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var beta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var beth$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var between$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var blank$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var block$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var bot$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var bottom$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var bowtie$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var breve$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var bull$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var bullet$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var bump$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var cacute$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Cap$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var cap$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var capand$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var caps$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var caret$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var caron$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var cedil$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Cedilla$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var cent$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var check$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var checkmark$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Chi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var chi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var cir$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var circ$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var clubs$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var clubsuit$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Colon$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var colon$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Colone$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var colone$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var comma$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var commat$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var comp$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var complement$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var complexes$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var cong$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Congruent$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var conint$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var copf$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var coprod$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var COPY$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var copy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Cross$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var cross$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Cup$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var cup$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var cups$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Dagger$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var dagger$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var daleth$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var darr$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var dash$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var DD$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var dd$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var deg$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Del$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Delta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var delta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var dharr$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var diam$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Diamond$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var diamond$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var diams$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var die$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var digamma$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var disin$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var div$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var divide$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var dollar$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var dopf$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Dot$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var dot$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var dsol$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var dtri$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var easter$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var ecir$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ecolon$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ecy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var edot$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ee$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var efr$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var eg$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var egrave$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var egs$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var el$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ell$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var els$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var empty$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var ENG$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var eng$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var epsi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Epsilon$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var epsilon$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Equal$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var equals$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var equest$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Equilibrium$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var equiv$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var escr$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var esim$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Eta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var eta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ETH$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var eth$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var euro$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var excl$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var exist$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Exists$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var expectation$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var female$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var flat$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var fork$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var frown$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Gamma$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var gamma$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var gap$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var gcy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ge$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var gel$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var geq$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ges$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var gesl$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var gg$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var gl$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var gla$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var gne$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var grave$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var GT$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var gt$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var half$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Hat$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var hearts$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var hopf$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var hyphen$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var ic$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var icy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var iff$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ii$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var image$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var imped$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var int$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var integers$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var iocy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var iogon$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var iota$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var isin$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var it$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Kappa$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var kappa$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var kopf$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Lambda$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var lambda$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var lang$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var lap$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var lat$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var late$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var lates$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var le$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var leg$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var leq$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var les$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var lg$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ll$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var lne$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var lozenge$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var lsh$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var LT$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var lt$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ltimes$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var male$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var malt$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var map$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var marker$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var mid$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var minus$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var models$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var mp$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var mu$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var nang$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nap$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var natural$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var naturals$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var ncy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ne$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nge$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ngt$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ni$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nis$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nle$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nles$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nless$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nlt$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nopf$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Not$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var not$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var nsc$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nsce$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var nu$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var num$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var ogt$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ohm$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var oline$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var olt$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Omega$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var omega$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Omicron$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var omicron$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var oopf$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var opar$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var or$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var order$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var oror$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var orv$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var osol$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var par$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var para$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var parallel$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var part$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var phi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var phone$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Pi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var pi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var pitchfork$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var plus$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var pm$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var popf$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var pound$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var pr$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var prime$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var primes$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var prod$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Product$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var prop$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Proportion$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Proportional$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var psi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var quest$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var QUOT$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var quot$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var race$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var rang$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var range$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var ratio$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Re$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var real$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var reals$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var rect$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var REG$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: true
  };
  var reg$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ring$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var rsh$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var sc$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var scap$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var sce$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var scy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var sdot$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var sect$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var semi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var sharp$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var shy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Sigma$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var sigma$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var sim$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var sol$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var spades$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var square$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Star$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var star$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Sub$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var sub$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var sube$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Sum$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var sum$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Tab$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var target$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Tau$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var tau$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var therefore$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Theta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var theta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var THORN$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var thorn$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Tilde$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var tilde$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var times$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var tint$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var top$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var tosa$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var TRADE$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var trade$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var triangle$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var trie$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ucy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var uml$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Union$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var uplus$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Upsi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var upsi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var uring$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var vee$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Vert$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var vert$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var wedge$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Wedge$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var wreath$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Xi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var xi$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Ycirc$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ycirc$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var ycy$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var yen$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var Zacute$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var zacute$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: "edge only"
  };
  var Zeta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var zeta$1 = {
    addAmpIfSemiPresent: false,
    addSemiIfAmpPresent: false
  };
  var uncertain = {
    ac: ac$1,
    acute: acute$1,
    Alpha: Alpha$1,
    alpha: alpha$1,
    amp: amp$1,
    And: And$1,
    and: and$1,
    ange: ange$1,
    angle: angle$1,
    angst: angst$1,
    ap: ap$1,
    ape: ape$1,
    approx: approx$1,
    Aring: Aring$1,
    aring: aring$1,
    Ascr: Ascr$1,
    ascr: ascr$1,
    Assign: Assign$1,
    ast: ast$1,
    atilde: atilde$1,
    Backslash: Backslash$1,
    barwedge: barwedge$1,
    becaus: becaus$1,
    Because: Because$1,
    because: because$1,
    bepsi: bepsi$1,
    Bernoullis: Bernoullis$1,
    Beta: Beta$1,
    beta: beta$1,
    beth: beth$1,
    between: between$1,
    blank: blank$1,
    block: block$1,
    bot: bot$1,
    bottom: bottom$1,
    bowtie: bowtie$1,
    breve: breve$1,
    bull: bull$1,
    bullet: bullet$1,
    bump: bump$1,
    cacute: cacute$1,
    Cap: Cap$1,
    cap: cap$1,
    capand: capand$1,
    caps: caps$1,
    caret: caret$1,
    caron: caron$1,
    cedil: cedil$1,
    Cedilla: Cedilla$1,
    cent: cent$1,
    check: check$1,
    checkmark: checkmark$1,
    Chi: Chi$1,
    chi: chi$1,
    cir: cir$1,
    circ: circ$1,
    clubs: clubs$1,
    clubsuit: clubsuit$1,
    Colon: Colon$1,
    colon: colon$1,
    Colone: Colone$1,
    colone: colone$1,
    comma: comma$1,
    commat: commat$1,
    comp: comp$1,
    complement: complement$1,
    complexes: complexes$1,
    cong: cong$1,
    Congruent: Congruent$1,
    conint: conint$1,
    copf: copf$1,
    coprod: coprod$1,
    COPY: COPY$1,
    copy: copy$1,
    Cross: Cross$1,
    cross: cross$1,
    Cup: Cup$1,
    cup: cup$1,
    cups: cups$1,
    Dagger: Dagger$1,
    dagger: dagger$1,
    daleth: daleth$1,
    darr: darr$1,
    dash: dash$1,
    DD: DD$1,
    dd: dd$1,
    deg: deg$1,
    Del: Del$1,
    Delta: Delta$1,
    delta: delta$1,
    dharr: dharr$1,
    diam: diam$1,
    Diamond: Diamond$1,
    diamond: diamond$1,
    diams: diams$1,
    die: die$1,
    digamma: digamma$1,
    disin: disin$1,
    div: div$1,
    divide: divide$1,
    dollar: dollar$1,
    dopf: dopf$1,
    Dot: Dot$1,
    dot: dot$1,
    dsol: dsol$1,
    dtri: dtri$1,
    easter: easter$1,
    ecir: ecir$1,
    ecolon: ecolon$1,
    ecy: ecy$1,
    edot: edot$1,
    ee: ee$1,
    efr: efr$1,
    eg: eg$1,
    egrave: egrave$1,
    egs: egs$1,
    el: el$1,
    ell: ell$1,
    els: els$1,
    empty: empty$1,
    ENG: ENG$1,
    eng: eng$1,
    epsi: epsi$1,
    Epsilon: Epsilon$1,
    epsilon: epsilon$1,
    Equal: Equal$1,
    equals: equals$1,
    equest: equest$1,
    Equilibrium: Equilibrium$1,
    equiv: equiv$1,
    escr: escr$1,
    esim: esim$1,
    Eta: Eta$1,
    eta: eta$1,
    ETH: ETH$1,
    eth: eth$1,
    euro: euro$1,
    excl: excl$1,
    exist: exist$1,
    Exists: Exists$1,
    expectation: expectation$1,
    female: female$1,
    flat: flat$1,
    fork: fork$1,
    frown: frown$1,
    Gamma: Gamma$1,
    gamma: gamma$1,
    gap: gap$1,
    gcy: gcy$1,
    ge: ge$1,
    gel: gel$1,
    geq: geq$1,
    ges: ges$1,
    gesl: gesl$1,
    gg: gg$1,
    gl: gl$1,
    gla: gla$1,
    gne: gne$1,
    grave: grave$1,
    GT: GT$1,
    gt: gt$1,
    half: half$1,
    Hat: Hat$1,
    hearts: hearts$1,
    hopf: hopf$1,
    hyphen: hyphen$1,
    ic: ic$1,
    icy: icy$1,
    iff: iff$1,
    ii: ii$1,
    image: image$1,
    imped: imped$1,
    "in": {
      addAmpIfSemiPresent: false,
      addSemiIfAmpPresent: false
    },
    int: int$1,
    integers: integers$1,
    iocy: iocy$1,
    iogon: iogon$1,
    iota: iota$1,
    isin: isin$1,
    it: it$1,
    Kappa: Kappa$1,
    kappa: kappa$1,
    kopf: kopf$1,
    Lambda: Lambda$1,
    lambda: lambda$1,
    lang: lang$1,
    lap: lap$1,
    lat: lat$1,
    late: late$1,
    lates: lates$1,
    le: le$1,
    leg: leg$1,
    leq: leq$1,
    les: les$1,
    lg: lg$1,
    ll: ll$1,
    lne: lne$1,
    lozenge: lozenge$1,
    lsh: lsh$1,
    LT: LT$1,
    lt: lt$1,
    ltimes: ltimes$1,
    male: male$1,
    malt: malt$1,
    map: map$1,
    marker: marker$1,
    mid: mid$1,
    minus: minus$1,
    models: models$1,
    mp: mp$1,
    mu: mu$1,
    nang: nang$1,
    nap: nap$1,
    natural: natural$1,
    naturals: naturals$1,
    ncy: ncy$1,
    ne: ne$1,
    nge: nge$1,
    ngt: ngt$1,
    ni: ni$1,
    nis: nis$1,
    nle: nle$1,
    nles: nles$1,
    nless: nless$1,
    nlt: nlt$1,
    nopf: nopf$1,
    Not: Not$1,
    not: not$1,
    nsc: nsc$1,
    nsce: nsce$1,
    nu: nu$1,
    num: num$1,
    ogt: ogt$1,
    ohm: ohm$1,
    oline: oline$1,
    olt: olt$1,
    Omega: Omega$1,
    omega: omega$1,
    Omicron: Omicron$1,
    omicron: omicron$1,
    oopf: oopf$1,
    opar: opar$1,
    or: or$1,
    order: order$1,
    oror: oror$1,
    orv: orv$1,
    osol: osol$1,
    par: par$1,
    para: para$1,
    parallel: parallel$1,
    part: part$1,
    phi: phi$1,
    phone: phone$1,
    Pi: Pi$1,
    pi: pi$1,
    pitchfork: pitchfork$1,
    plus: plus$1,
    pm: pm$1,
    popf: popf$1,
    pound: pound$1,
    pr: pr$1,
    prime: prime$1,
    primes: primes$1,
    prod: prod$1,
    Product: Product$1,
    prop: prop$1,
    Proportion: Proportion$1,
    Proportional: Proportional$1,
    psi: psi$1,
    quest: quest$1,
    QUOT: QUOT$1,
    quot: quot$1,
    race: race$1,
    rang: rang$1,
    range: range$1,
    ratio: ratio$1,
    Re: Re$1,
    real: real$1,
    reals: reals$1,
    rect: rect$1,
    REG: REG$1,
    reg: reg$1,
    ring: ring$1,
    rsh: rsh$1,
    sc: sc$1,
    scap: scap$1,
    sce: sce$1,
    scy: scy$1,
    sdot: sdot$1,
    sect: sect$1,
    semi: semi$1,
    sharp: sharp$1,
    shy: shy$1,
    Sigma: Sigma$1,
    sigma: sigma$1,
    sim: sim$1,
    sol: sol$1,
    spades: spades$1,
    square: square$1,
    Star: Star$1,
    star: star$1,
    Sub: Sub$1,
    sub: sub$1,
    sube: sube$1,
    Sum: Sum$1,
    sum: sum$1,
    Tab: Tab$1,
    target: target$1,
    Tau: Tau$1,
    tau: tau$1,
    therefore: therefore$1,
    Theta: Theta$1,
    theta: theta$1,
    THORN: THORN$1,
    thorn: thorn$1,
    Tilde: Tilde$1,
    tilde: tilde$1,
    times: times$1,
    tint: tint$1,
    top: top$1,
    tosa: tosa$1,
    TRADE: TRADE$1,
    trade: trade$1,
    triangle: triangle$1,
    trie: trie$1,
    ucy: ucy$1,
    uml: uml$1,
    Union: Union$1,
    uplus: uplus$1,
    Upsi: Upsi$1,
    upsi: upsi$1,
    uring: uring$1,
    vee: vee$1,
    Vert: Vert$1,
    vert: vert$1,
    wedge: wedge$1,
    Wedge: Wedge$1,
    wreath: wreath$1,
    Xi: Xi$1,
    xi: xi$1,
    Ycirc: Ycirc$1,
    ycirc: ycirc$1,
    ycy: ycy$1,
    yen: yen$1,
    Zacute: Zacute$1,
    zacute: zacute$1,
    Zeta: Zeta$1,
    zeta: zeta$1
  };

  function decode(ent) {
    if (typeof ent !== "string" || !ent.length || !ent.startsWith("&") || !ent.endsWith(";")) {
      throw new Error(`all-named-html-entities/decode(): [THROW_ID_01] Input must be an HTML entity with leading ampersand and trailing semicolon, but "${ent}" was given`);
    }

    const val = ent.slice(1, ent.length - 1);
    return allNamedEntities[val] ? allNamedEntities[val] : null;
  }
  const maxLength = 31;

  /**
   * string-left-right
   * Look what's to the left or the right of a given index within a string
   * Version: 2.3.18
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-left-right
   */

  function x$3(something) {
    const res = {
      value: something,
      hungry: false,
      optional: false
    };

    if ((res.value.endsWith("?*") || res.value.endsWith("*?")) && res.value.length > 2) {
      res.value = res.value.slice(0, res.value.length - 2);
      res.optional = true;
      res.hungry = true;
    } else if (res.value.endsWith("?") && res.value.length > 1) {
      res.value = res.value.slice(0, res.value.length - 1);
      res.optional = true;
    } else if (res.value.endsWith("*") && res.value.length > 1) {
      res.value = res.value.slice(0, res.value.length - 1);
      res.hungry = true;
    }

    return res;
  }

  function isNum(something) {
    return typeof something === "number";
  }

  function isStr(something) {
    return typeof something === "string";
  }

  function rightMain(str, idx, stopAtNewlines) {
    if (typeof str !== "string" || !str.length) {
      return null;
    }

    if (!idx || typeof idx !== "number") {
      idx = 0;
    }

    if (!str[idx + 1]) {
      return null;
    } else if (str[idx + 1] && (!stopAtNewlines && str[idx + 1].trim().length || stopAtNewlines && (str[idx + 1].trim().length || "\n\r".includes(str[idx + 1])))) {
      return idx + 1;
    } else if (str[idx + 2] && (!stopAtNewlines && str[idx + 2].trim().length || stopAtNewlines && (str[idx + 2].trim().length || "\n\r".includes(str[idx + 2])))) {
      return idx + 2;
    }

    for (let i = idx + 1, len = str.length; i < len; i++) {
      if (str[i] && (!stopAtNewlines && str[i].trim().length || stopAtNewlines && (str[i].trim().length || "\n\r".includes(str[i])))) {
        return i;
      }
    }

    return null;
  }

  function right(str, idx) {
    return rightMain(str, idx, false);
  }

  function leftMain(str, idx, stopAtNewlines) {
    if (typeof str !== "string" || !str.length) {
      return null;
    }

    if (!idx || typeof idx !== "number") {
      idx = 0;
    }

    if (idx < 1) {
      return null;
    } else if (str[idx - 1] && (!stopAtNewlines && str[idx - 1].trim().length || stopAtNewlines && (str[idx - 1].trim().length || "\n\r".includes(str[idx - 1])))) {
      return idx - 1;
    } else if (str[idx - 2] && (!stopAtNewlines && str[idx - 2].trim().length || stopAtNewlines && (str[idx - 2].trim().length || "\n\r".includes(str[idx - 2])))) {
      return idx - 2;
    }

    for (let i = idx; i--;) {
      if (str[i] && (!stopAtNewlines && str[i].trim().length || stopAtNewlines && (str[i].trim().length || "\n\r".includes(str[i])))) {
        return i;
      }
    }

    return null;
  }

  function left(str, idx) {
    return leftMain(str, idx, false);
  }

  function leftStopAtNewLines(str, idx) {
    return leftMain(str, idx, true);
  }

  function seq(direction, str, idx, opts, args) {
    if (typeof str !== "string" || !str.length) {
      return null;
    }

    if (!idx || typeof idx !== "number") {
      idx = 0;
    }

    if (direction === "right" && !str[idx + 1] || direction === "left" && !str[idx - 1]) {
      return null;
    }

    let lastFinding = idx;
    const gaps = [];
    let leftmostChar;
    let rightmostChar;
    let satiated;
    let i = 0;

    while (i < args.length) {
      if (!isStr(args[i]) || !args[i].length) {
        i++;
        continue;
      }

      const {
        value,
        optional,
        hungry
      } = x$3(args[i]);
      const whattsOnTheSide = direction === "right" ? right(str, lastFinding) : left(str, lastFinding);

      if (opts.i && str[whattsOnTheSide].toLowerCase() === value.toLowerCase() || !opts.i && str[whattsOnTheSide] === value) {
        const temp = direction === "right" ? right(str, whattsOnTheSide) : left(str, whattsOnTheSide);

        if (hungry && (opts.i && str[temp].toLowerCase() === value.toLowerCase() || !opts.i && str[temp] === value)) {
          satiated = true;
        } else {
          i++;
        }

        if (direction === "right" && whattsOnTheSide > lastFinding + 1) {
          gaps.push([lastFinding + 1, whattsOnTheSide]);
        } else if (direction === "left" && whattsOnTheSide < lastFinding - 1) {
          gaps.unshift([whattsOnTheSide + 1, lastFinding]);
        }

        lastFinding = whattsOnTheSide;

        if (direction === "right") {
          if (leftmostChar === undefined) {
            leftmostChar = whattsOnTheSide;
          }

          rightmostChar = whattsOnTheSide;
        } else {
          if (rightmostChar === undefined) {
            rightmostChar = whattsOnTheSide;
          }

          leftmostChar = whattsOnTheSide;
        }
      } else if (optional) {
        i++;
        continue;
      } else if (satiated) {
        i++;
        satiated = undefined;
        continue;
      } else {
        return null;
      }
    }

    if (leftmostChar === undefined) {
      return null;
    }

    return {
      gaps,
      leftmostChar,
      rightmostChar
    };
  }

  function leftSeq(str, idx, ...args) {
    if (!args.length) {
      return left(str, idx);
    }

    const defaults = {
      i: false
    };
    let opts;

    if (lodash_isplainobject(args[0])) {
      opts = Object.assign({}, defaults, args.shift());
    } else {
      opts = defaults;
    }

    return seq("left", str, idx, opts, Array.from(args).reverse());
  }

  function rightSeq(str, idx, ...args) {
    if (!args.length) {
      return right(str, idx);
    }

    const defaults = {
      i: false
    };
    let opts;

    if (lodash_isplainobject(args[0])) {
      opts = Object.assign({}, defaults, args.shift());
    } else {
      opts = defaults;
    }

    return seq("right", str, idx, opts, args);
  }

  function chomp(direction, str, idx, opts, args) {
    if (typeof str !== "string" || !str.length) {
      return null;
    }

    if (!idx || typeof idx !== "number") {
      idx = 0;
    }

    if (direction === "right" && !str[idx + 1] || direction === "left" && (isNum(idx) && idx < 1 || idx === "0")) {
      return null;
    }

    let lastRes = null;
    let lastIdx = null;

    do {
      lastRes = direction === "right" ? rightSeq(str, isNum(lastIdx) ? lastIdx : idx, ...args) : leftSeq(str, isNum(lastIdx) ? lastIdx : idx, ...args);

      if (lastRes !== null) {
        lastIdx = direction === "right" ? lastRes.rightmostChar : lastRes.leftmostChar;
      }
    } while (lastRes);

    if (lastIdx != null && direction === "right") {
      lastIdx++;
    }

    if (lastIdx === null) {
      return null;
    }

    if (direction === "right") {
      if (str[lastIdx] && str[lastIdx].trim().length) {
        return lastIdx;
      }

      const whatsOnTheRight = right(str, lastIdx);

      if (opts.mode === 0) {
        if (whatsOnTheRight === lastIdx + 1) {
          return lastIdx;
        } else if (str.slice(lastIdx, whatsOnTheRight || str.length).trim().length || str.slice(lastIdx, whatsOnTheRight || str.length).includes("\n") || str.slice(lastIdx, whatsOnTheRight || str.length).includes("\r")) {
          for (let y = lastIdx, len = str.length; y < len; y++) {
            if (`\n\r`.includes(str[y])) {
              return y;
            }
          }
        } else {
          return whatsOnTheRight ? whatsOnTheRight - 1 : str.length;
        }
      } else if (opts.mode === 1) {
        return lastIdx;
      } else if (opts.mode === 2) {
        const remainderString = str.slice(lastIdx);

        if (remainderString.trim().length || remainderString.includes("\n") || remainderString.includes("\r")) {
          for (let y = lastIdx, len = str.length; y < len; y++) {
            if (str[y].trim().length || `\n\r`.includes(str[y])) {
              return y;
            }
          }
        }

        return str.length;
      }

      return whatsOnTheRight ? whatsOnTheRight : str.length;
    }

    if (str[lastIdx] && str[lastIdx - 1] && str[lastIdx - 1].trim().length) {
      return lastIdx;
    }

    const whatsOnTheLeft = left(str, lastIdx);

    if (opts.mode === 0) {
      if (whatsOnTheLeft === lastIdx - 2) {
        return lastIdx;
      } else if (str.slice(0, lastIdx).trim().length || str.slice(0, lastIdx).includes("\n") || str.slice(0, lastIdx).includes("\r")) {
        for (let y = lastIdx; y--;) {
          if (`\n\r`.includes(str[y]) || str[y].trim().length) {
            return y + 1 + (str[y].trim().length ? 1 : 0);
          }
        }
      }

      return 0;
    } else if (opts.mode === 1) {
      return lastIdx;
    } else if (opts.mode === 2) {
      const remainderString = str.slice(0, lastIdx);

      if (remainderString.trim().length || remainderString.includes("\n") || remainderString.includes("\r")) {
        for (let y = lastIdx; y--;) {
          if (str[y].trim().length || `\n\r`.includes(str[y])) {
            return y + 1;
          }
        }
      }

      return 0;
    }

    return whatsOnTheLeft !== null ? whatsOnTheLeft + 1 : 0;
  }

  function chompLeft(str, idx, ...args) {
    if (!args.length || args.length === 1 && lodash_isplainobject(args[0])) {
      return null;
    }

    const defaults = {
      mode: 0
    };

    if (lodash_isplainobject(args[0])) {
      const opts = Object.assign({}, defaults, lodash_clonedeep(args[0]));

      if (!opts.mode) {
        opts.mode = 0;
      } else if (isStr(opts.mode) && `0123`.includes(opts.mode)) {
        opts.mode = Number.parseInt(opts.mode, 10);
      } else if (!isNum(opts.mode)) {
        throw new Error(`string-left-right/chompLeft(): [THROW_ID_01] the opts.mode is wrong! It should be 0, 1, 2 or 3. It was given as ${opts.mode} (type ${typeof opts.mode})`);
      }

      return chomp("left", str, idx, opts, lodash_clonedeep(args).slice(1));
    } else if (!isStr(args[0])) {
      return chomp("left", str, idx, defaults, lodash_clonedeep(args).slice(1));
    }

    return chomp("left", str, idx, defaults, lodash_clonedeep(args));
  }

  /**
   * string-fix-broken-named-entities
   * Finds and fixes common and not so common broken named HTML entities, returns ranges array of fixes
   * Version: 2.5.11
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-fix-broken-named-entities
   */
  const isArr = Array.isArray;

  function stringFixBrokenNamedEntities(str, originalOpts) {
    function resemblesNumericEntity(str, from, to) {
      let lettersCount = 0;
      let numbersCount = 0;
      let othersCount = 0;
      let hashesCount = 0;
      let whitespaceCount = 0;
      let numbersValue = "";
      let charTrimmed = "";

      for (let i = from; i < to; i++) {
        if (str[i].trim().length) {
          charTrimmed += str[i];
        } else {
          whitespaceCount++;
        }

        if (isLatinLetter(str[i])) {
          lettersCount++;
        } else if (isNumber(str[i])) {
          numbersCount++;
          numbersValue += String(str[i]);
        } else if (str[i] === "#") {
          hashesCount++;
        } else {
          othersCount++;
        }
      }

      let probablyNumeric = false;

      if (!lettersCount && numbersCount > othersCount) {
        probablyNumeric = "deci";
      } else if ((numbersCount || lettersCount) && (charTrimmed[0] === "#" && charTrimmed[1].toLowerCase() === "x" && (isNumber(charTrimmed[2]) || isLatinLetter(charTrimmed[2])) || charTrimmed[0].toLowerCase() === "x" && numbersCount && !othersCount)) {
        probablyNumeric = "hexi";
      }

      return {
        probablyNumeric,
        lettersCount,
        numbersCount,
        numbersValue,
        hashesCount,
        othersCount,
        charTrimmed,
        whitespaceCount
      };
    }

    function isNotaLetter(str) {
      return !(typeof str === "string" && str.length === 1 && str.toUpperCase() !== str.toLowerCase());
    }

    function isStr(something) {
      return typeof something === "string";
    }

    function isLatinLetter(something) {
      return typeof something === "string" && (something.charCodeAt(0) > 96 && something.charCodeAt(0) < 123 || something.charCodeAt(0) > 64 && something.charCodeAt(0) < 91);
    }

    function isLatinLetterOrNumberOrHash(char) {
      return isStr(char) && char.length === 1 && (char.charCodeAt(0) > 96 && char.charCodeAt(0) < 123 || char.charCodeAt(0) > 47 && char.charCodeAt(0) < 58 || char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91 || char.charCodeAt(0) === 35);
    }

    function isNumber(something) {
      return isStr(something) && something.charCodeAt(0) > 47 && something.charCodeAt(0) < 58;
    }

    function onlyContainsNbsp(str, from, to) {
      for (let i = from; i < to; i++) {
        if (str[i].trim().length && !`nbsp`.includes(str[i].toLowerCase())) {
          return false;
        }
      }

      return true;
    }

    function findLongest(temp1) {
      if (isArr(temp1) && temp1.length) {
        if (temp1.length === 1) {
          return temp1[0];
        }

        return temp1.reduce((accum, tempObj) => {
          if (tempObj.tempEnt.length > accum.tempEnt.length) {
            return tempObj;
          }

          return accum;
        });
      }

      return temp1;
    }

    function removeGappedFromMixedCases(temp1) {
      let copy;

      if (isArr(temp1) && temp1.length) {
        copy = Array.from(temp1);

        if (copy.length > 1 && copy.some(entityObj => str[right(str, entityObj.tempRes.rightmostChar)] === ";") && copy.some(entityObj => str[right(str, entityObj.tempRes.rightmostChar)] !== ";")) {
          copy = copy.filter(entityObj => str[right(str, entityObj.tempRes.rightmostChar)] === ";");
        }

        if (!(copy.every(entObj => !entObj || !entObj.tempRes || !entObj.tempRes.gaps || !isArr(entObj.tempRes.gaps) || !entObj.tempRes.gaps.length) || copy.every(entObj => entObj && entObj.tempRes && entObj.tempRes.gaps && isArr(entObj.tempRes.gaps) && entObj.tempRes.gaps.length))) {
          return findLongest(copy.filter(entObj => !entObj.tempRes.gaps || !isArr(entObj.tempRes.gaps) || !entObj.tempRes.gaps.length));
        }
      }

      return findLongest(temp1);
    }

    if (typeof str !== "string") {
      throw new Error(`string-fix-broken-named-entities: [THROW_ID_01] the first input argument must be string! It was given as:\n${JSON.stringify(str, null, 4)} (${typeof str}-type)`);
    }

    const defaults = {
      decode: false,
      cb: ({
        rangeFrom,
        rangeTo,
        rangeValEncoded,
        rangeValDecoded
      }) => rangeValDecoded || rangeValEncoded ? [rangeFrom, rangeTo, opts.decode ? rangeValDecoded : rangeValEncoded] : [rangeFrom, rangeTo],
      progressFn: null,
      entityCatcherCb: null
    };
    let opts;

    if (originalOpts != null) {
      if (!lodash_isplainobject(originalOpts)) {
        throw new Error(`string-fix-broken-named-entities: [THROW_ID_02] the second input argument must be a plain object! I was given as:\n${JSON.stringify(originalOpts, null, 4)} (${typeof originalOpts}-type)`);
      } else {
        opts = Object.assign({}, defaults, originalOpts);
      }
    } else {
      opts = defaults;
    }

    if (opts.cb && typeof opts.cb !== "function") {
      throw new TypeError(`string-fix-broken-named-entities: [THROW_ID_03] opts.cb must be a function (or falsey)! Currently it's: ${typeof opts.cb}, equal to: ${JSON.stringify(opts.cb, null, 4)}`);
    }

    if (opts.entityCatcherCb && typeof opts.entityCatcherCb !== "function") {
      throw new TypeError(`string-fix-broken-named-entities: [THROW_ID_03] opts.entityCatcherCb must be a function (or falsey)! Currently it's: ${typeof opts.entityCatcherCb}, equal to: ${JSON.stringify(opts.entityCatcherCb, null, 4)}`);
    }

    if (opts.progressFn && typeof opts.progressFn !== "function") {
      throw new TypeError(`string-fix-broken-named-entities: [THROW_ID_04] opts.progressFn must be a function (or falsey)! Currently it's: ${typeof opts.progressFn}, equal to: ${JSON.stringify(opts.progressFn, null, 4)}`);
    }

    let state_AmpersandNotNeeded = false;
    const nbspDefault = {
      nameStartsAt: null,
      ampersandNecessary: null,
      patience: 1,
      matchedN: null,
      matchedB: null,
      matchedS: null,
      matchedP: null,
      matchedSemicol: null
    };
    let nbsp = lodash_clonedeep(nbspDefault);

    const nbspWipe = () => {
      nbsp = lodash_clonedeep(nbspDefault);
    };

    const rangesArr2 = [];
    let smallestCharFromTheSetAt;
    let largestCharFromTheSetAt;
    let matchedLettersCount;
    let setOfValues;
    let percentageDone;
    let lastPercentageDone;
    const len = str.length + 1;
    let counter = 0;
    let doNothingUntil = null;
    let letterSeqStartAt = null;
    let brokenNumericEntityStartAt = null;
    const falsePositivesArr = ["&nspar;", "&prnsim;", "&subplus;"];

    outerloop: for (let i = 0; i < len; i++) {
      if (opts.progressFn) {
        percentageDone = Math.floor(counter / len * 100);

        if (percentageDone !== lastPercentageDone) {
          lastPercentageDone = percentageDone;
          opts.progressFn(percentageDone);
        }
      }

      if (doNothingUntil) {
        if (doNothingUntil !== true && i >= doNothingUntil) {
          doNothingUntil = null;
        } else {
          counter++;
          continue;
        }
      }

      matchedLettersCount = (nbsp.matchedN !== null ? 1 : 0) + (nbsp.matchedB !== null ? 1 : 0) + (nbsp.matchedS !== null ? 1 : 0) + (nbsp.matchedP !== null ? 1 : 0);
      setOfValues = [nbsp.matchedN, nbsp.matchedB, nbsp.matchedS, nbsp.matchedP].filter(val => val !== null);
      smallestCharFromTheSetAt = Math.min(...setOfValues);
      largestCharFromTheSetAt = Math.max(...setOfValues);

      if (nbsp.nameStartsAt !== null && matchedLettersCount > 2 && (nbsp.matchedSemicol !== null || !nbsp.ampersandNecessary || isNotaLetter(str[nbsp.nameStartsAt - 1]) && isNotaLetter(str[i]) || (isNotaLetter(str[nbsp.nameStartsAt - 1]) || isNotaLetter(str[i])) && largestCharFromTheSetAt - smallestCharFromTheSetAt <= 4 || nbsp.matchedN !== null && nbsp.matchedB !== null && nbsp.matchedS !== null && nbsp.matchedP !== null && nbsp.matchedN + 1 === nbsp.matchedB && nbsp.matchedB + 1 === nbsp.matchedS && nbsp.matchedS + 1 === nbsp.matchedP) && (!str[i] || nbsp.matchedN !== null && nbsp.matchedB !== null && nbsp.matchedS !== null && nbsp.matchedP !== null && str[i] !== str[i - 1] || str[i].toLowerCase() !== "n" && str[i].toLowerCase() !== "b" && str[i].toLowerCase() !== "s" && str[i].toLowerCase() !== "p" || str[left(str, i)] === ";") && str[i] !== ";" && (str[i + 1] === undefined || str[right(str, i)] !== ";") && (nbsp.matchedB !== null || !(str[smallestCharFromTheSetAt].toLowerCase() === "n" && str[left(str, smallestCharFromTheSetAt)] && str[left(str, smallestCharFromTheSetAt)].toLowerCase() === "e") && !(nbsp.matchedN !== null && rightSeq(str, nbsp.matchedN, {
        i: true
      }, "s", "u", "p")) && str[right(str, nbsp.matchedN)].toLowerCase() !== "c") && (nbsp.matchedB === null || onlyContainsNbsp(str, smallestCharFromTheSetAt, largestCharFromTheSetAt + 1) || !(str[smallestCharFromTheSetAt] && str[largestCharFromTheSetAt] && str[smallestCharFromTheSetAt].toLowerCase() === "n" && str[largestCharFromTheSetAt].toLowerCase() === "b"))) {
        const chompedAmpFromLeft = chompLeft(str, nbsp.nameStartsAt, "&?", "a", "m", "p", ";?");
        const beginningOfTheRange = chompedAmpFromLeft ? chompedAmpFromLeft : nbsp.nameStartsAt;

        if (!falsePositivesArr.some(val => str.slice(beginningOfTheRange).startsWith(val)) && str.slice(beginningOfTheRange, i) !== "&nbsp;") {
          rangesArr2.push({
            ruleName: "bad-named-html-entity-malformed-nbsp",
            entityName: "nbsp",
            rangeFrom: beginningOfTheRange,
            rangeTo: i,
            rangeValEncoded: "&nbsp;",
            rangeValDecoded: "\xA0"
          });
        } else {
          if (opts.decode) {
            rangesArr2.push({
              ruleName: "encoded-html-entity-nbsp",
              entityName: "nbsp",
              rangeFrom: beginningOfTheRange,
              rangeTo: i,
              rangeValEncoded: "&nbsp;",
              rangeValDecoded: "\xA0"
            });
          } else if (opts.entityCatcherCb) {
            opts.entityCatcherCb(beginningOfTheRange, i);
          }
        }

        nbspWipe();
        counter++;

        if (str[i] === "&" && str[i + 1] !== "&") {
          nbsp.nameStartsAt = i;
          nbsp.ampersandNecessary = false;
        }

        continue outerloop;
      }

      if (str[i] && str[i - 1] === ";" && !leftSeq(str, i - 1, "a", "m", "p") && str[i] !== ";" && matchedLettersCount > 0) {
        nbspWipe();
        counter++;
        continue outerloop;
      }

      if (letterSeqStartAt !== null && (!str[i] || str[i].trim().length && !isLatinLetterOrNumberOrHash(str[i]))) {
        if (i > letterSeqStartAt + 1 && str.slice(letterSeqStartAt - 1, i + 1) !== "&nbsp;") {
          const potentialEntity = str.slice(letterSeqStartAt, i);
          const whatsOnTheLeft = left(str, letterSeqStartAt);
          const whatsEvenMoreToTheLeft = whatsOnTheLeft ? left(str, whatsOnTheLeft) : "";

          if (str[whatsOnTheLeft] === "&" && (!str[i] || str[i] !== ";")) {
            const firstChar = letterSeqStartAt;
            const secondChar = letterSeqStartAt ? right(str, letterSeqStartAt) : null;

            if (Object.prototype.hasOwnProperty.call(startsWith, str[firstChar]) && Object.prototype.hasOwnProperty.call(startsWith[str[firstChar]], str[secondChar])) {
              let tempEnt;
              let tempRes;
              let temp1 = startsWith[str[firstChar]][str[secondChar]].reduce((gatheredSoFar, oneOfKnownEntities) => {
                const tempRes = rightSeq(str, letterSeqStartAt - 1, ...oneOfKnownEntities.split(""));

                if (tempRes && oneOfKnownEntities !== "nbsp") {
                  return gatheredSoFar.concat([{
                    tempEnt: oneOfKnownEntities,
                    tempRes
                  }]);
                }

                return gatheredSoFar;
              }, []);
              temp1 = removeGappedFromMixedCases(temp1);

              if (temp1) {
                ({
                  tempEnt,
                  tempRes
                } = temp1);
              }

              if (tempEnt && (!Object.keys(uncertain).includes(tempEnt) || !str[tempRes.rightmostChar + 1] || ["&"].includes(str[tempRes.rightmostChar + 1]) || (uncertain[tempEnt].addSemiIfAmpPresent === true || uncertain[tempEnt].addSemiIfAmpPresent && (!str[tempRes.rightmostChar + 1] || !str[tempRes.rightmostChar + 1].trim().length)) && str[tempRes.leftmostChar - 1] === "&")) {
                const decodedEntity = decode(`&${tempEnt};`);
                rangesArr2.push({
                  ruleName: `bad-named-html-entity-malformed-${tempEnt}`,
                  entityName: tempEnt,
                  rangeFrom: whatsOnTheLeft,
                  rangeTo: tempRes.rightmostChar + 1,
                  rangeValEncoded: `&${tempEnt};`,
                  rangeValDecoded: decodedEntity
                });
              }
            }
          } else if (str[whatsOnTheLeft] !== "&" && str[whatsEvenMoreToTheLeft] !== "&" && str[i] === ";") {
            const lastChar = left(str, i);
            const secondToLast = lastChar ? left(str, lastChar) : null;

            if (secondToLast !== null && Object.prototype.hasOwnProperty.call(endsWith, str[lastChar]) && Object.prototype.hasOwnProperty.call(endsWith[str[lastChar]], str[secondToLast])) {
              let tempEnt;
              let tempRes;
              let temp1 = endsWith[str[lastChar]][str[secondToLast]].reduce((gatheredSoFar, oneOfKnownEntities) => {
                const tempRes = leftSeq(str, i, ...oneOfKnownEntities.split(""));

                if (tempRes && oneOfKnownEntities !== "nbsp" && !(oneOfKnownEntities === "block" && str[left(str, letterSeqStartAt)] === ":")) {
                  return gatheredSoFar.concat([{
                    tempEnt: oneOfKnownEntities,
                    tempRes
                  }]);
                }

                return gatheredSoFar;
              }, []);
              temp1 = removeGappedFromMixedCases(temp1);

              if (temp1) {
                ({
                  tempEnt,
                  tempRes
                } = temp1);
              }

              if (tempEnt && (!Object.keys(uncertain).includes(tempEnt) || uncertain[tempEnt].addAmpIfSemiPresent === true || uncertain[tempEnt].addAmpIfSemiPresent && (!tempRes.leftmostChar || isStr(str[tempRes.leftmostChar - 1]) && !str[tempRes.leftmostChar - 1].trim().length))) {
                const decodedEntity = decode(`&${tempEnt};`);
                rangesArr2.push({
                  ruleName: `bad-named-html-entity-malformed-${tempEnt}`,
                  entityName: tempEnt,
                  rangeFrom: tempRes.leftmostChar,
                  rangeTo: i + 1,
                  rangeValEncoded: `&${tempEnt};`,
                  rangeValDecoded: decodedEntity
                });
              }
            } else if (brokenNumericEntityStartAt !== null) {
              rangesArr2.push({
                ruleName: "bad-malformed-numeric-character-entity",
                entityName: null,
                rangeFrom: brokenNumericEntityStartAt,
                rangeTo: i + 1,
                rangeValEncoded: null,
                rangeValDecoded: null
              });
              brokenNumericEntityStartAt = null;
            }
          } else if (str[whatsOnTheLeft] === "&" && str[i] === ";") {
            if (str.slice(whatsOnTheLeft + 1, i).trim().length > 1) {
              const situation = resemblesNumericEntity(str, whatsOnTheLeft + 1, i);

              if (situation.probablyNumeric) {
                if (situation.probablyNumeric && situation.charTrimmed[0] === "#" && !situation.whitespaceCount && (!situation.lettersCount && situation.numbersCount > 0 && !situation.othersCount || (situation.numbersCount || situation.lettersCount) && situation.charTrimmed[1] === "x" && !situation.othersCount)) {
                  const decodedEntitysValue = String.fromCharCode(parseInt(situation.charTrimmed.slice(situation.probablyNumeric === "deci" ? 1 : 2), situation.probablyNumeric === "deci" ? 10 : 16));

                  if (situation.probablyNumeric === "deci" && parseInt(situation.numbersValue, 10) > 918015) {
                    rangesArr2.push({
                      ruleName: `bad-malformed-numeric-character-entity`,
                      entityName: null,
                      rangeFrom: whatsOnTheLeft,
                      rangeTo: i + 1,
                      rangeValEncoded: null,
                      rangeValDecoded: null
                    });
                  } else if (opts.decode) {
                    rangesArr2.push({
                      ruleName: `encoded-numeric-html-entity-reference`,
                      entityName: situation.charTrimmed,
                      rangeFrom: whatsOnTheLeft,
                      rangeTo: i + 1,
                      rangeValEncoded: `&${situation.charTrimmed};`,
                      rangeValDecoded: decodedEntitysValue
                    });
                  }
                } else {
                  rangesArr2.push({
                    ruleName: `bad-malformed-numeric-character-entity`,
                    entityName: null,
                    rangeFrom: whatsOnTheLeft,
                    rangeTo: i + 1,
                    rangeValEncoded: null,
                    rangeValDecoded: null
                  });
                }

                if (opts.entityCatcherCb) {
                  opts.entityCatcherCb(whatsOnTheLeft, i + 1);
                }
              } else {
                const firstChar = letterSeqStartAt;
                const secondChar = letterSeqStartAt ? right(str, letterSeqStartAt) : null;
                let tempEnt;

                if (Object.prototype.hasOwnProperty.call(brokenNamedEntities, situation.charTrimmed.toLowerCase())) {
                  tempEnt = situation.charTrimmed;
                  const decodedEntity = decode(`&${brokenNamedEntities[situation.charTrimmed.toLowerCase()]};`);
                  rangesArr2.push({
                    ruleName: `bad-named-html-entity-malformed-${brokenNamedEntities[situation.charTrimmed.toLowerCase()]}`,
                    entityName: brokenNamedEntities[situation.charTrimmed.toLowerCase()],
                    rangeFrom: whatsOnTheLeft,
                    rangeTo: i + 1,
                    rangeValEncoded: `&${brokenNamedEntities[situation.charTrimmed.toLowerCase()]};`,
                    rangeValDecoded: decodedEntity
                  });
                } else if (Object.prototype.hasOwnProperty.call(startsWithCaseInsensitive, str[firstChar].toLowerCase()) && Object.prototype.hasOwnProperty.call(startsWithCaseInsensitive[str[firstChar].toLowerCase()], str[secondChar].toLowerCase())) {
                  let tempRes;
                  let matchedEntity = startsWithCaseInsensitive[str[firstChar].toLowerCase()][str[secondChar].toLowerCase()].reduce((gatheredSoFar, oneOfKnownEntities) => {
                    const tempRes = rightSeq(str, letterSeqStartAt - 1, {
                      i: true
                    }, ...oneOfKnownEntities.split(""));

                    if (tempRes && oneOfKnownEntities !== "nbsp") {
                      return gatheredSoFar.concat([{
                        tempEnt: oneOfKnownEntities,
                        tempRes
                      }]);
                    }

                    return gatheredSoFar;
                  }, []);
                  matchedEntity = removeGappedFromMixedCases(matchedEntity);

                  if (matchedEntity) {
                    ({
                      tempEnt,
                      tempRes
                    } = matchedEntity);
                  }

                  let entitysValue;

                  if (tempEnt) {
                    let issue = false;
                    const firstChar = tempRes.leftmostChar;
                    const secondChar = right(str, firstChar);

                    if (Object.keys(uncertain).includes(potentialEntity) && isStr(str[firstChar - 1]) && !str[firstChar - 1].trim().length && uncertain[potentialEntity].addAmpIfSemiPresent !== true) {
                      letterSeqStartAt = null;
                      continue;
                    }

                    if (Object.prototype.hasOwnProperty.call(startsWith, str[firstChar]) && Object.prototype.hasOwnProperty.call(startsWith[str[firstChar]], str[secondChar]) && startsWith[str[firstChar]][str[secondChar]].includes(situation.charTrimmed)) {
                      entitysValue = situation.charTrimmed;

                      if (i - whatsOnTheLeft - 1 === tempEnt.length) {
                        if (opts.decode) {
                          issue = "encoded-html-entity";
                        }
                      } else {
                        issue = "bad-named-html-entity-malformed";
                      }
                    } else {
                      issue = "bad-named-html-entity-malformed";
                      const matchingEntities = Object.keys(allNamedEntities).filter(entity => situation.charTrimmed.toLowerCase().startsWith(entity.toLowerCase()));

                      if (matchingEntities.length === 1) {
                        entitysValue = matchingEntities[0];
                      } else {
                        const filterLongest = matchingEntities.reduce((accum, curr) => {
                          if (!accum.length || curr.length === accum[0].length) {
                            return accum.concat([curr]);
                          }

                          if (curr.length > accum[0].length) {
                            return [curr];
                          }

                          return accum;
                        }, []);

                        if (filterLongest.length === 1) {
                          entitysValue = filterLongest[0];
                        } else {
                          const missingLetters = filterLongest.map(entity => {
                            let count = 0;

                            for (let z = 0, len = entity.length; z < len; z++) {
                              if (entity[z] !== situation.charTrimmed[z]) {
                                count++;
                              }
                            }

                            return count;
                          });

                          if (missingLetters.filter(val => val === Math.min(...missingLetters)).length > 1) {
                            rangesArr2.push({
                              ruleName: `bad-named-html-entity-unrecognised`,
                              entityName: null,
                              rangeFrom: whatsOnTheLeft,
                              rangeTo: tempRes.rightmostChar + 1 === i ? i + 1 : tempRes.rightmostChar + 1,
                              rangeValEncoded: null,
                              rangeValDecoded: null
                            });
                            issue = false;
                          }

                          entitysValue = filterLongest[missingLetters.indexOf(Math.min(...missingLetters))];
                        }
                      }
                    }

                    let endingIdx = tempRes.rightmostChar + 1 === i ? i + 1 : tempRes.rightmostChar + 1;

                    if (issue) {
                      const decodedEntity = decode(`&${entitysValue};`);

                      if (str[endingIdx] && str[endingIdx] !== ";" && !str[endingIdx].trim().length && str[right(str, endingIdx)] === ";") {
                        endingIdx = right(str, endingIdx) + 1;
                      }

                      rangesArr2.push({
                        ruleName: `${issue}-${entitysValue}`,
                        entityName: entitysValue,
                        rangeFrom: whatsOnTheLeft,
                        rangeTo: endingIdx,
                        rangeValEncoded: `&${entitysValue};`,
                        rangeValDecoded: decodedEntity
                      });
                    }

                    if (opts.entityCatcherCb) {
                      opts.entityCatcherCb(whatsOnTheLeft, endingIdx);
                    }
                  }
                }

                if (!tempEnt) {
                  if (situation.charTrimmed.toLowerCase() !== "&nbsp;") {
                    rangesArr2.push({
                      ruleName: `bad-named-html-entity-unrecognised`,
                      entityName: null,
                      rangeFrom: whatsOnTheLeft,
                      rangeTo: i + 1,
                      rangeValEncoded: null,
                      rangeValDecoded: null
                    });
                  }
                }
              }
            }
          } else if (str[whatsEvenMoreToTheLeft] === "&" && str[i] === ";" && i - whatsEvenMoreToTheLeft < maxLength) {
            const situation = resemblesNumericEntity(str, whatsEvenMoreToTheLeft + 1, i);
            rangesArr2.push({
              ruleName: `${situation.probablyNumeric ? "bad-malformed-numeric-character-entity" : "bad-named-html-entity-unrecognised"}`,
              entityName: null,
              rangeFrom: whatsEvenMoreToTheLeft,
              rangeTo: i + 1,
              rangeValEncoded: null,
              rangeValDecoded: null
            });
          }
        }

        letterSeqStartAt = null;
      }

      if (letterSeqStartAt === null && isLatinLetterOrNumberOrHash(str[i]) && str[i + 1]) {
        letterSeqStartAt = i;
      }

      if (str[i] === "a") {
        const singleAmpOnTheRight = rightSeq(str, i, "m", "p", ";");

        if (singleAmpOnTheRight) {
          let toDeleteAllAmpEndHere = singleAmpOnTheRight.rightmostChar + 1;
          const nextAmpOnTheRight = rightSeq(str, singleAmpOnTheRight.rightmostChar, "a", "m", "p", ";");

          if (nextAmpOnTheRight) {
            toDeleteAllAmpEndHere = nextAmpOnTheRight.rightmostChar + 1;
            let temp;

            do {
              temp = rightSeq(str, toDeleteAllAmpEndHere - 1, "a", "m", "p", ";");

              if (temp) {
                toDeleteAllAmpEndHere = temp.rightmostChar + 1;
              }
            } while (temp);
          }

          const firstCharThatFollows = right(str, toDeleteAllAmpEndHere - 1);
          const secondCharThatFollows = firstCharThatFollows ? right(str, firstCharThatFollows) : null;
          let matchedTemp;

          if (secondCharThatFollows && Object.prototype.hasOwnProperty.call(startsWith, str[firstCharThatFollows]) && Object.prototype.hasOwnProperty.call(startsWith[str[firstCharThatFollows]], str[secondCharThatFollows]) && startsWith[str[firstCharThatFollows]][str[secondCharThatFollows]].some(entity => {
            const matchEntityOnTheRight = rightSeq(str, toDeleteAllAmpEndHere - 1, ...entity.slice(""));

            if (matchEntityOnTheRight) {
              matchedTemp = entity;
              return true;
            }
          })) {
            doNothingUntil = firstCharThatFollows + matchedTemp.length + 1;
            const whatsOnTheLeft = left(str, i);

            if (str[whatsOnTheLeft] === "&") {
              rangesArr2.push({
                ruleName: "bad-named-html-entity-multiple-encoding",
                entityName: matchedTemp,
                rangeFrom: whatsOnTheLeft,
                rangeTo: doNothingUntil,
                rangeValEncoded: `&${matchedTemp};`,
                rangeValDecoded: decode(`&${matchedTemp};`)
              });
            } else if (whatsOnTheLeft) {
              const rangeFrom = i;
              const spaceReplacement = "";
              if (str[i - 1] === " ") ;

              if (opts.cb) {
                rangesArr2.push({
                  ruleName: "bad-named-html-entity-multiple-encoding",
                  entityName: matchedTemp,
                  rangeFrom: rangeFrom,
                  rangeTo: doNothingUntil,
                  rangeValEncoded: `${spaceReplacement}&${matchedTemp};`,
                  rangeValDecoded: `${spaceReplacement}${decode(`&${matchedTemp};`)}`
                });
              }
            }
          }
        }
      }

      if (str[i] === "&") {
        if (nbsp.nameStartsAt && nbsp.nameStartsAt < i && (nbsp.matchedN || nbsp.matchedB || nbsp.matchedS || nbsp.matchedP)) {
          nbspWipe();
        }

        nbsp.nameStartsAt = i;
        nbsp.ampersandNecessary = false;
      }

      if (str[i] && str[i].toLowerCase() === "n") {
        if (str[i - 1] && str[i - 1].toLowerCase() === "i" && str[i + 1] && str[i + 1].toLowerCase() === "s") {
          nbspWipe();
          counter++;
          continue outerloop;
        }

        if (nbsp.matchedN === null) {
          nbsp.matchedN = i;
        }

        if (nbsp.nameStartsAt === null) {
          nbsp.nameStartsAt = i;

          if (nbsp.ampersandNecessary === null && !state_AmpersandNotNeeded) {
            nbsp.ampersandNecessary = true;
          } else if (nbsp.ampersandNecessary !== true) {
            nbsp.ampersandNecessary = false;
          }
        }
      }

      if (str[i] && str[i].toLowerCase() === "b") {
        if (nbsp.nameStartsAt !== null) {
          if (nbsp.matchedB === null) {
            nbsp.matchedB = i;
          }
        } else if (nbsp.patience) {
          nbsp.patience--;
          nbsp.nameStartsAt = i;
          nbsp.matchedB = i;

          if (nbsp.ampersandNecessary === null && !state_AmpersandNotNeeded) {
            nbsp.ampersandNecessary = true;
          } else if (nbsp.ampersandNecessary !== true) {
            nbsp.ampersandNecessary = false;
          }
        } else {
          nbspWipe();
          counter++;
          continue outerloop;
        }
      }

      if (str[i] && str[i].toLowerCase() === "s") {
        if (nbsp.nameStartsAt !== null) {
          if (nbsp.matchedS === null) {
            nbsp.matchedS = i;
          }
        } else if (nbsp.patience) {
          nbsp.patience--;
          nbsp.nameStartsAt = i;
          nbsp.matchedS = i;

          if (nbsp.ampersandNecessary === null && !state_AmpersandNotNeeded) {
            nbsp.ampersandNecessary = true;
          } else if (nbsp.ampersandNecessary !== true) {
            nbsp.ampersandNecessary = false;
          }
        } else {
          nbspWipe();
          counter++;
          continue outerloop;
        }
      }

      if (str[i] && str[i].toLowerCase() === "p") {
        if (leftSeq(str, i, "t", "h", "i", "n", "s")) {
          nbspWipe();
        } else if (nbsp.nameStartsAt !== null) {
          if (nbsp.matchedP === null) {
            nbsp.matchedP = i;
          }
        } else if (nbsp.patience) {
          nbsp.patience--;
          nbsp.nameStartsAt = i;
          nbsp.matchedP = i;

          if (nbsp.ampersandNecessary === null && !state_AmpersandNotNeeded) {
            nbsp.ampersandNecessary = true;
          } else if (nbsp.ampersandNecessary !== true) {
            nbsp.ampersandNecessary = false;
          }
        } else {
          nbspWipe();
          counter++;
          continue outerloop;
        }
      }

      if (str[i] === ";") {
        if (nbsp.nameStartsAt !== null) {
          nbsp.matchedSemicol = i;

          if (nbsp.matchedN && !nbsp.matchedB && !nbsp.matchedS && !nbsp.matchedP || !nbsp.matchedN && nbsp.matchedB && !nbsp.matchedS && !nbsp.matchedP || !nbsp.matchedN && !nbsp.matchedB && nbsp.matchedS && !nbsp.matchedP || !nbsp.matchedN && !nbsp.matchedB && !nbsp.matchedS && nbsp.matchedP) {
            nbspWipe();
          }
        }
      }

      if (str[i] === "#" && right(str, i) && str[right(str, i)].toLowerCase() === "x" && (!str[i - 1] || !left(str, i) || str[left(str, i)] !== "&")) {
        if (isNumber(str[right(str, right(str, i))])) {
          brokenNumericEntityStartAt = i;
        }
      }

      if (nbsp.nameStartsAt !== null && i > nbsp.nameStartsAt && str[i] && str[i].toLowerCase() !== "n" && str[i].toLowerCase() !== "b" && str[i].toLowerCase() !== "s" && str[i].toLowerCase() !== "p" && str[i] !== "&" && str[i] !== ";" && str[i] !== " ") {
        if (nbsp.patience) {
          nbsp.patience = nbsp.patience - 1;
        } else {
          nbspWipe();
          counter++;
          continue outerloop;
        }
      }

      counter++;
    }

    if (!rangesArr2.length) {
      return [];
    }

    const res = rangesArr2.filter((filteredRangeObj, i) => {
      return rangesArr2.every((oneOfEveryObj, y) => {
        return i === y || !(filteredRangeObj.rangeFrom >= oneOfEveryObj.rangeFrom && filteredRangeObj.rangeTo < oneOfEveryObj.rangeTo);
      });
    }).filter((filteredRangeObj, i, allRangesArr) => {
      if (filteredRangeObj.ruleName === "bad-named-html-entity-unrecognised" && allRangesArr.some((oneRangeObj, y) => {
        return i !== y && oneRangeObj.rangeFrom <= filteredRangeObj.rangeFrom && oneRangeObj.rangeTo === filteredRangeObj.rangeTo;
      })) {
        return false;
      }

      return true;
    }).map(opts.cb);
    return res;
  }

  var defineLazyProp = (object, propertyName, fn) => {
    const define = value => Object.defineProperty(object, propertyName, {
      value,
      enumerable: true,
      writable: true
    });

    Object.defineProperty(object, propertyName, {
      configurable: true,
      enumerable: true,

      get() {
        const result = fn();
        define(result);
        return result;
      },

      set(value) {
        define(value);
      }

    });
    return object;
  };

  var allBadCharacterRules = [
  	"bad-character-acknowledge",
  	"bad-character-activate-arabic-form-shaping",
  	"bad-character-activate-symmetric-swapping",
  	"bad-character-application-program-command",
  	"bad-character-backspace",
  	"bad-character-bell",
  	"bad-character-break-permitted-here",
  	"bad-character-cancel",
  	"bad-character-cancel-character",
  	"bad-character-character-tabulation-set",
  	"bad-character-character-tabulation-with-justification",
  	"bad-character-control-0080",
  	"bad-character-control-0081",
  	"bad-character-control-0084",
  	"bad-character-control-0099",
  	"bad-character-control-sequence-introducer",
  	"bad-character-data-link-escape",
  	"bad-character-delete",
  	"bad-character-device-control-four",
  	"bad-character-device-control-one",
  	"bad-character-device-control-string",
  	"bad-character-device-control-three",
  	"bad-character-device-control-two",
  	"bad-character-em-quad",
  	"bad-character-em-space",
  	"bad-character-en-quad",
  	"bad-character-en-space",
  	"bad-character-end-of-medium",
  	"bad-character-end-of-protected-area",
  	"bad-character-end-of-selected-area",
  	"bad-character-end-of-text",
  	"bad-character-end-of-transmission",
  	"bad-character-end-of-transmission-block",
  	"bad-character-enquiry",
  	"bad-character-escape",
  	"bad-character-figure-space",
  	"bad-character-first-strong-isolate",
  	"bad-character-form-feed",
  	"bad-character-four-per-em-space",
  	"bad-character-function-application",
  	"bad-character-hair-space",
  	"bad-character-ideographic-space",
  	"bad-character-information-separator-four",
  	"bad-character-information-separator-one",
  	"bad-character-information-separator-three",
  	"bad-character-information-separator-two",
  	"bad-character-inhibit-arabic-form-shaping",
  	"bad-character-inhibit-symmetric-swapping",
  	"bad-character-interlinear-annotation-anchor",
  	"bad-character-interlinear-annotation-separator",
  	"bad-character-interlinear-annotation-terminator",
  	"bad-character-invisible-plus",
  	"bad-character-invisible-separator",
  	"bad-character-invisible-times",
  	"bad-character-left-to-right-embedding",
  	"bad-character-left-to-right-isolate",
  	"bad-character-left-to-right-mark",
  	"bad-character-left-to-right-override",
  	"bad-character-line-separator",
  	"bad-character-line-tabulation",
  	"bad-character-line-tabulation-set",
  	"bad-character-medium-mathematical-space",
  	"bad-character-message-waiting",
  	"bad-character-narrow-no-break-space",
  	"bad-character-national-digit-shapes",
  	"bad-character-negative-acknowledge",
  	"bad-character-next-line",
  	"bad-character-no-break-here",
  	"bad-character-nominal-digit-shapes",
  	"bad-character-non-breaking-space",
  	"bad-character-null",
  	"bad-character-ogham-space-mark",
  	"bad-character-operating-system-command",
  	"bad-character-paragraph-separator",
  	"bad-character-partial-line-backward",
  	"bad-character-partial-line-forward",
  	"bad-character-pop-directional-formatting",
  	"bad-character-pop-directional-isolate",
  	"bad-character-private-message",
  	"bad-character-private-use-1",
  	"bad-character-private-use-2",
  	"bad-character-punctuation-space",
  	"bad-character-replacement-character",
  	"bad-character-reverse-line-feed",
  	"bad-character-right-to-left-embedding",
  	"bad-character-right-to-left-isolate",
  	"bad-character-right-to-left-mark",
  	"bad-character-right-to-left-override",
  	"bad-character-set-transmit-state",
  	"bad-character-shift-in",
  	"bad-character-shift-out",
  	"bad-character-single-character-introducer",
  	"bad-character-single-shift-three",
  	"bad-character-single-shift-two",
  	"bad-character-six-per-em-space",
  	"bad-character-soft-hyphen",
  	"bad-character-start-of-heading",
  	"bad-character-start-of-protected-area",
  	"bad-character-start-of-selected-area",
  	"bad-character-start-of-string",
  	"bad-character-start-of-text",
  	"bad-character-string-terminator",
  	"bad-character-substitute",
  	"bad-character-synchronous-idle",
  	"bad-character-tabulation",
  	"bad-character-thin-space",
  	"bad-character-three-per-em-space",
  	"bad-character-word-joiner",
  	"bad-character-zero-width-joiner",
  	"bad-character-zero-width-no-break-space",
  	"bad-character-zero-width-non-joiner",
  	"bad-character-zero-width-space"
  ];

  var allTagRules = [
  	"tag-bad-self-closing",
  	"tag-bold",
  	"tag-closing-backslash",
  	"tag-is-present",
  	"tag-missing-closing",
  	"tag-missing-opening",
  	"tag-name-case",
  	"tag-rogue",
  	"tag-space-after-opening-bracket",
  	"tag-space-before-closing-bracket",
  	"tag-space-before-closing-slash",
  	"tag-space-between-slash-and-bracket",
  	"tag-void-frontal-slash",
  	"tag-void-slash"
  ];

  var allAttribRules = [
  	"attribute-duplicate",
  	"attribute-malformed"
  ];

  var allBadNamedHTMLEntityRules = [
  	"bad-malformed-numeric-character-entity",
  	"bad-named-html-entity-malformed-nbsp",
  	"bad-named-html-entity-multiple-encoding",
  	"bad-named-html-entity-not-email-friendly",
  	"bad-named-html-entity-unrecognised"
  ];

  const matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;

  var escapeStringRegexp = string => {
    if (typeof string !== 'string') {
      throw new TypeError('Expected a string');
    }

    return string.replace(matchOperatorsRegex, '\\$&');
  };

  const regexpCache = new Map();

  function makeRegexp(pattern, options) {
    options = {
      caseSensitive: false,
      ...options
    };
    const cacheKey = pattern + JSON.stringify(options);

    if (regexpCache.has(cacheKey)) {
      return regexpCache.get(cacheKey);
    }

    const negated = pattern[0] === '!';

    if (negated) {
      pattern = pattern.slice(1);
    }

    pattern = escapeStringRegexp(pattern).replace(/\\\*/g, '.*');
    const regexp = new RegExp(`^${pattern}$`, options.caseSensitive ? '' : 'i');
    regexp.negated = negated;
    regexpCache.set(cacheKey, regexp);
    return regexp;
  }

  var matcher = (inputs, patterns, options) => {
    if (!(Array.isArray(inputs) && Array.isArray(patterns))) {
      throw new TypeError(`Expected two arrays, got ${typeof inputs} ${typeof patterns}`);
    }

    if (patterns.length === 0) {
      return inputs;
    }

    const firstNegated = patterns[0][0] === '!';
    patterns = patterns.map(pattern => makeRegexp(pattern, options));
    const result = [];

    for (const input of inputs) {
      // If first pattern is negated we include everything to match user expectation
      let matches = firstNegated;

      for (const pattern of patterns) {
        if (pattern.test(input)) {
          matches = !pattern.negated;
        }
      }

      if (matches) {
        result.push(input);
      }
    }

    return result;
  };

  var isMatch = (input, pattern, options) => {
    const inputArray = Array.isArray(input) ? input : [input];
    const patternArray = Array.isArray(pattern) ? pattern : [pattern];
    return inputArray.some(input => {
      return patternArray.every(pattern => {
        const regexp = makeRegexp(pattern, options);
        const matches = regexp.test(input);
        return regexp.negated ? !matches : matches;
      });
    });
  };
  matcher.isMatch = isMatch;

  /**
   * string-process-comma-separated
   * Extracts chunks from possibly comma or whatever-separated string
   * Version: 1.2.3
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-process-comma-separated
   */
  function processCommaSeparated(str, originalOpts) {
    if (typeof str !== "string") {
      throw new Error(`string-process-comma-separated: [THROW_ID_01] input must be string! It was given as ${typeof str}, equal to:\n${JSON.stringify(str, null, 4)}`);
    } else if (!str.length || !originalOpts.cb && !originalOpts.errCb) {
      return;
    }

    const defaults = {
      from: 0,
      to: str.length,
      offset: 0,
      leadingWhitespaceOK: false,
      trailingWhitespaceOK: false,
      oneSpaceAfterCommaOK: false,
      innerWhitespaceAllowed: false,
      separator: ",",
      cb: null,
      errCb: null
    };
    const opts = Object.assign({}, defaults, originalOpts);

    if (!Number.isInteger(originalOpts.from)) {
      opts.from = 0;
    }

    if (!Number.isInteger(originalOpts.to)) {
      opts.to = str.length;
    }

    if (!Number.isInteger(originalOpts.offset)) {
      opts.offset = 0;
    }

    let chunkStartsAt = null;
    let whitespaceStartsAt = null;
    let firstNonwhitespaceNonseparatorCharFound = false;
    let separatorsArr = [];
    let lastNonWhitespaceCharAt = null;
    let fixable = true;

    for (let i = opts.from; i < opts.to; i++) {
      if (str[i].trim().length && str[i] !== opts.separator) {
        lastNonWhitespaceCharAt = i;
      }

      if (chunkStartsAt === null && str[i].trim().length && (!opts.separator || str[i] !== opts.separator)) {
        if (!firstNonwhitespaceNonseparatorCharFound) {
          firstNonwhitespaceNonseparatorCharFound = true;
        }

        if (separatorsArr.length) {
          if (separatorsArr.length > 1) {
            separatorsArr.forEach((separatorsIdx, orderNumber) => {
              if (orderNumber) {
                opts.errCb([[separatorsIdx + opts.offset, separatorsIdx + 1 + opts.offset]], "Remove separator.", fixable);
              }
            });
          }

          separatorsArr = [];
        }

        chunkStartsAt = i;
      }

      if (Number.isInteger(chunkStartsAt) && (i > chunkStartsAt && opts.separator && str[i] === opts.separator || i + 1 === opts.to)) {
        const chunk = str.slice(chunkStartsAt, i + 1 === opts.to && str[i] !== opts.separator && str[i].trim().length ? i + 1 : i);

        if (typeof opts.cb === "function") {
          opts.cb(chunkStartsAt + opts.offset, (i + 1 === opts.to && str[i] !== opts.separator && str[i].trim().length ? i + 1 : lastNonWhitespaceCharAt + 1) + opts.offset);
        }

        chunkStartsAt = null;
      }

      if (!str[i].trim().length && whitespaceStartsAt === null) {
        whitespaceStartsAt = i;
      }

      if (whitespaceStartsAt !== null && (str[i].trim().length || i + 1 === opts.to)) {
        if (whitespaceStartsAt === opts.from) {
          if (!opts.leadingWhitespaceOK && typeof opts.errCb === "function") {
            opts.errCb([[whitespaceStartsAt + opts.offset, (i + 1 === opts.to ? i + 1 : i) + opts.offset]], "Remove whitespace.", fixable);
          }
        } else if (!str[i].trim().length && i + 1 === opts.to) {
          if (!opts.trailingWhitespaceOK && typeof opts.errCb === "function") {
            opts.errCb([[whitespaceStartsAt + opts.offset, i + 1 + opts.offset]], "Remove whitespace.", fixable);
          }
        } else if ((!opts.oneSpaceAfterCommaOK || !(str[i].trim().length && i > opts.from + 1 && str[i - 1] === " " && str[i - 2] === ",")) && (!opts.innerWhitespaceAllowed || !(firstNonwhitespaceNonseparatorCharFound && str[whitespaceStartsAt - 1] && str[i].trim().length && str[i] !== opts.separator && str[whitespaceStartsAt - 1] !== opts.separator))) {
          let startingIdx = whitespaceStartsAt;
          let endingIdx = i;

          if (i + 1 === opts.to && str[i] !== opts.separator && !str[i].trim().length) {
            endingIdx++;
          }

          let whatToAdd = "";

          if (opts.oneSpaceAfterCommaOK) {
            if (str[whitespaceStartsAt] === " " && str[whitespaceStartsAt - 1] === opts.separator) {
              startingIdx++;
            } else if (str[whitespaceStartsAt] !== " ") {
              whatToAdd = " ";
            }
          }

          let message = "Remove whitespace.";

          if (!opts.innerWhitespaceAllowed && firstNonwhitespaceNonseparatorCharFound && str[whitespaceStartsAt - 1] && str[i].trim().length && str[i] !== opts.separator && str[whitespaceStartsAt - 1] !== opts.separator) {
            fixable = false;
            message = "Bad whitespace.";
          }

          if (whatToAdd.length) {
            opts.errCb([[startingIdx + opts.offset, endingIdx + opts.offset, whatToAdd]], message, fixable);
          } else {
            opts.errCb([[startingIdx + opts.offset, endingIdx + opts.offset]], message, fixable);
          }

          fixable = true;
        }

        whitespaceStartsAt = null;
      }

      if (str[i] === opts.separator) {
        if (!firstNonwhitespaceNonseparatorCharFound) {
          opts.errCb([[i + opts.offset, i + 1 + opts.offset]], "Remove separator.", fixable);
        } else {
          separatorsArr.push(i);
        }
      }

      if (i + 1 === opts.to) {
        separatorsArr.forEach(separatorsIdx => {
          opts.errCb([[separatorsIdx + opts.offset, separatorsIdx + 1 + opts.offset]], "Remove separator.", fixable);
        });
      }
    }
  }

  function checkForWhitespace() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var idxOffset = arguments.length > 1 ? arguments[1] : undefined;

    // insurance
    if (typeof str !== "string" || !str.length) {
      return {
        charStart: 0,
        charEnd: 0,
        errorArr: [],
        trimmedVal: ""
      };
    } // We'll catch surrounding whitespace and validate the value in one go. This means, we need to know where non-whitespace value is:


    var charStart = 0; // defaults

    var charEnd = str.length;
    var trimmedVal;
    var gatheredRanges = [];
    var errorArr = []; // tackle the inner wrapping whitespace first
    // ...left side:

    if (!str.length || !str[0].trim().length) {
      charStart = right(str); // returns digit or null - index of next non whitespace char on the right

      if (!str.length || charStart === null) {
        // it's just whitespace here
        charEnd = null;
        errorArr.push({
          idxFrom: +idxOffset,
          // that is, idxOffset + 0
          idxTo: +idxOffset + str.length,
          message: "Missing value.",
          fix: null // can't fix - value is missing completely!

        });
      } else {
        gatheredRanges.push([idxOffset, idxOffset + charStart]);
      }
    } // ...right side:


    if (charEnd && !str[str.length - 1].trim().length) {
      charEnd = left(str, str.length - 1) + 1;
      gatheredRanges.push([idxOffset + charEnd, idxOffset + str.length]);
    }

    if (!gatheredRanges.length) {
      trimmedVal = str;
    } else {
      errorArr.push({
        idxFrom: gatheredRanges[0][0],
        idxTo: gatheredRanges[gatheredRanges.length - 1][1],
        message: "Remove whitespace.",
        fix: {
          ranges: gatheredRanges
        } // we can fix - we delete this whitespace!

      }); // reset:

      gatheredRanges = [];
      trimmedVal = str.trim();
    }

    return {
      charStart: charStart,
      charEnd: charEnd,
      errorArr: errorArr,
      trimmedVal: trimmedVal
    };
  }

  var lodash_isregexp = createCommonjsModule(function (module, exports) {
    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** `Object#toString` result references. */
    var regexpTag = '[object RegExp]';
    /** Detect free variable `global` from Node.js. */

    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `exports`. */

    var freeExports =  exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        return freeProcess && freeProcess.binding('util');
      } catch (e) {}
    }();
    /* Node.js helper references. */


    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */

    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }
    /** Used for built-in method references. */


    var objectProto = Object.prototype;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */

    var objectToString = objectProto.toString;
    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */

    function baseIsRegExp(value) {
      return isObject(value) && objectToString.call(value) == regexpTag;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */


    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */


    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    module.exports = isRegExp;
  });

  function includesWithRegex(arr, whatToMatch) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!Array.isArray(arr) || !arr.length) {
      // definitely does not include
      return false;
    } // console.log(
    //   `017 includesWithRegex(): ${`\u001b[${33}m${`whatToMatch`}\u001b[${39}m`} = ${JSON.stringify(
    //     whatToMatch,
    //     null,
    //     4
    //   )}`
    // );


    return arr.some(function (val) {
      return lodash_isregexp(val) && whatToMatch.match(val) || typeof val === "string" && (!opts.caseInsensitive && whatToMatch === val || opts.caseInsensitive && whatToMatch.toLowerCase() === val.toLowerCase());
    });
  }

  // if value is comma-separated, each extracted chunk is passed to this
  // we keep it separate to keep it DRY

  function validateValue(str, idxOffset, opts, charStart, charEnd, errorArr) {
    var extractedValue = str.slice(charStart, charEnd);

    if (!(includesWithRegex(opts.quickPermittedValues, extractedValue, {
      caseInsensitive: opts.caseInsensitive
    }) || includesWithRegex(opts.permittedValues, extractedValue, {
      caseInsensitive: opts.caseInsensitive
    }))) {
      var fix = null;
      var message = "Unrecognised value: \"".concat(str.slice(charStart, charEnd), "\".");

      if (includesWithRegex(opts.quickPermittedValues, extractedValue.toLowerCase()) || includesWithRegex(opts.permittedValues, extractedValue.toLowerCase())) {
        message = "Should be lowercase.";
        fix = {
          ranges: [[charStart + idxOffset, charEnd + idxOffset, extractedValue.toLowerCase()]]
        };
      } else if (Array.isArray(opts.quickPermittedValues) && opts.quickPermittedValues.length && opts.quickPermittedValues.length < 6 && opts.quickPermittedValues.every(function (val) {
        return typeof val === "string";
      }) && (!Array.isArray(opts.permittedValues) || !opts.permittedValues.length) && opts.quickPermittedValues.join("|").length < 40) {
        // if all reference values are strings, if the case is simple,
        // for example, <td dir="tralala">, instead of message:
        // Unrecognised value: "tralala".
        // we can say:
        // Should be "rtl|ltr"
        message = "Should be \"".concat(opts.quickPermittedValues.join("|"), "\".");
      } else if (Array.isArray(opts.permittedValues) && opts.permittedValues.length && opts.permittedValues.length < 6 && opts.permittedValues.every(function (val) {
        return typeof val === "string";
      }) && (!Array.isArray(opts.quickPermittedValues) || !opts.quickPermittedValues.length) && opts.permittedValues.join("|").length < 40) {
        // if all reference values are strings, if the case is simple,
        // for example, <td dir="tralala">, instead of message:
        // Unrecognised value: "tralala".
        // we can say:
        // Should be "rtl|ltr"
        message = "Should be \"".concat(opts.permittedValues.join("|"), "\".");
      }

      errorArr.push({
        idxFrom: charStart + idxOffset,
        idxTo: charEnd + idxOffset,
        message: message,
        fix: fix
      });
    }
  } // opts.quickPermittedValues [Array] - will be matched first, if not matched, will move on to opts.permittedValues
  // opts.permittedValues      [Array] - matches value against that array
  // opts.canBeCommaSeparated  [Bool]  - for example, HTML attribute "accept" is like that


  function validateString(str, idxOffset, originalOpts) {
    var defaults = {
      canBeCommaSeparated: false,
      caseInsensitive: false,
      quickPermittedValues: null,
      permittedValues: null
    };
    var opts = Object.assign({}, defaults, originalOpts); // we get trimmed string start and end positions, also an encountered errors array

    var _checkForWhitespace = checkForWhitespace(str, idxOffset),
        charStart = _checkForWhitespace.charStart,
        charEnd = _checkForWhitespace.charEnd,
        errorArr = _checkForWhitespace.errorArr;

    if (Number.isInteger(charStart)) {
      // continue checks only if there are non-whitespace characters in the value
      if (opts.canBeCommaSeparated) {
        processCommaSeparated(str, {
          offset: idxOffset,
          oneSpaceAfterCommaOK: false,
          leadingWhitespaceOK: true,
          trailingWhitespaceOK: true,
          cb: function cb(idxFrom, idxTo) {
            var extractedValue = str.slice(idxFrom - idxOffset, idxTo - idxOffset); // if there are errors, validateValue() mutates the passed "errorArr",
            // pushing to it

            validateValue(str, idxOffset, opts, idxFrom - idxOffset, // processCommaSeparated() reports offset values so we need to restore indexes to start where this "str" above starts
            idxTo - idxOffset, errorArr);
          },
          errCb: function errCb(ranges, message) {
            errorArr.push({
              idxFrom: ranges[0][0],
              idxTo: ranges[ranges.length - 1][1],
              message: message,
              fix: {
                ranges: ranges
              }
            });
          }
        });
      } else {
        var extractedValue = str.slice(charStart, charEnd); // if there are errors, validateValue() mutates the passed "errorArr",
        // pushing to it

        validateValue(str, idxOffset, opts, charStart, charEnd, errorArr);
      }
    }

    return errorArr;
  }

  var wholeExtensionRegex = /^\.\w+$/g; // Regex is not so strict, to cover variations without miliseconds.
  // Also, we don't use capturing groups because we don't extract, only validate.
  // 2019-07-09T15:03:36Z (https://www.npmjs.com/package/iso-datestring-validator)
  // 2011-10-05T14:48:00.000Z (https://www.npmjs.com/package/regex-iso-date)

  var isoDateRegex = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z/g;
  var fontSizeRegex = /^[+-]?[1-7]$/;
  var linkTypes = ["apple-touch-icon", "apple-touch-startup-image", "alternate", "archives", "appendix", "author", "bookmark", "canonical", "chapter", "contents", "copyright", "dns-prefetch", "external", "first", "glossary", "help", "icon", "import", "index", "last", "license", "manifest", "modulepreload", "next", "nofollow", "noopener", "noreferrer", "opener", "pingback", "preconnect", "prefetch", "preload", "prerender", "prev", "search", "shortlink", "section", "sidebar", "start", "stylesheet", "subsection", "tag", "up"];
  var astErrMessages = {
    "tag-missing-opening": "Opening tag is missing.",
    "tag-missing-closing": "Closing tag is missing.",
    "tag-void-frontal-slash": "Remove frontal slash."
  }; // -----------------------------------------------------------------------------

  function isLetter(str) {
    return typeof str === "string" && str.length === 1 && str.toUpperCase() !== str.toLowerCase();
  }

  function isAnEnabledValue(maybeARulesValue) {
    if (Number.isInteger(maybeARulesValue) && maybeARulesValue > 0) {
      return maybeARulesValue;
    } else if (Array.isArray(maybeARulesValue) && maybeARulesValue.length && Number.isInteger(maybeARulesValue[0]) && maybeARulesValue[0] > 0) {
      return maybeARulesValue[0];
    }

    return 0;
  }

  function isObj(something) {
    return something && _typeof(something) === "object" && !Array.isArray(something);
  }

  function isAnEnabledRule(config, ruleId) {
    if (isObj(config) && Object.prototype.hasOwnProperty.call(config, ruleId)) {
      return config[ruleId];
    } else if (ruleId.includes("-") && Object.prototype.hasOwnProperty.call(config, ruleId.split("-")[0])) {
      return config[ruleId.split("-")[0]];
    } else if (isObj(config) && Object.prototype.hasOwnProperty.call(config, "all")) {
      return config.all;
    } // default return - rule's off:


    return 0; // Object.keys(config.rules).some(
    //   ruleName =>
    //     (ruleName === "all" || // group blanket setting
    //     ruleName === "tag" || // group blanket setting
    //       ruleName.startsWith(obj.ruleId)) &&
    //     (isAnEnabledValue(config.rules[ruleName]) ||
    //       isAnEnabledValue(processedRulesConfig[ruleName]))
    // )
  } // -----------------------------------------------------------------------------

  // rule: bad-character-null
  // -----------------------------------------------------------------------------
  // Catches raw character "NULL":
  // https://www.fileformat.info/info/unicode/char/0000/index.htm
  function badCharacterNull(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 0) {
          context.report({
            ruleId: "bad-character-null",
            message: "Bad character - NULL.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-start-of-heading
  // -----------------------------------------------------------------------------
  // Catches raw character "START OF HEADING":
  // https://www.fileformat.info/info/unicode/char/0001/index.htm
  function badCharacterStartOfHeading(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 1) {
          context.report({
            ruleId: "bad-character-start-of-heading",
            message: "Bad character - START OF HEADING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-start-of-text
  // -----------------------------------------------------------------------------
  // Catches raw character "START OF TEXT":
  // https://www.fileformat.info/info/unicode/char/0002/index.htm
  function badCharacterStartOfText(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 2) {
          context.report({
            ruleId: "bad-character-start-of-text",
            message: "Bad character - START OF TEXT.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-end-of-text
  // -----------------------------------------------------------------------------
  // Catches raw character "END OF TEXT":
  // https://www.fileformat.info/info/unicode/char/0003/index.htm
  function badCharacterEndOfText(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 3) {
          context.report({
            ruleId: "bad-character-end-of-text",
            message: "Bad character - END OF TEXT.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, "\n"]] // replace with line break

            }
          });
        }
      }
    };
  }

  // rule: bad-character-end-of-transmission
  // -----------------------------------------------------------------------------
  // Catches raw character "END OF TRANSMISSION":
  // https://www.fileformat.info/info/unicode/char/0004/index.htm
  function badCharacterEndOfTransmission(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 4) {
          context.report({
            ruleId: "bad-character-end-of-transmission",
            message: "Bad character - END OF TRANSMISSION.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-enquiry
  // -----------------------------------------------------------------------------
  // Catches raw character "ENQUIRY":
  // https://www.fileformat.info/info/unicode/char/0005/index.htm
  function badCharacterEnquiry(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 5) {
          context.report({
            ruleId: "bad-character-enquiry",
            message: "Bad character - ENQUIRY.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-acknowledge
  // -----------------------------------------------------------------------------
  // Catches raw character "ACKNOWLEDGE":
  // https://www.fileformat.info/info/unicode/char/0006/index.htm
  function badCharacterAcknowledge(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 6) {
          context.report({
            ruleId: "bad-character-acknowledge",
            message: "Bad character - ACKNOWLEDGE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-bell
  // -----------------------------------------------------------------------------
  // Catches raw character "BELL":
  // https://www.fileformat.info/info/unicode/char/0007/index.htm
  function badCharacterBell(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 7) {
          context.report({
            ruleId: "bad-character-bell",
            message: "Bad character - BELL.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-backspace
  // -----------------------------------------------------------------------------
  // Catches raw character "BACKSPACE":
  // https://www.fileformat.info/info/unicode/char/0008/index.htm
  function badCharacterBackspace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8) {
          context.report({
            ruleId: "bad-character-backspace",
            message: "Bad character - BACKSPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-tabulation

  function badCharacterTabulation(context) {
    // indentation tabs might be OK, check config.
    // tabs between text not OK.
    // tabs trailing lines, leading to EOL or line break, not OK. ("right-side indentation")
    // plan: use "leftStopAtNewLines" method, it stops at first non-whitespace
    // character or linebreaks of both kinds: CR or LF.
    var mode = "never";

    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    if (Array.isArray(originalOpts) && originalOpts[0] && typeof originalOpts[0] === "string" && originalOpts[0].toLowerCase() === "indentationisfine") {
      mode = "indentationIsFine";
    }

    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 9) {
          if (mode === "never") {
            // simple - there can't be any TABs, so raise it straight away
            context.report({
              ruleId: "bad-character-tabulation",
              message: "Bad character - TABULATION.",
              idxFrom: i,
              idxTo: i + 1,
              fix: {
                ranges: [[i, i + 1, " "]] // replace with one space

              }
            });
          } else if (mode === "indentationIsFine") {
            // leftStopAtNewLines() will stop either at first non-whitespace character
            // on the left, or LF or CR. By evaluating the trim of it, we can
            // filter out cases where it's non-whitespace character. In other
            // words, that's TAB in the middle of the line, between letter characters.
            var charTopOnBreaksIdx = leftStopAtNewLines(context.str, i);

            if (charTopOnBreaksIdx !== null && context.str[charTopOnBreaksIdx].trim().length) {
              context.report({
                ruleId: "bad-character-tabulation",
                message: "Bad character - TABULATION.",
                idxFrom: i,
                idxTo: i + 1,
                fix: {
                  ranges: [[i, i + 1, " "]] // replace with one space

                }
              });
            }
          }
        }
      }
    };
  }

  // rule: bad-character-line-tabulation
  // -----------------------------------------------------------------------------
  // Catches raw character "LINE TABULATION":
  // https://www.fileformat.info/info/unicode/char/000b/index.htm
  function badCharacterLineTabulation(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 11) {
          context.report({
            ruleId: "bad-character-line-tabulation",
            message: "Bad character - LINE TABULATION.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-form-feed
  // -----------------------------------------------------------------------------
  // Catches raw character "FORM FEED":
  // https://www.fileformat.info/info/unicode/char/000c/index.htm
  function badCharacterFormFeed(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 12) {
          context.report({
            ruleId: "bad-character-form-feed",
            message: "Bad character - FORM FEED.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-shift-out
  // -----------------------------------------------------------------------------
  // Catches raw character "SHIFT OUT":
  // https://www.fileformat.info/info/unicode/char/000e/index.htm
  function badCharacterShiftOut(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 14) {
          context.report({
            ruleId: "bad-character-shift-out",
            message: "Bad character - SHIFT OUT.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-shift-in
  // -----------------------------------------------------------------------------
  // Catches raw character "SHIFT IN":
  // https://www.fileformat.info/info/unicode/char/000f/index.htm
  function badCharacterShiftIn(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 15) {
          context.report({
            ruleId: "bad-character-shift-in",
            message: "Bad character - SHIFT IN.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-data-link-escape
  // -----------------------------------------------------------------------------
  // Catches raw character "DATA LINK ESCAPE":
  // https://www.fileformat.info/info/unicode/char/0010/index.htm
  function badCharacterDataLinkEscape(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 16) {
          context.report({
            ruleId: "bad-character-data-link-escape",
            message: "Bad character - DATA LINK ESCAPE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-device-control-one
  // -----------------------------------------------------------------------------
  // Catches raw character "DEVICE CONTROL ONE":
  // https://www.fileformat.info/info/unicode/char/0011/index.htm
  function badCharacterDeviceControlOne(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 17) {
          context.report({
            ruleId: "bad-character-device-control-one",
            message: "Bad character - DEVICE CONTROL ONE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-device-control-two
  // -----------------------------------------------------------------------------
  // Catches raw character "DEVICE CONTROL TWO":
  // https://www.fileformat.info/info/unicode/char/0012/index.htm
  function badCharacterDeviceControlTwo(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 18) {
          context.report({
            ruleId: "bad-character-device-control-two",
            message: "Bad character - DEVICE CONTROL TWO.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-device-control-three
  // -----------------------------------------------------------------------------
  // Catches raw character "DEVICE CONTROL THREE":
  // https://www.fileformat.info/info/unicode/char/0013/index.htm
  function badCharacterDeviceControlThree(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 19) {
          context.report({
            ruleId: "bad-character-device-control-three",
            message: "Bad character - DEVICE CONTROL THREE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-device-control-four
  // -----------------------------------------------------------------------------
  // Catches raw character "DEVICE CONTROL FOUR":
  // https://www.fileformat.info/info/unicode/char/0014/index.htm
  function badCharacterDeviceControlFour(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 20) {
          context.report({
            ruleId: "bad-character-device-control-four",
            message: "Bad character - DEVICE CONTROL FOUR.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-negative-acknowledge
  // -----------------------------------------------------------------------------
  // Catches raw character "NEGATIVE ACKNOWLEDGE":
  // https://www.fileformat.info/info/unicode/char/0015/index.htm
  function badCharacterNegativeAcknowledge(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 21) {
          context.report({
            ruleId: "bad-character-negative-acknowledge",
            message: "Bad character - NEGATIVE ACKNOWLEDGE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-synchronous-idle
  // -----------------------------------------------------------------------------
  // Catches raw character "SYNCHRONOUS IDLE":
  // https://www.fileformat.info/info/unicode/char/0016/index.htm
  function badCharacterSynchronousIdle(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 22) {
          context.report({
            ruleId: "bad-character-synchronous-idle",
            message: "Bad character - SYNCHRONOUS IDLE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-end-of-transmission-block
  // -----------------------------------------------------------------------------
  // Catches raw character "END OF TRANSMISSION BLOCK":
  // https://www.fileformat.info/info/unicode/char/0017/index.htm
  function badCharacterEndOfTransmissionBlock(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 23) {
          context.report({
            ruleId: "bad-character-end-of-transmission-block",
            message: "Bad character - END OF TRANSMISSION BLOCK.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-cancel
  // -----------------------------------------------------------------------------
  // Catches raw character "CANCEL":
  // https://www.fileformat.info/info/unicode/char/0018/index.htm
  function badCharacterCancel(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 24) {
          context.report({
            ruleId: "bad-character-cancel",
            message: "Bad character - CANCEL.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-end-of-medium
  // -----------------------------------------------------------------------------
  // Catches raw character "END OF MEDIUM":
  // https://www.fileformat.info/info/unicode/char/0019/index.htm
  function badCharacterEndOfMedium(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 25) {
          context.report({
            ruleId: "bad-character-end-of-medium",
            message: "Bad character - END OF MEDIUM.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-substitute
  // -----------------------------------------------------------------------------
  // Catches raw character "SUBSTITUTE":
  // https://www.fileformat.info/info/unicode/char/001a/index.htm
  function badCharacterSubstitute(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 26) {
          context.report({
            ruleId: "bad-character-substitute",
            message: "Bad character - SUBSTITUTE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-escape
  // -----------------------------------------------------------------------------
  // Catches raw character "ESCAPE":
  // https://www.fileformat.info/info/unicode/char/001b/index.htm
  function badCharacterEscape(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 27) {
          context.report({
            ruleId: "bad-character-escape",
            message: "Bad character - ESCAPE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-information-separator-four
  // -----------------------------------------------------------------------------
  // Catches raw character "INFORMATION SEPARATOR FOUR":
  // https://www.fileformat.info/info/unicode/char/001c/index.htm
  function badCharacterInformationSeparatorFour(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 28) {
          context.report({
            ruleId: "bad-character-information-separator-four",
            message: "Bad character - INFORMATION SEPARATOR FOUR.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-information-separator-three
  // -----------------------------------------------------------------------------
  // Catches raw character "INFORMATION SEPARATOR THREE":
  // https://www.fileformat.info/info/unicode/char/001d/index.htm
  function badCharacterInformationSeparatorThree(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 29) {
          context.report({
            ruleId: "bad-character-information-separator-three",
            message: "Bad character - INFORMATION SEPARATOR THREE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-information-separator-two
  // -----------------------------------------------------------------------------
  // Catches raw character "INFORMATION SEPARATOR TWO":
  // https://www.fileformat.info/info/unicode/char/001e/index.htm
  function badCharacterInformationSeparatorTwo(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 30) {
          context.report({
            ruleId: "bad-character-information-separator-two",
            message: "Bad character - INFORMATION SEPARATOR TWO.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-information-separator-one
  // -----------------------------------------------------------------------------
  // Catches raw character "INFORMATION SEPARATOR ONE":
  // https://www.fileformat.info/info/unicode/char/001f/index.htm
  function badCharacterInformationSeparatorTwo$1(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 31) {
          context.report({
            ruleId: "bad-character-information-separator-one",
            message: "Bad character - INFORMATION SEPARATOR ONE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-delete
  // -----------------------------------------------------------------------------
  // Catches raw character "DELETE":
  // https://www.fileformat.info/info/unicode/char/007f/index.htm
  function badCharacterDelete(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 127) {
          context.report({
            ruleId: "bad-character-delete",
            message: "Bad character - DELETE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-control-0080
  // -----------------------------------------------------------------------------
  // Catches raw character "CONTROL" (hex 80):
  // https://www.fileformat.info/info/unicode/char/0080/index.htm
  function badCharacterControl0080(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 128) {
          context.report({
            ruleId: "bad-character-control-0080",
            message: "Bad character - CONTROL.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-control-0081
  // -----------------------------------------------------------------------------
  // Catches raw character "CONTROL" (hex 81):
  // https://www.fileformat.info/info/unicode/char/0081/index.htm
  function badCharacterControl0081(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 129) {
          context.report({
            ruleId: "bad-character-control-0081",
            message: "Bad character - CONTROL.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-break-permitted-here
  // -----------------------------------------------------------------------------
  // Catches raw character "BREAK PERMITTED HERE":
  // https://www.fileformat.info/info/unicode/char/0082/index.htm
  function badCharacterBreakPermittedHere(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 130) {
          context.report({
            ruleId: "bad-character-break-permitted-here",
            message: "Bad character - BREAK PERMITTED HERE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-no-break-here
  // -----------------------------------------------------------------------------
  // Catches raw character "NO BREAK HERE":
  // https://www.fileformat.info/info/unicode/char/0083/index.htm
  function badCharacterNoBreakHere(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 131) {
          context.report({
            ruleId: "bad-character-no-break-here",
            message: "Bad character - NO BREAK HERE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-control-0084
  // -----------------------------------------------------------------------------
  // Catches raw character "CONTROL" (hex 84):
  // https://www.fileformat.info/info/unicode/char/0084/index.htm
  function badCharacterControl0084(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 132) {
          context.report({
            ruleId: "bad-character-control-0084",
            message: "Bad character - CONTROL.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-next-line
  // -----------------------------------------------------------------------------
  // Catches raw character "NEXT LINE":
  // https://www.fileformat.info/info/unicode/char/0085/index.htm
  function badCharacterNextLine(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 133) {
          context.report({
            ruleId: "bad-character-next-line",
            message: "Bad character - NEXT LINE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-start-of-selected-area
  // -----------------------------------------------------------------------------
  // Catches raw character "START OF SELECTED AREA":
  // https://www.fileformat.info/info/unicode/char/0086/index.htm
  function badCharacterStartOfSelectedArea(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 134) {
          context.report({
            ruleId: "bad-character-start-of-selected-area",
            message: "Bad character - START OF SELECTED AREA.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-end-of-selected-area
  // -----------------------------------------------------------------------------
  // Catches raw character "END OF SELECTED AREA":
  // https://www.fileformat.info/info/unicode/char/0087/index.htm
  function badCharacterEndOfSelectedArea(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 135) {
          context.report({
            ruleId: "bad-character-end-of-selected-area",
            message: "Bad character - END OF SELECTED AREA.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-character-tabulation-set
  // -----------------------------------------------------------------------------
  // Catches raw character "CHARACTER TABULATION SET":
  // https://www.fileformat.info/info/unicode/char/0088/index.htm
  function badCharacterCharacterTabulationSet(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 136) {
          context.report({
            ruleId: "bad-character-character-tabulation-set",
            message: "Bad character - CHARACTER TABULATION SET.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-character-tabulation-with-justification
  // -----------------------------------------------------------------------------
  // Catches raw character "CHARACTER TABULATION WITH JUSTIFICATION":
  // https://www.fileformat.info/info/unicode/char/0089/index.htm
  function badCharacterCharacterTabulationWithJustification(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 137) {
          context.report({
            ruleId: "bad-character-character-tabulation-with-justification",
            message: "Bad character - CHARACTER TABULATION WITH JUSTIFICATION.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-line-tabulation-set
  // -----------------------------------------------------------------------------
  // Catches raw character "LINE TABULATION SET":
  // https://www.fileformat.info/info/unicode/char/008a/index.htm
  function badCharacterLineTabulationSet(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 138) {
          context.report({
            ruleId: "bad-character-line-tabulation-set",
            message: "Bad character - LINE TABULATION SET.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-partial-line-forward
  // -----------------------------------------------------------------------------
  // Catches raw character "PARTIAL LINE FORWARD":
  // https://www.fileformat.info/info/unicode/char/008b/index.htm
  function badCharacterPartialLineForward(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 139) {
          context.report({
            ruleId: "bad-character-partial-line-forward",
            message: "Bad character - PARTIAL LINE FORWARD.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-partial-line-backward
  // -----------------------------------------------------------------------------
  // Catches raw character "PARTIAL LINE BACKWARD":
  // https://www.fileformat.info/info/unicode/char/008c/index.htm
  function badCharacterPartialLineBackward(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 140) {
          context.report({
            ruleId: "bad-character-partial-line-backward",
            message: "Bad character - PARTIAL LINE BACKWARD.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-reverse-line-feed
  // -----------------------------------------------------------------------------
  // Catches raw character "REVERSE LINE FEED":
  // https://www.fileformat.info/info/unicode/char/008d/index.htm
  function badCharacterReverseLineFeed(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 141) {
          context.report({
            ruleId: "bad-character-reverse-line-feed",
            message: "Bad character - REVERSE LINE FEED.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-single-shift-two
  // -----------------------------------------------------------------------------
  // Catches raw character "SINGLE SHIFT TWO":
  // https://www.fileformat.info/info/unicode/char/008e/index.htm
  function badCharacterSingleShiftTwo(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 142) {
          context.report({
            ruleId: "bad-character-single-shift-two",
            message: "Bad character - SINGLE SHIFT TWO.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-single-shift-three
  // -----------------------------------------------------------------------------
  // Catches raw character "SINGLE SHIFT THREE":
  // https://www.fileformat.info/info/unicode/char/008f/index.htm
  function badCharacterSingleShiftTwo$1(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 143) {
          context.report({
            ruleId: "bad-character-single-shift-three",
            message: "Bad character - SINGLE SHIFT THREE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-device-control-string
  // -----------------------------------------------------------------------------
  // Catches raw character "DEVICE CONTROL STRING":
  // https://www.fileformat.info/info/unicode/char/0090/index.htm
  function badCharacterDeviceControlString(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 144) {
          context.report({
            ruleId: "bad-character-device-control-string",
            message: "Bad character - DEVICE CONTROL STRING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-private-use-1
  // -----------------------------------------------------------------------------
  // Catches raw character "PRIVATE USE ONE":
  // https://www.fileformat.info/info/unicode/char/0091/index.htm
  function badCharacterPrivateUseOne(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 145) {
          context.report({
            ruleId: "bad-character-private-use-1",
            message: "Bad character - PRIVATE USE ONE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-private-use-2
  // -----------------------------------------------------------------------------
  // Catches raw character "PRIVATE USE TWO":
  // https://www.fileformat.info/info/unicode/char/0092/index.htm
  function badCharacterPrivateUseTwo(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 146) {
          context.report({
            ruleId: "bad-character-private-use-2",
            message: "Bad character - PRIVATE USE TWO.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-set-transmit-state
  // -----------------------------------------------------------------------------
  // Catches raw character "SET TRANSMIT STATE":
  // https://www.fileformat.info/info/unicode/char/0093/index.htm
  function badCharacterSetTransmitState(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 147) {
          context.report({
            ruleId: "bad-character-set-transmit-state",
            message: "Bad character - SET TRANSMIT STATE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-cancel-character
  // -----------------------------------------------------------------------------
  // Catches raw character "CANCEL CHARACTER":
  // https://www.fileformat.info/info/unicode/char/0094/index.htm
  function badCharacterCancelCharacter(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 148) {
          context.report({
            ruleId: "bad-character-cancel-character",
            message: "Bad character - CANCEL CHARACTER.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-message-waiting
  // -----------------------------------------------------------------------------
  // Catches raw character "MESSAGE WAITING":
  // https://www.fileformat.info/info/unicode/char/0095/index.htm
  function badCharacterMessageWaiting(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 149) {
          context.report({
            ruleId: "bad-character-message-waiting",
            message: "Bad character - MESSAGE WAITING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-start-of-protected-area
  // -----------------------------------------------------------------------------
  // Catches raw character "START OF PROTECTED AREA":
  // https://www.fileformat.info/info/unicode/char/0096/index.htm
  function badCharacterStartOfProtectedArea(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 150) {
          context.report({
            ruleId: "bad-character-start-of-protected-area",
            message: "Bad character - START OF PROTECTED AREA.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-end-of-protected-area
  // -----------------------------------------------------------------------------
  // Catches raw character "END OF PROTECTED AREA":
  // https://www.fileformat.info/info/unicode/char/0097/index.htm
  function badCharacterEndOfProtectedArea(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 151) {
          context.report({
            ruleId: "bad-character-end-of-protected-area",
            message: "Bad character - END OF PROTECTED AREA.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-start-of-string
  // -----------------------------------------------------------------------------
  // Catches raw character "START OF STRING":
  // https://www.fileformat.info/info/unicode/char/0098/index.htm
  function badCharacterStartOfString(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 152) {
          context.report({
            ruleId: "bad-character-start-of-string",
            message: "Bad character - START OF STRING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-control-0099
  // -----------------------------------------------------------------------------
  // Catches raw character "CONTROL" (hex 99):
  // https://www.fileformat.info/info/unicode/char/0099/index.htm
  function badCharacterControl0099(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 153) {
          context.report({
            ruleId: "bad-character-control-0099",
            message: "Bad character - CONTROL.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-single-character-introducer
  // -----------------------------------------------------------------------------
  // Catches raw character "SINGLE CHARACTER INTRODUCER":
  // https://www.fileformat.info/info/unicode/char/009a/index.htm
  function badCharacterSingleCharacterIntroducer(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 154) {
          context.report({
            ruleId: "bad-character-single-character-introducer",
            message: "Bad character - SINGLE CHARACTER INTRODUCER.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-control-sequence-introducer
  // -----------------------------------------------------------------------------
  // Catches raw character "CONTROL SEQUENCE INTRODUCER":
  // https://www.fileformat.info/info/unicode/char/009b/index.htm
  function badCharacterControlSequenceIntroducer(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 155) {
          context.report({
            ruleId: "bad-character-control-sequence-introducer",
            message: "Bad character - CONTROL SEQUENCE INTRODUCER.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-string-terminator
  // -----------------------------------------------------------------------------
  // Catches raw character "STRING TERMINATOR":
  // https://www.fileformat.info/info/unicode/char/009c/index.htm
  function badCharacterStringTerminator(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 156) {
          context.report({
            ruleId: "bad-character-string-terminator",
            message: "Bad character - STRING TERMINATOR.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-operating-system-command
  // -----------------------------------------------------------------------------
  // Catches raw character "OPERATING SYSTEM COMMAND":
  // https://www.fileformat.info/info/unicode/char/009d/index.htm
  function badCharacterOperatingSystemCommand(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 157) {
          context.report({
            ruleId: "bad-character-operating-system-command",
            message: "Bad character - OPERATING SYSTEM COMMAND.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-private-message
  // -----------------------------------------------------------------------------
  // Catches raw character "PRIVATE MESSAGE":
  // https://www.fileformat.info/info/unicode/char/009e/index.htm
  function badCharacterPrivateMessage(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 158) {
          context.report({
            ruleId: "bad-character-private-message",
            message: "Bad character - PRIVATE MESSAGE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-application-program-command
  // -----------------------------------------------------------------------------
  // Catches raw character "APPLICATION PROGRAM COMMAND":
  // https://www.fileformat.info/info/unicode/char/009f/index.htm
  function badCharacterApplicationProgramCommand(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 159) {
          context.report({
            ruleId: "bad-character-application-program-command",
            message: "Bad character - APPLICATION PROGRAM COMMAND.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-soft-hyphen
  // -----------------------------------------------------------------------------
  // Catches raw character "SOFT HYPHEN":
  // https://www.fileformat.info/info/unicode/char/00ad/index.htm
  function badCharacterSoftHyphen(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 173) {
          context.report({
            ruleId: "bad-character-soft-hyphen",
            message: "Bad character - SOFT HYPHEN.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-non-breaking-space
  // -----------------------------------------------------------------------------
  // Catches raw character "NON-BREAKING SPACE":
  // https://www.fileformat.info/info/unicode/char/00a0/index.htm
  function badCharacterNonBreakingSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 160) {
          context.report({
            ruleId: "bad-character-non-breaking-space",
            message: "Bad character - NON-BREAKING SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-ogham-space-mark
  // -----------------------------------------------------------------------------
  // Catches raw character "OGHAM SPACE MARK":
  // https://www.fileformat.info/info/unicode/char/1680/index.htm
  function badCharacterOghamSpaceMark(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 5760) {
          context.report({
            ruleId: "bad-character-ogham-space-mark",
            message: "Bad character - OGHAM SPACE MARK.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-en-quad
  // -----------------------------------------------------------------------------
  // Catches raw character "EN QUAD":
  // https://www.fileformat.info/info/unicode/char/2000/index.htm
  function badCharacterEnQuad(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8192) {
          context.report({
            ruleId: "bad-character-en-quad",
            message: "Bad character - EN QUAD.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-em-quad
  // -----------------------------------------------------------------------------
  // Catches raw character "EM QUAD":
  // https://www.fileformat.info/info/unicode/char/2001/index.htm
  function badCharacterEmQuad(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8193) {
          context.report({
            ruleId: "bad-character-em-quad",
            message: "Bad character - EM QUAD.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-en-space
  // -----------------------------------------------------------------------------
  // Catches raw character "EN SPACE":
  // https://www.fileformat.info/info/unicode/char/2002/index.htm
  function badCharacterEnSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8194) {
          context.report({
            ruleId: "bad-character-en-space",
            message: "Bad character - EN SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-em-space
  // -----------------------------------------------------------------------------
  // Catches raw character "EM SPACE":
  // https://www.fileformat.info/info/unicode/char/2003/index.htm
  function badCharacterEmSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8195) {
          context.report({
            ruleId: "bad-character-em-space",
            message: "Bad character - EM SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-three-per-em-space
  // -----------------------------------------------------------------------------
  // Catches raw character "THREE-PER-EM SPACE":
  // https://www.fileformat.info/info/unicode/char/2004/index.htm
  function badCharacterThreePerEmSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8196) {
          context.report({
            ruleId: "bad-character-three-per-em-space",
            message: "Bad character - THREE-PER-EM SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-four-per-em-space
  // -----------------------------------------------------------------------------
  // Catches raw character "FOUR-PER-EM SPACE":
  // https://www.fileformat.info/info/unicode/char/2005/index.htm
  function badCharacterFourPerEmSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8197) {
          context.report({
            ruleId: "bad-character-four-per-em-space",
            message: "Bad character - FOUR-PER-EM SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-six-per-em-space
  // -----------------------------------------------------------------------------
  // Catches raw character "SIX-PER-EM SPACE":
  // https://www.fileformat.info/info/unicode/char/2006/index.htm
  function badCharacterSixPerEmSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8198) {
          context.report({
            ruleId: "bad-character-six-per-em-space",
            message: "Bad character - SIX-PER-EM SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-figure-space
  // -----------------------------------------------------------------------------
  // Catches raw character "FIGURE SPACE":
  // https://www.fileformat.info/info/unicode/char/2007/index.htm
  function badCharacterFigureSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8199) {
          context.report({
            ruleId: "bad-character-figure-space",
            message: "Bad character - FIGURE SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-punctuation-space
  // -----------------------------------------------------------------------------
  // Catches raw character "PUNCTUATION SPACE":
  // https://www.fileformat.info/info/unicode/char/2008/index.htm
  function badCharacterPunctuationSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8200) {
          context.report({
            ruleId: "bad-character-punctuation-space",
            message: "Bad character - PUNCTUATION SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-thin-space
  // -----------------------------------------------------------------------------
  // Catches raw character "THIN SPACE":
  // https://www.fileformat.info/info/unicode/char/2009/index.htm
  function badCharacterThinSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8201) {
          context.report({
            ruleId: "bad-character-thin-space",
            message: "Bad character - THIN SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-hair-space
  // -----------------------------------------------------------------------------
  // Catches raw character "HAIR SPACE":
  // https://www.fileformat.info/info/unicode/char/200a/index.htm
  function badCharacterHairSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8202) {
          context.report({
            ruleId: "bad-character-hair-space",
            message: "Bad character - HAIR SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-zero-width-space
  // -----------------------------------------------------------------------------
  // Catches raw character "ZERO WIDTH SPACE":
  // https://www.fileformat.info/info/unicode/char/200b/index.htm
  function badCharacterZeroWidthSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8203) {
          context.report({
            ruleId: "bad-character-zero-width-space",
            message: "Bad character - ZERO WIDTH SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-zero-width-non-joiner
  // -----------------------------------------------------------------------------
  // Catches raw character "ZERO WIDTH NON-JOINER":
  // https://www.fileformat.info/info/unicode/char/200c/index.htm
  function badCharacterZeroWidthNonJoiner(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8204) {
          context.report({
            ruleId: "bad-character-zero-width-non-joiner",
            message: "Bad character - ZERO WIDTH NON-JOINER.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-zero-width-joiner
  // -----------------------------------------------------------------------------
  // Catches raw character "ZERO WIDTH JOINER":
  // https://www.fileformat.info/info/unicode/char/200d/index.htm
  function badCharacterZeroWidthJoiner(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8205) {
          context.report({
            ruleId: "bad-character-zero-width-joiner",
            message: "Bad character - ZERO WIDTH JOINER.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-left-to-right-mark
  // -----------------------------------------------------------------------------
  // Catches raw character "LEFT-TO-RIGHT MARK":
  // https://www.fileformat.info/info/unicode/char/200e/index.htm
  function badCharacterLeftToRightMark(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8206) {
          context.report({
            ruleId: "bad-character-left-to-right-mark",
            message: "Bad character - LEFT-TO-RIGHT MARK.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-right-to-left-mark
  // -----------------------------------------------------------------------------
  // Catches raw character "RIGHT-TO-LEFT MARK":
  // https://www.fileformat.info/info/unicode/char/200f/index.htm
  function badCharacterRightToLeftMark(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8207) {
          context.report({
            ruleId: "bad-character-right-to-left-mark",
            message: "Bad character - RIGHT-TO-LEFT MARK.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-left-to-right-embedding
  // -----------------------------------------------------------------------------
  // Catches raw character "LEFT-TO-RIGHT EMBEDDING":
  // https://www.fileformat.info/info/unicode/char/202a/index.htm
  function badCharacterLeftToRightEmbedding(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8234) {
          context.report({
            ruleId: "bad-character-left-to-right-embedding",
            message: "Bad character - LEFT-TO-RIGHT EMBEDDING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-right-to-left-embedding
  // -----------------------------------------------------------------------------
  // Catches raw character "RIGHT-TO-LEFT EMBEDDING":
  // https://www.fileformat.info/info/unicode/char/202b/index.htm
  function badCharacterRightToLeftEmbedding(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8235) {
          context.report({
            ruleId: "bad-character-right-to-left-embedding",
            message: "Bad character - RIGHT-TO-LEFT EMBEDDING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-pop-directional-formatting
  // -----------------------------------------------------------------------------
  // Catches raw character "POP DIRECTIONAL FORMATTING":
  // https://www.fileformat.info/info/unicode/char/202c/index.htm
  function badCharacterPopDirectionalFormatting(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8236) {
          context.report({
            ruleId: "bad-character-pop-directional-formatting",
            message: "Bad character - POP DIRECTIONAL FORMATTING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-left-to-right-override
  // -----------------------------------------------------------------------------
  // Catches raw character "LEFT-TO-RIGHT OVERRIDE":
  // https://www.fileformat.info/info/unicode/char/202d/index.htm
  function badCharacterLeftToRightOverride(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8237) {
          context.report({
            ruleId: "bad-character-left-to-right-override",
            message: "Bad character - LEFT-TO-RIGHT OVERRIDE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-right-to-left-override
  // -----------------------------------------------------------------------------
  // Catches raw character "RIGHT-TO-LEFT OVERRIDE":
  // https://www.fileformat.info/info/unicode/char/202e/index.htm
  function badCharacterRightToLeftOverride(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8238) {
          context.report({
            ruleId: "bad-character-right-to-left-override",
            message: "Bad character - RIGHT-TO-LEFT OVERRIDE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-word-joiner
  // -----------------------------------------------------------------------------
  // Catches raw character "WORD JOINER":
  // https://www.fileformat.info/info/unicode/char/2060/index.htm
  function badCharacterWordJoiner(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8288) {
          context.report({
            ruleId: "bad-character-word-joiner",
            message: "Bad character - WORD JOINER.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-function-application
  // -----------------------------------------------------------------------------
  // Catches raw character "FUNCTION APPLICATION":
  // https://www.fileformat.info/info/unicode/char/2061/index.htm
  function badCharacterFunctionApplication(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8289) {
          context.report({
            ruleId: "bad-character-function-application",
            message: "Bad character - FUNCTION APPLICATION.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-invisible-times
  // -----------------------------------------------------------------------------
  // Catches raw character "INVISIBLE TIMES":
  // https://www.fileformat.info/info/unicode/char/2062/index.htm
  function badCharacterInvisibleTimes(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8290) {
          context.report({
            ruleId: "bad-character-invisible-times",
            message: "Bad character - INVISIBLE TIMES.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-invisible-separator
  // -----------------------------------------------------------------------------
  // Catches raw character "INVISIBLE SEPARATOR":
  // https://www.fileformat.info/info/unicode/char/2063/index.htm
  function badCharacterInvisibleSeparator(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8291) {
          context.report({
            ruleId: "bad-character-invisible-separator",
            message: "Bad character - INVISIBLE SEPARATOR.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-invisible-plus
  // -----------------------------------------------------------------------------
  // Catches raw character "INVISIBLE PLUS":
  // https://www.fileformat.info/info/unicode/char/2064/index.htm
  function badCharacterInvisiblePlus(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8292) {
          context.report({
            ruleId: "bad-character-invisible-plus",
            message: "Bad character - INVISIBLE PLUS.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-left-to-right-isolate
  // -----------------------------------------------------------------------------
  // Catches raw character "LEFT-TO-RIGHT ISOLATE":
  // https://www.fileformat.info/info/unicode/char/2066/index.htm
  function badCharacterLeftToRightIsolate(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8294) {
          context.report({
            ruleId: "bad-character-left-to-right-isolate",
            message: "Bad character - LEFT-TO-RIGHT ISOLATE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-right-to-left-isolate
  // -----------------------------------------------------------------------------
  // Catches raw character "RIGHT-TO-LEFT ISOLATE":
  // https://www.fileformat.info/info/unicode/char/2067/index.htm
  function badCharacterRightToLeftIsolate(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8295) {
          context.report({
            ruleId: "bad-character-right-to-left-isolate",
            message: "Bad character - RIGHT-TO-LEFT ISOLATE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-first-strong-isolate
  // -----------------------------------------------------------------------------
  // Catches raw character "FIRST STRONG ISOLATE":
  // https://www.fileformat.info/info/unicode/char/2068/index.htm
  function badCharacterFirstStrongIsolate(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8296) {
          context.report({
            ruleId: "bad-character-first-strong-isolate",
            message: "Bad character - FIRST STRONG ISOLATE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-pop-directional-isolate
  // -----------------------------------------------------------------------------
  // Catches raw character "FIRST STRONG ISOLATE":
  // https://www.fileformat.info/info/unicode/char/2069/index.htm
  function badCharacterPopDirectionalIsolate(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8297) {
          context.report({
            ruleId: "bad-character-pop-directional-isolate",
            message: "Bad character - FIRST STRONG ISOLATE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-inhibit-symmetric-swapping
  // -----------------------------------------------------------------------------
  // Catches raw character "INHIBIT SYMMETRIC SWAPPING":
  // https://www.fileformat.info/info/unicode/char/206a/index.htm
  function badCharacterInhibitSymmetricSwapping(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8298) {
          context.report({
            ruleId: "bad-character-inhibit-symmetric-swapping",
            message: "Bad character - INHIBIT SYMMETRIC SWAPPING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-activate-symmetric-swapping
  // -----------------------------------------------------------------------------
  // Catches raw character "INHIBIT SYMMETRIC SWAPPING":
  // https://www.fileformat.info/info/unicode/char/206b/index.htm
  function badCharacterActivateSymmetricSwapping(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8299) {
          context.report({
            ruleId: "bad-character-activate-symmetric-swapping",
            message: "Bad character - INHIBIT SYMMETRIC SWAPPING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-inhibit-arabic-form-shaping
  // -----------------------------------------------------------------------------
  // Catches raw character "INHIBIT ARABIC FORM SHAPING":
  // https://www.fileformat.info/info/unicode/char/206c/index.htm
  function badCharacterInhibitArabicFormShaping(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8300) {
          context.report({
            ruleId: "bad-character-inhibit-arabic-form-shaping",
            message: "Bad character - INHIBIT ARABIC FORM SHAPING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-activate-arabic-form-shaping
  // -----------------------------------------------------------------------------
  // Catches raw character "ACTIVATE ARABIC FORM SHAPING":
  // https://www.fileformat.info/info/unicode/char/206d/index.htm
  function badCharacterActivateArabicFormShaping(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8301) {
          context.report({
            ruleId: "bad-character-activate-arabic-form-shaping",
            message: "Bad character - ACTIVATE ARABIC FORM SHAPING.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-national-digit-shapes
  // -----------------------------------------------------------------------------
  // Catches raw character "NATIONAL DIGIT SHAPES":
  // https://www.fileformat.info/info/unicode/char/206e/index.htm
  function badCharacterNationalDigitShapes(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8302) {
          context.report({
            ruleId: "bad-character-national-digit-shapes",
            message: "Bad character - NATIONAL DIGIT SHAPES.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-nominal-digit-shapes
  // -----------------------------------------------------------------------------
  // Catches raw character "NOMINAL DIGIT SHAPES":
  // https://www.fileformat.info/info/unicode/char/206f/index.htm
  function badCharacterNominalDigitShapes(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8303) {
          context.report({
            ruleId: "bad-character-nominal-digit-shapes",
            message: "Bad character - NOMINAL DIGIT SHAPES.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-zero-width-no-break-space
  // -----------------------------------------------------------------------------
  // Catches raw character "ZERO WIDTH NO-BREAK SPACE":
  // https://www.fileformat.info/info/unicode/char/feff/index.htm
  function badCharacterZeroWidthNoBreakSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 65279) {
          context.report({
            ruleId: "bad-character-zero-width-no-break-space",
            message: "Bad character - ZERO WIDTH NO-BREAK SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-interlinear-annotation-anchor
  // -----------------------------------------------------------------------------
  // Catches raw character "INTERLINEAR ANNOTATION ANCHOR":
  // https://www.fileformat.info/info/unicode/char/fff9/index.htm
  function badCharacterInterlinearAnnotationAnchor(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 65529) {
          context.report({
            ruleId: "bad-character-interlinear-annotation-anchor",
            message: "Bad character - INTERLINEAR ANNOTATION ANCHOR.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-interlinear-annotation-separator
  // -----------------------------------------------------------------------------
  // Catches raw character "INTERLINEAR ANNOTATION SEPARATOR":
  // https://www.fileformat.info/info/unicode/char/fffa/index.htm
  function badCharacterInterlinearAnnotationSeparator(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 65530) {
          context.report({
            ruleId: "bad-character-interlinear-annotation-separator",
            message: "Bad character - INTERLINEAR ANNOTATION SEPARATOR.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-interlinear-annotation-terminator
  // -----------------------------------------------------------------------------
  // Catches raw character "INTERLINEAR ANNOTATION TERMINATOR":
  // https://www.fileformat.info/info/unicode/char/fffb/index.htm
  function badCharacterInterlinearAnnotationTerminator(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 65531) {
          context.report({
            ruleId: "bad-character-interlinear-annotation-terminator",
            message: "Bad character - INTERLINEAR ANNOTATION TERMINATOR.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-line-separator
  // -----------------------------------------------------------------------------
  // Catches raw character "LINE SEPARATOR":
  // https://www.fileformat.info/info/unicode/char/2028/index.htm
  function badCharacterLineSeparator(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8232) {
          context.report({
            ruleId: "bad-character-line-separator",
            message: "Bad character - LINE SEPARATOR.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-paragraph-separator
  // -----------------------------------------------------------------------------
  // Catches raw character "PARAGRAPH SEPARATOR":
  // https://www.fileformat.info/info/unicode/char/2029/index.htm
  function badCharacterParagraphSeparator(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8233) {
          context.report({
            ruleId: "bad-character-paragraph-separator",
            message: "Bad character - PARAGRAPH SEPARATOR.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: bad-character-narrow-no-break-space
  // -----------------------------------------------------------------------------
  // Catches raw character "NARROW NO-BREAK SPACE":
  // https://www.fileformat.info/info/unicode/char/202f/index.htm
  function badCharacterNarrowNoBreakSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8239) {
          context.report({
            ruleId: "bad-character-narrow-no-break-space",
            message: "Bad character - NARROW NO-BREAK SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-medium-mathematical-space
  // -----------------------------------------------------------------------------
  // Catches raw character "MEDIUM MATHEMATICAL SPACE":
  // https://www.fileformat.info/info/unicode/char/205f/index.htm
  function badCharacterMediumMathematicalSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 8287) {
          context.report({
            ruleId: "bad-character-medium-mathematical-space",
            message: "Bad character - MEDIUM MATHEMATICAL SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-ideographic-space
  // -----------------------------------------------------------------------------
  // Catches raw character "IDEOGRAPHIC SPACE":
  // https://www.fileformat.info/info/unicode/char/3000/index.htm
  function badCharacterIdeographicSpace(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 12288) {
          context.report({
            ruleId: "bad-character-ideographic-space",
            message: "Bad character - IDEOGRAPHIC SPACE.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1, " "]] // replace with a normal space

            }
          });
        }
      }
    };
  }

  // rule: bad-character-replacement-character
  // -----------------------------------------------------------------------------
  // Catches raw character "REPLACEMENT CHARACTER":
  // https://www.fileformat.info/info/unicode/char/fffd/index.htm
  function badCharacterReplacementCharacter(context) {
    return {
      character: function character(_ref) {
        var chr = _ref.chr,
            i = _ref.i;

        if (chr.charCodeAt(0) === 65533) {
          context.report({
            ruleId: "bad-character-replacement-character",
            message: "Bad character - REPLACEMENT CHARACTER.",
            idxFrom: i,
            idxTo: i + 1,
            fix: {
              ranges: [[i, i + 1]] // just delete it

            }
          });
        }
      }
    };
  }

  // rule: tag-space-after-opening-bracket
  // tag name letter:
  //
  // < table>
  // <   a href="">
  // <\n\nspan>

  function tagSpaceAfterOpeningBracket(context) {
    return {
      tag: function tag(node) {
        var ranges = []; // const wholeGap = context.str.slice(node.start + 1, node.tagNameStartsAt);
        // 1. if there's whitespace after opening bracket

        if (typeof context.str[node.start + 1] === "string" && !context.str[node.start + 1].trim().length) {
          ranges.push([node.start + 1, right(context.str, node.start + 1)]);
        } // 2. if there's whitespace before tag name


        if (!context.str[node.tagNameStartsAt - 1].trim().length) {
          var charToTheLeftOfTagNameIdx = left(context.str, node.tagNameStartsAt);

          if (charToTheLeftOfTagNameIdx !== node.start) {
            // we don't want duplication
            ranges.push([charToTheLeftOfTagNameIdx + 1, node.tagNameStartsAt]);
          }
        }

        if (ranges.length) {
          context.report({
            ruleId: "tag-space-after-opening-bracket",
            message: "Bad whitespace.",
            idxFrom: ranges[0][0],
            idxTo: ranges[ranges.length - 1][1],
            // second elem. from last range
            fix: {
              ranges: ranges
            }
          });
        }
      }
    };
  }

  // rule: tag-space-before-closing-bracket
  var BACKSLASH = "\\"; // it flags up any tags which have whitespace between opening bracket and first
  // tag name letter:
  //
  // < table>
  // <   a href="">
  // <\n\nspan>

  function tagSpaceBeforeClosingBracket(context) {
    return {
      tag: function tag(node) {
        var ranges = []; // const wholeGap = context.str.slice(node.start + 1, node.tagNameStartsAt);
        // 1. if there's whitespace before the closing bracket

        if ( // tag ends with a bracket:
        context.str[node.end - 1] === ">" && // and there's a whitespace on the left of it:
        !context.str[node.end - 2].trim().length && // and the next non-whitespace character on the left is not slash of
        // any kind (we don't want to step into rule's
        // "tag-space-between-slash-and-bracket" turf)
        !"".concat(BACKSLASH, "/").includes(context.str[left(context.str, node.end - 1)])) {
          ranges.push([left(context.str, node.end - 1) + 1, node.end - 1]);
        }

        if (ranges.length) {
          context.report({
            ruleId: "tag-space-before-closing-bracket",
            message: "Bad whitespace.",
            idxFrom: ranges[0][0],
            idxTo: ranges[ranges.length - 1][1],
            // second elem. from last range
            fix: {
              ranges: ranges
            }
          });
        }
      }
    };
  }

  // rule: tag-space-before-closing-slash

  function tagSpaceBeforeClosingSlash(context) {
    for (var _len = arguments.length, opts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      opts[_key - 1] = arguments[_key];
    }

    return {
      tag: function tag(node) {
        var gapValue = context.str.slice(node.start + 1, node.tagNameStartsAt); // settle the mode, is it "always" or a default, "never"

        var mode = "never"; // opts array comes already sliced, without 1st element, so opts value
        // is 0th (and onwards if more)

        if (Array.isArray(opts) && ["always", "never"].includes(opts[0])) {
          mode = opts[0];
        } // PROCESSING:


        var closingBracketPos = node.end - 1;
        var slashPos = left(context.str, closingBracketPos);
        var leftOfSlashPos = left(context.str, slashPos);

        if (mode === "never" && node["void"] && context.str[slashPos] === "/" && leftOfSlashPos < slashPos - 1) {
          context.report({
            ruleId: "tag-space-before-closing-slash",
            message: "Bad whitespace.",
            idxFrom: leftOfSlashPos + 1,
            idxTo: slashPos,
            fix: {
              ranges: [[leftOfSlashPos + 1, slashPos]]
            }
          });
        } else if (mode === "always" && node["void"] && context.str[slashPos] === "/" && leftOfSlashPos === slashPos - 1) {
          context.report({
            ruleId: "tag-space-before-closing-slash",
            message: "Missing space.",
            idxFrom: slashPos,
            idxTo: slashPos,
            fix: {
              ranges: [[slashPos, slashPos, " "]]
            }
          });
        }
      }
    };
  }

  // rule: tag-space-between-slash-and-bracket

  function tagSpaceBetweenSlashAndBracket(context) {
    return {
      tag: function tag(node) {
        // since we know the location of the closing bracket,
        // let's look to the left, is there a slash and check the distance
        if (Number.isInteger(node.end) && context.str[node.end - 1] === ">" && // necessary because in the future unclosed tags will be recognised!
        context.str[left(context.str, node.end - 1)] === "/" && left(context.str, node.end - 1) < node.end - 2) {
          var idxFrom = left(context.str, node.end - 1) + 1;
          context.report({
            ruleId: "tag-space-between-slash-and-bracket",
            message: "Bad whitespace.",
            idxFrom: idxFrom,
            idxTo: node.end - 1,
            fix: {
              ranges: [[idxFrom, node.end - 1]]
            }
          });
        }
      }
    };
  }

  // rule: tag-closing-backslash
  var BACKSLASH$1 = "\\";

  function tagClosingBackslash(context) {
    return {
      tag: function tag(node) {
        // since we know the location of the closing bracket,
        // let's look to the left, is there a slash and check the distance
        var ranges = []; //
        //
        //
        //           PART 1 - backslash is after opening bracket
        //
        //
        //

        if (Number.isInteger(node.start) && Number.isInteger(node.tagNameStartsAt) && context.str.slice(node.start, node.tagNameStartsAt).includes(BACKSLASH$1)) {
          for (var i = node.start; i < node.tagNameStartsAt; i++) {
            // fish-out all backslashes
            if (context.str[i] === BACKSLASH$1) {
              // just delete the backslash because it doesn't belong here
              // if there's a need for closing (left) slash, it will be added
              // by 3rd level rules which can "see" the surrounding tag layout.
              ranges.push([i, i + 1]);
            }
          }
        } //
        //
        //
        //           PART 2 - backslash is before closing bracket
        //
        //
        //


        if (Number.isInteger(node.end) && context.str[node.end - 1] === ">" && // necessary because in the future unclosed tags will be recognised!
        context.str[left(context.str, node.end - 1)] === BACKSLASH$1) {
          var message = node["void"] ? "Replace backslash with slash." : "Delete this.";
          var backSlashPos = left(context.str, node.end - 1); // So we confirmed there's left slash.
          // Is it completely rogue or is it meant to be self-closing tag's closing?

          var idxFrom = left(context.str, backSlashPos) + 1;
          var whatToInsert = node["void"] ? "/" : "";

          if (context.processedRulesConfig["tag-space-before-closing-slash"] && (Number.isInteger(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"] > 0 || Array.isArray(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"][0] > 0 && context.processedRulesConfig["tag-space-before-closing-slash"][1] === "never")) {
            // include any and all the whitespace to the left as well
            idxFrom = left(context.str, backSlashPos) + 1;
          } // but if spaces are requested via "tag-space-before-closing-slash",
          // ensure they're added


          if (Array.isArray(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"][0] > 0 && context.processedRulesConfig["tag-space-before-closing-slash"][1] === "always") {
            idxFrom = left(context.str, backSlashPos) + 1;
            whatToInsert = " ".concat(whatToInsert); // but if space is already present at the beginning of the range at
            // index left(context.str, backSlashPos) + 1, don't add one there

            if (node["void"] && context.str[idxFrom + 1] === " ") {
              idxFrom++;
              whatToInsert = whatToInsert.trim();
            } else if (!node["void"]) {
              whatToInsert = whatToInsert.trim();
            }
          } // maybe slashes are forbidden on void tags?


          if (node["void"] && Array.isArray(context.processedRulesConfig["tag-void-slash"]) && context.processedRulesConfig["tag-void-slash"][0] > 0 && context.processedRulesConfig["tag-void-slash"][1] === "never") {
            whatToInsert = "";
            idxFrom = left(context.str, backSlashPos) + 1;
            message = "Delete this.";
          }

          context.report({
            ruleId: "tag-closing-backslash",
            message: message,
            idxFrom: idxFrom,
            idxTo: node.end - 1,
            fix: {
              ranges: [[idxFrom, node.end - 1, whatToInsert]]
            }
          });
        } // FINALLY,


        if (ranges.length) {
          context.report({
            ruleId: "tag-closing-backslash",
            message: "Wrong slash - backslash.",
            idxFrom: ranges[0][0],
            idxTo: ranges[ranges.length - 1][1],
            fix: {
              ranges: ranges
            }
          });
        }
      }
    };
  }

  // rule: tag-void-slash
  var BACKSLASH$2 = "\\";

  function tagVoidSlash(context) {
    for (var _len = arguments.length, opts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      opts[_key - 1] = arguments[_key];
    }

    return {
      tag: function tag(node) {
        // settle the mode, is it "always" or a default, "never"
        var mode = "always"; // opts array comes already sliced, without 1st element, so opts value
        // is 0th (and onwards if more)

        if (Array.isArray(opts) && ["always", "never"].includes(opts[0])) {
          mode = opts[0];
        } // PROCESSING:


        var closingBracketPos = node.end - 1;
        var slashPos = left(context.str, closingBracketPos);
        var leftOfSlashPos = left(context.str, slashPos);

        if (mode === "never" && node["void"] && context.str[slashPos] === "/") {
          // if slashes are forbidden on void tags, delete the slash and all
          // the whitespace in front, because there's never a space before
          // non-void tag's closing bracket without a slash, for example, "<span >"
          context.report({
            ruleId: "tag-void-slash",
            message: "Remove the slash.",
            idxFrom: leftOfSlashPos + 1,
            idxTo: closingBracketPos,
            fix: {
              ranges: [[leftOfSlashPos + 1, closingBracketPos]]
            }
          });
        } else if (mode === "always" && node["void"] && context.str[slashPos] !== "/" && ( // don't trigger if backslash rules are on:
        !context.processedRulesConfig["tag-closing-backslash"] || !(context.str[slashPos] === BACKSLASH$2 && (Number.isInteger(context.processedRulesConfig["tag-closing-backslash"]) && context.processedRulesConfig["tag-closing-backslash"] > 0 || Array.isArray(context.processedRulesConfig["tag-closing-backslash"]) && context.processedRulesConfig["tag-closing-backslash"][0] > 0 && context.processedRulesConfig["tag-closing-backslash"][1] === "always")))) {
          // if slashes are requested on void tags, situation is more complex,
          // because we need to take into the account the rule
          // "tag-space-before-closing-slash"
          if (Array.isArray(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"][1] === "always") {
            // space is needed
            // check, maybe space is there
            if (context.str[slashPos + 1] === " ") {
              // but space exists already
              context.report({
                ruleId: "tag-void-slash",
                message: "Missing slash.",
                idxFrom: slashPos + 2,
                idxTo: closingBracketPos,
                fix: {
                  ranges: [[slashPos + 2, closingBracketPos, "/"]]
                }
              });
            } else {
              // space is missing so add one
              context.report({
                ruleId: "tag-void-slash",
                message: "Missing slash.",
                idxFrom: slashPos + 1,
                idxTo: closingBracketPos,
                fix: {
                  ranges: [[slashPos + 1, closingBracketPos, " /"]]
                }
              });
            }
          } else if (context.processedRulesConfig["tag-space-before-closing-slash"] === undefined || Array.isArray(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"][1] === "never" || Number.isInteger(context.processedRulesConfig["tag-space-before-closing-slash"]) && context.processedRulesConfig["tag-space-before-closing-slash"] > 0) {
            // no space needed
            context.report({
              ruleId: "tag-void-slash",
              message: "Missing slash.",
              idxFrom: slashPos + 1,
              idxTo: closingBracketPos,
              fix: {
                ranges: [[slashPos + 1, closingBracketPos, "/"]]
              }
            });
          }
        }
      }
    };
  }

  // rule: tag-name-case
  // -----------------------------------------------------------------------------
  function tagNameCase(context) {
    var knownUpperCaseTags = ["CDATA"];
    var variableCaseTagNames = ["doctype"];
    return {
      tag: function tag(node) {
        // since we know the location of the closing bracket,
        // let's look to the left, is there a slash and check the distance
        if (node.tagName && node.recognised === true) {
          if (knownUpperCaseTags.includes(node.tagName.toUpperCase())) {
            // node.tagName will arrive lowercased, so we have to retrieve
            // the real characters by slicing from ranges
            if (context.str.slice(node.tagNameStartsAt, node.tagNameEndsAt) !== node.tagName.toUpperCase()) {
              var ranges = [[node.tagNameStartsAt, node.tagNameEndsAt, node.tagName.toUpperCase()]];
              context.report({
                ruleId: "tag-name-case",
                message: "Bad tag name case.",
                idxFrom: node.tagNameStartsAt,
                idxTo: node.tagNameEndsAt,
                fix: {
                  ranges: ranges
                }
              });
            } // else - FINE

          } else if (context.str.slice(node.tagNameStartsAt, node.tagNameEndsAt) !== node.tagName && !variableCaseTagNames.includes(node.tagName.toLowerCase())) {
            var _ranges = [[node.tagNameStartsAt, node.tagNameEndsAt, node.tagName]];
            context.report({
              ruleId: "tag-name-case",
              message: "Bad tag name case.",
              idxFrom: node.tagNameStartsAt,
              idxTo: node.tagNameEndsAt,
              fix: {
                ranges: _ranges
              }
            });
          }
        }
      }
    };
  }

  // rule: tag-is-present

  function tagIsPresent(context) {
    for (var _len = arguments.length, opts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      opts[_key - 1] = arguments[_key];
    }

    return {
      tag: function tag(node) {
        if (Array.isArray(opts) && opts.length) {
          var temp = matcher([node.tagName], opts);

          if (matcher([node.tagName], opts).length) {
            context.report({
              ruleId: "tag-is-present",
              message: "".concat(node.tagName, " is not allowed."),
              idxFrom: node.start,
              idxTo: node.end,
              // second elem. from last range
              fix: {
                ranges: [[node.start, node.end]]
              }
            });
          }
        }
      }
    };
  }

  // rule: tag-bold
  // -----------------------------------------------------------------------------
  // it flags up any <bold> tags
  function tagBold(context) {
    for (var _len = arguments.length, opts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      opts[_key - 1] = arguments[_key];
    }

    return {
      tag: function tag(node) {
        var suggested = "strong";

        if (Array.isArray(opts) && typeof opts[0] === "string" && opts[0].toLowerCase() === "b") {
          suggested = "b";
        }

        if (node.tagName === "bold") {
          context.report({
            ruleId: "tag-bold",
            message: "Tag \"bold\" does not exist in HTML.",
            idxFrom: node.start,
            idxTo: node.end,
            // second elem. from last range
            fix: {
              ranges: [[node.tagNameStartsAt, node.tagNameEndsAt, suggested]]
            }
          });
        }
      }
    };
  }

  // rule: tag-bad-self-closing

  function tagBadSelfClosing(context) {
    return {
      tag: function tag(node) {
        if (!node["void"] && node.value.endsWith(">") && node.value[left(node.value, node.value.length - 1)] === "/") {
          var idxFrom = node.start + left(node.value, left(node.value, node.value.length - 1)) + 1;
          var idxTo = node.start + node.value.length - 1;
          context.report({
            ruleId: "tag-bad-self-closing",
            message: "Remove the slash.",
            idxFrom: idxFrom,
            idxTo: idxTo,
            fix: {
              ranges: [[idxFrom, idxTo]]
            }
          });
        }
      }
    };
  }

  function splitByWhitespace(str, cbValues, cbWhitespace, originalOpts) {
    // console.log(
    //   `003 splitByWhitespace(): ${`\u001b[${36}m${`traverse and extract`}\u001b[${39}m`}`
    // );
    var defaults = {
      offset: 0,
      from: 0,
      to: str.length
    };
    var opts = Object.assign({}, defaults, originalOpts);
    var nameStartsAt = null;
    var whitespaceStartsAt = null;

    for (var i = opts.from; i < opts.to; i++) {
      // console.log(
      //   `018 ${`\u001b[${36}m${`------------------------------------------------\nstr[${i}]`}\u001b[${39}m`} = ${JSON.stringify(
      //     str[i],
      //     null,
      //     4
      //   )}`
      // );
      // catch the beginning of a whitespace
      if (whitespaceStartsAt === null && !str[i].trim().length) {
        whitespaceStartsAt = i; // console.log(
        //   `029 splitByWhitespace(): ${`\u001b[${32}m${`SET`}\u001b[${39}m`} ${`\u001b[${33}m${`whitespaceStartsAt`}\u001b[${39}m`} = ${whitespaceStartsAt}`
        // );
      } // catch the ending of a whitespace


      if (whitespaceStartsAt !== null && (str[i].trim().length || i + 1 === opts.to)) {
        // console.log(
        //   `039 ${`\u001b[${32}m${`PING`}\u001b[${39}m`} whitespace [${whitespaceStartsAt}, ${
        //     str[i].trim().length ? i : i + 1
        //   }]`
        // );
        if (typeof cbWhitespace === "function") {
          cbWhitespace([whitespaceStartsAt + opts.offset, (str[i].trim().length ? i : i + 1) + opts.offset]);
        }

        whitespaceStartsAt = null; // console.log(
        //   `051 splitByWhitespace(): ${`\u001b[${31}m${`RESET`}\u001b[${39}m`} ${`\u001b[${33}m${`whitespaceStartsAt`}\u001b[${39}m`} = ${whitespaceStartsAt}`
        // );
      } // catch the beginning of a name


      if (nameStartsAt === null && str[i].trim().length) {
        nameStartsAt = i; // console.log(
        //   `059 splitByWhitespace(): ${`\u001b[${32}m${`SET`}\u001b[${39}m`} ${`\u001b[${33}m${`nameStartsAt`}\u001b[${39}m`} = ${nameStartsAt}`
        // );
      } // catch the ending of a name


      if (nameStartsAt !== null && (!str[i].trim().length || i + 1 === opts.to)) {
        // console.log(
        //   `066 splitByWhitespace(): ${`\u001b[${32}m${``}\u001b[${39}m`} ${`\u001b[${32}m${`carved out ${opts.typeName} name`}\u001b[${39}m`} ${JSON.stringify(
        //     str.slice(
        //       nameStartsAt,
        //       i + 1 === opts.to && str[i].trim().length ? i + 1 : i
        //     ),
        //     null,
        //     0
        //   )}`
        // );
        // // call CB
        // console.log(
        //   `078 ${`\u001b[${32}m${`PING`}\u001b[${39}m`} chunk [${nameStartsAt}, ${
        //     i + 1 === opts.to ? i + 1 && str[i].trim().length : i
        //   }]`
        // );
        if (typeof cbValues === "function") {
          cbValues([nameStartsAt + opts.offset, (i + 1 === opts.to && str[i].trim().length ? i + 1 : i) + opts.offset]);
        } // reset


        nameStartsAt = null; // console.log(
        //   `092 splitByWhitespace(): ${`\u001b[${31}m${`RESET`}\u001b[${39}m`} ${`\u001b[${33}m${`nameStartsAt`}\u001b[${39}m`} = ${nameStartsAt}`
        // );
      } // console.log(" ");
      // console.log(" ");
      // console.log(
      //   `${`\u001b[${90}m${`1 splitByWhitespace():  nameStartsAt = ${nameStartsAt}; whitespaceStartsAt = ${whitespaceStartsAt}`}\u001b[${39}m`}`
      // );
      // console.log(" ");
      // console.log(" ");

    }
  }

  function attributeDuplicate(context) {
    var attributesWhichCanBeMerged = ["id", "class"];
    return {
      tag: function tag(node) {
        // if there is more than 1 attribute
        if (Array.isArray(node.attribs) && node.attribs.length > 1) {
          var attrsGatheredSoFar = []; // record unique names

          var mergeableAttrsCaught = []; // also unique

          for (var i = 0, len = node.attribs.length; i < len; i++) {
            if (!attrsGatheredSoFar.includes(node.attribs[i].attribName)) {
              attrsGatheredSoFar.push(node.attribs[i].attribName);
            } else if (!attributesWhichCanBeMerged.includes(node.attribs[i].attribName)) {
              context.report({
                ruleId: "attribute-duplicate",
                message: "Duplicate attribute \"".concat(node.attribs[i].attribName, "\"."),
                idxFrom: node.attribs[i].attribStart,
                idxTo: node.attribs[i].attribEnd,
                fix: null
              });
            } else if (!mergeableAttrsCaught.includes(node.attribs[i].attribName)) {
              // ^ ensure we don't push the same class/id twice
              mergeableAttrsCaught.push(node.attribs[i].attribName);
            }
          } // process all recorded attributes which can be merged:


          if (mergeableAttrsCaught.length) {
            mergeableAttrsCaught.forEach(function (attrNameBeingMerged) {
              var theFirstRange = [];
              var extractedValues = [];
              var allOtherRanges = []; // can't use functional way with filter+reduce
              // instead we'll loop through all attributes

              var _loop = function _loop(_i, _len) {
                if (node.attribs[_i].attribName === attrNameBeingMerged) {
                  // make a note of the index ranges, separating the first
                  // attribute occurence from the rest:
                  if (!theFirstRange.length) {
                    // notice we push two values into an array
                    theFirstRange.push(node.attribs[_i].attribValueStartsAt, node.attribs[_i].attribValueEndsAt);
                  } else {
                    // notice we push an array into an array
                    // include whitespace to the left, unless it's the first
                    // attribute of a tag (i === 0, or falsey)
                    allOtherRanges.push([_i ? left(context.str, node.attribs[_i].attribStart) + 1 : node.attribs[_i].attribStart, node.attribs[_i].attribEnd]);
                  } // either way, extract the values, split by whitespace


                  splitByWhitespace(node.attribs[_i].attribValue, function (_ref) {
                    var _ref2 = _slicedToArray(_ref, 2),
                        from = _ref2[0],
                        to = _ref2[1];

                    extractedValues.push(node.attribs[_i].attribValue.slice(from, to));
                  });
                }
              };

              for (var _i = 0, _len = node.attribs.length; _i < _len; _i++) {
                _loop(_i);
              }

              var mergedValue = extractedValues.sort().join(" "); // finally, raise the error:

              context.report({
                ruleId: "attribute-duplicate",
                message: "Duplicate attribute \"".concat(attrNameBeingMerged, "\"."),
                idxFrom: node.start,
                idxTo: node.end,
                fix: {
                  ranges: [[].concat(theFirstRange, [mergedValue])].concat(allOtherRanges)
                }
              });
            });
          }
        }
      }
    };
  }

  /**
   * html-all-known-attributes
   * All HTML attributes known to the humanity
   * Version: 1.3.2
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/all-named-html-entities
   */
  var allHtmlAttribs = ["abbr", "accept", "accept-charset", "accesskey", "action", "align", "alink", "allow", "alt", "archive", "async", "autocapitalize", "autocomplete", "autofocus", "autoplay", "axis", "background", "background-attachment", "background-color", "background-image", "background-position", "background-position-x", "background-position-y", "background-repeat", "bgcolor", "border", "border-bottom", "border-bottom-color", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-style", "border-top", "border-top-color", "border-top-style", "border-top-width", "border-width", "buffered", "capture", "cellpadding", "cellspacing", "challenge", "char", "charoff", "charset", "checked", "cite", "class", "classid", "clear", "clip", "code", "codebase", "codetype", "color", "cols", "colspan", "column-span", "compact", "content", "contenteditable", "contextmenu", "controls", "coords", "crossorigin", "csp", "cursor", "data", "data-*", "datetime", "declare", "decoding", "default", "defer", "dir", "direction", "dirname", "disabled", "display", "download", "draggable", "dropzone", "enctype", "enterkeyhint", "face", "filter", "float", "font", "font-color", "font-emphasize", "font-emphasize-position", "font-emphasize-style", "font-family", "font-size", "font-style", "font-variant", "font-weight", "for", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "frame", "frameborder", "frontuid", "headers", "height", "hidden", "high", "horiz-align", "href", "hreflang", "hspace", "http-equiv", "icon", "id", "importance", "inputmode", "integrity", "intrinsicsize", "ismap", "itemprop", "keytype", "kind", "label", "lang", "language", "layout-flow", "layout-grid", "layout-grid-char", "layout-grid-line", "layout-grid-mode", "layout-grid-type", "left", "letter-spacing", "line-break", "line-height", "link", "list", "list-image-1", "list-image-2", "list-image-3", "list-style", "list-style-image", "list-style-position", "list-style-type", "loading", "longdesc", "loop", "low", "manifest", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marginheight", "marginwidth", "max", "maxlength", "media", "method", "min", "minlength", "mso-ansi-font-size", "mso-ansi-font-style", "mso-ansi-font-weight", "mso-ansi-language", "mso-ascii-font-family", "mso-background", "mso-background-source", "mso-baseline-position", "mso-bidi-flag", "mso-bidi-font-family", "mso-bidi-font-size", "mso-bidi-font-style", "mso-bidi-font-weight", "mso-bidi-language", "mso-bookmark", "mso-border-alt", "mso-border-between", "mso-border-between-color", "mso-border-between-style", "mso-border-between-width", "mso-border-bottom-alt", "mso-border-bottom-color-alt", "mso-border-bottom-source", "mso-border-bottom-style-alt", "mso-border-bottom-width-alt", "mso-border-color-alt", "mso-border-effect", "mso-border-left-alt", "mso-border-left-color-alt", "mso-border-left-source", "mso-border-left-style-alt", "mso-border-left-width-alt", "mso-border-right-alt", "mso-border-right-color-alt", "mso-border-right-source", "mso-border-right-style-alt", "mso-border-right-width-alt", "mso-border-shadow", "mso-border-source", "mso-border-style-alt", "mso-border-top-alt", "mso-border-top-color-alt", "mso-border-top-source", "mso-border-top-style-alt", "mso-border-top-width-alt", "mso-border-width-alt", "mso-break-type", "mso-build", "mso-build-after-action", "mso-build-after-color", "mso-build-auto-secs", "mso-build-avi", "mso-build-dual-id", "mso-build-order", "mso-build-sound-name", "mso-bullet-image", "mso-cell-special", "mso-cellspacing", "mso-char-indent", "mso-char-indent-count", "mso-char-indent-size", "mso-char-type", "mso-char-wrap", "mso-color-alt", "mso-color-index", "mso-color-source", "mso-column-break-before", "mso-column-separator", "mso-columns", "mso-comment-author", "mso-comment-continuation", "mso-comment-id", "mso-comment-reference", "mso-data-placement", "mso-default-height", "mso-default-width", "mso-diagonal-down", "mso-diagonal-down-color", "mso-diagonal-down-source", "mso-diagonal-down-style", "mso-diagonal-down-width", "mso-diagonal-up", "mso-diagonal-up-color", "mso-diagonal-up-source", "mso-diagonal-up-style", "mso-diagonal-up-width", "mso-displayed-decimal-separator", "mso-displayed-thousand-separator", "mso-element", "mso-element-anchor-horizontal", "mso-element-anchor-lock", "mso-element-anchor-vertical", "mso-element-frame-height", "mso-element-frame-hspace", "mso-element-frame-vspace", "mso-element-frame-width", "mso-element-left", "mso-element-linespan", "mso-element-top", "mso-element-wrap", "mso-endnote-continuation-notice", "mso-endnote-continuation-notice-id", "mso-endnote-continuation-notice-src", "mso-endnote-continuation-separator", "mso-endnote-continuation-separator-id", "mso-endnote-continuation-separator-src", "mso-endnote-display", "mso-endnote-id", "mso-endnote-numbering", "mso-endnote-numbering-restart", "mso-endnote-numbering-start", "mso-endnote-numbering-style", "mso-endnote-position", "mso-endnote-separator", "mso-endnote-separator-id", "mso-endnote-separator-src", "mso-even-footer", "mso-even-footer-id", "mso-even-footer-src", "mso-even-header", "mso-even-header-id", "mso-even-header-src", "mso-facing-pages", "mso-fareast-font-family", "mso-fareast-hint", "mso-fareast-language", "mso-field-change", "mso-field-change-author", "mso-field-change-time", "mso-field-change-value", "mso-field-code", "mso-field-lock", "mso-fills-color", "mso-first-footer", "mso-first-footer-id", "mso-first-footer-src", "mso-first-header", "mso-first-header-id", "mso-first-header-src", "mso-font-alt", "mso-font-charset", "mso-font-format", "mso-font-info", "mso-font-info-charset", "mso-font-info-type", "mso-font-kerning", "mso-font-pitch", "mso-font-signature", "mso-font-signature-csb-one", "mso-font-signature-csb-two", "mso-font-signature-usb-four", "mso-font-signature-usb-one", "mso-font-signature-usb-three", "mso-font-signature-usb-two", "mso-font-src", "mso-font-width", "mso-footer", "mso-footer-data", "mso-footer-id", "mso-footer-margin", "mso-footer-src", "mso-footnote-continuation-notice", "mso-footnote-continuation-notice-id", "mso-footnote-continuation-notice-src", "mso-footnote-continuation-separator", "mso-footnote-continuation-separator-id", "mso-footnote-continuation-separator-src", "mso-footnote-id", "mso-footnote-numbering", "mso-footnote-numbering-restart", "mso-footnote-numbering-start", "mso-footnote-numbering-style", "mso-footnote-position", "mso-footnote-separator", "mso-footnote-separator-id", "mso-footnote-separator-src", "mso-foreground", "mso-forms-protection", "mso-generic-font-family", "mso-grid-bottom", "mso-grid-bottom-count", "mso-grid-left", "mso-grid-left-count", "mso-grid-right", "mso-grid-right-count", "mso-grid-top", "mso-grid-top-count", "mso-gutter-direction", "mso-gutter-margin", "mso-gutter-position", "mso-hansi-font-family", "mso-header", "mso-header-data", "mso-header-id", "mso-header-margin", "mso-header-src", "mso-height-alt", "mso-height-rule", "mso-height-source", "mso-hide", "mso-highlight", "mso-horizontal-page-align", "mso-hyphenate", "mso-ignore", "mso-kinsoku-overflow", "mso-layout-grid-align", "mso-layout-grid-char-alt", "mso-layout-grid-origin", "mso-level-inherit", "mso-level-legacy", "mso-level-legacy-indent", "mso-level-legacy-space", "mso-level-legal-format", "mso-level-number-format", "mso-level-number-position", "mso-level-numbering", "mso-level-reset-level", "mso-level-start-at", "mso-level-style-link", "mso-level-suffix", "mso-level-tab-stop", "mso-level-text", "mso-line-break-override", "mso-line-grid", "mso-line-height-alt", "mso-line-height-rule", "mso-line-numbers-count-by", "mso-line-numbers-distance", "mso-line-numbers-restart", "mso-line-numbers-start", "mso-line-spacing", "mso-linked-frame", "mso-list", "mso-list-change", "mso-list-change-author", "mso-list-change-time", "mso-list-change-values", "mso-list-id", "mso-list-ins", "mso-list-ins-author", "mso-list-ins-time", "mso-list-name", "mso-list-template-ids", "mso-list-type", "mso-margin-bottom-alt", "mso-margin-left-alt", "mso-margin-top-alt", "mso-mirror-margins", "mso-negative-indent-tab", "mso-number-format", "mso-outline-level", "mso-outline-parent", "mso-outline-parent-col", "mso-outline-parent-row", "mso-outline-parent-visibility", "mso-outline-style", "mso-padding-alt", "mso-padding-between", "mso-padding-bottom-alt", "mso-padding-left-alt", "mso-padding-right-alt", "mso-padding-top-alt", "mso-page-border-aligned", "mso-page-border-art", "mso-page-border-bottom-art", "mso-page-border-display", "mso-page-border-left-art", "mso-page-border-offset-from", "mso-page-border-right-art", "mso-page-border-surround-footer", "mso-page-border-surround-header", "mso-page-border-top-art", "mso-page-border-z-order", "mso-page-numbers", "mso-page-numbers-chapter-separator", "mso-page-numbers-chapter-style", "mso-page-numbers-start", "mso-page-numbers-style", "mso-page-orientation", "mso-page-scale", "mso-pagination", "mso-panose-arm-style", "mso-panose-contrast", "mso-panose-family-type", "mso-panose-letterform", "mso-panose-midline", "mso-panose-proportion", "mso-panose-serif-style", "mso-panose-stroke-variation", "mso-panose-weight", "mso-panose-x-height", "mso-paper-source", "mso-paper-source-first-page", "mso-paper-source-other-pages", "mso-pattern", "mso-pattern-color", "mso-pattern-style", "mso-print-area", "mso-print-color", "mso-print-gridlines", "mso-print-headings", "mso-print-resolution", "mso-print-sheet-order", "mso-print-title-column", "mso-print-title-row", "mso-prop-change", "mso-prop-change-author", "mso-prop-change-time", "mso-protection", "mso-rotate", "mso-row-margin-left", "mso-row-margin-right", "mso-ruby-merge", "mso-ruby-visibility", "mso-scheme-fill-color", "mso-scheme-shadow-color", "mso-shading", "mso-shadow-color", "mso-space-above", "mso-space-below", "mso-spacerun", "mso-special-character", "mso-special-format", "mso-style-id", "mso-style-name", "mso-style-next", "mso-style-parent", "mso-style-type", "mso-style-update", "mso-subdocument", "mso-symbol-font-family", "mso-tab-count", "mso-table-anchor-horizontal", "mso-table-anchor-vertical", "mso-table-bspace", "mso-table-del-author", "mso-table-del-time", "mso-table-deleted", "mso-table-dir", "mso-table-ins-author", "mso-table-ins-time", "mso-table-inserted", "mso-table-layout-alt", "mso-table-left", "mso-table-lspace", "mso-table-overlap", "mso-table-prop-author", "mso-table-prop-change", "mso-table-prop-time", "mso-table-rspace", "mso-table-top", "mso-table-tspace", "mso-table-wrap", "mso-text-animation", "mso-text-combine-brackets", "mso-text-combine-id", "mso-text-control", "mso-text-fit-id", "mso-text-indent-alt", "mso-text-orientation", "mso-text-raise", "mso-title-page", "mso-tny-compress", "mso-unsynced", "mso-vertical-align-alt", "mso-vertical-align-special", "mso-vertical-page-align", "mso-width-alt", "mso-width-source", "mso-word-wrap", "mso-xlrowspan", "mso-zero-height", "multiple", "muted", "name", "nav-banner-image", "navbutton_background_color", "navbutton_home_hovered", "navbutton_home_normal", "navbutton_home_pushed", "navbutton_horiz_hovered", "navbutton_horiz_normal", "navbutton_horiz_pushed", "navbutton_next_hovered", "navbutton_next_normal", "navbutton_next_pushed", "navbutton_prev_hovered", "navbutton_prev_normal", "navbutton_prev_pushed", "navbutton_up_hovered", "navbutton_up_normal", "navbutton_up_pushed", "navbutton_vert_hovered", "navbutton_vert_normal", "navbutton_vert_pushed", "nohref", "noresize", "noshade", "novalidate", "nowrap", "object", "onblur", "onchange", "onclick", "ondblclick", "onfocus", "onkeydown", "onkeypress", "onkeyup", "onload", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onreset", "onselect", "onsubmit", "onunload", "open", "optimum", "overflow", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "panose-1", "pattern", "ping", "placeholder", "position", "poster", "preload", "profile", "prompt", "punctuation-trim", "punctuation-wrap", "radiogroup", "readonly", "referrerpolicy", "rel", "required", "rev", "reversed", "right", "row-span", "rows", "rowspan", "ruby-align", "ruby-overhang", "ruby-position", "rules", "sandbox", "scheme", "scope", "scoped", "scrolling", "selected", "separator-image", "shape", "size", "sizes", "slot", "span", "spellcheck", "src", "srcdoc", "srclang", "srcset", "standby", "start", "step", "style", "summary", "tab-interval", "tab-stops", "tabindex", "table-border-color-dark", "table-border-color-light", "table-layout", "target", "text", "text-align", "text-autospace", "text-combine", "text-decoration", "text-effect", "text-fit", "text-indent", "text-justify", "text-justify-trim", "text-kashida", "text-line-through", "text-shadow", "text-transform", "text-underline", "text-underline-color", "text-underline-style", "title", "top", "top-bar-button", "translate", "type", "unicode-bidi", "urlId", "usemap", "valign", "value", "valuetype", "version", "vert-align", "vertical-align", "visibility", "vlink", "vnd.ms-excel.numberformat", "vspace", "white-space", "width", "word-break", "word-spacing", "wrap", "xmlns", "z-index"];

  const array = [];
  const charCodeCache = [];

  const leven = (left, right) => {
    if (left === right) {
      return 0;
    }

    const swap = left; // Swapping the strings if `a` is longer than `b` so we know which one is the
    // shortest & which one is the longest

    if (left.length > right.length) {
      left = right;
      right = swap;
    }

    let leftLength = left.length;
    let rightLength = right.length; // Performing suffix trimming:
    // We can linearly drop suffix common to both strings since they
    // don't increase distance at all
    // Note: `~-` is the bitwise way to perform a `- 1` operation

    while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
      leftLength--;
      rightLength--;
    } // Performing prefix trimming
    // We can linearly drop prefix common to both strings since they
    // don't increase distance at all


    let start = 0;

    while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
      start++;
    }

    leftLength -= start;
    rightLength -= start;

    if (leftLength === 0) {
      return rightLength;
    }

    let bCharCode;
    let result;
    let temp;
    let temp2;
    let i = 0;
    let j = 0;

    while (i < leftLength) {
      charCodeCache[i] = left.charCodeAt(start + i);
      array[i] = ++i;
    }

    while (j < rightLength) {
      bCharCode = right.charCodeAt(start + j);
      temp = j++;
      result = j;

      for (i = 0; i < leftLength; i++) {
        temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;
        temp = array[i]; // eslint-disable-next-line no-multi-assign

        result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
      }
    }

    return result;
  };

  var leven_1 = leven; // TODO: Remove this for the next major release

  var default_1 = leven;
  leven_1.default = default_1;

  // rule: attribute-malformed
  // -----------------------------------------------------------------------------
  // it flags up malformed HTML attributes

  function attributeMalformed(context) {
    // the following tags will be processed separately
    var blacklist = ["doctype"];
    return {
      attribute: function attribute(node) {
        // if Levenshtein distance is 1 and it's not among known attribute names,
        // it's definitely mis-typed
        if (!node.attribNameRecognised && !node.attribName.startsWith("xmlns:") && !blacklist.includes(node.parent.tagName)) {
          var somethingMatched = false;

          for (var i = 0, len = allHtmlAttribs.length; i < len; i++) {
            if (leven_1(allHtmlAttribs[i], node.attribName) === 1) {
              context.report({
                ruleId: "attribute-malformed",
                message: "Probably meant \"".concat(allHtmlAttribs[i], "\"."),
                idxFrom: node.attribNameStartsAt,
                idxTo: node.attribNameEndsAt,
                // second elem. from last range
                fix: {
                  ranges: [[node.attribNameStartsAt, node.attribNameEndsAt, allHtmlAttribs[i]]]
                }
              });
              somethingMatched = true;
              break;
            }
          }

          if (!somethingMatched) {
            // the attribute was not recognised
            context.report({
              ruleId: "attribute-malformed",
              message: "Unrecognised attribute \"".concat(node.attribName, "\"."),
              idxFrom: node.attribNameStartsAt,
              idxTo: node.attribNameEndsAt,
              fix: null
            });
          }
        } // context.str[node.attribNameEndsAt] !== "="
        // equal missing or something's wrong around it


        if (node.attribNameEndsAt && node.attribValueStartsAt) {
          if ( // if opening quotes are present, let's use their location
          node.attribOpeningQuoteAt !== null && context.str.slice(node.attribNameEndsAt, node.attribOpeningQuoteAt) !== "=") {
            var message = "Malformed around equal.";

            if (!context.str.slice(node.attribNameEndsAt, node.attribOpeningQuoteAt).includes("=")) {
              message = "Equal is missing.";
            } else if ( // rogue quotes after equals
            ["=\"", "='"].includes(context.str.slice(node.attribNameEndsAt, node.attribOpeningQuoteAt))) {
              message = "Delete repeated opening quotes.";
            }

            var fromRange = node.attribNameEndsAt;
            var toRange = node.attribOpeningQuoteAt;
            var whatToAdd = "="; // if equals is in a correct place, don't replace it

            if (context.str[fromRange] === "=") {
              fromRange++;
              whatToAdd = undefined;
            }

            context.report({
              ruleId: "attribute-malformed",
              message: message,
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              fix: {
                ranges: whatToAdd ? [[fromRange, toRange, "="]] : [[fromRange, toRange]]
              }
            });
          }
        } // maybe some quotes are missing?


        var ranges = [];

        if (node.attribOpeningQuoteAt === null && node.attribValueStartsAt !== null) {
          ranges.push([node.attribValueStartsAt, node.attribValueStartsAt, node.attribClosingQuoteAt === null ? "\"" : context.str[node.attribClosingQuoteAt]]);
        }

        if (node.attribClosingQuoteAt === null && node.attribValueEndsAt !== null) {
          ranges.push([node.attribValueEndsAt, node.attribValueEndsAt, node.attribOpeningQuoteAt === null ? "\"" : context.str[node.attribOpeningQuoteAt]]);
        }

        if (ranges.length) {
          context.report({
            ruleId: "attribute-malformed",
            message: "Quote".concat(ranges.length > 1 ? "s are" : " is", " missing."),
            idxFrom: node.attribStart,
            idxTo: node.attribEnd,
            fix: {
              ranges: ranges
            }
          });
        } // maybe quotes are mismatching?


        if (node.attribOpeningQuoteAt !== null && node.attribClosingQuoteAt !== null && context.str[node.attribOpeningQuoteAt] !== context.str[node.attribClosingQuoteAt]) {
          // default is double quotes; if content doesn't have them, that's what
          // we're going to use
          if (!node.attribValue.includes("\"")) {
            context.report({
              ruleId: "attribute-malformed",
              message: "".concat(context.str[node.attribClosingQuoteAt] === "\"" ? "Opening" : "Closing", " quote should be double."),
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              fix: {
                ranges: [context.str[node.attribClosingQuoteAt] === "\"" ? [node.attribOpeningQuoteAt, node.attribOpeningQuoteAt + 1, "\""] : [node.attribClosingQuoteAt, node.attribClosingQuoteAt + 1, "\""]]
              }
            });
          } else if (!node.attribValue.includes("'")) {
            context.report({
              ruleId: "attribute-malformed",
              message: "".concat(context.str[node.attribClosingQuoteAt] === "'" ? "Opening" : "Closing", " quote should be single."),
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              fix: {
                ranges: [context.str[node.attribClosingQuoteAt] === "'" ? [node.attribOpeningQuoteAt, node.attribOpeningQuoteAt + 1, "'"] : [node.attribClosingQuoteAt, node.attribClosingQuoteAt + 1, "'"]]
              }
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-abbr

  function attributeValidateAbbr(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "abbr") {
          // validate the parent
          if (!["td", "th"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-abbr",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any string


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-abbr"
            }));
          });
        }
      }
    };
  }

  var knownUnits = ["cm", "mm", "in", "px", "pt", "pc", "em", "ex", "ch", "rem", "vw", "vh", "vmin", "vmax", "%"];
  var knownCharsets = ["adobe-standard-encoding", "adobe-symbol-encoding", "amiga-1251", "ansi_x3.110-1983", "asmo_449", "big5", "big5-hkscs", "bocu-1", "brf", "bs_4730", "bs_viewdata", "cesu-8", "cp50220", "cp51932", "csa_z243.4-1985-1", "csa_z243.4-1985-2", "csa_z243.4-1985-gr", "csn_369103", "dec-mcs", "din_66003", "dk-us", "ds_2089", "ebcdic-at-de", "ebcdic-at-de-a", "ebcdic-ca-fr", "ebcdic-dk-no", "ebcdic-dk-no-a", "ebcdic-es", "ebcdic-es-a", "ebcdic-es-s", "ebcdic-fi-se", "ebcdic-fi-se-a", "ebcdic-fr", "ebcdic-it", "ebcdic-pt", "ebcdic-uk", "ebcdic-us", "ecma-cyrillic", "es", "es2", "euc-kr", "extended_unix_code_fixed_width_for_japanese", "extended_unix_code_packed_format_for_japanese", "gb18030", "gb2312", "gb_1988-80", "gb_2312-80", "gbk", "gost_19768-74", "greek-ccitt", "greek7", "greek7-old", "hp-desktop", "hp-legal", "hp-math8", "hp-pi-font", "hp-roman8", "hz-gb-2312", "ibm-symbols", "ibm-thai", "ibm00858", "ibm00924", "ibm01140", "ibm01141", "ibm01142", "ibm01143", "ibm01144", "ibm01145", "ibm01146", "ibm01147", "ibm01148", "ibm01149", "ibm037", "ibm038", "ibm1026", "ibm1047", "ibm273", "ibm274", "ibm275", "ibm277", "ibm278", "ibm280", "ibm281", "ibm284", "ibm285", "ibm290", "ibm297", "ibm420", "ibm423", "ibm424", "ibm437", "ibm500", "ibm775", "ibm850", "ibm851", "ibm852", "ibm855", "ibm857", "ibm860", "ibm861", "ibm862", "ibm863", "ibm864", "ibm865", "ibm866", "ibm868", "ibm869", "ibm870", "ibm871", "ibm880", "ibm891", "ibm903", "ibm904", "ibm905", "ibm918", "iec_p27-1", "inis", "inis-8", "inis-cyrillic", "invariant", "iso-10646-j-1", "iso-10646-ucs-2", "iso-10646-ucs-4", "iso-10646-ucs-basic", "iso-10646-unicode-latin1", "iso-10646-utf-1", "iso-11548-1", "iso-2022-cn", "iso-2022-cn-ext", "iso-2022-jp", "iso-2022-jp-2", "iso-2022-kr", "iso-8859-1-windows-3.0-latin-1", "iso-8859-1-windows-3.1-latin-1", "iso-8859-10", "iso-8859-13", "iso-8859-14", "iso-8859-15", "iso-8859-16", "iso-8859-2-windows-latin-2", "iso-8859-9-windows-latin-5", "iso-ir-90", "iso-unicode-ibm-1261", "iso-unicode-ibm-1264", "iso-unicode-ibm-1265", "iso-unicode-ibm-1268", "iso-unicode-ibm-1276", "iso_10367-box", "iso_2033-1983", "iso_5427", "iso_5427:1981", "iso_5428:1980", "iso_646.basic:1983", "iso_646.irv:1983", "iso_6937-2-25", "iso_6937-2-add", "iso_8859-1:1987", "iso_8859-2:1987", "iso_8859-3:1988", "iso_8859-4:1988", "iso_8859-5:1988", "iso_8859-6-e", "iso_8859-6-i", "iso_8859-6:1987", "iso_8859-7:1987", "iso_8859-8-e", "iso_8859-8-i", "iso_8859-8:1988", "iso_8859-9:1989", "iso_8859-supp", "it", "jis_c6220-1969-jp", "jis_c6220-1969-ro", "jis_c6226-1978", "jis_c6226-1983", "jis_c6229-1984-a", "jis_c6229-1984-b", "jis_c6229-1984-b-add", "jis_c6229-1984-hand", "jis_c6229-1984-hand-add", "jis_c6229-1984-kana", "jis_encoding", "jis_x0201", "jis_x0212-1990", "jus_i.b1.002", "jus_i.b1.003-mac", "jus_i.b1.003-serb", "koi7-switched", "koi8-r", "koi8-u", "ks_c_5601-1987", "ksc5636", "kz-1048", "latin-greek", "latin-greek-1", "latin-lap", "macintosh", "microsoft-publishing", "mnem", "mnemonic", "msz_7795.3", "nats-dano", "nats-dano-add", "nats-sefi", "nats-sefi-add", "nc_nc00-10:81", "nf_z_62-010", "nf_z_62-010_(1973)", "ns_4551-1", "ns_4551-2", "osd_ebcdic_df03_irv", "osd_ebcdic_df04_1", "osd_ebcdic_df04_15", "pc8-danish-norwegian", "pc8-turkish", "pt", "pt2", "ptcp154", "scsu", "sen_850200_b", "sen_850200_c", "shift_jis", "t.101-g2", "t.61-7bit", "t.61-8bit", "tis-620", "tscii", "unicode-1-1", "unicode-1-1-utf-7", "unknown-8bit", "us-ascii", "us-dk", "utf-16", "utf-16be", "utf-16le", "utf-32", "utf-32be", "utf-32le", "utf-7", "utf-8", "ventura-international", "ventura-math", "ventura-us", "videotex-suppl", "viqr", "viscii", "windows-1250", "windows-1251", "windows-1252", "windows-1253", "windows-1254", "windows-1255", "windows-1256", "windows-1257", "windows-1258", "windows-31j", "windows-874"]; // https://www.w3.org/TR/html4/sgml/loosedtd.html#Color
  // "There are also 16 widely known color names with their sRGB values"

  var basicColorNames = {
    aqua: "#00ffff",
    black: "#000000",
    blue: "#0000ff",
    fuchsia: "#ff00ff",
    gray: "#808080",
    green: "#008000",
    lime: "#00ff00",
    maroon: "#800000",
    navy: "#000080",
    olive: "#808000",
    purple: "#800080",
    red: "#ff0000",
    silver: "#c0c0c0",
    teal: "#008080",
    white: "#ffffff",
    yellow: "#ffff00"
  }; // https://www.w3schools.com/colors/colors_names.asp
  // https://developer.mozilla.org/en-US/docs/Web/CSS/color_value

  var extendedColorNames = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgrey: "#a9a9a9",
    darkgreen: "#006400",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    grey: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgrey: "#d3d3d3",
    lightgreen: "#90ee90",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  var sixDigitHexColorRegex = /^#([a-f0-9]{6})$/i;
  var classNameRegex = /^-?[_a-zA-Z]+[_a-zA-Z0-9-]*$/;

  // rule: attribute-validate-accept-charset

  function attributeValidateAcceptCharset(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "accept-charset") {
          // validate the parent
          if (!["form"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-accept-charset",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // validate against the charsets list from IANA:
          // https://www.iana.org/assignments/character-sets/character-sets.xhtml
          // https://www.w3.org/TR/html4/interact/forms.html#adef-accept-charset


          var errorArr = validateString(node.attribValue, node.attribValueStartsAt, {
            canBeCommaSeparated: true,
            noSpaceAfterComma: true,
            quickPermittedValues: ["UNKNOWN"],
            permittedValues: knownCharsets
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-accept-charset"
            }));
          });
        }
      }
    };
  }

  var db = {
  	"application/1d-interleaved-parityfec": {
  	source: "iana"
  },
  	"application/3gpdash-qoe-report+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/3gpp-ims+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/a2l": {
  	source: "iana"
  },
  	"application/activemessage": {
  	source: "iana"
  },
  	"application/activity+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-costmap+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-costmapfilter+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-directory+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-endpointcost+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-endpointcostparams+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-endpointprop+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-endpointpropparams+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-error+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-networkmap+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/alto-networkmapfilter+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/aml": {
  	source: "iana"
  },
  	"application/andrew-inset": {
  	source: "iana",
  	extensions: [
  		"ez"
  	]
  },
  	"application/applefile": {
  	source: "iana"
  },
  	"application/applixware": {
  	source: "apache",
  	extensions: [
  		"aw"
  	]
  },
  	"application/atf": {
  	source: "iana"
  },
  	"application/atfx": {
  	source: "iana"
  },
  	"application/atom+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"atom"
  	]
  },
  	"application/atomcat+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"atomcat"
  	]
  },
  	"application/atomdeleted+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"atomdeleted"
  	]
  },
  	"application/atomicmail": {
  	source: "iana"
  },
  	"application/atomsvc+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"atomsvc"
  	]
  },
  	"application/atsc-dwd+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"dwd"
  	]
  },
  	"application/atsc-held+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"held"
  	]
  },
  	"application/atsc-rdt+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/atsc-rsat+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rsat"
  	]
  },
  	"application/atxml": {
  	source: "iana"
  },
  	"application/auth-policy+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/bacnet-xdd+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/batch-smtp": {
  	source: "iana"
  },
  	"application/bdoc": {
  	compressible: false,
  	extensions: [
  		"bdoc"
  	]
  },
  	"application/beep+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/calendar+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/calendar+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xcs"
  	]
  },
  	"application/call-completion": {
  	source: "iana"
  },
  	"application/cals-1840": {
  	source: "iana"
  },
  	"application/cbor": {
  	source: "iana"
  },
  	"application/cbor-seq": {
  	source: "iana"
  },
  	"application/cccex": {
  	source: "iana"
  },
  	"application/ccmp+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/ccxml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"ccxml"
  	]
  },
  	"application/cdfx+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"cdfx"
  	]
  },
  	"application/cdmi-capability": {
  	source: "iana",
  	extensions: [
  		"cdmia"
  	]
  },
  	"application/cdmi-container": {
  	source: "iana",
  	extensions: [
  		"cdmic"
  	]
  },
  	"application/cdmi-domain": {
  	source: "iana",
  	extensions: [
  		"cdmid"
  	]
  },
  	"application/cdmi-object": {
  	source: "iana",
  	extensions: [
  		"cdmio"
  	]
  },
  	"application/cdmi-queue": {
  	source: "iana",
  	extensions: [
  		"cdmiq"
  	]
  },
  	"application/cdni": {
  	source: "iana"
  },
  	"application/cea": {
  	source: "iana"
  },
  	"application/cea-2018+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/cellml+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/cfw": {
  	source: "iana"
  },
  	"application/clue+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/clue_info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/cms": {
  	source: "iana"
  },
  	"application/cnrp+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/coap-group+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/coap-payload": {
  	source: "iana"
  },
  	"application/commonground": {
  	source: "iana"
  },
  	"application/conference-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/cose": {
  	source: "iana"
  },
  	"application/cose-key": {
  	source: "iana"
  },
  	"application/cose-key-set": {
  	source: "iana"
  },
  	"application/cpl+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/csrattrs": {
  	source: "iana"
  },
  	"application/csta+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/cstadata+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/csvm+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/cu-seeme": {
  	source: "apache",
  	extensions: [
  		"cu"
  	]
  },
  	"application/cwt": {
  	source: "iana"
  },
  	"application/cybercash": {
  	source: "iana"
  },
  	"application/dart": {
  	compressible: true
  },
  	"application/dash+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"mpd"
  	]
  },
  	"application/dashdelta": {
  	source: "iana"
  },
  	"application/davmount+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"davmount"
  	]
  },
  	"application/dca-rft": {
  	source: "iana"
  },
  	"application/dcd": {
  	source: "iana"
  },
  	"application/dec-dx": {
  	source: "iana"
  },
  	"application/dialog-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/dicom": {
  	source: "iana"
  },
  	"application/dicom+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/dicom+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/dii": {
  	source: "iana"
  },
  	"application/dit": {
  	source: "iana"
  },
  	"application/dns": {
  	source: "iana"
  },
  	"application/dns+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/dns-message": {
  	source: "iana"
  },
  	"application/docbook+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"dbk"
  	]
  },
  	"application/dskpp+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/dssc+der": {
  	source: "iana",
  	extensions: [
  		"dssc"
  	]
  },
  	"application/dssc+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xdssc"
  	]
  },
  	"application/dvcs": {
  	source: "iana"
  },
  	"application/ecmascript": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"ecma",
  		"es"
  	]
  },
  	"application/edi-consent": {
  	source: "iana"
  },
  	"application/edi-x12": {
  	source: "iana",
  	compressible: false
  },
  	"application/edifact": {
  	source: "iana",
  	compressible: false
  },
  	"application/efi": {
  	source: "iana"
  },
  	"application/emergencycalldata.comment+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/emergencycalldata.control+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/emergencycalldata.deviceinfo+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/emergencycalldata.ecall.msd": {
  	source: "iana"
  },
  	"application/emergencycalldata.providerinfo+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/emergencycalldata.serviceinfo+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/emergencycalldata.subscriberinfo+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/emergencycalldata.veds+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/emma+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"emma"
  	]
  },
  	"application/emotionml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"emotionml"
  	]
  },
  	"application/encaprtp": {
  	source: "iana"
  },
  	"application/epp+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/epub+zip": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"epub"
  	]
  },
  	"application/eshop": {
  	source: "iana"
  },
  	"application/exi": {
  	source: "iana",
  	extensions: [
  		"exi"
  	]
  },
  	"application/expect-ct-report+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/fastinfoset": {
  	source: "iana"
  },
  	"application/fastsoap": {
  	source: "iana"
  },
  	"application/fdt+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"fdt"
  	]
  },
  	"application/fhir+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/fhir+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/fido.trusted-apps+json": {
  	compressible: true
  },
  	"application/fits": {
  	source: "iana"
  },
  	"application/flexfec": {
  	source: "iana"
  },
  	"application/font-sfnt": {
  	source: "iana"
  },
  	"application/font-tdpfr": {
  	source: "iana",
  	extensions: [
  		"pfr"
  	]
  },
  	"application/font-woff": {
  	source: "iana",
  	compressible: false
  },
  	"application/framework-attributes+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/geo+json": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"geojson"
  	]
  },
  	"application/geo+json-seq": {
  	source: "iana"
  },
  	"application/geopackage+sqlite3": {
  	source: "iana"
  },
  	"application/geoxacml+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/gltf-buffer": {
  	source: "iana"
  },
  	"application/gml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"gml"
  	]
  },
  	"application/gpx+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"gpx"
  	]
  },
  	"application/gxf": {
  	source: "apache",
  	extensions: [
  		"gxf"
  	]
  },
  	"application/gzip": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"gz"
  	]
  },
  	"application/h224": {
  	source: "iana"
  },
  	"application/held+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/hjson": {
  	extensions: [
  		"hjson"
  	]
  },
  	"application/http": {
  	source: "iana"
  },
  	"application/hyperstudio": {
  	source: "iana",
  	extensions: [
  		"stk"
  	]
  },
  	"application/ibe-key-request+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/ibe-pkg-reply+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/ibe-pp-data": {
  	source: "iana"
  },
  	"application/iges": {
  	source: "iana"
  },
  	"application/im-iscomposing+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/index": {
  	source: "iana"
  },
  	"application/index.cmd": {
  	source: "iana"
  },
  	"application/index.obj": {
  	source: "iana"
  },
  	"application/index.response": {
  	source: "iana"
  },
  	"application/index.vnd": {
  	source: "iana"
  },
  	"application/inkml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"ink",
  		"inkml"
  	]
  },
  	"application/iotp": {
  	source: "iana"
  },
  	"application/ipfix": {
  	source: "iana",
  	extensions: [
  		"ipfix"
  	]
  },
  	"application/ipp": {
  	source: "iana"
  },
  	"application/isup": {
  	source: "iana"
  },
  	"application/its+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"its"
  	]
  },
  	"application/java-archive": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"jar",
  		"war",
  		"ear"
  	]
  },
  	"application/java-serialized-object": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"ser"
  	]
  },
  	"application/java-vm": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"class"
  	]
  },
  	"application/javascript": {
  	source: "iana",
  	charset: "UTF-8",
  	compressible: true,
  	extensions: [
  		"js",
  		"mjs"
  	]
  },
  	"application/jf2feed+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/jose": {
  	source: "iana"
  },
  	"application/jose+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/jrd+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/json": {
  	source: "iana",
  	charset: "UTF-8",
  	compressible: true,
  	extensions: [
  		"json",
  		"map"
  	]
  },
  	"application/json-patch+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/json-seq": {
  	source: "iana"
  },
  	"application/json5": {
  	extensions: [
  		"json5"
  	]
  },
  	"application/jsonml+json": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"jsonml"
  	]
  },
  	"application/jwk+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/jwk-set+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/jwt": {
  	source: "iana"
  },
  	"application/kpml-request+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/kpml-response+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/ld+json": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"jsonld"
  	]
  },
  	"application/lgr+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"lgr"
  	]
  },
  	"application/link-format": {
  	source: "iana"
  },
  	"application/load-control+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/lost+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"lostxml"
  	]
  },
  	"application/lostsync+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/lxf": {
  	source: "iana"
  },
  	"application/mac-binhex40": {
  	source: "iana",
  	extensions: [
  		"hqx"
  	]
  },
  	"application/mac-compactpro": {
  	source: "apache",
  	extensions: [
  		"cpt"
  	]
  },
  	"application/macwriteii": {
  	source: "iana"
  },
  	"application/mads+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"mads"
  	]
  },
  	"application/manifest+json": {
  	charset: "UTF-8",
  	compressible: true,
  	extensions: [
  		"webmanifest"
  	]
  },
  	"application/marc": {
  	source: "iana",
  	extensions: [
  		"mrc"
  	]
  },
  	"application/marcxml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"mrcx"
  	]
  },
  	"application/mathematica": {
  	source: "iana",
  	extensions: [
  		"ma",
  		"nb",
  		"mb"
  	]
  },
  	"application/mathml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"mathml"
  	]
  },
  	"application/mathml-content+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mathml-presentation+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-associated-procedure-description+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-deregister+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-envelope+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-msk+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-msk-response+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-protection-description+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-reception-report+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-register+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-register-response+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-schedule+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbms-user-service-description+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mbox": {
  	source: "iana",
  	extensions: [
  		"mbox"
  	]
  },
  	"application/media-policy-dataset+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/media_control+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/mediaservercontrol+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"mscml"
  	]
  },
  	"application/merge-patch+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/metalink+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"metalink"
  	]
  },
  	"application/metalink4+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"meta4"
  	]
  },
  	"application/mets+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"mets"
  	]
  },
  	"application/mf4": {
  	source: "iana"
  },
  	"application/mikey": {
  	source: "iana"
  },
  	"application/mipc": {
  	source: "iana"
  },
  	"application/mmt-aei+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"maei"
  	]
  },
  	"application/mmt-usd+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"musd"
  	]
  },
  	"application/mods+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"mods"
  	]
  },
  	"application/moss-keys": {
  	source: "iana"
  },
  	"application/moss-signature": {
  	source: "iana"
  },
  	"application/mosskey-data": {
  	source: "iana"
  },
  	"application/mosskey-request": {
  	source: "iana"
  },
  	"application/mp21": {
  	source: "iana",
  	extensions: [
  		"m21",
  		"mp21"
  	]
  },
  	"application/mp4": {
  	source: "iana",
  	extensions: [
  		"mp4s",
  		"m4p"
  	]
  },
  	"application/mpeg4-generic": {
  	source: "iana"
  },
  	"application/mpeg4-iod": {
  	source: "iana"
  },
  	"application/mpeg4-iod-xmt": {
  	source: "iana"
  },
  	"application/mrb-consumer+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xdf"
  	]
  },
  	"application/mrb-publish+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xdf"
  	]
  },
  	"application/msc-ivr+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/msc-mixer+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/msword": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"doc",
  		"dot"
  	]
  },
  	"application/mud+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/multipart-core": {
  	source: "iana"
  },
  	"application/mxf": {
  	source: "iana",
  	extensions: [
  		"mxf"
  	]
  },
  	"application/n-quads": {
  	source: "iana",
  	extensions: [
  		"nq"
  	]
  },
  	"application/n-triples": {
  	source: "iana",
  	extensions: [
  		"nt"
  	]
  },
  	"application/nasdata": {
  	source: "iana"
  },
  	"application/news-checkgroups": {
  	source: "iana"
  },
  	"application/news-groupinfo": {
  	source: "iana"
  },
  	"application/news-transmission": {
  	source: "iana"
  },
  	"application/nlsml+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/node": {
  	source: "iana"
  },
  	"application/nss": {
  	source: "iana"
  },
  	"application/ocsp-request": {
  	source: "iana"
  },
  	"application/ocsp-response": {
  	source: "iana"
  },
  	"application/octet-stream": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"bin",
  		"dms",
  		"lrf",
  		"mar",
  		"so",
  		"dist",
  		"distz",
  		"pkg",
  		"bpk",
  		"dump",
  		"elc",
  		"deploy",
  		"exe",
  		"dll",
  		"deb",
  		"dmg",
  		"iso",
  		"img",
  		"msi",
  		"msp",
  		"msm",
  		"buffer"
  	]
  },
  	"application/oda": {
  	source: "iana",
  	extensions: [
  		"oda"
  	]
  },
  	"application/odm+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/odx": {
  	source: "iana"
  },
  	"application/oebps-package+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"opf"
  	]
  },
  	"application/ogg": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"ogx"
  	]
  },
  	"application/omdoc+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"omdoc"
  	]
  },
  	"application/onenote": {
  	source: "apache",
  	extensions: [
  		"onetoc",
  		"onetoc2",
  		"onetmp",
  		"onepkg"
  	]
  },
  	"application/oscore": {
  	source: "iana"
  },
  	"application/oxps": {
  	source: "iana",
  	extensions: [
  		"oxps"
  	]
  },
  	"application/p2p-overlay+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"relo"
  	]
  },
  	"application/parityfec": {
  	source: "iana"
  },
  	"application/passport": {
  	source: "iana"
  },
  	"application/patch-ops-error+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xer"
  	]
  },
  	"application/pdf": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"pdf"
  	]
  },
  	"application/pdx": {
  	source: "iana"
  },
  	"application/pem-certificate-chain": {
  	source: "iana"
  },
  	"application/pgp-encrypted": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"pgp"
  	]
  },
  	"application/pgp-keys": {
  	source: "iana"
  },
  	"application/pgp-signature": {
  	source: "iana",
  	extensions: [
  		"asc",
  		"sig"
  	]
  },
  	"application/pics-rules": {
  	source: "apache",
  	extensions: [
  		"prf"
  	]
  },
  	"application/pidf+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/pidf-diff+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/pkcs10": {
  	source: "iana",
  	extensions: [
  		"p10"
  	]
  },
  	"application/pkcs12": {
  	source: "iana"
  },
  	"application/pkcs7-mime": {
  	source: "iana",
  	extensions: [
  		"p7m",
  		"p7c"
  	]
  },
  	"application/pkcs7-signature": {
  	source: "iana",
  	extensions: [
  		"p7s"
  	]
  },
  	"application/pkcs8": {
  	source: "iana",
  	extensions: [
  		"p8"
  	]
  },
  	"application/pkcs8-encrypted": {
  	source: "iana"
  },
  	"application/pkix-attr-cert": {
  	source: "iana",
  	extensions: [
  		"ac"
  	]
  },
  	"application/pkix-cert": {
  	source: "iana",
  	extensions: [
  		"cer"
  	]
  },
  	"application/pkix-crl": {
  	source: "iana",
  	extensions: [
  		"crl"
  	]
  },
  	"application/pkix-pkipath": {
  	source: "iana",
  	extensions: [
  		"pkipath"
  	]
  },
  	"application/pkixcmp": {
  	source: "iana",
  	extensions: [
  		"pki"
  	]
  },
  	"application/pls+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"pls"
  	]
  },
  	"application/poc-settings+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/postscript": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"ai",
  		"eps",
  		"ps"
  	]
  },
  	"application/ppsp-tracker+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/problem+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/problem+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/provenance+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"provx"
  	]
  },
  	"application/prs.alvestrand.titrax-sheet": {
  	source: "iana"
  },
  	"application/prs.cww": {
  	source: "iana",
  	extensions: [
  		"cww"
  	]
  },
  	"application/prs.hpub+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/prs.nprend": {
  	source: "iana"
  },
  	"application/prs.plucker": {
  	source: "iana"
  },
  	"application/prs.rdf-xml-crypt": {
  	source: "iana"
  },
  	"application/prs.xsf+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/pskc+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"pskcxml"
  	]
  },
  	"application/qsig": {
  	source: "iana"
  },
  	"application/raml+yaml": {
  	compressible: true,
  	extensions: [
  		"raml"
  	]
  },
  	"application/raptorfec": {
  	source: "iana"
  },
  	"application/rdap+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/rdf+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rdf",
  		"owl"
  	]
  },
  	"application/reginfo+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rif"
  	]
  },
  	"application/relax-ng-compact-syntax": {
  	source: "iana",
  	extensions: [
  		"rnc"
  	]
  },
  	"application/remote-printing": {
  	source: "iana"
  },
  	"application/reputon+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/resource-lists+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rl"
  	]
  },
  	"application/resource-lists-diff+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rld"
  	]
  },
  	"application/rfc+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/riscos": {
  	source: "iana"
  },
  	"application/rlmi+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/rls-services+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rs"
  	]
  },
  	"application/route-apd+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rapd"
  	]
  },
  	"application/route-s-tsid+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"sls"
  	]
  },
  	"application/route-usd+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rusd"
  	]
  },
  	"application/rpki-ghostbusters": {
  	source: "iana",
  	extensions: [
  		"gbr"
  	]
  },
  	"application/rpki-manifest": {
  	source: "iana",
  	extensions: [
  		"mft"
  	]
  },
  	"application/rpki-publication": {
  	source: "iana"
  },
  	"application/rpki-roa": {
  	source: "iana",
  	extensions: [
  		"roa"
  	]
  },
  	"application/rpki-updown": {
  	source: "iana"
  },
  	"application/rsd+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"rsd"
  	]
  },
  	"application/rss+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"rss"
  	]
  },
  	"application/rtf": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rtf"
  	]
  },
  	"application/rtploopback": {
  	source: "iana"
  },
  	"application/rtx": {
  	source: "iana"
  },
  	"application/samlassertion+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/samlmetadata+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/sbml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"sbml"
  	]
  },
  	"application/scaip+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/scim+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/scvp-cv-request": {
  	source: "iana",
  	extensions: [
  		"scq"
  	]
  },
  	"application/scvp-cv-response": {
  	source: "iana",
  	extensions: [
  		"scs"
  	]
  },
  	"application/scvp-vp-request": {
  	source: "iana",
  	extensions: [
  		"spq"
  	]
  },
  	"application/scvp-vp-response": {
  	source: "iana",
  	extensions: [
  		"spp"
  	]
  },
  	"application/sdp": {
  	source: "iana",
  	extensions: [
  		"sdp"
  	]
  },
  	"application/secevent+jwt": {
  	source: "iana"
  },
  	"application/senml+cbor": {
  	source: "iana"
  },
  	"application/senml+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/senml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"senmlx"
  	]
  },
  	"application/senml-exi": {
  	source: "iana"
  },
  	"application/sensml+cbor": {
  	source: "iana"
  },
  	"application/sensml+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/sensml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"sensmlx"
  	]
  },
  	"application/sensml-exi": {
  	source: "iana"
  },
  	"application/sep+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/sep-exi": {
  	source: "iana"
  },
  	"application/session-info": {
  	source: "iana"
  },
  	"application/set-payment": {
  	source: "iana"
  },
  	"application/set-payment-initiation": {
  	source: "iana",
  	extensions: [
  		"setpay"
  	]
  },
  	"application/set-registration": {
  	source: "iana"
  },
  	"application/set-registration-initiation": {
  	source: "iana",
  	extensions: [
  		"setreg"
  	]
  },
  	"application/sgml": {
  	source: "iana"
  },
  	"application/sgml-open-catalog": {
  	source: "iana"
  },
  	"application/shf+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"shf"
  	]
  },
  	"application/sieve": {
  	source: "iana",
  	extensions: [
  		"siv",
  		"sieve"
  	]
  },
  	"application/simple-filter+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/simple-message-summary": {
  	source: "iana"
  },
  	"application/simplesymbolcontainer": {
  	source: "iana"
  },
  	"application/sipc": {
  	source: "iana"
  },
  	"application/slate": {
  	source: "iana"
  },
  	"application/smil": {
  	source: "iana"
  },
  	"application/smil+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"smi",
  		"smil"
  	]
  },
  	"application/smpte336m": {
  	source: "iana"
  },
  	"application/soap+fastinfoset": {
  	source: "iana"
  },
  	"application/soap+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/sparql-query": {
  	source: "iana",
  	extensions: [
  		"rq"
  	]
  },
  	"application/sparql-results+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"srx"
  	]
  },
  	"application/spirits-event+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/sql": {
  	source: "iana"
  },
  	"application/srgs": {
  	source: "iana",
  	extensions: [
  		"gram"
  	]
  },
  	"application/srgs+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"grxml"
  	]
  },
  	"application/sru+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"sru"
  	]
  },
  	"application/ssdl+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"ssdl"
  	]
  },
  	"application/ssml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"ssml"
  	]
  },
  	"application/stix+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/swid+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"swidtag"
  	]
  },
  	"application/tamp-apex-update": {
  	source: "iana"
  },
  	"application/tamp-apex-update-confirm": {
  	source: "iana"
  },
  	"application/tamp-community-update": {
  	source: "iana"
  },
  	"application/tamp-community-update-confirm": {
  	source: "iana"
  },
  	"application/tamp-error": {
  	source: "iana"
  },
  	"application/tamp-sequence-adjust": {
  	source: "iana"
  },
  	"application/tamp-sequence-adjust-confirm": {
  	source: "iana"
  },
  	"application/tamp-status-query": {
  	source: "iana"
  },
  	"application/tamp-status-response": {
  	source: "iana"
  },
  	"application/tamp-update": {
  	source: "iana"
  },
  	"application/tamp-update-confirm": {
  	source: "iana"
  },
  	"application/tar": {
  	compressible: true
  },
  	"application/taxii+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/tei+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"tei",
  		"teicorpus"
  	]
  },
  	"application/tetra_isi": {
  	source: "iana"
  },
  	"application/thraud+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"tfi"
  	]
  },
  	"application/timestamp-query": {
  	source: "iana"
  },
  	"application/timestamp-reply": {
  	source: "iana"
  },
  	"application/timestamped-data": {
  	source: "iana",
  	extensions: [
  		"tsd"
  	]
  },
  	"application/tlsrpt+gzip": {
  	source: "iana"
  },
  	"application/tlsrpt+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/tnauthlist": {
  	source: "iana"
  },
  	"application/toml": {
  	compressible: true,
  	extensions: [
  		"toml"
  	]
  },
  	"application/trickle-ice-sdpfrag": {
  	source: "iana"
  },
  	"application/trig": {
  	source: "iana"
  },
  	"application/ttml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"ttml"
  	]
  },
  	"application/tve-trigger": {
  	source: "iana"
  },
  	"application/tzif": {
  	source: "iana"
  },
  	"application/tzif-leap": {
  	source: "iana"
  },
  	"application/ulpfec": {
  	source: "iana"
  },
  	"application/urc-grpsheet+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/urc-ressheet+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rsheet"
  	]
  },
  	"application/urc-targetdesc+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/urc-uisocketdesc+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vcard+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vcard+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vemmi": {
  	source: "iana"
  },
  	"application/vividence.scriptfile": {
  	source: "apache"
  },
  	"application/vnd.1000minds.decision-model+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"1km"
  	]
  },
  	"application/vnd.3gpp-prose+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp-prose-pc3ch+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp-v2x-local-service-information": {
  	source: "iana"
  },
  	"application/vnd.3gpp.access-transfer-events+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.bsf+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.gmop+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mc-signalling-ear": {
  	source: "iana"
  },
  	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcdata-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcdata-payload": {
  	source: "iana"
  },
  	"application/vnd.3gpp.mcdata-service-config+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcdata-signalling": {
  	source: "iana"
  },
  	"application/vnd.3gpp.mcdata-ue-config+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcdata-user-profile+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-floor-request+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-location-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-service-config+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-signed+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-ue-config+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcptt-user-profile+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcvideo-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcvideo-location-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcvideo-service-config+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcvideo-ue-config+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mcvideo-user-profile+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.mid-call+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.pic-bw-large": {
  	source: "iana",
  	extensions: [
  		"plb"
  	]
  },
  	"application/vnd.3gpp.pic-bw-small": {
  	source: "iana",
  	extensions: [
  		"psb"
  	]
  },
  	"application/vnd.3gpp.pic-bw-var": {
  	source: "iana",
  	extensions: [
  		"pvb"
  	]
  },
  	"application/vnd.3gpp.sms": {
  	source: "iana"
  },
  	"application/vnd.3gpp.sms+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.srvcc-ext+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.srvcc-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.state-and-event-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp.ussd+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp2.bcmcsinfo+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.3gpp2.sms": {
  	source: "iana"
  },
  	"application/vnd.3gpp2.tcap": {
  	source: "iana",
  	extensions: [
  		"tcap"
  	]
  },
  	"application/vnd.3lightssoftware.imagescal": {
  	source: "iana"
  },
  	"application/vnd.3m.post-it-notes": {
  	source: "iana",
  	extensions: [
  		"pwn"
  	]
  },
  	"application/vnd.accpac.simply.aso": {
  	source: "iana",
  	extensions: [
  		"aso"
  	]
  },
  	"application/vnd.accpac.simply.imp": {
  	source: "iana",
  	extensions: [
  		"imp"
  	]
  },
  	"application/vnd.acucobol": {
  	source: "iana",
  	extensions: [
  		"acu"
  	]
  },
  	"application/vnd.acucorp": {
  	source: "iana",
  	extensions: [
  		"atc",
  		"acutc"
  	]
  },
  	"application/vnd.adobe.air-application-installer-package+zip": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"air"
  	]
  },
  	"application/vnd.adobe.flash.movie": {
  	source: "iana"
  },
  	"application/vnd.adobe.formscentral.fcdt": {
  	source: "iana",
  	extensions: [
  		"fcdt"
  	]
  },
  	"application/vnd.adobe.fxp": {
  	source: "iana",
  	extensions: [
  		"fxp",
  		"fxpl"
  	]
  },
  	"application/vnd.adobe.partial-upload": {
  	source: "iana"
  },
  	"application/vnd.adobe.xdp+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xdp"
  	]
  },
  	"application/vnd.adobe.xfdf": {
  	source: "iana",
  	extensions: [
  		"xfdf"
  	]
  },
  	"application/vnd.aether.imp": {
  	source: "iana"
  },
  	"application/vnd.afpc.afplinedata": {
  	source: "iana"
  },
  	"application/vnd.afpc.afplinedata-pagedef": {
  	source: "iana"
  },
  	"application/vnd.afpc.foca-charset": {
  	source: "iana"
  },
  	"application/vnd.afpc.foca-codedfont": {
  	source: "iana"
  },
  	"application/vnd.afpc.foca-codepage": {
  	source: "iana"
  },
  	"application/vnd.afpc.modca": {
  	source: "iana"
  },
  	"application/vnd.afpc.modca-formdef": {
  	source: "iana"
  },
  	"application/vnd.afpc.modca-mediummap": {
  	source: "iana"
  },
  	"application/vnd.afpc.modca-objectcontainer": {
  	source: "iana"
  },
  	"application/vnd.afpc.modca-overlay": {
  	source: "iana"
  },
  	"application/vnd.afpc.modca-pagesegment": {
  	source: "iana"
  },
  	"application/vnd.ah-barcode": {
  	source: "iana"
  },
  	"application/vnd.ahead.space": {
  	source: "iana",
  	extensions: [
  		"ahead"
  	]
  },
  	"application/vnd.airzip.filesecure.azf": {
  	source: "iana",
  	extensions: [
  		"azf"
  	]
  },
  	"application/vnd.airzip.filesecure.azs": {
  	source: "iana",
  	extensions: [
  		"azs"
  	]
  },
  	"application/vnd.amadeus+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.amazon.ebook": {
  	source: "apache",
  	extensions: [
  		"azw"
  	]
  },
  	"application/vnd.amazon.mobi8-ebook": {
  	source: "iana"
  },
  	"application/vnd.americandynamics.acc": {
  	source: "iana",
  	extensions: [
  		"acc"
  	]
  },
  	"application/vnd.amiga.ami": {
  	source: "iana",
  	extensions: [
  		"ami"
  	]
  },
  	"application/vnd.amundsen.maze+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.android.ota": {
  	source: "iana"
  },
  	"application/vnd.android.package-archive": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"apk"
  	]
  },
  	"application/vnd.anki": {
  	source: "iana"
  },
  	"application/vnd.anser-web-certificate-issue-initiation": {
  	source: "iana",
  	extensions: [
  		"cii"
  	]
  },
  	"application/vnd.anser-web-funds-transfer-initiation": {
  	source: "apache",
  	extensions: [
  		"fti"
  	]
  },
  	"application/vnd.antix.game-component": {
  	source: "iana",
  	extensions: [
  		"atx"
  	]
  },
  	"application/vnd.apache.thrift.binary": {
  	source: "iana"
  },
  	"application/vnd.apache.thrift.compact": {
  	source: "iana"
  },
  	"application/vnd.apache.thrift.json": {
  	source: "iana"
  },
  	"application/vnd.api+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.aplextor.warrp+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.apothekende.reservation+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.apple.installer+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"mpkg"
  	]
  },
  	"application/vnd.apple.keynote": {
  	source: "iana",
  	extensions: [
  		"keynote"
  	]
  },
  	"application/vnd.apple.mpegurl": {
  	source: "iana",
  	extensions: [
  		"m3u8"
  	]
  },
  	"application/vnd.apple.numbers": {
  	source: "iana",
  	extensions: [
  		"numbers"
  	]
  },
  	"application/vnd.apple.pages": {
  	source: "iana",
  	extensions: [
  		"pages"
  	]
  },
  	"application/vnd.apple.pkpass": {
  	compressible: false,
  	extensions: [
  		"pkpass"
  	]
  },
  	"application/vnd.arastra.swi": {
  	source: "iana"
  },
  	"application/vnd.aristanetworks.swi": {
  	source: "iana",
  	extensions: [
  		"swi"
  	]
  },
  	"application/vnd.artisan+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.artsquare": {
  	source: "iana"
  },
  	"application/vnd.astraea-software.iota": {
  	source: "iana",
  	extensions: [
  		"iota"
  	]
  },
  	"application/vnd.audiograph": {
  	source: "iana",
  	extensions: [
  		"aep"
  	]
  },
  	"application/vnd.autopackage": {
  	source: "iana"
  },
  	"application/vnd.avalon+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.avistar+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.balsamiq.bmml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"bmml"
  	]
  },
  	"application/vnd.balsamiq.bmpr": {
  	source: "iana"
  },
  	"application/vnd.banana-accounting": {
  	source: "iana"
  },
  	"application/vnd.bbf.usp.error": {
  	source: "iana"
  },
  	"application/vnd.bbf.usp.msg": {
  	source: "iana"
  },
  	"application/vnd.bbf.usp.msg+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.bekitzur-stech+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.bint.med-content": {
  	source: "iana"
  },
  	"application/vnd.biopax.rdf+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.blink-idb-value-wrapper": {
  	source: "iana"
  },
  	"application/vnd.blueice.multipass": {
  	source: "iana",
  	extensions: [
  		"mpm"
  	]
  },
  	"application/vnd.bluetooth.ep.oob": {
  	source: "iana"
  },
  	"application/vnd.bluetooth.le.oob": {
  	source: "iana"
  },
  	"application/vnd.bmi": {
  	source: "iana",
  	extensions: [
  		"bmi"
  	]
  },
  	"application/vnd.bpf": {
  	source: "iana"
  },
  	"application/vnd.bpf3": {
  	source: "iana"
  },
  	"application/vnd.businessobjects": {
  	source: "iana",
  	extensions: [
  		"rep"
  	]
  },
  	"application/vnd.byu.uapi+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.cab-jscript": {
  	source: "iana"
  },
  	"application/vnd.canon-cpdl": {
  	source: "iana"
  },
  	"application/vnd.canon-lips": {
  	source: "iana"
  },
  	"application/vnd.capasystems-pg+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.cendio.thinlinc.clientconf": {
  	source: "iana"
  },
  	"application/vnd.century-systems.tcp_stream": {
  	source: "iana"
  },
  	"application/vnd.chemdraw+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"cdxml"
  	]
  },
  	"application/vnd.chess-pgn": {
  	source: "iana"
  },
  	"application/vnd.chipnuts.karaoke-mmd": {
  	source: "iana",
  	extensions: [
  		"mmd"
  	]
  },
  	"application/vnd.ciedi": {
  	source: "iana"
  },
  	"application/vnd.cinderella": {
  	source: "iana",
  	extensions: [
  		"cdy"
  	]
  },
  	"application/vnd.cirpack.isdn-ext": {
  	source: "iana"
  },
  	"application/vnd.citationstyles.style+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"csl"
  	]
  },
  	"application/vnd.claymore": {
  	source: "iana",
  	extensions: [
  		"cla"
  	]
  },
  	"application/vnd.cloanto.rp9": {
  	source: "iana",
  	extensions: [
  		"rp9"
  	]
  },
  	"application/vnd.clonk.c4group": {
  	source: "iana",
  	extensions: [
  		"c4g",
  		"c4d",
  		"c4f",
  		"c4p",
  		"c4u"
  	]
  },
  	"application/vnd.cluetrust.cartomobile-config": {
  	source: "iana",
  	extensions: [
  		"c11amc"
  	]
  },
  	"application/vnd.cluetrust.cartomobile-config-pkg": {
  	source: "iana",
  	extensions: [
  		"c11amz"
  	]
  },
  	"application/vnd.coffeescript": {
  	source: "iana"
  },
  	"application/vnd.collabio.xodocuments.document": {
  	source: "iana"
  },
  	"application/vnd.collabio.xodocuments.document-template": {
  	source: "iana"
  },
  	"application/vnd.collabio.xodocuments.presentation": {
  	source: "iana"
  },
  	"application/vnd.collabio.xodocuments.presentation-template": {
  	source: "iana"
  },
  	"application/vnd.collabio.xodocuments.spreadsheet": {
  	source: "iana"
  },
  	"application/vnd.collabio.xodocuments.spreadsheet-template": {
  	source: "iana"
  },
  	"application/vnd.collection+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.collection.doc+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.collection.next+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.comicbook+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.comicbook-rar": {
  	source: "iana"
  },
  	"application/vnd.commerce-battelle": {
  	source: "iana"
  },
  	"application/vnd.commonspace": {
  	source: "iana",
  	extensions: [
  		"csp"
  	]
  },
  	"application/vnd.contact.cmsg": {
  	source: "iana",
  	extensions: [
  		"cdbcmsg"
  	]
  },
  	"application/vnd.coreos.ignition+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.cosmocaller": {
  	source: "iana",
  	extensions: [
  		"cmc"
  	]
  },
  	"application/vnd.crick.clicker": {
  	source: "iana",
  	extensions: [
  		"clkx"
  	]
  },
  	"application/vnd.crick.clicker.keyboard": {
  	source: "iana",
  	extensions: [
  		"clkk"
  	]
  },
  	"application/vnd.crick.clicker.palette": {
  	source: "iana",
  	extensions: [
  		"clkp"
  	]
  },
  	"application/vnd.crick.clicker.template": {
  	source: "iana",
  	extensions: [
  		"clkt"
  	]
  },
  	"application/vnd.crick.clicker.wordbank": {
  	source: "iana",
  	extensions: [
  		"clkw"
  	]
  },
  	"application/vnd.criticaltools.wbs+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"wbs"
  	]
  },
  	"application/vnd.cryptii.pipe+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.crypto-shade-file": {
  	source: "iana"
  },
  	"application/vnd.ctc-posml": {
  	source: "iana",
  	extensions: [
  		"pml"
  	]
  },
  	"application/vnd.ctct.ws+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.cups-pdf": {
  	source: "iana"
  },
  	"application/vnd.cups-postscript": {
  	source: "iana"
  },
  	"application/vnd.cups-ppd": {
  	source: "iana",
  	extensions: [
  		"ppd"
  	]
  },
  	"application/vnd.cups-raster": {
  	source: "iana"
  },
  	"application/vnd.cups-raw": {
  	source: "iana"
  },
  	"application/vnd.curl": {
  	source: "iana"
  },
  	"application/vnd.curl.car": {
  	source: "apache",
  	extensions: [
  		"car"
  	]
  },
  	"application/vnd.curl.pcurl": {
  	source: "apache",
  	extensions: [
  		"pcurl"
  	]
  },
  	"application/vnd.cyan.dean.root+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.cybank": {
  	source: "iana"
  },
  	"application/vnd.d2l.coursepackage1p0+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.dart": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"dart"
  	]
  },
  	"application/vnd.data-vision.rdz": {
  	source: "iana",
  	extensions: [
  		"rdz"
  	]
  },
  	"application/vnd.datapackage+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dataresource+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.debian.binary-package": {
  	source: "iana"
  },
  	"application/vnd.dece.data": {
  	source: "iana",
  	extensions: [
  		"uvf",
  		"uvvf",
  		"uvd",
  		"uvvd"
  	]
  },
  	"application/vnd.dece.ttml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"uvt",
  		"uvvt"
  	]
  },
  	"application/vnd.dece.unspecified": {
  	source: "iana",
  	extensions: [
  		"uvx",
  		"uvvx"
  	]
  },
  	"application/vnd.dece.zip": {
  	source: "iana",
  	extensions: [
  		"uvz",
  		"uvvz"
  	]
  },
  	"application/vnd.denovo.fcselayout-link": {
  	source: "iana",
  	extensions: [
  		"fe_launch"
  	]
  },
  	"application/vnd.desmume.movie": {
  	source: "iana"
  },
  	"application/vnd.dir-bi.plate-dl-nosuffix": {
  	source: "iana"
  },
  	"application/vnd.dm.delegation+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dna": {
  	source: "iana",
  	extensions: [
  		"dna"
  	]
  },
  	"application/vnd.document+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dolby.mlp": {
  	source: "apache",
  	extensions: [
  		"mlp"
  	]
  },
  	"application/vnd.dolby.mobile.1": {
  	source: "iana"
  },
  	"application/vnd.dolby.mobile.2": {
  	source: "iana"
  },
  	"application/vnd.doremir.scorecloud-binary-document": {
  	source: "iana"
  },
  	"application/vnd.dpgraph": {
  	source: "iana",
  	extensions: [
  		"dpg"
  	]
  },
  	"application/vnd.dreamfactory": {
  	source: "iana",
  	extensions: [
  		"dfac"
  	]
  },
  	"application/vnd.drive+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ds-keypoint": {
  	source: "apache",
  	extensions: [
  		"kpxx"
  	]
  },
  	"application/vnd.dtg.local": {
  	source: "iana"
  },
  	"application/vnd.dtg.local.flash": {
  	source: "iana"
  },
  	"application/vnd.dtg.local.html": {
  	source: "iana"
  },
  	"application/vnd.dvb.ait": {
  	source: "iana",
  	extensions: [
  		"ait"
  	]
  },
  	"application/vnd.dvb.dvbj": {
  	source: "iana"
  },
  	"application/vnd.dvb.esgcontainer": {
  	source: "iana"
  },
  	"application/vnd.dvb.ipdcdftnotifaccess": {
  	source: "iana"
  },
  	"application/vnd.dvb.ipdcesgaccess": {
  	source: "iana"
  },
  	"application/vnd.dvb.ipdcesgaccess2": {
  	source: "iana"
  },
  	"application/vnd.dvb.ipdcesgpdd": {
  	source: "iana"
  },
  	"application/vnd.dvb.ipdcroaming": {
  	source: "iana"
  },
  	"application/vnd.dvb.iptv.alfec-base": {
  	source: "iana"
  },
  	"application/vnd.dvb.iptv.alfec-enhancement": {
  	source: "iana"
  },
  	"application/vnd.dvb.notif-aggregate-root+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dvb.notif-container+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dvb.notif-generic+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dvb.notif-ia-msglist+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dvb.notif-ia-registration-request+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dvb.notif-ia-registration-response+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dvb.notif-init+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.dvb.pfr": {
  	source: "iana"
  },
  	"application/vnd.dvb.service": {
  	source: "iana",
  	extensions: [
  		"svc"
  	]
  },
  	"application/vnd.dxr": {
  	source: "iana"
  },
  	"application/vnd.dynageo": {
  	source: "iana",
  	extensions: [
  		"geo"
  	]
  },
  	"application/vnd.dzr": {
  	source: "iana"
  },
  	"application/vnd.easykaraoke.cdgdownload": {
  	source: "iana"
  },
  	"application/vnd.ecdis-update": {
  	source: "iana"
  },
  	"application/vnd.ecip.rlp": {
  	source: "iana"
  },
  	"application/vnd.ecowin.chart": {
  	source: "iana",
  	extensions: [
  		"mag"
  	]
  },
  	"application/vnd.ecowin.filerequest": {
  	source: "iana"
  },
  	"application/vnd.ecowin.fileupdate": {
  	source: "iana"
  },
  	"application/vnd.ecowin.series": {
  	source: "iana"
  },
  	"application/vnd.ecowin.seriesrequest": {
  	source: "iana"
  },
  	"application/vnd.ecowin.seriesupdate": {
  	source: "iana"
  },
  	"application/vnd.efi.img": {
  	source: "iana"
  },
  	"application/vnd.efi.iso": {
  	source: "iana"
  },
  	"application/vnd.emclient.accessrequest+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.enliven": {
  	source: "iana",
  	extensions: [
  		"nml"
  	]
  },
  	"application/vnd.enphase.envoy": {
  	source: "iana"
  },
  	"application/vnd.eprints.data+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.epson.esf": {
  	source: "iana",
  	extensions: [
  		"esf"
  	]
  },
  	"application/vnd.epson.msf": {
  	source: "iana",
  	extensions: [
  		"msf"
  	]
  },
  	"application/vnd.epson.quickanime": {
  	source: "iana",
  	extensions: [
  		"qam"
  	]
  },
  	"application/vnd.epson.salt": {
  	source: "iana",
  	extensions: [
  		"slt"
  	]
  },
  	"application/vnd.epson.ssf": {
  	source: "iana",
  	extensions: [
  		"ssf"
  	]
  },
  	"application/vnd.ericsson.quickcall": {
  	source: "iana"
  },
  	"application/vnd.espass-espass+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.eszigno3+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"es3",
  		"et3"
  	]
  },
  	"application/vnd.etsi.aoc+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.asic-e+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.etsi.asic-s+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.etsi.cug+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.iptvcommand+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.iptvdiscovery+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.iptvprofile+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.iptvsad-bc+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.iptvsad-cod+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.iptvsad-npvr+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.iptvservice+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.iptvsync+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.iptvueprofile+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.mcid+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.mheg5": {
  	source: "iana"
  },
  	"application/vnd.etsi.overload-control-policy-dataset+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.pstn+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.sci+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.simservs+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.timestamp-token": {
  	source: "iana"
  },
  	"application/vnd.etsi.tsl+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.etsi.tsl.der": {
  	source: "iana"
  },
  	"application/vnd.eudora.data": {
  	source: "iana"
  },
  	"application/vnd.evolv.ecig.profile": {
  	source: "iana"
  },
  	"application/vnd.evolv.ecig.settings": {
  	source: "iana"
  },
  	"application/vnd.evolv.ecig.theme": {
  	source: "iana"
  },
  	"application/vnd.exstream-empower+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.exstream-package": {
  	source: "iana"
  },
  	"application/vnd.ezpix-album": {
  	source: "iana",
  	extensions: [
  		"ez2"
  	]
  },
  	"application/vnd.ezpix-package": {
  	source: "iana",
  	extensions: [
  		"ez3"
  	]
  },
  	"application/vnd.f-secure.mobile": {
  	source: "iana"
  },
  	"application/vnd.fastcopy-disk-image": {
  	source: "iana"
  },
  	"application/vnd.fdf": {
  	source: "iana",
  	extensions: [
  		"fdf"
  	]
  },
  	"application/vnd.fdsn.mseed": {
  	source: "iana",
  	extensions: [
  		"mseed"
  	]
  },
  	"application/vnd.fdsn.seed": {
  	source: "iana",
  	extensions: [
  		"seed",
  		"dataless"
  	]
  },
  	"application/vnd.ffsns": {
  	source: "iana"
  },
  	"application/vnd.ficlab.flb+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.filmit.zfc": {
  	source: "iana"
  },
  	"application/vnd.fints": {
  	source: "iana"
  },
  	"application/vnd.firemonkeys.cloudcell": {
  	source: "iana"
  },
  	"application/vnd.flographit": {
  	source: "iana",
  	extensions: [
  		"gph"
  	]
  },
  	"application/vnd.fluxtime.clip": {
  	source: "iana",
  	extensions: [
  		"ftc"
  	]
  },
  	"application/vnd.font-fontforge-sfd": {
  	source: "iana"
  },
  	"application/vnd.framemaker": {
  	source: "iana",
  	extensions: [
  		"fm",
  		"frame",
  		"maker",
  		"book"
  	]
  },
  	"application/vnd.frogans.fnc": {
  	source: "iana",
  	extensions: [
  		"fnc"
  	]
  },
  	"application/vnd.frogans.ltf": {
  	source: "iana",
  	extensions: [
  		"ltf"
  	]
  },
  	"application/vnd.fsc.weblaunch": {
  	source: "iana",
  	extensions: [
  		"fsc"
  	]
  },
  	"application/vnd.fujitsu.oasys": {
  	source: "iana",
  	extensions: [
  		"oas"
  	]
  },
  	"application/vnd.fujitsu.oasys2": {
  	source: "iana",
  	extensions: [
  		"oa2"
  	]
  },
  	"application/vnd.fujitsu.oasys3": {
  	source: "iana",
  	extensions: [
  		"oa3"
  	]
  },
  	"application/vnd.fujitsu.oasysgp": {
  	source: "iana",
  	extensions: [
  		"fg5"
  	]
  },
  	"application/vnd.fujitsu.oasysprs": {
  	source: "iana",
  	extensions: [
  		"bh2"
  	]
  },
  	"application/vnd.fujixerox.art-ex": {
  	source: "iana"
  },
  	"application/vnd.fujixerox.art4": {
  	source: "iana"
  },
  	"application/vnd.fujixerox.ddd": {
  	source: "iana",
  	extensions: [
  		"ddd"
  	]
  },
  	"application/vnd.fujixerox.docuworks": {
  	source: "iana",
  	extensions: [
  		"xdw"
  	]
  },
  	"application/vnd.fujixerox.docuworks.binder": {
  	source: "iana",
  	extensions: [
  		"xbd"
  	]
  },
  	"application/vnd.fujixerox.docuworks.container": {
  	source: "iana"
  },
  	"application/vnd.fujixerox.hbpl": {
  	source: "iana"
  },
  	"application/vnd.fut-misnet": {
  	source: "iana"
  },
  	"application/vnd.futoin+cbor": {
  	source: "iana"
  },
  	"application/vnd.futoin+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.fuzzysheet": {
  	source: "iana",
  	extensions: [
  		"fzs"
  	]
  },
  	"application/vnd.genomatix.tuxedo": {
  	source: "iana",
  	extensions: [
  		"txd"
  	]
  },
  	"application/vnd.gentics.grd+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.geo+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.geocube+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.geogebra.file": {
  	source: "iana",
  	extensions: [
  		"ggb"
  	]
  },
  	"application/vnd.geogebra.tool": {
  	source: "iana",
  	extensions: [
  		"ggt"
  	]
  },
  	"application/vnd.geometry-explorer": {
  	source: "iana",
  	extensions: [
  		"gex",
  		"gre"
  	]
  },
  	"application/vnd.geonext": {
  	source: "iana",
  	extensions: [
  		"gxt"
  	]
  },
  	"application/vnd.geoplan": {
  	source: "iana",
  	extensions: [
  		"g2w"
  	]
  },
  	"application/vnd.geospace": {
  	source: "iana",
  	extensions: [
  		"g3w"
  	]
  },
  	"application/vnd.gerber": {
  	source: "iana"
  },
  	"application/vnd.globalplatform.card-content-mgt": {
  	source: "iana"
  },
  	"application/vnd.globalplatform.card-content-mgt-response": {
  	source: "iana"
  },
  	"application/vnd.gmx": {
  	source: "iana",
  	extensions: [
  		"gmx"
  	]
  },
  	"application/vnd.google-apps.document": {
  	compressible: false,
  	extensions: [
  		"gdoc"
  	]
  },
  	"application/vnd.google-apps.presentation": {
  	compressible: false,
  	extensions: [
  		"gslides"
  	]
  },
  	"application/vnd.google-apps.spreadsheet": {
  	compressible: false,
  	extensions: [
  		"gsheet"
  	]
  },
  	"application/vnd.google-earth.kml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"kml"
  	]
  },
  	"application/vnd.google-earth.kmz": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"kmz"
  	]
  },
  	"application/vnd.gov.sk.e-form+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.gov.sk.e-form+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.gov.sk.xmldatacontainer+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.grafeq": {
  	source: "iana",
  	extensions: [
  		"gqf",
  		"gqs"
  	]
  },
  	"application/vnd.gridmp": {
  	source: "iana"
  },
  	"application/vnd.groove-account": {
  	source: "iana",
  	extensions: [
  		"gac"
  	]
  },
  	"application/vnd.groove-help": {
  	source: "iana",
  	extensions: [
  		"ghf"
  	]
  },
  	"application/vnd.groove-identity-message": {
  	source: "iana",
  	extensions: [
  		"gim"
  	]
  },
  	"application/vnd.groove-injector": {
  	source: "iana",
  	extensions: [
  		"grv"
  	]
  },
  	"application/vnd.groove-tool-message": {
  	source: "iana",
  	extensions: [
  		"gtm"
  	]
  },
  	"application/vnd.groove-tool-template": {
  	source: "iana",
  	extensions: [
  		"tpl"
  	]
  },
  	"application/vnd.groove-vcard": {
  	source: "iana",
  	extensions: [
  		"vcg"
  	]
  },
  	"application/vnd.hal+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.hal+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"hal"
  	]
  },
  	"application/vnd.handheld-entertainment+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"zmm"
  	]
  },
  	"application/vnd.hbci": {
  	source: "iana",
  	extensions: [
  		"hbci"
  	]
  },
  	"application/vnd.hc+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.hcl-bireports": {
  	source: "iana"
  },
  	"application/vnd.hdt": {
  	source: "iana"
  },
  	"application/vnd.heroku+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.hhe.lesson-player": {
  	source: "iana",
  	extensions: [
  		"les"
  	]
  },
  	"application/vnd.hp-hpgl": {
  	source: "iana",
  	extensions: [
  		"hpgl"
  	]
  },
  	"application/vnd.hp-hpid": {
  	source: "iana",
  	extensions: [
  		"hpid"
  	]
  },
  	"application/vnd.hp-hps": {
  	source: "iana",
  	extensions: [
  		"hps"
  	]
  },
  	"application/vnd.hp-jlyt": {
  	source: "iana",
  	extensions: [
  		"jlt"
  	]
  },
  	"application/vnd.hp-pcl": {
  	source: "iana",
  	extensions: [
  		"pcl"
  	]
  },
  	"application/vnd.hp-pclxl": {
  	source: "iana",
  	extensions: [
  		"pclxl"
  	]
  },
  	"application/vnd.httphone": {
  	source: "iana"
  },
  	"application/vnd.hydrostatix.sof-data": {
  	source: "iana",
  	extensions: [
  		"sfd-hdstx"
  	]
  },
  	"application/vnd.hyper+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.hyper-item+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.hyperdrive+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.hzn-3d-crossword": {
  	source: "iana"
  },
  	"application/vnd.ibm.afplinedata": {
  	source: "iana"
  },
  	"application/vnd.ibm.electronic-media": {
  	source: "iana"
  },
  	"application/vnd.ibm.minipay": {
  	source: "iana",
  	extensions: [
  		"mpy"
  	]
  },
  	"application/vnd.ibm.modcap": {
  	source: "iana",
  	extensions: [
  		"afp",
  		"listafp",
  		"list3820"
  	]
  },
  	"application/vnd.ibm.rights-management": {
  	source: "iana",
  	extensions: [
  		"irm"
  	]
  },
  	"application/vnd.ibm.secure-container": {
  	source: "iana",
  	extensions: [
  		"sc"
  	]
  },
  	"application/vnd.iccprofile": {
  	source: "iana",
  	extensions: [
  		"icc",
  		"icm"
  	]
  },
  	"application/vnd.ieee.1905": {
  	source: "iana"
  },
  	"application/vnd.igloader": {
  	source: "iana",
  	extensions: [
  		"igl"
  	]
  },
  	"application/vnd.imagemeter.folder+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.imagemeter.image+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.immervision-ivp": {
  	source: "iana",
  	extensions: [
  		"ivp"
  	]
  },
  	"application/vnd.immervision-ivu": {
  	source: "iana",
  	extensions: [
  		"ivu"
  	]
  },
  	"application/vnd.ims.imsccv1p1": {
  	source: "iana"
  },
  	"application/vnd.ims.imsccv1p2": {
  	source: "iana"
  },
  	"application/vnd.ims.imsccv1p3": {
  	source: "iana"
  },
  	"application/vnd.ims.lis.v2.result+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ims.lti.v2.toolproxy+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ims.lti.v2.toolproxy.id+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ims.lti.v2.toolsettings+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.informedcontrol.rms+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.informix-visionary": {
  	source: "iana"
  },
  	"application/vnd.infotech.project": {
  	source: "iana"
  },
  	"application/vnd.infotech.project+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.innopath.wamp.notification": {
  	source: "iana"
  },
  	"application/vnd.insors.igm": {
  	source: "iana",
  	extensions: [
  		"igm"
  	]
  },
  	"application/vnd.intercon.formnet": {
  	source: "iana",
  	extensions: [
  		"xpw",
  		"xpx"
  	]
  },
  	"application/vnd.intergeo": {
  	source: "iana",
  	extensions: [
  		"i2g"
  	]
  },
  	"application/vnd.intertrust.digibox": {
  	source: "iana"
  },
  	"application/vnd.intertrust.nncp": {
  	source: "iana"
  },
  	"application/vnd.intu.qbo": {
  	source: "iana",
  	extensions: [
  		"qbo"
  	]
  },
  	"application/vnd.intu.qfx": {
  	source: "iana",
  	extensions: [
  		"qfx"
  	]
  },
  	"application/vnd.iptc.g2.catalogitem+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.iptc.g2.conceptitem+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.iptc.g2.knowledgeitem+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.iptc.g2.newsitem+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.iptc.g2.newsmessage+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.iptc.g2.packageitem+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.iptc.g2.planningitem+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ipunplugged.rcprofile": {
  	source: "iana",
  	extensions: [
  		"rcprofile"
  	]
  },
  	"application/vnd.irepository.package+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"irp"
  	]
  },
  	"application/vnd.is-xpr": {
  	source: "iana",
  	extensions: [
  		"xpr"
  	]
  },
  	"application/vnd.isac.fcs": {
  	source: "iana",
  	extensions: [
  		"fcs"
  	]
  },
  	"application/vnd.iso11783-10+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.jam": {
  	source: "iana",
  	extensions: [
  		"jam"
  	]
  },
  	"application/vnd.japannet-directory-service": {
  	source: "iana"
  },
  	"application/vnd.japannet-jpnstore-wakeup": {
  	source: "iana"
  },
  	"application/vnd.japannet-payment-wakeup": {
  	source: "iana"
  },
  	"application/vnd.japannet-registration": {
  	source: "iana"
  },
  	"application/vnd.japannet-registration-wakeup": {
  	source: "iana"
  },
  	"application/vnd.japannet-setstore-wakeup": {
  	source: "iana"
  },
  	"application/vnd.japannet-verification": {
  	source: "iana"
  },
  	"application/vnd.japannet-verification-wakeup": {
  	source: "iana"
  },
  	"application/vnd.jcp.javame.midlet-rms": {
  	source: "iana",
  	extensions: [
  		"rms"
  	]
  },
  	"application/vnd.jisp": {
  	source: "iana",
  	extensions: [
  		"jisp"
  	]
  },
  	"application/vnd.joost.joda-archive": {
  	source: "iana",
  	extensions: [
  		"joda"
  	]
  },
  	"application/vnd.jsk.isdn-ngn": {
  	source: "iana"
  },
  	"application/vnd.kahootz": {
  	source: "iana",
  	extensions: [
  		"ktz",
  		"ktr"
  	]
  },
  	"application/vnd.kde.karbon": {
  	source: "iana",
  	extensions: [
  		"karbon"
  	]
  },
  	"application/vnd.kde.kchart": {
  	source: "iana",
  	extensions: [
  		"chrt"
  	]
  },
  	"application/vnd.kde.kformula": {
  	source: "iana",
  	extensions: [
  		"kfo"
  	]
  },
  	"application/vnd.kde.kivio": {
  	source: "iana",
  	extensions: [
  		"flw"
  	]
  },
  	"application/vnd.kde.kontour": {
  	source: "iana",
  	extensions: [
  		"kon"
  	]
  },
  	"application/vnd.kde.kpresenter": {
  	source: "iana",
  	extensions: [
  		"kpr",
  		"kpt"
  	]
  },
  	"application/vnd.kde.kspread": {
  	source: "iana",
  	extensions: [
  		"ksp"
  	]
  },
  	"application/vnd.kde.kword": {
  	source: "iana",
  	extensions: [
  		"kwd",
  		"kwt"
  	]
  },
  	"application/vnd.kenameaapp": {
  	source: "iana",
  	extensions: [
  		"htke"
  	]
  },
  	"application/vnd.kidspiration": {
  	source: "iana",
  	extensions: [
  		"kia"
  	]
  },
  	"application/vnd.kinar": {
  	source: "iana",
  	extensions: [
  		"kne",
  		"knp"
  	]
  },
  	"application/vnd.koan": {
  	source: "iana",
  	extensions: [
  		"skp",
  		"skd",
  		"skt",
  		"skm"
  	]
  },
  	"application/vnd.kodak-descriptor": {
  	source: "iana",
  	extensions: [
  		"sse"
  	]
  },
  	"application/vnd.las": {
  	source: "iana"
  },
  	"application/vnd.las.las+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.las.las+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"lasxml"
  	]
  },
  	"application/vnd.laszip": {
  	source: "iana"
  },
  	"application/vnd.leap+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.liberty-request+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.llamagraphics.life-balance.desktop": {
  	source: "iana",
  	extensions: [
  		"lbd"
  	]
  },
  	"application/vnd.llamagraphics.life-balance.exchange+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"lbe"
  	]
  },
  	"application/vnd.logipipe.circuit+zip": {
  	source: "iana",
  	compressible: false
  },
  	"application/vnd.loom": {
  	source: "iana"
  },
  	"application/vnd.lotus-1-2-3": {
  	source: "iana",
  	extensions: [
  		"123"
  	]
  },
  	"application/vnd.lotus-approach": {
  	source: "iana",
  	extensions: [
  		"apr"
  	]
  },
  	"application/vnd.lotus-freelance": {
  	source: "iana",
  	extensions: [
  		"pre"
  	]
  },
  	"application/vnd.lotus-notes": {
  	source: "iana",
  	extensions: [
  		"nsf"
  	]
  },
  	"application/vnd.lotus-organizer": {
  	source: "iana",
  	extensions: [
  		"org"
  	]
  },
  	"application/vnd.lotus-screencam": {
  	source: "iana",
  	extensions: [
  		"scm"
  	]
  },
  	"application/vnd.lotus-wordpro": {
  	source: "iana",
  	extensions: [
  		"lwp"
  	]
  },
  	"application/vnd.macports.portpkg": {
  	source: "iana",
  	extensions: [
  		"portpkg"
  	]
  },
  	"application/vnd.mapbox-vector-tile": {
  	source: "iana"
  },
  	"application/vnd.marlin.drm.actiontoken+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.marlin.drm.conftoken+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.marlin.drm.license+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.marlin.drm.mdcf": {
  	source: "iana"
  },
  	"application/vnd.mason+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.maxmind.maxmind-db": {
  	source: "iana"
  },
  	"application/vnd.mcd": {
  	source: "iana",
  	extensions: [
  		"mcd"
  	]
  },
  	"application/vnd.medcalcdata": {
  	source: "iana",
  	extensions: [
  		"mc1"
  	]
  },
  	"application/vnd.mediastation.cdkey": {
  	source: "iana",
  	extensions: [
  		"cdkey"
  	]
  },
  	"application/vnd.meridian-slingshot": {
  	source: "iana"
  },
  	"application/vnd.mfer": {
  	source: "iana",
  	extensions: [
  		"mwf"
  	]
  },
  	"application/vnd.mfmp": {
  	source: "iana",
  	extensions: [
  		"mfm"
  	]
  },
  	"application/vnd.micro+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.micrografx.flo": {
  	source: "iana",
  	extensions: [
  		"flo"
  	]
  },
  	"application/vnd.micrografx.igx": {
  	source: "iana",
  	extensions: [
  		"igx"
  	]
  },
  	"application/vnd.microsoft.portable-executable": {
  	source: "iana"
  },
  	"application/vnd.microsoft.windows.thumbnail-cache": {
  	source: "iana"
  },
  	"application/vnd.miele+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.mif": {
  	source: "iana",
  	extensions: [
  		"mif"
  	]
  },
  	"application/vnd.minisoft-hp3000-save": {
  	source: "iana"
  },
  	"application/vnd.mitsubishi.misty-guard.trustweb": {
  	source: "iana"
  },
  	"application/vnd.mobius.daf": {
  	source: "iana",
  	extensions: [
  		"daf"
  	]
  },
  	"application/vnd.mobius.dis": {
  	source: "iana",
  	extensions: [
  		"dis"
  	]
  },
  	"application/vnd.mobius.mbk": {
  	source: "iana",
  	extensions: [
  		"mbk"
  	]
  },
  	"application/vnd.mobius.mqy": {
  	source: "iana",
  	extensions: [
  		"mqy"
  	]
  },
  	"application/vnd.mobius.msl": {
  	source: "iana",
  	extensions: [
  		"msl"
  	]
  },
  	"application/vnd.mobius.plc": {
  	source: "iana",
  	extensions: [
  		"plc"
  	]
  },
  	"application/vnd.mobius.txf": {
  	source: "iana",
  	extensions: [
  		"txf"
  	]
  },
  	"application/vnd.mophun.application": {
  	source: "iana",
  	extensions: [
  		"mpn"
  	]
  },
  	"application/vnd.mophun.certificate": {
  	source: "iana",
  	extensions: [
  		"mpc"
  	]
  },
  	"application/vnd.motorola.flexsuite": {
  	source: "iana"
  },
  	"application/vnd.motorola.flexsuite.adsi": {
  	source: "iana"
  },
  	"application/vnd.motorola.flexsuite.fis": {
  	source: "iana"
  },
  	"application/vnd.motorola.flexsuite.gotap": {
  	source: "iana"
  },
  	"application/vnd.motorola.flexsuite.kmr": {
  	source: "iana"
  },
  	"application/vnd.motorola.flexsuite.ttc": {
  	source: "iana"
  },
  	"application/vnd.motorola.flexsuite.wem": {
  	source: "iana"
  },
  	"application/vnd.motorola.iprm": {
  	source: "iana"
  },
  	"application/vnd.mozilla.xul+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xul"
  	]
  },
  	"application/vnd.ms-3mfdocument": {
  	source: "iana"
  },
  	"application/vnd.ms-artgalry": {
  	source: "iana",
  	extensions: [
  		"cil"
  	]
  },
  	"application/vnd.ms-asf": {
  	source: "iana"
  },
  	"application/vnd.ms-cab-compressed": {
  	source: "iana",
  	extensions: [
  		"cab"
  	]
  },
  	"application/vnd.ms-color.iccprofile": {
  	source: "apache"
  },
  	"application/vnd.ms-excel": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"xls",
  		"xlm",
  		"xla",
  		"xlc",
  		"xlt",
  		"xlw"
  	]
  },
  	"application/vnd.ms-excel.addin.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"xlam"
  	]
  },
  	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"xlsb"
  	]
  },
  	"application/vnd.ms-excel.sheet.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"xlsm"
  	]
  },
  	"application/vnd.ms-excel.template.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"xltm"
  	]
  },
  	"application/vnd.ms-fontobject": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"eot"
  	]
  },
  	"application/vnd.ms-htmlhelp": {
  	source: "iana",
  	extensions: [
  		"chm"
  	]
  },
  	"application/vnd.ms-ims": {
  	source: "iana",
  	extensions: [
  		"ims"
  	]
  },
  	"application/vnd.ms-lrm": {
  	source: "iana",
  	extensions: [
  		"lrm"
  	]
  },
  	"application/vnd.ms-office.activex+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ms-officetheme": {
  	source: "iana",
  	extensions: [
  		"thmx"
  	]
  },
  	"application/vnd.ms-opentype": {
  	source: "apache",
  	compressible: true
  },
  	"application/vnd.ms-outlook": {
  	compressible: false,
  	extensions: [
  		"msg"
  	]
  },
  	"application/vnd.ms-package.obfuscated-opentype": {
  	source: "apache"
  },
  	"application/vnd.ms-pki.seccat": {
  	source: "apache",
  	extensions: [
  		"cat"
  	]
  },
  	"application/vnd.ms-pki.stl": {
  	source: "apache",
  	extensions: [
  		"stl"
  	]
  },
  	"application/vnd.ms-playready.initiator+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ms-powerpoint": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"ppt",
  		"pps",
  		"pot"
  	]
  },
  	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"ppam"
  	]
  },
  	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"pptm"
  	]
  },
  	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"sldm"
  	]
  },
  	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"ppsm"
  	]
  },
  	"application/vnd.ms-powerpoint.template.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"potm"
  	]
  },
  	"application/vnd.ms-printdevicecapabilities+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ms-printing.printticket+xml": {
  	source: "apache",
  	compressible: true
  },
  	"application/vnd.ms-printschematicket+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.ms-project": {
  	source: "iana",
  	extensions: [
  		"mpp",
  		"mpt"
  	]
  },
  	"application/vnd.ms-tnef": {
  	source: "iana"
  },
  	"application/vnd.ms-windows.devicepairing": {
  	source: "iana"
  },
  	"application/vnd.ms-windows.nwprinting.oob": {
  	source: "iana"
  },
  	"application/vnd.ms-windows.printerpairing": {
  	source: "iana"
  },
  	"application/vnd.ms-windows.wsd.oob": {
  	source: "iana"
  },
  	"application/vnd.ms-wmdrm.lic-chlg-req": {
  	source: "iana"
  },
  	"application/vnd.ms-wmdrm.lic-resp": {
  	source: "iana"
  },
  	"application/vnd.ms-wmdrm.meter-chlg-req": {
  	source: "iana"
  },
  	"application/vnd.ms-wmdrm.meter-resp": {
  	source: "iana"
  },
  	"application/vnd.ms-word.document.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"docm"
  	]
  },
  	"application/vnd.ms-word.template.macroenabled.12": {
  	source: "iana",
  	extensions: [
  		"dotm"
  	]
  },
  	"application/vnd.ms-works": {
  	source: "iana",
  	extensions: [
  		"wps",
  		"wks",
  		"wcm",
  		"wdb"
  	]
  },
  	"application/vnd.ms-wpl": {
  	source: "iana",
  	extensions: [
  		"wpl"
  	]
  },
  	"application/vnd.ms-xpsdocument": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"xps"
  	]
  },
  	"application/vnd.msa-disk-image": {
  	source: "iana"
  },
  	"application/vnd.mseq": {
  	source: "iana",
  	extensions: [
  		"mseq"
  	]
  },
  	"application/vnd.msign": {
  	source: "iana"
  },
  	"application/vnd.multiad.creator": {
  	source: "iana"
  },
  	"application/vnd.multiad.creator.cif": {
  	source: "iana"
  },
  	"application/vnd.music-niff": {
  	source: "iana"
  },
  	"application/vnd.musician": {
  	source: "iana",
  	extensions: [
  		"mus"
  	]
  },
  	"application/vnd.muvee.style": {
  	source: "iana",
  	extensions: [
  		"msty"
  	]
  },
  	"application/vnd.mynfc": {
  	source: "iana",
  	extensions: [
  		"taglet"
  	]
  },
  	"application/vnd.ncd.control": {
  	source: "iana"
  },
  	"application/vnd.ncd.reference": {
  	source: "iana"
  },
  	"application/vnd.nearst.inv+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.nervana": {
  	source: "iana"
  },
  	"application/vnd.netfpx": {
  	source: "iana"
  },
  	"application/vnd.neurolanguage.nlu": {
  	source: "iana",
  	extensions: [
  		"nlu"
  	]
  },
  	"application/vnd.nimn": {
  	source: "iana"
  },
  	"application/vnd.nintendo.nitro.rom": {
  	source: "iana"
  },
  	"application/vnd.nintendo.snes.rom": {
  	source: "iana"
  },
  	"application/vnd.nitf": {
  	source: "iana",
  	extensions: [
  		"ntf",
  		"nitf"
  	]
  },
  	"application/vnd.noblenet-directory": {
  	source: "iana",
  	extensions: [
  		"nnd"
  	]
  },
  	"application/vnd.noblenet-sealer": {
  	source: "iana",
  	extensions: [
  		"nns"
  	]
  },
  	"application/vnd.noblenet-web": {
  	source: "iana",
  	extensions: [
  		"nnw"
  	]
  },
  	"application/vnd.nokia.catalogs": {
  	source: "iana"
  },
  	"application/vnd.nokia.conml+wbxml": {
  	source: "iana"
  },
  	"application/vnd.nokia.conml+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.nokia.iptv.config+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.nokia.isds-radio-presets": {
  	source: "iana"
  },
  	"application/vnd.nokia.landmark+wbxml": {
  	source: "iana"
  },
  	"application/vnd.nokia.landmark+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.nokia.landmarkcollection+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.nokia.n-gage.ac+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"ac"
  	]
  },
  	"application/vnd.nokia.n-gage.data": {
  	source: "iana",
  	extensions: [
  		"ngdat"
  	]
  },
  	"application/vnd.nokia.n-gage.symbian.install": {
  	source: "iana",
  	extensions: [
  		"n-gage"
  	]
  },
  	"application/vnd.nokia.ncd": {
  	source: "iana"
  },
  	"application/vnd.nokia.pcd+wbxml": {
  	source: "iana"
  },
  	"application/vnd.nokia.pcd+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.nokia.radio-preset": {
  	source: "iana",
  	extensions: [
  		"rpst"
  	]
  },
  	"application/vnd.nokia.radio-presets": {
  	source: "iana",
  	extensions: [
  		"rpss"
  	]
  },
  	"application/vnd.novadigm.edm": {
  	source: "iana",
  	extensions: [
  		"edm"
  	]
  },
  	"application/vnd.novadigm.edx": {
  	source: "iana",
  	extensions: [
  		"edx"
  	]
  },
  	"application/vnd.novadigm.ext": {
  	source: "iana",
  	extensions: [
  		"ext"
  	]
  },
  	"application/vnd.ntt-local.content-share": {
  	source: "iana"
  },
  	"application/vnd.ntt-local.file-transfer": {
  	source: "iana"
  },
  	"application/vnd.ntt-local.ogw_remote-access": {
  	source: "iana"
  },
  	"application/vnd.ntt-local.sip-ta_remote": {
  	source: "iana"
  },
  	"application/vnd.ntt-local.sip-ta_tcp_stream": {
  	source: "iana"
  },
  	"application/vnd.oasis.opendocument.chart": {
  	source: "iana",
  	extensions: [
  		"odc"
  	]
  },
  	"application/vnd.oasis.opendocument.chart-template": {
  	source: "iana",
  	extensions: [
  		"otc"
  	]
  },
  	"application/vnd.oasis.opendocument.database": {
  	source: "iana",
  	extensions: [
  		"odb"
  	]
  },
  	"application/vnd.oasis.opendocument.formula": {
  	source: "iana",
  	extensions: [
  		"odf"
  	]
  },
  	"application/vnd.oasis.opendocument.formula-template": {
  	source: "iana",
  	extensions: [
  		"odft"
  	]
  },
  	"application/vnd.oasis.opendocument.graphics": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"odg"
  	]
  },
  	"application/vnd.oasis.opendocument.graphics-template": {
  	source: "iana",
  	extensions: [
  		"otg"
  	]
  },
  	"application/vnd.oasis.opendocument.image": {
  	source: "iana",
  	extensions: [
  		"odi"
  	]
  },
  	"application/vnd.oasis.opendocument.image-template": {
  	source: "iana",
  	extensions: [
  		"oti"
  	]
  },
  	"application/vnd.oasis.opendocument.presentation": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"odp"
  	]
  },
  	"application/vnd.oasis.opendocument.presentation-template": {
  	source: "iana",
  	extensions: [
  		"otp"
  	]
  },
  	"application/vnd.oasis.opendocument.spreadsheet": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"ods"
  	]
  },
  	"application/vnd.oasis.opendocument.spreadsheet-template": {
  	source: "iana",
  	extensions: [
  		"ots"
  	]
  },
  	"application/vnd.oasis.opendocument.text": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"odt"
  	]
  },
  	"application/vnd.oasis.opendocument.text-master": {
  	source: "iana",
  	extensions: [
  		"odm"
  	]
  },
  	"application/vnd.oasis.opendocument.text-template": {
  	source: "iana",
  	extensions: [
  		"ott"
  	]
  },
  	"application/vnd.oasis.opendocument.text-web": {
  	source: "iana",
  	extensions: [
  		"oth"
  	]
  },
  	"application/vnd.obn": {
  	source: "iana"
  },
  	"application/vnd.ocf+cbor": {
  	source: "iana"
  },
  	"application/vnd.oftn.l10n+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oipf.contentaccessdownload+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oipf.contentaccessstreaming+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oipf.cspg-hexbinary": {
  	source: "iana"
  },
  	"application/vnd.oipf.dae.svg+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oipf.dae.xhtml+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oipf.mippvcontrolmessage+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oipf.pae.gem": {
  	source: "iana"
  },
  	"application/vnd.oipf.spdiscovery+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oipf.spdlist+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oipf.ueprofile+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oipf.userprofile+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.olpc-sugar": {
  	source: "iana",
  	extensions: [
  		"xo"
  	]
  },
  	"application/vnd.oma-scws-config": {
  	source: "iana"
  },
  	"application/vnd.oma-scws-http-request": {
  	source: "iana"
  },
  	"application/vnd.oma-scws-http-response": {
  	source: "iana"
  },
  	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.bcast.drm-trigger+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.bcast.imd+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.bcast.ltkm": {
  	source: "iana"
  },
  	"application/vnd.oma.bcast.notification+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.bcast.provisioningtrigger": {
  	source: "iana"
  },
  	"application/vnd.oma.bcast.sgboot": {
  	source: "iana"
  },
  	"application/vnd.oma.bcast.sgdd+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.bcast.sgdu": {
  	source: "iana"
  },
  	"application/vnd.oma.bcast.simple-symbol-container": {
  	source: "iana"
  },
  	"application/vnd.oma.bcast.smartcard-trigger+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.bcast.sprov+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.bcast.stkm": {
  	source: "iana"
  },
  	"application/vnd.oma.cab-address-book+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.cab-feature-handler+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.cab-pcc+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.cab-subs-invite+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.cab-user-prefs+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.dcd": {
  	source: "iana"
  },
  	"application/vnd.oma.dcdc": {
  	source: "iana"
  },
  	"application/vnd.oma.dd2+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"dd2"
  	]
  },
  	"application/vnd.oma.drm.risd+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.group-usage-list+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.lwm2m+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.lwm2m+tlv": {
  	source: "iana"
  },
  	"application/vnd.oma.pal+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.poc.detailed-progress-report+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.poc.final-report+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.poc.groups+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.poc.invocation-descriptor+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.poc.optimized-progress-report+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.push": {
  	source: "iana"
  },
  	"application/vnd.oma.scidm.messages+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oma.xcap-directory+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.omads-email+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.omads-file+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.omads-folder+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.omaloc-supl-init": {
  	source: "iana"
  },
  	"application/vnd.onepager": {
  	source: "iana"
  },
  	"application/vnd.onepagertamp": {
  	source: "iana"
  },
  	"application/vnd.onepagertamx": {
  	source: "iana"
  },
  	"application/vnd.onepagertat": {
  	source: "iana"
  },
  	"application/vnd.onepagertatp": {
  	source: "iana"
  },
  	"application/vnd.onepagertatx": {
  	source: "iana"
  },
  	"application/vnd.openblox.game+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"obgx"
  	]
  },
  	"application/vnd.openblox.game-binary": {
  	source: "iana"
  },
  	"application/vnd.openeye.oeb": {
  	source: "iana"
  },
  	"application/vnd.openofficeorg.extension": {
  	source: "apache",
  	extensions: [
  		"oxt"
  	]
  },
  	"application/vnd.openstreetmap.data+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"osm"
  	]
  },
  	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.drawing+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"pptx"
  	]
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
  	source: "iana",
  	extensions: [
  		"sldx"
  	]
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
  	source: "iana",
  	extensions: [
  		"ppsx"
  	]
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.template": {
  	source: "iana",
  	extensions: [
  		"potx"
  	]
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"xlsx"
  	]
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
  	source: "iana",
  	extensions: [
  		"xltx"
  	]
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.theme+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.vmldrawing": {
  	source: "iana"
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"docx"
  	]
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
  	source: "iana",
  	extensions: [
  		"dotx"
  	]
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-package.core-properties+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.openxmlformats-package.relationships+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oracle.resource+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.orange.indata": {
  	source: "iana"
  },
  	"application/vnd.osa.netdeploy": {
  	source: "iana"
  },
  	"application/vnd.osgeo.mapguide.package": {
  	source: "iana",
  	extensions: [
  		"mgp"
  	]
  },
  	"application/vnd.osgi.bundle": {
  	source: "iana"
  },
  	"application/vnd.osgi.dp": {
  	source: "iana",
  	extensions: [
  		"dp"
  	]
  },
  	"application/vnd.osgi.subsystem": {
  	source: "iana",
  	extensions: [
  		"esa"
  	]
  },
  	"application/vnd.otps.ct-kip+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.oxli.countgraph": {
  	source: "iana"
  },
  	"application/vnd.pagerduty+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.palm": {
  	source: "iana",
  	extensions: [
  		"pdb",
  		"pqa",
  		"oprc"
  	]
  },
  	"application/vnd.panoply": {
  	source: "iana"
  },
  	"application/vnd.paos.xml": {
  	source: "iana"
  },
  	"application/vnd.patentdive": {
  	source: "iana"
  },
  	"application/vnd.patientecommsdoc": {
  	source: "iana"
  },
  	"application/vnd.pawaafile": {
  	source: "iana",
  	extensions: [
  		"paw"
  	]
  },
  	"application/vnd.pcos": {
  	source: "iana"
  },
  	"application/vnd.pg.format": {
  	source: "iana",
  	extensions: [
  		"str"
  	]
  },
  	"application/vnd.pg.osasli": {
  	source: "iana",
  	extensions: [
  		"ei6"
  	]
  },
  	"application/vnd.piaccess.application-licence": {
  	source: "iana"
  },
  	"application/vnd.picsel": {
  	source: "iana",
  	extensions: [
  		"efif"
  	]
  },
  	"application/vnd.pmi.widget": {
  	source: "iana",
  	extensions: [
  		"wg"
  	]
  },
  	"application/vnd.poc.group-advertisement+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.pocketlearn": {
  	source: "iana",
  	extensions: [
  		"plf"
  	]
  },
  	"application/vnd.powerbuilder6": {
  	source: "iana",
  	extensions: [
  		"pbd"
  	]
  },
  	"application/vnd.powerbuilder6-s": {
  	source: "iana"
  },
  	"application/vnd.powerbuilder7": {
  	source: "iana"
  },
  	"application/vnd.powerbuilder7-s": {
  	source: "iana"
  },
  	"application/vnd.powerbuilder75": {
  	source: "iana"
  },
  	"application/vnd.powerbuilder75-s": {
  	source: "iana"
  },
  	"application/vnd.preminet": {
  	source: "iana"
  },
  	"application/vnd.previewsystems.box": {
  	source: "iana",
  	extensions: [
  		"box"
  	]
  },
  	"application/vnd.proteus.magazine": {
  	source: "iana",
  	extensions: [
  		"mgz"
  	]
  },
  	"application/vnd.psfs": {
  	source: "iana"
  },
  	"application/vnd.publishare-delta-tree": {
  	source: "iana",
  	extensions: [
  		"qps"
  	]
  },
  	"application/vnd.pvi.ptid1": {
  	source: "iana",
  	extensions: [
  		"ptid"
  	]
  },
  	"application/vnd.pwg-multiplexed": {
  	source: "iana"
  },
  	"application/vnd.pwg-xhtml-print+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.qualcomm.brew-app-res": {
  	source: "iana"
  },
  	"application/vnd.quarantainenet": {
  	source: "iana"
  },
  	"application/vnd.quark.quarkxpress": {
  	source: "iana",
  	extensions: [
  		"qxd",
  		"qxt",
  		"qwd",
  		"qwt",
  		"qxl",
  		"qxb"
  	]
  },
  	"application/vnd.quobject-quoxdocument": {
  	source: "iana"
  },
  	"application/vnd.radisys.moml+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-audit+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-audit-conf+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-audit-conn+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-audit-dialog+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-audit-stream+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-conf+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-dialog+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-dialog-base+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-dialog-group+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-dialog-speech+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.radisys.msml-dialog-transform+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.rainstor.data": {
  	source: "iana"
  },
  	"application/vnd.rapid": {
  	source: "iana"
  },
  	"application/vnd.rar": {
  	source: "iana"
  },
  	"application/vnd.realvnc.bed": {
  	source: "iana",
  	extensions: [
  		"bed"
  	]
  },
  	"application/vnd.recordare.musicxml": {
  	source: "iana",
  	extensions: [
  		"mxl"
  	]
  },
  	"application/vnd.recordare.musicxml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"musicxml"
  	]
  },
  	"application/vnd.renlearn.rlprint": {
  	source: "iana"
  },
  	"application/vnd.restful+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.rig.cryptonote": {
  	source: "iana",
  	extensions: [
  		"cryptonote"
  	]
  },
  	"application/vnd.rim.cod": {
  	source: "apache",
  	extensions: [
  		"cod"
  	]
  },
  	"application/vnd.rn-realmedia": {
  	source: "apache",
  	extensions: [
  		"rm"
  	]
  },
  	"application/vnd.rn-realmedia-vbr": {
  	source: "apache",
  	extensions: [
  		"rmvb"
  	]
  },
  	"application/vnd.route66.link66+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"link66"
  	]
  },
  	"application/vnd.rs-274x": {
  	source: "iana"
  },
  	"application/vnd.ruckus.download": {
  	source: "iana"
  },
  	"application/vnd.s3sms": {
  	source: "iana"
  },
  	"application/vnd.sailingtracker.track": {
  	source: "iana",
  	extensions: [
  		"st"
  	]
  },
  	"application/vnd.sbm.cid": {
  	source: "iana"
  },
  	"application/vnd.sbm.mid2": {
  	source: "iana"
  },
  	"application/vnd.scribus": {
  	source: "iana"
  },
  	"application/vnd.sealed.3df": {
  	source: "iana"
  },
  	"application/vnd.sealed.csf": {
  	source: "iana"
  },
  	"application/vnd.sealed.doc": {
  	source: "iana"
  },
  	"application/vnd.sealed.eml": {
  	source: "iana"
  },
  	"application/vnd.sealed.mht": {
  	source: "iana"
  },
  	"application/vnd.sealed.net": {
  	source: "iana"
  },
  	"application/vnd.sealed.ppt": {
  	source: "iana"
  },
  	"application/vnd.sealed.tiff": {
  	source: "iana"
  },
  	"application/vnd.sealed.xls": {
  	source: "iana"
  },
  	"application/vnd.sealedmedia.softseal.html": {
  	source: "iana"
  },
  	"application/vnd.sealedmedia.softseal.pdf": {
  	source: "iana"
  },
  	"application/vnd.seemail": {
  	source: "iana",
  	extensions: [
  		"see"
  	]
  },
  	"application/vnd.sema": {
  	source: "iana",
  	extensions: [
  		"sema"
  	]
  },
  	"application/vnd.semd": {
  	source: "iana",
  	extensions: [
  		"semd"
  	]
  },
  	"application/vnd.semf": {
  	source: "iana",
  	extensions: [
  		"semf"
  	]
  },
  	"application/vnd.shade-save-file": {
  	source: "iana"
  },
  	"application/vnd.shana.informed.formdata": {
  	source: "iana",
  	extensions: [
  		"ifm"
  	]
  },
  	"application/vnd.shana.informed.formtemplate": {
  	source: "iana",
  	extensions: [
  		"itp"
  	]
  },
  	"application/vnd.shana.informed.interchange": {
  	source: "iana",
  	extensions: [
  		"iif"
  	]
  },
  	"application/vnd.shana.informed.package": {
  	source: "iana",
  	extensions: [
  		"ipk"
  	]
  },
  	"application/vnd.shootproof+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.shopkick+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.sigrok.session": {
  	source: "iana"
  },
  	"application/vnd.simtech-mindmapper": {
  	source: "iana",
  	extensions: [
  		"twd",
  		"twds"
  	]
  },
  	"application/vnd.siren+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.smaf": {
  	source: "iana",
  	extensions: [
  		"mmf"
  	]
  },
  	"application/vnd.smart.notebook": {
  	source: "iana"
  },
  	"application/vnd.smart.teacher": {
  	source: "iana",
  	extensions: [
  		"teacher"
  	]
  },
  	"application/vnd.software602.filler.form+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"fo"
  	]
  },
  	"application/vnd.software602.filler.form-xml-zip": {
  	source: "iana"
  },
  	"application/vnd.solent.sdkm+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"sdkm",
  		"sdkd"
  	]
  },
  	"application/vnd.spotfire.dxp": {
  	source: "iana",
  	extensions: [
  		"dxp"
  	]
  },
  	"application/vnd.spotfire.sfs": {
  	source: "iana",
  	extensions: [
  		"sfs"
  	]
  },
  	"application/vnd.sqlite3": {
  	source: "iana"
  },
  	"application/vnd.sss-cod": {
  	source: "iana"
  },
  	"application/vnd.sss-dtf": {
  	source: "iana"
  },
  	"application/vnd.sss-ntf": {
  	source: "iana"
  },
  	"application/vnd.stardivision.calc": {
  	source: "apache",
  	extensions: [
  		"sdc"
  	]
  },
  	"application/vnd.stardivision.draw": {
  	source: "apache",
  	extensions: [
  		"sda"
  	]
  },
  	"application/vnd.stardivision.impress": {
  	source: "apache",
  	extensions: [
  		"sdd"
  	]
  },
  	"application/vnd.stardivision.math": {
  	source: "apache",
  	extensions: [
  		"smf"
  	]
  },
  	"application/vnd.stardivision.writer": {
  	source: "apache",
  	extensions: [
  		"sdw",
  		"vor"
  	]
  },
  	"application/vnd.stardivision.writer-global": {
  	source: "apache",
  	extensions: [
  		"sgl"
  	]
  },
  	"application/vnd.stepmania.package": {
  	source: "iana",
  	extensions: [
  		"smzip"
  	]
  },
  	"application/vnd.stepmania.stepchart": {
  	source: "iana",
  	extensions: [
  		"sm"
  	]
  },
  	"application/vnd.street-stream": {
  	source: "iana"
  },
  	"application/vnd.sun.wadl+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"wadl"
  	]
  },
  	"application/vnd.sun.xml.calc": {
  	source: "apache",
  	extensions: [
  		"sxc"
  	]
  },
  	"application/vnd.sun.xml.calc.template": {
  	source: "apache",
  	extensions: [
  		"stc"
  	]
  },
  	"application/vnd.sun.xml.draw": {
  	source: "apache",
  	extensions: [
  		"sxd"
  	]
  },
  	"application/vnd.sun.xml.draw.template": {
  	source: "apache",
  	extensions: [
  		"std"
  	]
  },
  	"application/vnd.sun.xml.impress": {
  	source: "apache",
  	extensions: [
  		"sxi"
  	]
  },
  	"application/vnd.sun.xml.impress.template": {
  	source: "apache",
  	extensions: [
  		"sti"
  	]
  },
  	"application/vnd.sun.xml.math": {
  	source: "apache",
  	extensions: [
  		"sxm"
  	]
  },
  	"application/vnd.sun.xml.writer": {
  	source: "apache",
  	extensions: [
  		"sxw"
  	]
  },
  	"application/vnd.sun.xml.writer.global": {
  	source: "apache",
  	extensions: [
  		"sxg"
  	]
  },
  	"application/vnd.sun.xml.writer.template": {
  	source: "apache",
  	extensions: [
  		"stw"
  	]
  },
  	"application/vnd.sus-calendar": {
  	source: "iana",
  	extensions: [
  		"sus",
  		"susp"
  	]
  },
  	"application/vnd.svd": {
  	source: "iana",
  	extensions: [
  		"svd"
  	]
  },
  	"application/vnd.swiftview-ics": {
  	source: "iana"
  },
  	"application/vnd.symbian.install": {
  	source: "apache",
  	extensions: [
  		"sis",
  		"sisx"
  	]
  },
  	"application/vnd.syncml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xsm"
  	]
  },
  	"application/vnd.syncml.dm+wbxml": {
  	source: "iana",
  	extensions: [
  		"bdm"
  	]
  },
  	"application/vnd.syncml.dm+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xdm"
  	]
  },
  	"application/vnd.syncml.dm.notification": {
  	source: "iana"
  },
  	"application/vnd.syncml.dmddf+wbxml": {
  	source: "iana"
  },
  	"application/vnd.syncml.dmddf+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"ddf"
  	]
  },
  	"application/vnd.syncml.dmtnds+wbxml": {
  	source: "iana"
  },
  	"application/vnd.syncml.dmtnds+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.syncml.ds.notification": {
  	source: "iana"
  },
  	"application/vnd.tableschema+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.tao.intent-module-archive": {
  	source: "iana",
  	extensions: [
  		"tao"
  	]
  },
  	"application/vnd.tcpdump.pcap": {
  	source: "iana",
  	extensions: [
  		"pcap",
  		"cap",
  		"dmp"
  	]
  },
  	"application/vnd.think-cell.ppttc+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.tmd.mediaflex.api+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.tml": {
  	source: "iana"
  },
  	"application/vnd.tmobile-livetv": {
  	source: "iana",
  	extensions: [
  		"tmo"
  	]
  },
  	"application/vnd.tri.onesource": {
  	source: "iana"
  },
  	"application/vnd.trid.tpt": {
  	source: "iana",
  	extensions: [
  		"tpt"
  	]
  },
  	"application/vnd.triscape.mxs": {
  	source: "iana",
  	extensions: [
  		"mxs"
  	]
  },
  	"application/vnd.trueapp": {
  	source: "iana",
  	extensions: [
  		"tra"
  	]
  },
  	"application/vnd.truedoc": {
  	source: "iana"
  },
  	"application/vnd.ubisoft.webplayer": {
  	source: "iana"
  },
  	"application/vnd.ufdl": {
  	source: "iana",
  	extensions: [
  		"ufd",
  		"ufdl"
  	]
  },
  	"application/vnd.uiq.theme": {
  	source: "iana",
  	extensions: [
  		"utz"
  	]
  },
  	"application/vnd.umajin": {
  	source: "iana",
  	extensions: [
  		"umj"
  	]
  },
  	"application/vnd.unity": {
  	source: "iana",
  	extensions: [
  		"unityweb"
  	]
  },
  	"application/vnd.uoml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"uoml"
  	]
  },
  	"application/vnd.uplanet.alert": {
  	source: "iana"
  },
  	"application/vnd.uplanet.alert-wbxml": {
  	source: "iana"
  },
  	"application/vnd.uplanet.bearer-choice": {
  	source: "iana"
  },
  	"application/vnd.uplanet.bearer-choice-wbxml": {
  	source: "iana"
  },
  	"application/vnd.uplanet.cacheop": {
  	source: "iana"
  },
  	"application/vnd.uplanet.cacheop-wbxml": {
  	source: "iana"
  },
  	"application/vnd.uplanet.channel": {
  	source: "iana"
  },
  	"application/vnd.uplanet.channel-wbxml": {
  	source: "iana"
  },
  	"application/vnd.uplanet.list": {
  	source: "iana"
  },
  	"application/vnd.uplanet.list-wbxml": {
  	source: "iana"
  },
  	"application/vnd.uplanet.listcmd": {
  	source: "iana"
  },
  	"application/vnd.uplanet.listcmd-wbxml": {
  	source: "iana"
  },
  	"application/vnd.uplanet.signal": {
  	source: "iana"
  },
  	"application/vnd.uri-map": {
  	source: "iana"
  },
  	"application/vnd.valve.source.material": {
  	source: "iana"
  },
  	"application/vnd.vcx": {
  	source: "iana",
  	extensions: [
  		"vcx"
  	]
  },
  	"application/vnd.vd-study": {
  	source: "iana"
  },
  	"application/vnd.vectorworks": {
  	source: "iana"
  },
  	"application/vnd.vel+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.verimatrix.vcas": {
  	source: "iana"
  },
  	"application/vnd.veryant.thin": {
  	source: "iana"
  },
  	"application/vnd.ves.encrypted": {
  	source: "iana"
  },
  	"application/vnd.vidsoft.vidconference": {
  	source: "iana"
  },
  	"application/vnd.visio": {
  	source: "iana",
  	extensions: [
  		"vsd",
  		"vst",
  		"vss",
  		"vsw"
  	]
  },
  	"application/vnd.visionary": {
  	source: "iana",
  	extensions: [
  		"vis"
  	]
  },
  	"application/vnd.vividence.scriptfile": {
  	source: "iana"
  },
  	"application/vnd.vsf": {
  	source: "iana",
  	extensions: [
  		"vsf"
  	]
  },
  	"application/vnd.wap.sic": {
  	source: "iana"
  },
  	"application/vnd.wap.slc": {
  	source: "iana"
  },
  	"application/vnd.wap.wbxml": {
  	source: "iana",
  	extensions: [
  		"wbxml"
  	]
  },
  	"application/vnd.wap.wmlc": {
  	source: "iana",
  	extensions: [
  		"wmlc"
  	]
  },
  	"application/vnd.wap.wmlscriptc": {
  	source: "iana",
  	extensions: [
  		"wmlsc"
  	]
  },
  	"application/vnd.webturbo": {
  	source: "iana",
  	extensions: [
  		"wtb"
  	]
  },
  	"application/vnd.wfa.p2p": {
  	source: "iana"
  },
  	"application/vnd.wfa.wsc": {
  	source: "iana"
  },
  	"application/vnd.windows.devicepairing": {
  	source: "iana"
  },
  	"application/vnd.wmc": {
  	source: "iana"
  },
  	"application/vnd.wmf.bootstrap": {
  	source: "iana"
  },
  	"application/vnd.wolfram.mathematica": {
  	source: "iana"
  },
  	"application/vnd.wolfram.mathematica.package": {
  	source: "iana"
  },
  	"application/vnd.wolfram.player": {
  	source: "iana",
  	extensions: [
  		"nbp"
  	]
  },
  	"application/vnd.wordperfect": {
  	source: "iana",
  	extensions: [
  		"wpd"
  	]
  },
  	"application/vnd.wqd": {
  	source: "iana",
  	extensions: [
  		"wqd"
  	]
  },
  	"application/vnd.wrq-hp3000-labelled": {
  	source: "iana"
  },
  	"application/vnd.wt.stf": {
  	source: "iana",
  	extensions: [
  		"stf"
  	]
  },
  	"application/vnd.wv.csp+wbxml": {
  	source: "iana"
  },
  	"application/vnd.wv.csp+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.wv.ssp+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.xacml+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.xara": {
  	source: "iana",
  	extensions: [
  		"xar"
  	]
  },
  	"application/vnd.xfdl": {
  	source: "iana",
  	extensions: [
  		"xfdl"
  	]
  },
  	"application/vnd.xfdl.webform": {
  	source: "iana"
  },
  	"application/vnd.xmi+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/vnd.xmpie.cpkg": {
  	source: "iana"
  },
  	"application/vnd.xmpie.dpkg": {
  	source: "iana"
  },
  	"application/vnd.xmpie.plan": {
  	source: "iana"
  },
  	"application/vnd.xmpie.ppkg": {
  	source: "iana"
  },
  	"application/vnd.xmpie.xlim": {
  	source: "iana"
  },
  	"application/vnd.yamaha.hv-dic": {
  	source: "iana",
  	extensions: [
  		"hvd"
  	]
  },
  	"application/vnd.yamaha.hv-script": {
  	source: "iana",
  	extensions: [
  		"hvs"
  	]
  },
  	"application/vnd.yamaha.hv-voice": {
  	source: "iana",
  	extensions: [
  		"hvp"
  	]
  },
  	"application/vnd.yamaha.openscoreformat": {
  	source: "iana",
  	extensions: [
  		"osf"
  	]
  },
  	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"osfpvg"
  	]
  },
  	"application/vnd.yamaha.remote-setup": {
  	source: "iana"
  },
  	"application/vnd.yamaha.smaf-audio": {
  	source: "iana",
  	extensions: [
  		"saf"
  	]
  },
  	"application/vnd.yamaha.smaf-phrase": {
  	source: "iana",
  	extensions: [
  		"spf"
  	]
  },
  	"application/vnd.yamaha.through-ngn": {
  	source: "iana"
  },
  	"application/vnd.yamaha.tunnel-udpencap": {
  	source: "iana"
  },
  	"application/vnd.yaoweme": {
  	source: "iana"
  },
  	"application/vnd.yellowriver-custom-menu": {
  	source: "iana",
  	extensions: [
  		"cmp"
  	]
  },
  	"application/vnd.youtube.yt": {
  	source: "iana"
  },
  	"application/vnd.zul": {
  	source: "iana",
  	extensions: [
  		"zir",
  		"zirz"
  	]
  },
  	"application/vnd.zzazz.deck+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"zaz"
  	]
  },
  	"application/voicexml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"vxml"
  	]
  },
  	"application/voucher-cms+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/vq-rtcpxr": {
  	source: "iana"
  },
  	"application/wasm": {
  	compressible: true,
  	extensions: [
  		"wasm"
  	]
  },
  	"application/watcherinfo+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/webpush-options+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/whoispp-query": {
  	source: "iana"
  },
  	"application/whoispp-response": {
  	source: "iana"
  },
  	"application/widget": {
  	source: "iana",
  	extensions: [
  		"wgt"
  	]
  },
  	"application/winhlp": {
  	source: "apache",
  	extensions: [
  		"hlp"
  	]
  },
  	"application/wita": {
  	source: "iana"
  },
  	"application/wordperfect5.1": {
  	source: "iana"
  },
  	"application/wsdl+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"wsdl"
  	]
  },
  	"application/wspolicy+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"wspolicy"
  	]
  },
  	"application/x-7z-compressed": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"7z"
  	]
  },
  	"application/x-abiword": {
  	source: "apache",
  	extensions: [
  		"abw"
  	]
  },
  	"application/x-ace-compressed": {
  	source: "apache",
  	extensions: [
  		"ace"
  	]
  },
  	"application/x-amf": {
  	source: "apache"
  },
  	"application/x-apple-diskimage": {
  	source: "apache",
  	extensions: [
  		"dmg"
  	]
  },
  	"application/x-arj": {
  	compressible: false,
  	extensions: [
  		"arj"
  	]
  },
  	"application/x-authorware-bin": {
  	source: "apache",
  	extensions: [
  		"aab",
  		"x32",
  		"u32",
  		"vox"
  	]
  },
  	"application/x-authorware-map": {
  	source: "apache",
  	extensions: [
  		"aam"
  	]
  },
  	"application/x-authorware-seg": {
  	source: "apache",
  	extensions: [
  		"aas"
  	]
  },
  	"application/x-bcpio": {
  	source: "apache",
  	extensions: [
  		"bcpio"
  	]
  },
  	"application/x-bdoc": {
  	compressible: false,
  	extensions: [
  		"bdoc"
  	]
  },
  	"application/x-bittorrent": {
  	source: "apache",
  	extensions: [
  		"torrent"
  	]
  },
  	"application/x-blorb": {
  	source: "apache",
  	extensions: [
  		"blb",
  		"blorb"
  	]
  },
  	"application/x-bzip": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"bz"
  	]
  },
  	"application/x-bzip2": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"bz2",
  		"boz"
  	]
  },
  	"application/x-cbr": {
  	source: "apache",
  	extensions: [
  		"cbr",
  		"cba",
  		"cbt",
  		"cbz",
  		"cb7"
  	]
  },
  	"application/x-cdlink": {
  	source: "apache",
  	extensions: [
  		"vcd"
  	]
  },
  	"application/x-cfs-compressed": {
  	source: "apache",
  	extensions: [
  		"cfs"
  	]
  },
  	"application/x-chat": {
  	source: "apache",
  	extensions: [
  		"chat"
  	]
  },
  	"application/x-chess-pgn": {
  	source: "apache",
  	extensions: [
  		"pgn"
  	]
  },
  	"application/x-chrome-extension": {
  	extensions: [
  		"crx"
  	]
  },
  	"application/x-cocoa": {
  	source: "nginx",
  	extensions: [
  		"cco"
  	]
  },
  	"application/x-compress": {
  	source: "apache"
  },
  	"application/x-conference": {
  	source: "apache",
  	extensions: [
  		"nsc"
  	]
  },
  	"application/x-cpio": {
  	source: "apache",
  	extensions: [
  		"cpio"
  	]
  },
  	"application/x-csh": {
  	source: "apache",
  	extensions: [
  		"csh"
  	]
  },
  	"application/x-deb": {
  	compressible: false
  },
  	"application/x-debian-package": {
  	source: "apache",
  	extensions: [
  		"deb",
  		"udeb"
  	]
  },
  	"application/x-dgc-compressed": {
  	source: "apache",
  	extensions: [
  		"dgc"
  	]
  },
  	"application/x-director": {
  	source: "apache",
  	extensions: [
  		"dir",
  		"dcr",
  		"dxr",
  		"cst",
  		"cct",
  		"cxt",
  		"w3d",
  		"fgd",
  		"swa"
  	]
  },
  	"application/x-doom": {
  	source: "apache",
  	extensions: [
  		"wad"
  	]
  },
  	"application/x-dtbncx+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"ncx"
  	]
  },
  	"application/x-dtbook+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"dtb"
  	]
  },
  	"application/x-dtbresource+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"res"
  	]
  },
  	"application/x-dvi": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"dvi"
  	]
  },
  	"application/x-envoy": {
  	source: "apache",
  	extensions: [
  		"evy"
  	]
  },
  	"application/x-eva": {
  	source: "apache",
  	extensions: [
  		"eva"
  	]
  },
  	"application/x-font-bdf": {
  	source: "apache",
  	extensions: [
  		"bdf"
  	]
  },
  	"application/x-font-dos": {
  	source: "apache"
  },
  	"application/x-font-framemaker": {
  	source: "apache"
  },
  	"application/x-font-ghostscript": {
  	source: "apache",
  	extensions: [
  		"gsf"
  	]
  },
  	"application/x-font-libgrx": {
  	source: "apache"
  },
  	"application/x-font-linux-psf": {
  	source: "apache",
  	extensions: [
  		"psf"
  	]
  },
  	"application/x-font-pcf": {
  	source: "apache",
  	extensions: [
  		"pcf"
  	]
  },
  	"application/x-font-snf": {
  	source: "apache",
  	extensions: [
  		"snf"
  	]
  },
  	"application/x-font-speedo": {
  	source: "apache"
  },
  	"application/x-font-sunos-news": {
  	source: "apache"
  },
  	"application/x-font-type1": {
  	source: "apache",
  	extensions: [
  		"pfa",
  		"pfb",
  		"pfm",
  		"afm"
  	]
  },
  	"application/x-font-vfont": {
  	source: "apache"
  },
  	"application/x-freearc": {
  	source: "apache",
  	extensions: [
  		"arc"
  	]
  },
  	"application/x-futuresplash": {
  	source: "apache",
  	extensions: [
  		"spl"
  	]
  },
  	"application/x-gca-compressed": {
  	source: "apache",
  	extensions: [
  		"gca"
  	]
  },
  	"application/x-glulx": {
  	source: "apache",
  	extensions: [
  		"ulx"
  	]
  },
  	"application/x-gnumeric": {
  	source: "apache",
  	extensions: [
  		"gnumeric"
  	]
  },
  	"application/x-gramps-xml": {
  	source: "apache",
  	extensions: [
  		"gramps"
  	]
  },
  	"application/x-gtar": {
  	source: "apache",
  	extensions: [
  		"gtar"
  	]
  },
  	"application/x-gzip": {
  	source: "apache"
  },
  	"application/x-hdf": {
  	source: "apache",
  	extensions: [
  		"hdf"
  	]
  },
  	"application/x-httpd-php": {
  	compressible: true,
  	extensions: [
  		"php"
  	]
  },
  	"application/x-install-instructions": {
  	source: "apache",
  	extensions: [
  		"install"
  	]
  },
  	"application/x-iso9660-image": {
  	source: "apache",
  	extensions: [
  		"iso"
  	]
  },
  	"application/x-java-archive-diff": {
  	source: "nginx",
  	extensions: [
  		"jardiff"
  	]
  },
  	"application/x-java-jnlp-file": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"jnlp"
  	]
  },
  	"application/x-javascript": {
  	compressible: true
  },
  	"application/x-keepass2": {
  	extensions: [
  		"kdbx"
  	]
  },
  	"application/x-latex": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"latex"
  	]
  },
  	"application/x-lua-bytecode": {
  	extensions: [
  		"luac"
  	]
  },
  	"application/x-lzh-compressed": {
  	source: "apache",
  	extensions: [
  		"lzh",
  		"lha"
  	]
  },
  	"application/x-makeself": {
  	source: "nginx",
  	extensions: [
  		"run"
  	]
  },
  	"application/x-mie": {
  	source: "apache",
  	extensions: [
  		"mie"
  	]
  },
  	"application/x-mobipocket-ebook": {
  	source: "apache",
  	extensions: [
  		"prc",
  		"mobi"
  	]
  },
  	"application/x-mpegurl": {
  	compressible: false
  },
  	"application/x-ms-application": {
  	source: "apache",
  	extensions: [
  		"application"
  	]
  },
  	"application/x-ms-shortcut": {
  	source: "apache",
  	extensions: [
  		"lnk"
  	]
  },
  	"application/x-ms-wmd": {
  	source: "apache",
  	extensions: [
  		"wmd"
  	]
  },
  	"application/x-ms-wmz": {
  	source: "apache",
  	extensions: [
  		"wmz"
  	]
  },
  	"application/x-ms-xbap": {
  	source: "apache",
  	extensions: [
  		"xbap"
  	]
  },
  	"application/x-msaccess": {
  	source: "apache",
  	extensions: [
  		"mdb"
  	]
  },
  	"application/x-msbinder": {
  	source: "apache",
  	extensions: [
  		"obd"
  	]
  },
  	"application/x-mscardfile": {
  	source: "apache",
  	extensions: [
  		"crd"
  	]
  },
  	"application/x-msclip": {
  	source: "apache",
  	extensions: [
  		"clp"
  	]
  },
  	"application/x-msdos-program": {
  	extensions: [
  		"exe"
  	]
  },
  	"application/x-msdownload": {
  	source: "apache",
  	extensions: [
  		"exe",
  		"dll",
  		"com",
  		"bat",
  		"msi"
  	]
  },
  	"application/x-msmediaview": {
  	source: "apache",
  	extensions: [
  		"mvb",
  		"m13",
  		"m14"
  	]
  },
  	"application/x-msmetafile": {
  	source: "apache",
  	extensions: [
  		"wmf",
  		"wmz",
  		"emf",
  		"emz"
  	]
  },
  	"application/x-msmoney": {
  	source: "apache",
  	extensions: [
  		"mny"
  	]
  },
  	"application/x-mspublisher": {
  	source: "apache",
  	extensions: [
  		"pub"
  	]
  },
  	"application/x-msschedule": {
  	source: "apache",
  	extensions: [
  		"scd"
  	]
  },
  	"application/x-msterminal": {
  	source: "apache",
  	extensions: [
  		"trm"
  	]
  },
  	"application/x-mswrite": {
  	source: "apache",
  	extensions: [
  		"wri"
  	]
  },
  	"application/x-netcdf": {
  	source: "apache",
  	extensions: [
  		"nc",
  		"cdf"
  	]
  },
  	"application/x-ns-proxy-autoconfig": {
  	compressible: true,
  	extensions: [
  		"pac"
  	]
  },
  	"application/x-nzb": {
  	source: "apache",
  	extensions: [
  		"nzb"
  	]
  },
  	"application/x-perl": {
  	source: "nginx",
  	extensions: [
  		"pl",
  		"pm"
  	]
  },
  	"application/x-pilot": {
  	source: "nginx",
  	extensions: [
  		"prc",
  		"pdb"
  	]
  },
  	"application/x-pkcs12": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"p12",
  		"pfx"
  	]
  },
  	"application/x-pkcs7-certificates": {
  	source: "apache",
  	extensions: [
  		"p7b",
  		"spc"
  	]
  },
  	"application/x-pkcs7-certreqresp": {
  	source: "apache",
  	extensions: [
  		"p7r"
  	]
  },
  	"application/x-rar-compressed": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"rar"
  	]
  },
  	"application/x-redhat-package-manager": {
  	source: "nginx",
  	extensions: [
  		"rpm"
  	]
  },
  	"application/x-research-info-systems": {
  	source: "apache",
  	extensions: [
  		"ris"
  	]
  },
  	"application/x-sea": {
  	source: "nginx",
  	extensions: [
  		"sea"
  	]
  },
  	"application/x-sh": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"sh"
  	]
  },
  	"application/x-shar": {
  	source: "apache",
  	extensions: [
  		"shar"
  	]
  },
  	"application/x-shockwave-flash": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"swf"
  	]
  },
  	"application/x-silverlight-app": {
  	source: "apache",
  	extensions: [
  		"xap"
  	]
  },
  	"application/x-sql": {
  	source: "apache",
  	extensions: [
  		"sql"
  	]
  },
  	"application/x-stuffit": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"sit"
  	]
  },
  	"application/x-stuffitx": {
  	source: "apache",
  	extensions: [
  		"sitx"
  	]
  },
  	"application/x-subrip": {
  	source: "apache",
  	extensions: [
  		"srt"
  	]
  },
  	"application/x-sv4cpio": {
  	source: "apache",
  	extensions: [
  		"sv4cpio"
  	]
  },
  	"application/x-sv4crc": {
  	source: "apache",
  	extensions: [
  		"sv4crc"
  	]
  },
  	"application/x-t3vm-image": {
  	source: "apache",
  	extensions: [
  		"t3"
  	]
  },
  	"application/x-tads": {
  	source: "apache",
  	extensions: [
  		"gam"
  	]
  },
  	"application/x-tar": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"tar"
  	]
  },
  	"application/x-tcl": {
  	source: "apache",
  	extensions: [
  		"tcl",
  		"tk"
  	]
  },
  	"application/x-tex": {
  	source: "apache",
  	extensions: [
  		"tex"
  	]
  },
  	"application/x-tex-tfm": {
  	source: "apache",
  	extensions: [
  		"tfm"
  	]
  },
  	"application/x-texinfo": {
  	source: "apache",
  	extensions: [
  		"texinfo",
  		"texi"
  	]
  },
  	"application/x-tgif": {
  	source: "apache",
  	extensions: [
  		"obj"
  	]
  },
  	"application/x-ustar": {
  	source: "apache",
  	extensions: [
  		"ustar"
  	]
  },
  	"application/x-virtualbox-hdd": {
  	compressible: true,
  	extensions: [
  		"hdd"
  	]
  },
  	"application/x-virtualbox-ova": {
  	compressible: true,
  	extensions: [
  		"ova"
  	]
  },
  	"application/x-virtualbox-ovf": {
  	compressible: true,
  	extensions: [
  		"ovf"
  	]
  },
  	"application/x-virtualbox-vbox": {
  	compressible: true,
  	extensions: [
  		"vbox"
  	]
  },
  	"application/x-virtualbox-vbox-extpack": {
  	compressible: false,
  	extensions: [
  		"vbox-extpack"
  	]
  },
  	"application/x-virtualbox-vdi": {
  	compressible: true,
  	extensions: [
  		"vdi"
  	]
  },
  	"application/x-virtualbox-vhd": {
  	compressible: true,
  	extensions: [
  		"vhd"
  	]
  },
  	"application/x-virtualbox-vmdk": {
  	compressible: true,
  	extensions: [
  		"vmdk"
  	]
  },
  	"application/x-wais-source": {
  	source: "apache",
  	extensions: [
  		"src"
  	]
  },
  	"application/x-web-app-manifest+json": {
  	compressible: true,
  	extensions: [
  		"webapp"
  	]
  },
  	"application/x-www-form-urlencoded": {
  	source: "iana",
  	compressible: true
  },
  	"application/x-x509-ca-cert": {
  	source: "apache",
  	extensions: [
  		"der",
  		"crt",
  		"pem"
  	]
  },
  	"application/x-xfig": {
  	source: "apache",
  	extensions: [
  		"fig"
  	]
  },
  	"application/x-xliff+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"xlf"
  	]
  },
  	"application/x-xpinstall": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"xpi"
  	]
  },
  	"application/x-xz": {
  	source: "apache",
  	extensions: [
  		"xz"
  	]
  },
  	"application/x-zmachine": {
  	source: "apache",
  	extensions: [
  		"z1",
  		"z2",
  		"z3",
  		"z4",
  		"z5",
  		"z6",
  		"z7",
  		"z8"
  	]
  },
  	"application/x400-bp": {
  	source: "iana"
  },
  	"application/xacml+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/xaml+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"xaml"
  	]
  },
  	"application/xcap-att+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xav"
  	]
  },
  	"application/xcap-caps+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xca"
  	]
  },
  	"application/xcap-diff+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xdf"
  	]
  },
  	"application/xcap-el+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xel"
  	]
  },
  	"application/xcap-error+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xer"
  	]
  },
  	"application/xcap-ns+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xns"
  	]
  },
  	"application/xcon-conference-info+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/xcon-conference-info-diff+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/xenc+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xenc"
  	]
  },
  	"application/xhtml+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xhtml",
  		"xht"
  	]
  },
  	"application/xhtml-voice+xml": {
  	source: "apache",
  	compressible: true
  },
  	"application/xliff+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xlf"
  	]
  },
  	"application/xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xml",
  		"xsl",
  		"xsd",
  		"rng"
  	]
  },
  	"application/xml-dtd": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"dtd"
  	]
  },
  	"application/xml-external-parsed-entity": {
  	source: "iana"
  },
  	"application/xml-patch+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/xmpp+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/xop+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xop"
  	]
  },
  	"application/xproc+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"xpl"
  	]
  },
  	"application/xslt+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xslt"
  	]
  },
  	"application/xspf+xml": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"xspf"
  	]
  },
  	"application/xv+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"mxml",
  		"xhvml",
  		"xvml",
  		"xvm"
  	]
  },
  	"application/yang": {
  	source: "iana",
  	extensions: [
  		"yang"
  	]
  },
  	"application/yang-data+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/yang-data+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/yang-patch+json": {
  	source: "iana",
  	compressible: true
  },
  	"application/yang-patch+xml": {
  	source: "iana",
  	compressible: true
  },
  	"application/yin+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"yin"
  	]
  },
  	"application/zip": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"zip"
  	]
  },
  	"application/zlib": {
  	source: "iana"
  },
  	"application/zstd": {
  	source: "iana"
  },
  	"audio/1d-interleaved-parityfec": {
  	source: "iana"
  },
  	"audio/32kadpcm": {
  	source: "iana"
  },
  	"audio/3gpp": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"3gpp"
  	]
  },
  	"audio/3gpp2": {
  	source: "iana"
  },
  	"audio/aac": {
  	source: "iana"
  },
  	"audio/ac3": {
  	source: "iana"
  },
  	"audio/adpcm": {
  	source: "apache",
  	extensions: [
  		"adp"
  	]
  },
  	"audio/amr": {
  	source: "iana"
  },
  	"audio/amr-wb": {
  	source: "iana"
  },
  	"audio/amr-wb+": {
  	source: "iana"
  },
  	"audio/aptx": {
  	source: "iana"
  },
  	"audio/asc": {
  	source: "iana"
  },
  	"audio/atrac-advanced-lossless": {
  	source: "iana"
  },
  	"audio/atrac-x": {
  	source: "iana"
  },
  	"audio/atrac3": {
  	source: "iana"
  },
  	"audio/basic": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"au",
  		"snd"
  	]
  },
  	"audio/bv16": {
  	source: "iana"
  },
  	"audio/bv32": {
  	source: "iana"
  },
  	"audio/clearmode": {
  	source: "iana"
  },
  	"audio/cn": {
  	source: "iana"
  },
  	"audio/dat12": {
  	source: "iana"
  },
  	"audio/dls": {
  	source: "iana"
  },
  	"audio/dsr-es201108": {
  	source: "iana"
  },
  	"audio/dsr-es202050": {
  	source: "iana"
  },
  	"audio/dsr-es202211": {
  	source: "iana"
  },
  	"audio/dsr-es202212": {
  	source: "iana"
  },
  	"audio/dv": {
  	source: "iana"
  },
  	"audio/dvi4": {
  	source: "iana"
  },
  	"audio/eac3": {
  	source: "iana"
  },
  	"audio/encaprtp": {
  	source: "iana"
  },
  	"audio/evrc": {
  	source: "iana"
  },
  	"audio/evrc-qcp": {
  	source: "iana"
  },
  	"audio/evrc0": {
  	source: "iana"
  },
  	"audio/evrc1": {
  	source: "iana"
  },
  	"audio/evrcb": {
  	source: "iana"
  },
  	"audio/evrcb0": {
  	source: "iana"
  },
  	"audio/evrcb1": {
  	source: "iana"
  },
  	"audio/evrcnw": {
  	source: "iana"
  },
  	"audio/evrcnw0": {
  	source: "iana"
  },
  	"audio/evrcnw1": {
  	source: "iana"
  },
  	"audio/evrcwb": {
  	source: "iana"
  },
  	"audio/evrcwb0": {
  	source: "iana"
  },
  	"audio/evrcwb1": {
  	source: "iana"
  },
  	"audio/evs": {
  	source: "iana"
  },
  	"audio/flexfec": {
  	source: "iana"
  },
  	"audio/fwdred": {
  	source: "iana"
  },
  	"audio/g711-0": {
  	source: "iana"
  },
  	"audio/g719": {
  	source: "iana"
  },
  	"audio/g722": {
  	source: "iana"
  },
  	"audio/g7221": {
  	source: "iana"
  },
  	"audio/g723": {
  	source: "iana"
  },
  	"audio/g726-16": {
  	source: "iana"
  },
  	"audio/g726-24": {
  	source: "iana"
  },
  	"audio/g726-32": {
  	source: "iana"
  },
  	"audio/g726-40": {
  	source: "iana"
  },
  	"audio/g728": {
  	source: "iana"
  },
  	"audio/g729": {
  	source: "iana"
  },
  	"audio/g7291": {
  	source: "iana"
  },
  	"audio/g729d": {
  	source: "iana"
  },
  	"audio/g729e": {
  	source: "iana"
  },
  	"audio/gsm": {
  	source: "iana"
  },
  	"audio/gsm-efr": {
  	source: "iana"
  },
  	"audio/gsm-hr-08": {
  	source: "iana"
  },
  	"audio/ilbc": {
  	source: "iana"
  },
  	"audio/ip-mr_v2.5": {
  	source: "iana"
  },
  	"audio/isac": {
  	source: "apache"
  },
  	"audio/l16": {
  	source: "iana"
  },
  	"audio/l20": {
  	source: "iana"
  },
  	"audio/l24": {
  	source: "iana",
  	compressible: false
  },
  	"audio/l8": {
  	source: "iana"
  },
  	"audio/lpc": {
  	source: "iana"
  },
  	"audio/melp": {
  	source: "iana"
  },
  	"audio/melp1200": {
  	source: "iana"
  },
  	"audio/melp2400": {
  	source: "iana"
  },
  	"audio/melp600": {
  	source: "iana"
  },
  	"audio/midi": {
  	source: "apache",
  	extensions: [
  		"mid",
  		"midi",
  		"kar",
  		"rmi"
  	]
  },
  	"audio/mobile-xmf": {
  	source: "iana",
  	extensions: [
  		"mxmf"
  	]
  },
  	"audio/mp3": {
  	compressible: false,
  	extensions: [
  		"mp3"
  	]
  },
  	"audio/mp4": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"m4a",
  		"mp4a"
  	]
  },
  	"audio/mp4a-latm": {
  	source: "iana"
  },
  	"audio/mpa": {
  	source: "iana"
  },
  	"audio/mpa-robust": {
  	source: "iana"
  },
  	"audio/mpeg": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"mpga",
  		"mp2",
  		"mp2a",
  		"mp3",
  		"m2a",
  		"m3a"
  	]
  },
  	"audio/mpeg4-generic": {
  	source: "iana"
  },
  	"audio/musepack": {
  	source: "apache"
  },
  	"audio/ogg": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"oga",
  		"ogg",
  		"spx"
  	]
  },
  	"audio/opus": {
  	source: "iana"
  },
  	"audio/parityfec": {
  	source: "iana"
  },
  	"audio/pcma": {
  	source: "iana"
  },
  	"audio/pcma-wb": {
  	source: "iana"
  },
  	"audio/pcmu": {
  	source: "iana"
  },
  	"audio/pcmu-wb": {
  	source: "iana"
  },
  	"audio/prs.sid": {
  	source: "iana"
  },
  	"audio/qcelp": {
  	source: "iana"
  },
  	"audio/raptorfec": {
  	source: "iana"
  },
  	"audio/red": {
  	source: "iana"
  },
  	"audio/rtp-enc-aescm128": {
  	source: "iana"
  },
  	"audio/rtp-midi": {
  	source: "iana"
  },
  	"audio/rtploopback": {
  	source: "iana"
  },
  	"audio/rtx": {
  	source: "iana"
  },
  	"audio/s3m": {
  	source: "apache",
  	extensions: [
  		"s3m"
  	]
  },
  	"audio/silk": {
  	source: "apache",
  	extensions: [
  		"sil"
  	]
  },
  	"audio/smv": {
  	source: "iana"
  },
  	"audio/smv-qcp": {
  	source: "iana"
  },
  	"audio/smv0": {
  	source: "iana"
  },
  	"audio/sp-midi": {
  	source: "iana"
  },
  	"audio/speex": {
  	source: "iana"
  },
  	"audio/t140c": {
  	source: "iana"
  },
  	"audio/t38": {
  	source: "iana"
  },
  	"audio/telephone-event": {
  	source: "iana"
  },
  	"audio/tetra_acelp": {
  	source: "iana"
  },
  	"audio/tone": {
  	source: "iana"
  },
  	"audio/uemclip": {
  	source: "iana"
  },
  	"audio/ulpfec": {
  	source: "iana"
  },
  	"audio/usac": {
  	source: "iana"
  },
  	"audio/vdvi": {
  	source: "iana"
  },
  	"audio/vmr-wb": {
  	source: "iana"
  },
  	"audio/vnd.3gpp.iufp": {
  	source: "iana"
  },
  	"audio/vnd.4sb": {
  	source: "iana"
  },
  	"audio/vnd.audiokoz": {
  	source: "iana"
  },
  	"audio/vnd.celp": {
  	source: "iana"
  },
  	"audio/vnd.cisco.nse": {
  	source: "iana"
  },
  	"audio/vnd.cmles.radio-events": {
  	source: "iana"
  },
  	"audio/vnd.cns.anp1": {
  	source: "iana"
  },
  	"audio/vnd.cns.inf1": {
  	source: "iana"
  },
  	"audio/vnd.dece.audio": {
  	source: "iana",
  	extensions: [
  		"uva",
  		"uvva"
  	]
  },
  	"audio/vnd.digital-winds": {
  	source: "iana",
  	extensions: [
  		"eol"
  	]
  },
  	"audio/vnd.dlna.adts": {
  	source: "iana"
  },
  	"audio/vnd.dolby.heaac.1": {
  	source: "iana"
  },
  	"audio/vnd.dolby.heaac.2": {
  	source: "iana"
  },
  	"audio/vnd.dolby.mlp": {
  	source: "iana"
  },
  	"audio/vnd.dolby.mps": {
  	source: "iana"
  },
  	"audio/vnd.dolby.pl2": {
  	source: "iana"
  },
  	"audio/vnd.dolby.pl2x": {
  	source: "iana"
  },
  	"audio/vnd.dolby.pl2z": {
  	source: "iana"
  },
  	"audio/vnd.dolby.pulse.1": {
  	source: "iana"
  },
  	"audio/vnd.dra": {
  	source: "iana",
  	extensions: [
  		"dra"
  	]
  },
  	"audio/vnd.dts": {
  	source: "iana",
  	extensions: [
  		"dts"
  	]
  },
  	"audio/vnd.dts.hd": {
  	source: "iana",
  	extensions: [
  		"dtshd"
  	]
  },
  	"audio/vnd.dts.uhd": {
  	source: "iana"
  },
  	"audio/vnd.dvb.file": {
  	source: "iana"
  },
  	"audio/vnd.everad.plj": {
  	source: "iana"
  },
  	"audio/vnd.hns.audio": {
  	source: "iana"
  },
  	"audio/vnd.lucent.voice": {
  	source: "iana",
  	extensions: [
  		"lvp"
  	]
  },
  	"audio/vnd.ms-playready.media.pya": {
  	source: "iana",
  	extensions: [
  		"pya"
  	]
  },
  	"audio/vnd.nokia.mobile-xmf": {
  	source: "iana"
  },
  	"audio/vnd.nortel.vbk": {
  	source: "iana"
  },
  	"audio/vnd.nuera.ecelp4800": {
  	source: "iana",
  	extensions: [
  		"ecelp4800"
  	]
  },
  	"audio/vnd.nuera.ecelp7470": {
  	source: "iana",
  	extensions: [
  		"ecelp7470"
  	]
  },
  	"audio/vnd.nuera.ecelp9600": {
  	source: "iana",
  	extensions: [
  		"ecelp9600"
  	]
  },
  	"audio/vnd.octel.sbc": {
  	source: "iana"
  },
  	"audio/vnd.presonus.multitrack": {
  	source: "iana"
  },
  	"audio/vnd.qcelp": {
  	source: "iana"
  },
  	"audio/vnd.rhetorex.32kadpcm": {
  	source: "iana"
  },
  	"audio/vnd.rip": {
  	source: "iana",
  	extensions: [
  		"rip"
  	]
  },
  	"audio/vnd.rn-realaudio": {
  	compressible: false
  },
  	"audio/vnd.sealedmedia.softseal.mpeg": {
  	source: "iana"
  },
  	"audio/vnd.vmx.cvsd": {
  	source: "iana"
  },
  	"audio/vnd.wave": {
  	compressible: false
  },
  	"audio/vorbis": {
  	source: "iana",
  	compressible: false
  },
  	"audio/vorbis-config": {
  	source: "iana"
  },
  	"audio/wav": {
  	compressible: false,
  	extensions: [
  		"wav"
  	]
  },
  	"audio/wave": {
  	compressible: false,
  	extensions: [
  		"wav"
  	]
  },
  	"audio/webm": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"weba"
  	]
  },
  	"audio/x-aac": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"aac"
  	]
  },
  	"audio/x-aiff": {
  	source: "apache",
  	extensions: [
  		"aif",
  		"aiff",
  		"aifc"
  	]
  },
  	"audio/x-caf": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"caf"
  	]
  },
  	"audio/x-flac": {
  	source: "apache",
  	extensions: [
  		"flac"
  	]
  },
  	"audio/x-m4a": {
  	source: "nginx",
  	extensions: [
  		"m4a"
  	]
  },
  	"audio/x-matroska": {
  	source: "apache",
  	extensions: [
  		"mka"
  	]
  },
  	"audio/x-mpegurl": {
  	source: "apache",
  	extensions: [
  		"m3u"
  	]
  },
  	"audio/x-ms-wax": {
  	source: "apache",
  	extensions: [
  		"wax"
  	]
  },
  	"audio/x-ms-wma": {
  	source: "apache",
  	extensions: [
  		"wma"
  	]
  },
  	"audio/x-pn-realaudio": {
  	source: "apache",
  	extensions: [
  		"ram",
  		"ra"
  	]
  },
  	"audio/x-pn-realaudio-plugin": {
  	source: "apache",
  	extensions: [
  		"rmp"
  	]
  },
  	"audio/x-realaudio": {
  	source: "nginx",
  	extensions: [
  		"ra"
  	]
  },
  	"audio/x-tta": {
  	source: "apache"
  },
  	"audio/x-wav": {
  	source: "apache",
  	extensions: [
  		"wav"
  	]
  },
  	"audio/xm": {
  	source: "apache",
  	extensions: [
  		"xm"
  	]
  },
  	"chemical/x-cdx": {
  	source: "apache",
  	extensions: [
  		"cdx"
  	]
  },
  	"chemical/x-cif": {
  	source: "apache",
  	extensions: [
  		"cif"
  	]
  },
  	"chemical/x-cmdf": {
  	source: "apache",
  	extensions: [
  		"cmdf"
  	]
  },
  	"chemical/x-cml": {
  	source: "apache",
  	extensions: [
  		"cml"
  	]
  },
  	"chemical/x-csml": {
  	source: "apache",
  	extensions: [
  		"csml"
  	]
  },
  	"chemical/x-pdb": {
  	source: "apache"
  },
  	"chemical/x-xyz": {
  	source: "apache",
  	extensions: [
  		"xyz"
  	]
  },
  	"font/collection": {
  	source: "iana",
  	extensions: [
  		"ttc"
  	]
  },
  	"font/otf": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"otf"
  	]
  },
  	"font/sfnt": {
  	source: "iana"
  },
  	"font/ttf": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"ttf"
  	]
  },
  	"font/woff": {
  	source: "iana",
  	extensions: [
  		"woff"
  	]
  },
  	"font/woff2": {
  	source: "iana",
  	extensions: [
  		"woff2"
  	]
  },
  	"image/aces": {
  	source: "iana",
  	extensions: [
  		"exr"
  	]
  },
  	"image/apng": {
  	compressible: false,
  	extensions: [
  		"apng"
  	]
  },
  	"image/avci": {
  	source: "iana"
  },
  	"image/avcs": {
  	source: "iana"
  },
  	"image/bmp": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"bmp"
  	]
  },
  	"image/cgm": {
  	source: "iana",
  	extensions: [
  		"cgm"
  	]
  },
  	"image/dicom-rle": {
  	source: "iana",
  	extensions: [
  		"drle"
  	]
  },
  	"image/emf": {
  	source: "iana",
  	extensions: [
  		"emf"
  	]
  },
  	"image/fits": {
  	source: "iana",
  	extensions: [
  		"fits"
  	]
  },
  	"image/g3fax": {
  	source: "iana",
  	extensions: [
  		"g3"
  	]
  },
  	"image/gif": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"gif"
  	]
  },
  	"image/heic": {
  	source: "iana",
  	extensions: [
  		"heic"
  	]
  },
  	"image/heic-sequence": {
  	source: "iana",
  	extensions: [
  		"heics"
  	]
  },
  	"image/heif": {
  	source: "iana",
  	extensions: [
  		"heif"
  	]
  },
  	"image/heif-sequence": {
  	source: "iana",
  	extensions: [
  		"heifs"
  	]
  },
  	"image/hej2k": {
  	source: "iana",
  	extensions: [
  		"hej2"
  	]
  },
  	"image/hsj2": {
  	source: "iana",
  	extensions: [
  		"hsj2"
  	]
  },
  	"image/ief": {
  	source: "iana",
  	extensions: [
  		"ief"
  	]
  },
  	"image/jls": {
  	source: "iana",
  	extensions: [
  		"jls"
  	]
  },
  	"image/jp2": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"jp2",
  		"jpg2"
  	]
  },
  	"image/jpeg": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"jpeg",
  		"jpg",
  		"jpe"
  	]
  },
  	"image/jph": {
  	source: "iana",
  	extensions: [
  		"jph"
  	]
  },
  	"image/jphc": {
  	source: "iana",
  	extensions: [
  		"jhc"
  	]
  },
  	"image/jpm": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"jpm"
  	]
  },
  	"image/jpx": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"jpx",
  		"jpf"
  	]
  },
  	"image/jxr": {
  	source: "iana",
  	extensions: [
  		"jxr"
  	]
  },
  	"image/jxra": {
  	source: "iana",
  	extensions: [
  		"jxra"
  	]
  },
  	"image/jxrs": {
  	source: "iana",
  	extensions: [
  		"jxrs"
  	]
  },
  	"image/jxs": {
  	source: "iana",
  	extensions: [
  		"jxs"
  	]
  },
  	"image/jxsc": {
  	source: "iana",
  	extensions: [
  		"jxsc"
  	]
  },
  	"image/jxsi": {
  	source: "iana",
  	extensions: [
  		"jxsi"
  	]
  },
  	"image/jxss": {
  	source: "iana",
  	extensions: [
  		"jxss"
  	]
  },
  	"image/ktx": {
  	source: "iana",
  	extensions: [
  		"ktx"
  	]
  },
  	"image/naplps": {
  	source: "iana"
  },
  	"image/pjpeg": {
  	compressible: false
  },
  	"image/png": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"png"
  	]
  },
  	"image/prs.btif": {
  	source: "iana",
  	extensions: [
  		"btif"
  	]
  },
  	"image/prs.pti": {
  	source: "iana",
  	extensions: [
  		"pti"
  	]
  },
  	"image/pwg-raster": {
  	source: "iana"
  },
  	"image/sgi": {
  	source: "apache",
  	extensions: [
  		"sgi"
  	]
  },
  	"image/svg+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"svg",
  		"svgz"
  	]
  },
  	"image/t38": {
  	source: "iana",
  	extensions: [
  		"t38"
  	]
  },
  	"image/tiff": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"tif",
  		"tiff"
  	]
  },
  	"image/tiff-fx": {
  	source: "iana",
  	extensions: [
  		"tfx"
  	]
  },
  	"image/vnd.adobe.photoshop": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"psd"
  	]
  },
  	"image/vnd.airzip.accelerator.azv": {
  	source: "iana",
  	extensions: [
  		"azv"
  	]
  },
  	"image/vnd.cns.inf2": {
  	source: "iana"
  },
  	"image/vnd.dece.graphic": {
  	source: "iana",
  	extensions: [
  		"uvi",
  		"uvvi",
  		"uvg",
  		"uvvg"
  	]
  },
  	"image/vnd.djvu": {
  	source: "iana",
  	extensions: [
  		"djvu",
  		"djv"
  	]
  },
  	"image/vnd.dvb.subtitle": {
  	source: "iana",
  	extensions: [
  		"sub"
  	]
  },
  	"image/vnd.dwg": {
  	source: "iana",
  	extensions: [
  		"dwg"
  	]
  },
  	"image/vnd.dxf": {
  	source: "iana",
  	extensions: [
  		"dxf"
  	]
  },
  	"image/vnd.fastbidsheet": {
  	source: "iana",
  	extensions: [
  		"fbs"
  	]
  },
  	"image/vnd.fpx": {
  	source: "iana",
  	extensions: [
  		"fpx"
  	]
  },
  	"image/vnd.fst": {
  	source: "iana",
  	extensions: [
  		"fst"
  	]
  },
  	"image/vnd.fujixerox.edmics-mmr": {
  	source: "iana",
  	extensions: [
  		"mmr"
  	]
  },
  	"image/vnd.fujixerox.edmics-rlc": {
  	source: "iana",
  	extensions: [
  		"rlc"
  	]
  },
  	"image/vnd.globalgraphics.pgb": {
  	source: "iana"
  },
  	"image/vnd.microsoft.icon": {
  	source: "iana",
  	extensions: [
  		"ico"
  	]
  },
  	"image/vnd.mix": {
  	source: "iana"
  },
  	"image/vnd.mozilla.apng": {
  	source: "iana"
  },
  	"image/vnd.ms-dds": {
  	extensions: [
  		"dds"
  	]
  },
  	"image/vnd.ms-modi": {
  	source: "iana",
  	extensions: [
  		"mdi"
  	]
  },
  	"image/vnd.ms-photo": {
  	source: "apache",
  	extensions: [
  		"wdp"
  	]
  },
  	"image/vnd.net-fpx": {
  	source: "iana",
  	extensions: [
  		"npx"
  	]
  },
  	"image/vnd.radiance": {
  	source: "iana"
  },
  	"image/vnd.sealed.png": {
  	source: "iana"
  },
  	"image/vnd.sealedmedia.softseal.gif": {
  	source: "iana"
  },
  	"image/vnd.sealedmedia.softseal.jpg": {
  	source: "iana"
  },
  	"image/vnd.svf": {
  	source: "iana"
  },
  	"image/vnd.tencent.tap": {
  	source: "iana",
  	extensions: [
  		"tap"
  	]
  },
  	"image/vnd.valve.source.texture": {
  	source: "iana",
  	extensions: [
  		"vtf"
  	]
  },
  	"image/vnd.wap.wbmp": {
  	source: "iana",
  	extensions: [
  		"wbmp"
  	]
  },
  	"image/vnd.xiff": {
  	source: "iana",
  	extensions: [
  		"xif"
  	]
  },
  	"image/vnd.zbrush.pcx": {
  	source: "iana",
  	extensions: [
  		"pcx"
  	]
  },
  	"image/webp": {
  	source: "apache",
  	extensions: [
  		"webp"
  	]
  },
  	"image/wmf": {
  	source: "iana",
  	extensions: [
  		"wmf"
  	]
  },
  	"image/x-3ds": {
  	source: "apache",
  	extensions: [
  		"3ds"
  	]
  },
  	"image/x-cmu-raster": {
  	source: "apache",
  	extensions: [
  		"ras"
  	]
  },
  	"image/x-cmx": {
  	source: "apache",
  	extensions: [
  		"cmx"
  	]
  },
  	"image/x-freehand": {
  	source: "apache",
  	extensions: [
  		"fh",
  		"fhc",
  		"fh4",
  		"fh5",
  		"fh7"
  	]
  },
  	"image/x-icon": {
  	source: "apache",
  	compressible: true,
  	extensions: [
  		"ico"
  	]
  },
  	"image/x-jng": {
  	source: "nginx",
  	extensions: [
  		"jng"
  	]
  },
  	"image/x-mrsid-image": {
  	source: "apache",
  	extensions: [
  		"sid"
  	]
  },
  	"image/x-ms-bmp": {
  	source: "nginx",
  	compressible: true,
  	extensions: [
  		"bmp"
  	]
  },
  	"image/x-pcx": {
  	source: "apache",
  	extensions: [
  		"pcx"
  	]
  },
  	"image/x-pict": {
  	source: "apache",
  	extensions: [
  		"pic",
  		"pct"
  	]
  },
  	"image/x-portable-anymap": {
  	source: "apache",
  	extensions: [
  		"pnm"
  	]
  },
  	"image/x-portable-bitmap": {
  	source: "apache",
  	extensions: [
  		"pbm"
  	]
  },
  	"image/x-portable-graymap": {
  	source: "apache",
  	extensions: [
  		"pgm"
  	]
  },
  	"image/x-portable-pixmap": {
  	source: "apache",
  	extensions: [
  		"ppm"
  	]
  },
  	"image/x-rgb": {
  	source: "apache",
  	extensions: [
  		"rgb"
  	]
  },
  	"image/x-tga": {
  	source: "apache",
  	extensions: [
  		"tga"
  	]
  },
  	"image/x-xbitmap": {
  	source: "apache",
  	extensions: [
  		"xbm"
  	]
  },
  	"image/x-xcf": {
  	compressible: false
  },
  	"image/x-xpixmap": {
  	source: "apache",
  	extensions: [
  		"xpm"
  	]
  },
  	"image/x-xwindowdump": {
  	source: "apache",
  	extensions: [
  		"xwd"
  	]
  },
  	"message/cpim": {
  	source: "iana"
  },
  	"message/delivery-status": {
  	source: "iana"
  },
  	"message/disposition-notification": {
  	source: "iana",
  	extensions: [
  		"disposition-notification"
  	]
  },
  	"message/external-body": {
  	source: "iana"
  },
  	"message/feedback-report": {
  	source: "iana"
  },
  	"message/global": {
  	source: "iana",
  	extensions: [
  		"u8msg"
  	]
  },
  	"message/global-delivery-status": {
  	source: "iana",
  	extensions: [
  		"u8dsn"
  	]
  },
  	"message/global-disposition-notification": {
  	source: "iana",
  	extensions: [
  		"u8mdn"
  	]
  },
  	"message/global-headers": {
  	source: "iana",
  	extensions: [
  		"u8hdr"
  	]
  },
  	"message/http": {
  	source: "iana",
  	compressible: false
  },
  	"message/imdn+xml": {
  	source: "iana",
  	compressible: true
  },
  	"message/news": {
  	source: "iana"
  },
  	"message/partial": {
  	source: "iana",
  	compressible: false
  },
  	"message/rfc822": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"eml",
  		"mime"
  	]
  },
  	"message/s-http": {
  	source: "iana"
  },
  	"message/sip": {
  	source: "iana"
  },
  	"message/sipfrag": {
  	source: "iana"
  },
  	"message/tracking-status": {
  	source: "iana"
  },
  	"message/vnd.si.simp": {
  	source: "iana"
  },
  	"message/vnd.wfa.wsc": {
  	source: "iana",
  	extensions: [
  		"wsc"
  	]
  },
  	"model/3mf": {
  	source: "iana",
  	extensions: [
  		"3mf"
  	]
  },
  	"model/gltf+json": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"gltf"
  	]
  },
  	"model/gltf-binary": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"glb"
  	]
  },
  	"model/iges": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"igs",
  		"iges"
  	]
  },
  	"model/mesh": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"msh",
  		"mesh",
  		"silo"
  	]
  },
  	"model/stl": {
  	source: "iana",
  	extensions: [
  		"stl"
  	]
  },
  	"model/vnd.collada+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"dae"
  	]
  },
  	"model/vnd.dwf": {
  	source: "iana",
  	extensions: [
  		"dwf"
  	]
  },
  	"model/vnd.flatland.3dml": {
  	source: "iana"
  },
  	"model/vnd.gdl": {
  	source: "iana",
  	extensions: [
  		"gdl"
  	]
  },
  	"model/vnd.gs-gdl": {
  	source: "apache"
  },
  	"model/vnd.gs.gdl": {
  	source: "iana"
  },
  	"model/vnd.gtw": {
  	source: "iana",
  	extensions: [
  		"gtw"
  	]
  },
  	"model/vnd.moml+xml": {
  	source: "iana",
  	compressible: true
  },
  	"model/vnd.mts": {
  	source: "iana",
  	extensions: [
  		"mts"
  	]
  },
  	"model/vnd.opengex": {
  	source: "iana",
  	extensions: [
  		"ogex"
  	]
  },
  	"model/vnd.parasolid.transmit.binary": {
  	source: "iana",
  	extensions: [
  		"x_b"
  	]
  },
  	"model/vnd.parasolid.transmit.text": {
  	source: "iana",
  	extensions: [
  		"x_t"
  	]
  },
  	"model/vnd.rosette.annotated-data-model": {
  	source: "iana"
  },
  	"model/vnd.usdz+zip": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"usdz"
  	]
  },
  	"model/vnd.valve.source.compiled-map": {
  	source: "iana",
  	extensions: [
  		"bsp"
  	]
  },
  	"model/vnd.vtu": {
  	source: "iana",
  	extensions: [
  		"vtu"
  	]
  },
  	"model/vrml": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"wrl",
  		"vrml"
  	]
  },
  	"model/x3d+binary": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"x3db",
  		"x3dbz"
  	]
  },
  	"model/x3d+fastinfoset": {
  	source: "iana",
  	extensions: [
  		"x3db"
  	]
  },
  	"model/x3d+vrml": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"x3dv",
  		"x3dvz"
  	]
  },
  	"model/x3d+xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"x3d",
  		"x3dz"
  	]
  },
  	"model/x3d-vrml": {
  	source: "iana",
  	extensions: [
  		"x3dv"
  	]
  },
  	"multipart/alternative": {
  	source: "iana",
  	compressible: false
  },
  	"multipart/appledouble": {
  	source: "iana"
  },
  	"multipart/byteranges": {
  	source: "iana"
  },
  	"multipart/digest": {
  	source: "iana"
  },
  	"multipart/encrypted": {
  	source: "iana",
  	compressible: false
  },
  	"multipart/form-data": {
  	source: "iana",
  	compressible: false
  },
  	"multipart/header-set": {
  	source: "iana"
  },
  	"multipart/mixed": {
  	source: "iana"
  },
  	"multipart/multilingual": {
  	source: "iana"
  },
  	"multipart/parallel": {
  	source: "iana"
  },
  	"multipart/related": {
  	source: "iana",
  	compressible: false
  },
  	"multipart/report": {
  	source: "iana"
  },
  	"multipart/signed": {
  	source: "iana",
  	compressible: false
  },
  	"multipart/vnd.bint.med-plus": {
  	source: "iana"
  },
  	"multipart/voice-message": {
  	source: "iana"
  },
  	"multipart/x-mixed-replace": {
  	source: "iana"
  },
  	"text/1d-interleaved-parityfec": {
  	source: "iana"
  },
  	"text/cache-manifest": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"appcache",
  		"manifest"
  	]
  },
  	"text/calendar": {
  	source: "iana",
  	extensions: [
  		"ics",
  		"ifb"
  	]
  },
  	"text/calender": {
  	compressible: true
  },
  	"text/cmd": {
  	compressible: true
  },
  	"text/coffeescript": {
  	extensions: [
  		"coffee",
  		"litcoffee"
  	]
  },
  	"text/css": {
  	source: "iana",
  	charset: "UTF-8",
  	compressible: true,
  	extensions: [
  		"css"
  	]
  },
  	"text/csv": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"csv"
  	]
  },
  	"text/csv-schema": {
  	source: "iana"
  },
  	"text/directory": {
  	source: "iana"
  },
  	"text/dns": {
  	source: "iana"
  },
  	"text/ecmascript": {
  	source: "iana"
  },
  	"text/encaprtp": {
  	source: "iana"
  },
  	"text/enriched": {
  	source: "iana"
  },
  	"text/flexfec": {
  	source: "iana"
  },
  	"text/fwdred": {
  	source: "iana"
  },
  	"text/grammar-ref-list": {
  	source: "iana"
  },
  	"text/html": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"html",
  		"htm",
  		"shtml"
  	]
  },
  	"text/jade": {
  	extensions: [
  		"jade"
  	]
  },
  	"text/javascript": {
  	source: "iana",
  	compressible: true
  },
  	"text/jcr-cnd": {
  	source: "iana"
  },
  	"text/jsx": {
  	compressible: true,
  	extensions: [
  		"jsx"
  	]
  },
  	"text/less": {
  	compressible: true,
  	extensions: [
  		"less"
  	]
  },
  	"text/markdown": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"markdown",
  		"md"
  	]
  },
  	"text/mathml": {
  	source: "nginx",
  	extensions: [
  		"mml"
  	]
  },
  	"text/mdx": {
  	compressible: true,
  	extensions: [
  		"mdx"
  	]
  },
  	"text/mizar": {
  	source: "iana"
  },
  	"text/n3": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"n3"
  	]
  },
  	"text/parameters": {
  	source: "iana"
  },
  	"text/parityfec": {
  	source: "iana"
  },
  	"text/plain": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"txt",
  		"text",
  		"conf",
  		"def",
  		"list",
  		"log",
  		"in",
  		"ini"
  	]
  },
  	"text/provenance-notation": {
  	source: "iana"
  },
  	"text/prs.fallenstein.rst": {
  	source: "iana"
  },
  	"text/prs.lines.tag": {
  	source: "iana",
  	extensions: [
  		"dsc"
  	]
  },
  	"text/prs.prop.logic": {
  	source: "iana"
  },
  	"text/raptorfec": {
  	source: "iana"
  },
  	"text/red": {
  	source: "iana"
  },
  	"text/rfc822-headers": {
  	source: "iana"
  },
  	"text/richtext": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rtx"
  	]
  },
  	"text/rtf": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"rtf"
  	]
  },
  	"text/rtp-enc-aescm128": {
  	source: "iana"
  },
  	"text/rtploopback": {
  	source: "iana"
  },
  	"text/rtx": {
  	source: "iana"
  },
  	"text/sgml": {
  	source: "iana",
  	extensions: [
  		"sgml",
  		"sgm"
  	]
  },
  	"text/shex": {
  	extensions: [
  		"shex"
  	]
  },
  	"text/slim": {
  	extensions: [
  		"slim",
  		"slm"
  	]
  },
  	"text/strings": {
  	source: "iana"
  },
  	"text/stylus": {
  	extensions: [
  		"stylus",
  		"styl"
  	]
  },
  	"text/t140": {
  	source: "iana"
  },
  	"text/tab-separated-values": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"tsv"
  	]
  },
  	"text/troff": {
  	source: "iana",
  	extensions: [
  		"t",
  		"tr",
  		"roff",
  		"man",
  		"me",
  		"ms"
  	]
  },
  	"text/turtle": {
  	source: "iana",
  	charset: "UTF-8",
  	extensions: [
  		"ttl"
  	]
  },
  	"text/ulpfec": {
  	source: "iana"
  },
  	"text/uri-list": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"uri",
  		"uris",
  		"urls"
  	]
  },
  	"text/vcard": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"vcard"
  	]
  },
  	"text/vnd.a": {
  	source: "iana"
  },
  	"text/vnd.abc": {
  	source: "iana"
  },
  	"text/vnd.ascii-art": {
  	source: "iana"
  },
  	"text/vnd.curl": {
  	source: "iana",
  	extensions: [
  		"curl"
  	]
  },
  	"text/vnd.curl.dcurl": {
  	source: "apache",
  	extensions: [
  		"dcurl"
  	]
  },
  	"text/vnd.curl.mcurl": {
  	source: "apache",
  	extensions: [
  		"mcurl"
  	]
  },
  	"text/vnd.curl.scurl": {
  	source: "apache",
  	extensions: [
  		"scurl"
  	]
  },
  	"text/vnd.debian.copyright": {
  	source: "iana"
  },
  	"text/vnd.dmclientscript": {
  	source: "iana"
  },
  	"text/vnd.dvb.subtitle": {
  	source: "iana",
  	extensions: [
  		"sub"
  	]
  },
  	"text/vnd.esmertec.theme-descriptor": {
  	source: "iana"
  },
  	"text/vnd.ficlab.flt": {
  	source: "iana"
  },
  	"text/vnd.fly": {
  	source: "iana",
  	extensions: [
  		"fly"
  	]
  },
  	"text/vnd.fmi.flexstor": {
  	source: "iana",
  	extensions: [
  		"flx"
  	]
  },
  	"text/vnd.gml": {
  	source: "iana"
  },
  	"text/vnd.graphviz": {
  	source: "iana",
  	extensions: [
  		"gv"
  	]
  },
  	"text/vnd.hgl": {
  	source: "iana"
  },
  	"text/vnd.in3d.3dml": {
  	source: "iana",
  	extensions: [
  		"3dml"
  	]
  },
  	"text/vnd.in3d.spot": {
  	source: "iana",
  	extensions: [
  		"spot"
  	]
  },
  	"text/vnd.iptc.newsml": {
  	source: "iana"
  },
  	"text/vnd.iptc.nitf": {
  	source: "iana"
  },
  	"text/vnd.latex-z": {
  	source: "iana"
  },
  	"text/vnd.motorola.reflex": {
  	source: "iana"
  },
  	"text/vnd.ms-mediapackage": {
  	source: "iana"
  },
  	"text/vnd.net2phone.commcenter.command": {
  	source: "iana"
  },
  	"text/vnd.radisys.msml-basic-layout": {
  	source: "iana"
  },
  	"text/vnd.senx.warpscript": {
  	source: "iana"
  },
  	"text/vnd.si.uricatalogue": {
  	source: "iana"
  },
  	"text/vnd.sosi": {
  	source: "iana"
  },
  	"text/vnd.sun.j2me.app-descriptor": {
  	source: "iana",
  	extensions: [
  		"jad"
  	]
  },
  	"text/vnd.trolltech.linguist": {
  	source: "iana"
  },
  	"text/vnd.wap.si": {
  	source: "iana"
  },
  	"text/vnd.wap.sl": {
  	source: "iana"
  },
  	"text/vnd.wap.wml": {
  	source: "iana",
  	extensions: [
  		"wml"
  	]
  },
  	"text/vnd.wap.wmlscript": {
  	source: "iana",
  	extensions: [
  		"wmls"
  	]
  },
  	"text/vtt": {
  	source: "iana",
  	charset: "UTF-8",
  	compressible: true,
  	extensions: [
  		"vtt"
  	]
  },
  	"text/x-asm": {
  	source: "apache",
  	extensions: [
  		"s",
  		"asm"
  	]
  },
  	"text/x-c": {
  	source: "apache",
  	extensions: [
  		"c",
  		"cc",
  		"cxx",
  		"cpp",
  		"h",
  		"hh",
  		"dic"
  	]
  },
  	"text/x-component": {
  	source: "nginx",
  	extensions: [
  		"htc"
  	]
  },
  	"text/x-fortran": {
  	source: "apache",
  	extensions: [
  		"f",
  		"for",
  		"f77",
  		"f90"
  	]
  },
  	"text/x-gwt-rpc": {
  	compressible: true
  },
  	"text/x-handlebars-template": {
  	extensions: [
  		"hbs"
  	]
  },
  	"text/x-java-source": {
  	source: "apache",
  	extensions: [
  		"java"
  	]
  },
  	"text/x-jquery-tmpl": {
  	compressible: true
  },
  	"text/x-lua": {
  	extensions: [
  		"lua"
  	]
  },
  	"text/x-markdown": {
  	compressible: true,
  	extensions: [
  		"mkd"
  	]
  },
  	"text/x-nfo": {
  	source: "apache",
  	extensions: [
  		"nfo"
  	]
  },
  	"text/x-opml": {
  	source: "apache",
  	extensions: [
  		"opml"
  	]
  },
  	"text/x-org": {
  	compressible: true,
  	extensions: [
  		"org"
  	]
  },
  	"text/x-pascal": {
  	source: "apache",
  	extensions: [
  		"p",
  		"pas"
  	]
  },
  	"text/x-processing": {
  	compressible: true,
  	extensions: [
  		"pde"
  	]
  },
  	"text/x-sass": {
  	extensions: [
  		"sass"
  	]
  },
  	"text/x-scss": {
  	extensions: [
  		"scss"
  	]
  },
  	"text/x-setext": {
  	source: "apache",
  	extensions: [
  		"etx"
  	]
  },
  	"text/x-sfv": {
  	source: "apache",
  	extensions: [
  		"sfv"
  	]
  },
  	"text/x-suse-ymp": {
  	compressible: true,
  	extensions: [
  		"ymp"
  	]
  },
  	"text/x-uuencode": {
  	source: "apache",
  	extensions: [
  		"uu"
  	]
  },
  	"text/x-vcalendar": {
  	source: "apache",
  	extensions: [
  		"vcs"
  	]
  },
  	"text/x-vcard": {
  	source: "apache",
  	extensions: [
  		"vcf"
  	]
  },
  	"text/xml": {
  	source: "iana",
  	compressible: true,
  	extensions: [
  		"xml"
  	]
  },
  	"text/xml-external-parsed-entity": {
  	source: "iana"
  },
  	"text/yaml": {
  	extensions: [
  		"yaml",
  		"yml"
  	]
  },
  	"video/1d-interleaved-parityfec": {
  	source: "iana"
  },
  	"video/3gpp": {
  	source: "iana",
  	extensions: [
  		"3gp",
  		"3gpp"
  	]
  },
  	"video/3gpp-tt": {
  	source: "iana"
  },
  	"video/3gpp2": {
  	source: "iana",
  	extensions: [
  		"3g2"
  	]
  },
  	"video/bmpeg": {
  	source: "iana"
  },
  	"video/bt656": {
  	source: "iana"
  },
  	"video/celb": {
  	source: "iana"
  },
  	"video/dv": {
  	source: "iana"
  },
  	"video/encaprtp": {
  	source: "iana"
  },
  	"video/flexfec": {
  	source: "iana"
  },
  	"video/h261": {
  	source: "iana",
  	extensions: [
  		"h261"
  	]
  },
  	"video/h263": {
  	source: "iana",
  	extensions: [
  		"h263"
  	]
  },
  	"video/h263-1998": {
  	source: "iana"
  },
  	"video/h263-2000": {
  	source: "iana"
  },
  	"video/h264": {
  	source: "iana",
  	extensions: [
  		"h264"
  	]
  },
  	"video/h264-rcdo": {
  	source: "iana"
  },
  	"video/h264-svc": {
  	source: "iana"
  },
  	"video/h265": {
  	source: "iana"
  },
  	"video/iso.segment": {
  	source: "iana"
  },
  	"video/jpeg": {
  	source: "iana",
  	extensions: [
  		"jpgv"
  	]
  },
  	"video/jpeg2000": {
  	source: "iana"
  },
  	"video/jpm": {
  	source: "apache",
  	extensions: [
  		"jpm",
  		"jpgm"
  	]
  },
  	"video/mj2": {
  	source: "iana",
  	extensions: [
  		"mj2",
  		"mjp2"
  	]
  },
  	"video/mp1s": {
  	source: "iana"
  },
  	"video/mp2p": {
  	source: "iana"
  },
  	"video/mp2t": {
  	source: "iana",
  	extensions: [
  		"ts"
  	]
  },
  	"video/mp4": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"mp4",
  		"mp4v",
  		"mpg4"
  	]
  },
  	"video/mp4v-es": {
  	source: "iana"
  },
  	"video/mpeg": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"mpeg",
  		"mpg",
  		"mpe",
  		"m1v",
  		"m2v"
  	]
  },
  	"video/mpeg4-generic": {
  	source: "iana"
  },
  	"video/mpv": {
  	source: "iana"
  },
  	"video/nv": {
  	source: "iana"
  },
  	"video/ogg": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"ogv"
  	]
  },
  	"video/parityfec": {
  	source: "iana"
  },
  	"video/pointer": {
  	source: "iana"
  },
  	"video/quicktime": {
  	source: "iana",
  	compressible: false,
  	extensions: [
  		"qt",
  		"mov"
  	]
  },
  	"video/raptorfec": {
  	source: "iana"
  },
  	"video/raw": {
  	source: "iana"
  },
  	"video/rtp-enc-aescm128": {
  	source: "iana"
  },
  	"video/rtploopback": {
  	source: "iana"
  },
  	"video/rtx": {
  	source: "iana"
  },
  	"video/smpte291": {
  	source: "iana"
  },
  	"video/smpte292m": {
  	source: "iana"
  },
  	"video/ulpfec": {
  	source: "iana"
  },
  	"video/vc1": {
  	source: "iana"
  },
  	"video/vc2": {
  	source: "iana"
  },
  	"video/vnd.cctv": {
  	source: "iana"
  },
  	"video/vnd.dece.hd": {
  	source: "iana",
  	extensions: [
  		"uvh",
  		"uvvh"
  	]
  },
  	"video/vnd.dece.mobile": {
  	source: "iana",
  	extensions: [
  		"uvm",
  		"uvvm"
  	]
  },
  	"video/vnd.dece.mp4": {
  	source: "iana"
  },
  	"video/vnd.dece.pd": {
  	source: "iana",
  	extensions: [
  		"uvp",
  		"uvvp"
  	]
  },
  	"video/vnd.dece.sd": {
  	source: "iana",
  	extensions: [
  		"uvs",
  		"uvvs"
  	]
  },
  	"video/vnd.dece.video": {
  	source: "iana",
  	extensions: [
  		"uvv",
  		"uvvv"
  	]
  },
  	"video/vnd.directv.mpeg": {
  	source: "iana"
  },
  	"video/vnd.directv.mpeg-tts": {
  	source: "iana"
  },
  	"video/vnd.dlna.mpeg-tts": {
  	source: "iana"
  },
  	"video/vnd.dvb.file": {
  	source: "iana",
  	extensions: [
  		"dvb"
  	]
  },
  	"video/vnd.fvt": {
  	source: "iana",
  	extensions: [
  		"fvt"
  	]
  },
  	"video/vnd.hns.video": {
  	source: "iana"
  },
  	"video/vnd.iptvforum.1dparityfec-1010": {
  	source: "iana"
  },
  	"video/vnd.iptvforum.1dparityfec-2005": {
  	source: "iana"
  },
  	"video/vnd.iptvforum.2dparityfec-1010": {
  	source: "iana"
  },
  	"video/vnd.iptvforum.2dparityfec-2005": {
  	source: "iana"
  },
  	"video/vnd.iptvforum.ttsavc": {
  	source: "iana"
  },
  	"video/vnd.iptvforum.ttsmpeg2": {
  	source: "iana"
  },
  	"video/vnd.motorola.video": {
  	source: "iana"
  },
  	"video/vnd.motorola.videop": {
  	source: "iana"
  },
  	"video/vnd.mpegurl": {
  	source: "iana",
  	extensions: [
  		"mxu",
  		"m4u"
  	]
  },
  	"video/vnd.ms-playready.media.pyv": {
  	source: "iana",
  	extensions: [
  		"pyv"
  	]
  },
  	"video/vnd.nokia.interleaved-multimedia": {
  	source: "iana"
  },
  	"video/vnd.nokia.mp4vr": {
  	source: "iana"
  },
  	"video/vnd.nokia.videovoip": {
  	source: "iana"
  },
  	"video/vnd.objectvideo": {
  	source: "iana"
  },
  	"video/vnd.radgamettools.bink": {
  	source: "iana"
  },
  	"video/vnd.radgamettools.smacker": {
  	source: "iana"
  },
  	"video/vnd.sealed.mpeg1": {
  	source: "iana"
  },
  	"video/vnd.sealed.mpeg4": {
  	source: "iana"
  },
  	"video/vnd.sealed.swf": {
  	source: "iana"
  },
  	"video/vnd.sealedmedia.softseal.mov": {
  	source: "iana"
  },
  	"video/vnd.uvvu.mp4": {
  	source: "iana",
  	extensions: [
  		"uvu",
  		"uvvu"
  	]
  },
  	"video/vnd.vivo": {
  	source: "iana",
  	extensions: [
  		"viv"
  	]
  },
  	"video/vnd.youtube.yt": {
  	source: "iana"
  },
  	"video/vp8": {
  	source: "iana"
  },
  	"video/webm": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"webm"
  	]
  },
  	"video/x-f4v": {
  	source: "apache",
  	extensions: [
  		"f4v"
  	]
  },
  	"video/x-fli": {
  	source: "apache",
  	extensions: [
  		"fli"
  	]
  },
  	"video/x-flv": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"flv"
  	]
  },
  	"video/x-m4v": {
  	source: "apache",
  	extensions: [
  		"m4v"
  	]
  },
  	"video/x-matroska": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"mkv",
  		"mk3d",
  		"mks"
  	]
  },
  	"video/x-mng": {
  	source: "apache",
  	extensions: [
  		"mng"
  	]
  },
  	"video/x-ms-asf": {
  	source: "apache",
  	extensions: [
  		"asf",
  		"asx"
  	]
  },
  	"video/x-ms-vob": {
  	source: "apache",
  	extensions: [
  		"vob"
  	]
  },
  	"video/x-ms-wm": {
  	source: "apache",
  	extensions: [
  		"wm"
  	]
  },
  	"video/x-ms-wmv": {
  	source: "apache",
  	compressible: false,
  	extensions: [
  		"wmv"
  	]
  },
  	"video/x-ms-wmx": {
  	source: "apache",
  	extensions: [
  		"wmx"
  	]
  },
  	"video/x-ms-wvx": {
  	source: "apache",
  	extensions: [
  		"wvx"
  	]
  },
  	"video/x-msvideo": {
  	source: "apache",
  	extensions: [
  		"avi"
  	]
  },
  	"video/x-sgi-movie": {
  	source: "apache",
  	extensions: [
  		"movie"
  	]
  },
  	"video/x-smv": {
  	source: "apache",
  	extensions: [
  		"smv"
  	]
  },
  	"x-conference/x-cooltalk": {
  	source: "apache",
  	extensions: [
  		"ice"
  	]
  },
  	"x-shader/x-fragment": {
  	compressible: true
  },
  	"x-shader/x-vertex": {
  	compressible: true
  }
  };

  var db$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': db
  });

  var require$$0 = getCjsExportFromNamespace(db$1);

  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */

  /**
   * Module exports.
   */

  var mimeDb = require$$0;

  // rule: attribute-validate-accept

  function attributeValidateAccept(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "accept") {
          // validate the parent
          if (!["form", "input"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-accept",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            quickPermittedValues: ["audio/*", "video/*", "image/*", "text/html", "image/png", "image/gif", "video/mpeg", "text/css", "audio/basic", wholeExtensionRegex],
            permittedValues: Object.keys(mimeDb),
            canBeCommaSeparated: true,
            noSpaceAfterComma: true
          }); // HTML attribute accept MIME types as values. Here we reference the given
          // value against all official MIME types, taken from IANA and other sources,
          // https://www.npmjs.com/package/mime-db

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-accept"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-accesskey

  function attributeValidateAccesskey(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "accesskey") {
          // validate the parent
          if (!["a", "area", "button", "input", "label", "legend", "textarea"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-accesskey",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any string


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr,
              trimmedVal = _checkForWhitespace.trimmedVal;

          if (Number.isInteger(charStart)) {
            // the value must be a character, raw or escaped, from a document's
            // charset
            // https://www.w3.org/TR/html4/interact/forms.html#adef-accesskey
            if (trimmedVal.length > 1 && !(trimmedVal.startsWith("&") && trimmedVal.endsWith(";"))) {
              errorArr.push({
                idxFrom: node.attribValueStartsAt + charStart,
                idxTo: node.attribValueStartsAt + charEnd,
                message: "Should be a single character (escaped or not).",
                fix: null
              });
            }
          }

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-accesskey"
            }));
          });
        }
      }
    };
  }

  function isSingleSpace(str, originalOpts, errorArr) {
    var defaults = {
      from: 0,
      to: str.length,
      offset: 0
    };
    var opts = Object.assign({}, defaults, originalOpts); // whitespace starts at "from" and ends at "to"

    if (str.slice(opts.from, opts.to) !== " ") {
      // remove the minimal amount of content - if spaces are there
      // already, leave them
      var ranges;

      if (str[opts.from] === " ") {
        ranges = [[opts.offset + opts.from + 1, opts.offset + opts.to]];
      } else if (str[opts.to - 1] === " ") {
        ranges = [[opts.offset + opts.from, opts.offset + opts.to - 1]];
      } else {
        ranges = [[opts.offset + opts.from, opts.offset + opts.to, " "]];
      } // raise an error about this excessive/wrong whitespace


      errorArr.push({
        idxFrom: opts.offset + opts.from,
        idxTo: opts.offset + opts.to,
        message: "Should be a single space.",
        fix: {
          ranges: ranges
        }
      });
    }
  }

  /**
   * is-relative-uri
   * Is given string a relative URI?
   * Version: 1.0.5
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/is-relative-uri
   */
  const BACKSLASH$3 = "\u005C";
  const knownSchemes = ["aaa", "aaas", "about", "acap", "acct", "acd", "acr", "adiumxtra", "adt", "afp", "afs", "aim", "amss", "android", "appdata", "apt", "ark", "attachment", "aw", "barion", "beshare", "bitcoin", "bitcoincash", "blob", "bolo", "browserext", "calculator", "callto", "cap", "cast", "casts", "chrome", "chrome-extension", "cid", "coap", "coap+tcp", "coap+ws", "coaps", "coaps+tcp", "coaps+ws", "com-eventbrite-attendee", "content", "conti", "crid", "cvs", "dab", "dav", "diaspora", "dict", "did", "dis", "dlna-playcontainer", "dlna-playsingle", "dns", "dntp", "dpp", "drm", "drop", "dtn", "dvb", "ed2k", "elsi", "example", "facetime", "fax", "feed", "feedready", "filesystem", "finger", "first-run-pen-experience", "fish", "fm", "fuchsia-pkg", "geo", "gg", "git", "gizmoproject", "go", "gopher", "graph", "gtalk", "h323", "ham", "hcap", "hcp", "hxxp", "hxxps", "hydrazone", "iax", "icap", "icon", "im", "imap", "info", "iotdisco", "ipn", "ipp", "ipps", "irc6", "ircs", "iris", "iris.beep", "iris.lwz", "iris.xpc", "iris.xpcs", "isostore", "itms", "jabber", "jar", "jms", "keyparc", "lastfm", "ldap", "ldaps", "leaptofrogans", "lorawan", "lvlt", "magnet", "mailserver", "maps", "market", "message", "microsoft.windows.camera", "microsoft.windows.camera.multipicker", "microsoft.windows.camera.picker", "mid", "mms", "modem", "mongodb", "moz", "ms-access", "ms-browser-extension", "ms-calculator", "ms-drive-to", "ms-enrollment", "ms-excel", "ms-eyecontrolspeech", "ms-gamebarservices", "ms-gamingoverlay", "ms-getoffice", "ms-help", "ms-infopath", "ms-inputapp", "ms-lockscreencomponent-config", "ms-media-stream-id", "ms-mixedrealitycapture", "ms-mobileplans", "ms-officeapp", "ms-people", "ms-project", "ms-powerpoint", "ms-publisher", "ms-restoretabcompanion", "ms-screenclip", "ms-screensketch", "ms-search", "ms-search-repair", "ms-secondary-screen-controller", "ms-secondary-screen-setup", "ms-settings", "ms-settings-airplanemode", "ms-settings-bluetooth", "ms-settings-camera", "ms-settings-cellular", "ms-settings-cloudstorage", "ms-settings-connectabledevices", "ms-settings-displays-topology", "ms-settings-emailandaccounts", "ms-settings-language", "ms-settings-location", "ms-settings-lock", "ms-settings-nfctransactions", "ms-settings-notifications", "ms-settings-power", "ms-settings-privacy", "ms-settings-proximity", "ms-settings-screenrotation", "ms-settings-wifi", "ms-settings-workplace", "ms-spd", "ms-sttoverlay", "ms-transit-to", "ms-useractivityset", "ms-virtualtouchpad", "ms-visio", "ms-walk-to", "ms-whiteboard", "ms-whiteboard-cmd", "ms-word", "msnim", "msrp", "msrps", "mss", "mtqp", "mumble", "mupdate", "mvn", "news", "nfs", "ni", "nih", "nntp", "notes", "ocf", "oid", "onenote", "onenote-cmd", "opaquelocktoken", "openpgp4fpr", "pack", "palm", "paparazzi", "payment", "payto", "pkcs11", "platform", "pop", "pres", "prospero", "proxy", "pwid", "psyc", "pttp", "qb", "query", "quic-transport", "redis", "rediss", "reload", "res", "resource", "rmi", "rsync", "rtmfp", "rtmp", "rtsp", "rtsps", "rtspu", "secondlife", "service", "session", "sftp", "sgn", "shttp", "sieve", "simpleledger", "sip", "sips", "skype", "smb", "sms", "smtp", "snews", "snmp", "soap.beep", "soap.beeps", "soldat", "spiffe", "spotify", "ssh", "steam", "stun", "stuns", "submit", "svn", "tag", "teamspeak", "tel", "teliaeid", "telnet", "tftp", "things", "thismessage", "tip", "tn3270", "tool", "turn", "turns", "tv", "udp", "unreal", "urn", "ut2004", "v-event", "vemmi", "ventrilo", "videotex", "vnc", "view-source", "wais", "webcal", "wpid", "ws", "wss", "wtai", "wyciwyg", "xcon", "xcon-userid", "xfire", "xmlrpc.beep", "xmlrpc.beeps", "xmpp", "xri", "ymsgr", "z39.50", "z39.50r", "z39.50s"];

  function isRel(str, originalOpts) {
    if (typeof str !== "string") {
      throw new Error(`is-relative-uri: [THROW_ID_01] input string must be string, it was given as "${str}" (type ${typeof str})`);
    }

    if (originalOpts && typeof originalOpts !== "object") {
      throw new Error(`is-relative-uri: [THROW_ID_02] opts be plain object, it was given as ${originalOpts} (type ${typeof originalOpts})`);
    }

    const defaults = {
      flagUpUrisWithSchemes: true
    };
    let opts;

    if (originalOpts) {
      opts = Object.assign({}, defaults, originalOpts);
    } else {
      opts = Object.assign({}, defaults);
    }

    if (opts.offset && !Number.isInteger(opts.offset)) {
      throw new Error(`is-relative-uri: [THROW_ID_02] opts.offset must be an integer, it was given as ${opts.offset} (type ${typeof opts.offset})`);
    }

    if (!opts.offset) {
      opts.offset = 0;
    }

    if (str.split("").some(char => !char.trim().length)) {
      return {
        res: false,
        message: `Remove whitespace.`
      };
    }

    if (str.match(/\/\s*\/\s*\//g)) {
      return {
        res: false,
        message: `Three consecutive slashes found.`
      };
    }

    if (str.match(/.\/\s*\//g)) {
      return {
        res: false,
        message: `Character followed by two slashes.`
      };
    }

    if (str.includes("...")) {
      return {
        res: false,
        message: `Three consecutive dots.`
      };
    }

    if (str.includes("%") && !str.match(/%[0-9a-f]/gi)) {
      return {
        res: false,
        message: `Unescaped "%" character.`
      };
    }

    if (str.includes("<")) {
      return {
        res: false,
        message: `Unescaped "<" character.`
      };
    }

    if (str.includes(">")) {
      return {
        res: false,
        message: `Unescaped ">" character.`
      };
    }

    if (str.includes("[")) {
      return {
        res: false,
        message: `Unescaped "[" character.`
      };
    }

    if (str.includes("]")) {
      return {
        res: false,
        message: `Unescaped "]" character.`
      };
    }

    if (str.includes("{")) {
      return {
        res: false,
        message: `Unescaped "{" character.`
      };
    }

    if (str.includes("}")) {
      return {
        res: false,
        message: `Unescaped "}" character.`
      };
    }

    if (str.includes("|")) {
      return {
        res: false,
        message: `Unescaped "|" character.`
      };
    }

    if (str.includes(BACKSLASH$3)) {
      return {
        res: false,
        message: `Unescaped backslash (${BACKSLASH$3}) character.`
      };
    }

    if (str.includes("^")) {
      return {
        res: false,
        message: `Unescaped caret (^) character.`
      };
    }

    if (str.endsWith(".") && !str.startsWith(".")) {
      return {
        res: false,
        message: `Ends with dot, is file extension missing?`
      };
    }

    if (str.includes("??")) {
      return {
        res: false,
        message: `Two consecutive question marks.`
      };
    }

    if (str.includes("##")) {
      return {
        res: false,
        message: `Two consecutive hashes.`
      };
    }

    if (str.endsWith("#")) {
      return {
        res: false,
        message: `Ends with a hash.`
      };
    }

    if (str.includes("#") && str.slice(str.indexOf("#") + 1).includes("/")) {
      return {
        res: false,
        message: `Slash follows hash.`
      };
    }

    if (str.match(/\.\.[^/]/g)) {
      return {
        res: false,
        message: `Two dots should be followed by a slash.`
      };
    }

    if (opts.flagUpUrisWithSchemes && (str.startsWith(`http:`) || str.startsWith(`https:`) || str.startsWith(`ftp:`) || str.startsWith(`mailto:`) || str.startsWith(`file:`) || str.startsWith(`data:`) || str.startsWith(`irc:`) || knownSchemes.some(scheme => str.startsWith(`${scheme}:`)))) {
      return {
        res: false,
        message: null
      };
    }

    return {
      res: true,
      message: null
    };
  }

  const word = '[a-fA-F\\d:]';

  const b$3 = options => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : '';

  const v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
  const v6seg = '[a-fA-F\\d]{1,4}';
  const v6 = `
(
(?:${v6seg}:){7}(?:${v6seg}|:)|                                // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                         // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(:${v6seg}){1,2}|:)|                 // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(:${v6seg}){0,1}:${v4}|(:${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(:${v6seg}){0,2}:${v4}|(:${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(:${v6seg}){0,3}:${v4}|(:${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(:${v6seg}){0,4}:${v4}|(:${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::((?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))           // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(%[0-9a-zA-Z]{1,})?                                           // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();

  const ip = options => options && options.exact ? new RegExp(`(?:^${v4}$)|(?:^${v6}$)`) : new RegExp(`(?:${b$3(options)}${v4}${b$3(options)})|(?:${b$3(options)}${v6}${b$3(options)})`, 'g');

  ip.v4 = options => options && options.exact ? new RegExp(`^${v4}$`) : new RegExp(`${b$3(options)}${v4}${b$3(options)}`, 'g');

  ip.v6 = options => options && options.exact ? new RegExp(`^${v6}$`) : new RegExp(`${b$3(options)}${v6}${b$3(options)}`, 'g');

  var ipRegex = ip;

  var tlds = ["aaa", "aarp", "abarth", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "ac", "academy", "accenture", "accountant", "accountants", "aco", "actor", "ad", "adac", "ads", "adult", "ae", "aeg", "aero", "aetna", "af", "afamilycompany", "afl", "africa", "ag", "agakhan", "agency", "ai", "aig", "aigo", "airbus", "airforce", "airtel", "akdn", "al", "alfaromeo", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "am", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "ao", "aol", "apartments", "app", "apple", "aq", "aquarelle", "ar", "arab", "aramco", "archi", "army", "arpa", "art", "arte", "as", "asda", "asia", "associates", "at", "athleta", "attorney", "au", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "avianca", "aw", "aws", "ax", "axa", "az", "azure", "ba", "baby", "baidu", "banamex", "bananarepublic", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bb", "bbc", "bbt", "bbva", "bcg", "bcn", "bd", "be", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bf", "bg", "bh", "bharti", "bi", "bible", "bid", "bike", "bing", "bingo", "bio", "biz", "bj", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bm", "bms", "bmw", "bn", "bnpparibas", "bo", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "br", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "bs", "bt", "budapest", "bugatti", "build", "builders", "business", "buy", "buzz", "bv", "bw", "by", "bz", "bzh", "ca", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "cancerresearch", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "caseih", "cash", "casino", "cat", "catering", "catholic", "cba", "cbn", "cbre", "cbs", "cc", "cd", "ceb", "center", "ceo", "cern", "cf", "cfa", "cfd", "cg", "ch", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "ci", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "cityeats", "ck", "cl", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "cm", "cn", "co", "coach", "codes", "coffee", "college", "cologne", "com", "comcast", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cookingchannel", "cool", "coop", "corsica", "country", "coupon", "coupons", "courses", "cpa", "cr", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "csc", "cu", "cuisinella", "cv", "cw", "cx", "cy", "cymru", "cyou", "cz", "dabur", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "de", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dj", "dk", "dm", "dnp", "do", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "duck", "dunlop", "dupont", "durban", "dvag", "dvr", "dz", "earth", "eat", "ec", "eco", "edeka", "edu", "education", "ee", "eg", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "er", "ericsson", "erni", "es", "esq", "estate", "esurance", "et", "etisalat", "eu", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fi", "fiat", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "fj", "fk", "flickr", "flights", "flir", "florist", "flowers", "fly", "fm", "fo", "foo", "food", "foodnetwork", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "fr", "free", "fresenius", "frl", "frogans", "frontdoor", "frontier", "ftr", "fujitsu", "fujixerox", "fun", "fund", "furniture", "futbol", "fyi", "ga", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gb", "gbiz", "gd", "gdn", "ge", "gea", "gent", "genting", "george", "gf", "gg", "ggee", "gh", "gi", "gift", "gifts", "gives", "giving", "gl", "glade", "glass", "gle", "global", "globo", "gm", "gmail", "gmbh", "gmo", "gmx", "gn", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "gov", "gp", "gq", "gr", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "gs", "gt", "gu", "guardian", "gucci", "guge", "guide", "guitars", "guru", "gw", "gy", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hgtv", "hiphop", "hisamitsu", "hitachi", "hiv", "hk", "hkt", "hm", "hn", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hoteles", "hotels", "hotmail", "house", "how", "hr", "hsbc", "ht", "hu", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "id", "ie", "ieee", "ifm", "ikano", "il", "im", "imamat", "imdb", "immo", "immobilien", "in", "inc", "industries", "infiniti", "info", "ing", "ink", "institute", "insurance", "insure", "int", "intel", "international", "intuit", "investments", "io", "ipiranga", "iq", "ir", "irish", "is", "ismaili", "ist", "istanbul", "it", "itau", "itv", "iveco", "jaguar", "java", "jcb", "jcp", "je", "jeep", "jetzt", "jewelry", "jio", "jll", "jm", "jmp", "jnj", "jo", "jobs", "joburg", "jot", "joy", "jp", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "ke", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kg", "kh", "ki", "kia", "kim", "kinder", "kindle", "kitchen", "kiwi", "km", "kn", "koeln", "komatsu", "kosher", "kp", "kpmg", "kpn", "kr", "krd", "kred", "kuokgroup", "kw", "ky", "kyoto", "kz", "la", "lacaixa", "lamborghini", "lamer", "lancaster", "lancia", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lb", "lc", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "li", "liaison", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "linde", "link", "lipsy", "live", "living", "lixil", "lk", "llc", "loan", "loans", "locker", "locus", "loft", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "lr", "ls", "lt", "ltd", "ltda", "lu", "lundbeck", "lupin", "luxe", "luxury", "lv", "ly", "ma", "macys", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "maserati", "mattel", "mba", "mc", "mckinsey", "md", "me", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merckmsd", "metlife", "mg", "mh", "miami", "microsoft", "mil", "mini", "mint", "mit", "mitsubishi", "mk", "ml", "mlb", "mls", "mm", "mma", "mn", "mo", "mobi", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "movistar", "mp", "mq", "mr", "ms", "msd", "mt", "mtn", "mtr", "mu", "museum", "mutual", "mv", "mw", "mx", "my", "mz", "na", "nab", "nadex", "nagoya", "name", "nationwide", "natura", "navy", "nba", "nc", "ne", "nec", "net", "netbank", "netflix", "network", "neustar", "new", "newholland", "news", "next", "nextdirect", "nexus", "nf", "nfl", "ng", "ngo", "nhk", "ni", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nl", "no", "nokia", "northwesternmutual", "norton", "now", "nowruz", "nowtv", "np", "nr", "nra", "nrw", "ntt", "nu", "nyc", "nz", "obi", "observer", "off", "office", "okinawa", "olayan", "olayangroup", "oldnavy", "ollo", "om", "omega", "one", "ong", "onl", "online", "onyourside", "ooo", "open", "oracle", "orange", "org", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "pa", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "passagens", "pay", "pccw", "pe", "pet", "pf", "pfizer", "pg", "ph", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "pk", "pl", "place", "play", "playstation", "plumbing", "plus", "pm", "pn", "pnc", "pohl", "poker", "politie", "porn", "post", "pr", "pramerica", "praxi", "press", "prime", "pro", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "ps", "pt", "pub", "pw", "pwc", "py", "qa", "qpon", "quebec", "quest", "qvc", "racing", "radio", "raid", "re", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "rightathome", "ril", "rio", "rip", "rmit", "ro", "rocher", "rocks", "rodeo", "rogers", "room", "rs", "rsvp", "ru", "rugby", "ruhr", "run", "rw", "rwe", "ryukyu", "sa", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sb", "sbi", "sbs", "sc", "sca", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scjohnson", "scor", "scot", "sd", "se", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "ses", "seven", "sew", "sex", "sexy", "sfr", "sg", "sh", "shangrila", "sharp", "shaw", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "showtime", "shriram", "si", "silk", "sina", "singles", "site", "sj", "sk", "ski", "skin", "sky", "skype", "sl", "sling", "sm", "smart", "smile", "sn", "sncf", "so", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "space", "sport", "spot", "spreadbetting", "sr", "srl", "ss", "st", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "su", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "sv", "swatch", "swiftcover", "swiss", "sx", "sy", "sydney", "symantec", "systems", "sz", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tc", "tci", "td", "tdk", "team", "tech", "technology", "tel", "telefonica", "temasek", "tennis", "teva", "tf", "tg", "th", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tiffany", "tips", "tires", "tirol", "tj", "tjmaxx", "tjx", "tk", "tkmaxx", "tl", "tm", "tmall", "tn", "to", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "tr", "trade", "trading", "training", "travel", "travelchannel", "travelers", "travelersinsurance", "trust", "trv", "tt", "tube", "tui", "tunes", "tushu", "tv", "tvs", "tw", "tz", "ua", "ubank", "ubs", "ug", "uk", "unicom", "university", "uno", "uol", "ups", "us", "uy", "uz", "va", "vacations", "vana", "vanguard", "vc", "ve", "vegas", "ventures", "verisign", "versicherung", "vet", "vg", "vi", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "vistaprint", "viva", "vivo", "vlaanderen", "vn", "vodka", "volkswagen", "volvo", "vote", "voting", "voto", "voyage", "vu", "vuelos", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "wf", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "ws", "wtc", "wtf", "xbox", "xerox", "xfinity", "xihuan", "xin", "", // xn--11b4c3d
  "", // xn--1ck2e1b
  "", // xn--1qqw23a
  "", // xn--2scrj9c
  "", // xn--30rr7y
  "", // xn--3bst00m
  "", // xn--3ds443g
  "", // xn--3e0b707e
  "", // xn--3hcrj9c
  "", // xn--3oq18vl8pn36a
  "", // xn--3pxu8k
  "", // xn--42c2d9a
  "", // xn--45br5cyl
  "", // xn--45brj9c
  "", // xn--45q11c
  "", // xn--4gbrim
  "", // xn--54b7fta0cc
  "", // xn--55qw42g
  "", // xn--55qx5d
  "", // xn--5su34j936bgsg
  "", // xn--5tzm5g
  "", // xn--6frz82g
  "", // xn--6qq986b3xl
  "", // xn--80adxhks
  "", // xn--80ao21a
  "", // xn--80aqecdr1a
  "", // xn--80asehdb
  "", // xn--80aswg
  "", // xn--8y0a063a
  "", // xn--90a3ac
  "", // xn--90ae
  "", // xn--90ais
  "", // xn--9dbq2a
  "", // xn--9et52u
  "", // xn--9krt00a
  "", // xn--b4w605ferd
  "", // xn--bck1b9a5dre4c
  "", // xn--c1avg
  "", // xn--c2br7g
  "", // xn--cck2b3b
  "", // xn--cg4bki
  "", // xn--clchc0ea0b2g2a9gcd
  "", // xn--czr694b
  "", // xn--czrs0t
  "", // xn--czru2d
  "", // xn--d1acj3b
  "", // xn--d1alf
  "", // xn--e1a4c
  "", // xn--eckvdtc9d
  "", // xn--efvy88h
  "", // xn--estv75g
  "", // xn--fct429k
  "", // xn--fhbei
  "", // xn--fiq228c5hs
  "", // xn--fiq64b
  "", // xn--fiqs8s
  "", // xn--fiqz9s
  "", // xn--fjq720a
  "", // xn--flw351e
  "", // xn--fpcrj9c3d
  "", // xn--fzc2c9e2c
  "", // xn--fzys8d69uvgm
  "", // xn--g2xx48c
  "", // xn--gckr3f0f
  "", // xn--gecrj9c
  "", // xn--gk3at1e
  "", // xn--h2breg3eve
  "", // xn--h2brj9c
  "", // xn--h2brj9c8c
  "", // xn--hxt814e
  "", // xn--i1b6b1a6a2e
  "", // xn--imr513n
  "", // xn--io0a7i
  "", // xn--j1aef
  "", // xn--j1amh
  "", // xn--j6w193g
  "", // xn--jlq61u9w7b
  "", // xn--jvr189m
  "", // xn--kcrx77d1x4a
  "", // xn--kprw13d
  "", // xn--kpry57d
  "", // xn--kpu716f
  "", // xn--kput3i
  "", // xn--l1acc
  "", // xn--lgbbat1ad8j
  "", // xn--mgb9awbf
  "", // xn--mgba3a3ejt
  "", // xn--mgba3a4f16a
  "", // xn--mgba7c0bbn0a
  "", // xn--mgbaakc7dvf
  "", // xn--mgbaam7a8h
  "", // xn--mgbab2bd
  "", // xn--mgbah1a3hjkrd
  "", // xn--mgbai9azgqp6j
  "", // xn--mgbayh7gpa
  "", // xn--mgbbh1a
  "", // xn--mgbbh1a71e
  "", // xn--mgbc0a9azcg
  "", // xn--mgbca7dzdo
  "", // xn--mgberp4a5d4ar
  "", // xn--mgbgu82a
  "", // xn--mgbi4ecexp
  "", // xn--mgbpl2fh
  "", // xn--mgbt3dhd
  "", // xn--mgbtx2b
  "", // xn--mgbx4cd0ab
  "", // xn--mix891f
  "", // xn--mk1bu44c
  "", // xn--mxtq1m
  "", // xn--ngbc5azd
  "", // xn--ngbe9e0a
  "", // xn--ngbrx
  "", // xn--node
  "", // xn--nqv7f
  "", // xn--nqv7fs00ema
  "", // xn--nyqy26a
  "", // xn--o3cw4h
  "", // xn--ogbpf8fl
  "", // xn--otu796d
  "", // xn--p1acf
  "", // xn--p1ai
  "", // xn--pbt977c
  "", // xn--pgbs0dh
  "", // xn--pssy2u
  "", // xn--q9jyb4c
  "", // xn--qcka1pmc
  "", // xn--qxa6a
  "", // xn--qxam
  "", // xn--rhqv96g
  "", // xn--rovu88b
  "", // xn--rvc1e0am3e
  "", // xn--s9brj9c
  "", // xn--ses554g
  "", // xn--t60b56a
  "", // xn--tckwe
  "", // xn--tiq49xqyj
  "", // xn--unup4y
  "vermgensberater", // xn--vermgensberater-ctb
  "vermgensberatung", // xn--vermgensberatung-pwb
  "", // xn--vhquv
  "", // xn--vuq861b
  "", // xn--w4r85el8fhu5dnra
  "", // xn--w4rs40l
  "", // xn--wgbh1c
  "", // xn--wgbl6a
  "", // xn--xhq521b
  "", // xn--xkc2al3hye2a
  "", // xn--xkc2dl3a5ee0h
  "", // xn--y9a3aq
  "", // xn--yfro4i67o
  "", // xn--ygbi2ammx
  "", // xn--zfr164b
  "xxx", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "ye", "yodobashi", "yoga", "yokohama", "you", "youtube", "yt", "yun", "za", "zappos", "zara", "zero", "zip", "zm", "zone", "zuerich", "zw"];

  var urlRegex = options => {
    options = {
      strict: true,
      ...options
    };
    const protocol = `(?:(?:[a-z]+:)?//)${options.strict ? '' : '?'}`;
    const auth = '(?:\\S+(?::\\S*)?@)?';
    const ip = ipRegex.v4().source;
    const host = '(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)';
    const domain = '(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*';
    const tld = `(?:\\.${options.strict ? '(?:[a-z\\u00a1-\\uffff]{2,})' : `(?:${tlds.sort((a, b) => b.length - a.length).join('|')})`})\\.?`;
    const port = '(?::\\d{2,5})?';
    const path = '(?:[/?#][^\\s"]*)?';
    const regex = `(?:${protocol}|www\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;
    return options.exact ? new RegExp(`(?:^${regex}$)`, 'i') : new RegExp(regex, 'ig');
  };

  function validateValue$1(str, originalOpts, errorArr) {
    var defaults = {
      offset: 0,
      multipleOK: false,
      from: 0,
      to: str.length,
      attribStart: 0,
      attribEnd: str.length
    };
    var opts = Object.assign({}, defaults, originalOpts);
    var extractedValue = str.slice(opts.from, opts.to);
    var calcultedIsRel = isRel(extractedValue);

    if (Array.from(extractedValue).some(function (val) {
      return !val.trim().length;
    })) {
      // try to find out, is it whitespace within one URL, or is it whitespace
      // separating two URL's:
      var ranges = []; // whitespace ranges

      var foundCharacterRanges = [];
      splitByWhitespace(extractedValue, function (valueRangeArr) {
        foundCharacterRanges.push(valueRangeArr);
      }, function (whitespaceRangeArr) {
        ranges.push(whitespaceRangeArr);
      }, originalOpts);
      var countOfURIs = foundCharacterRanges.reduce(function (acc, curr) {
        if (extractedValue.slice(curr[0] - opts.offset, curr[1] - opts.offset).match(urlRegex({
          exact: true
        }))) {
          return acc + 1;
        }

        return acc;
      }, 0); // assemble the value without whitespace

      var valueWithoutWhitespace = foundCharacterRanges.reduce(function (acc, curr) {
        return acc + extractedValue.slice(curr[0] - opts.offset, curr[1] - opts.offset);
      }, "");

      if (countOfURIs > 1) {
        errorArr.push({
          idxFrom: opts.from + opts.offset,
          idxTo: opts.to + opts.offset,
          message: "There should be only one URI.",
          fix: null
        });
      } else {
        errorArr.push({
          idxFrom: opts.from + opts.offset,
          idxTo: opts.to + opts.offset,
          message: "Remove whitespace.",
          fix: {
            ranges: ranges
          }
        });
      }
    } else if (!extractedValue.startsWith("tel:") && !(urlRegex({
      exact: true
    }).test(extractedValue) || calcultedIsRel.res)) {
      // message:
      // Should be ${opts.separator}-separated list of URI's.
      // applies onto when multiple values are allowed and whole attribute is
      // reported as wrong (not one of chunks):
      var message = "Should be an URI.";
      var idxFrom = opts.offset + opts.from;
      var idxTo = opts.offset + opts.to;
      var whatCouldBeExtractedAtAllFromRegex = extractedValue.match(urlRegex()); // if URL's were extracted

      if (Array.isArray(whatCouldBeExtractedAtAllFromRegex)) {
        // something was indeed extracted
        if (whatCouldBeExtractedAtAllFromRegex.length > 1 && !opts.multipleOK) {
          message = "There should be only one URI.";
        } else {
          message = "URI's should be separated with a single space.";
        }

        idxFrom = opts.offset + opts.attribStart;
        idxTo = opts.offset + opts.attribEnd;
      }

      errorArr.push({
        idxFrom: idxFrom,
        idxTo: idxTo,
        message: message,
        fix: null
      });
    }
  }

  function validateUri(str, originalOpts) {
    var defaults = {
      offset: 0,
      multipleOK: false,
      separator: "space",
      // or "comma"
      oneSpaceAfterCommaOK: false,
      leadingWhitespaceOK: false,
      trailingWhitespaceOK: false
    };
    var opts = Object.assign({}, defaults, originalOpts); // checkForWhitespace() reports index range between the
    // first last non-whitespace character; nulls otherwise

    var _checkForWhitespace = checkForWhitespace(str, opts.offset),
        charStart = _checkForWhitespace.charStart,
        charEnd = _checkForWhitespace.charEnd,
        errorArr = _checkForWhitespace.errorArr; // now that we know where non-whitespace chars are, we can evaluate them


    if (Number.isInteger(charStart)) {
      if (opts.multipleOK) {
        // depends, is it comma or space-separated format
        if (opts.separator === "space") {
          splitByWhitespace(str, function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                charFrom = _ref2[0],
                charTo = _ref2[1];

            var extractedName = str.slice(charFrom, charTo); // maybe it's comma-and-space-separated, like
            // <object archive="https://codsen.com, https://detergent.io">

            if (extractedName.endsWith(",") && extractedName.length > 1) {
              errorArr.push({
                idxFrom: opts.offset + charTo - 1,
                idxTo: opts.offset + charTo,
                message: "No commas.",
                fix: null
              });
            } else {
              // Object assign needed to retain opts.multipleOK
              validateValue$1(str, Object.assign({}, opts, {
                from: charFrom,
                to: charTo,
                attribStart: charStart,
                attribEnd: charEnd,
                offset: opts.offset
              }), errorArr);
            }
          }, function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                whitespaceFrom = _ref4[0],
                whitespaceTo = _ref4[1];

            return isSingleSpace(str, {
              from: whitespaceFrom,
              to: whitespaceTo,
              offset: opts.offset
            }, errorArr);
          }, {
            from: charStart,
            to: charEnd
          });
        } else {
          processCommaSeparated(str, {
            offset: opts.offset,
            oneSpaceAfterCommaOK: false,
            leadingWhitespaceOK: true,
            trailingWhitespaceOK: true,
            cb: function cb(idxFrom, idxTo) {
              var extractedValue = str.slice(idxFrom - opts.offset, idxTo - opts.offset); // if there are errors, validateValue() mutates the passed "errorArr",
              // pushing to it
              // Object assign needed to retain opts.multipleOK

              validateValue$1(str, Object.assign({}, opts, {
                from: idxFrom - opts.offset,
                to: idxTo - opts.offset,
                attribStart: charStart,
                attribEnd: charEnd,
                offset: opts.offset
              }), errorArr);
            },
            errCb: function errCb(ranges, message) {
              var fix = {
                ranges: ranges
              }; // Some bad whitespace errors like spaces in the middle or URL
              // can't be fixed. We need to cater those cases.

              if (!str[ranges[0][0] - opts.offset].trim().length && str[ranges[0][0] - opts.offset - 1] && charStart < ranges[0][0] - 1 && (opts.separator === "space" || str[ranges[0][0] - opts.offset - 1] !== "," && str[ranges[0][1] - opts.offset] !== ",")) {
                // if it's not outer whitespace, skip the fix
                fix = null;
              }

              errorArr.push({
                idxFrom: ranges[0][0],
                idxTo: ranges[ranges.length - 1][1],
                message: message,
                fix: fix
              });
            }
          });
        }
      } else {
        // we pass whole value to validateValue(), "cropping" the whitespace:
        validateValue$1(str, {
          from: charStart,
          to: charEnd,
          offset: opts.offset
        }, errorArr);
      }
    }

    return errorArr;
  }

  // rule: attribute-validate-action

  function attributeValidateAction(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "action") {
          // validate the parent
          if (node.parent.tagName !== "form") {
            context.report({
              ruleId: "attribute-validate-action",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // Call validation upon whole attribute's value. Validator includes
            // whitespace checks.
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-action"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-align

  function attributeValidateAlign(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "align") {
          // validate the parent
          if (!["applet", "caption", "iframe", "img", "input", "object", "legend", "table", "hr", "div", "h1", "h2", "h3", "h4", "h5", "h6", "p", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-align",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = [];

          if (["legend", "caption"].includes(node.parent.tagName.toLowerCase())) {
            // top|bottom|left|right
            errorArr = validateString(node.attribValue, // value
            node.attribValueStartsAt, // offset
            {
              permittedValues: ["top", "bottom", "left", "right"],
              canBeCommaSeparated: false
            });
          } else if (["applet", "iframe", "img", "input", "object"].includes(node.parent.tagName.toLowerCase())) {
            // top|middle|bottom|left|right
            errorArr = validateString(node.attribValue, // value
            node.attribValueStartsAt, // offset
            {
              permittedValues: ["top", "middle", "bottom", "left", "right"],
              canBeCommaSeparated: false
            });
          } else if (["table", "hr"].includes(node.parent.tagName.toLowerCase())) {
            // left|center|right
            errorArr = validateString(node.attribValue, // value
            node.attribValueStartsAt, // offset
            {
              permittedValues: ["left", "center", "right"],
              canBeCommaSeparated: false
            });
          } else if (["div", "h1", "h2", "h3", "h4", "h5", "h6", "p"].includes(node.parent.tagName.toLowerCase())) {
            // left|center|right|justify
            errorArr = validateString(node.attribValue, // value
            node.attribValueStartsAt, // offset
            {
              permittedValues: ["left", "center", "right", "justify"],
              canBeCommaSeparated: false
            });
          } else if (["col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName.toLowerCase())) {
            // left|center|right|justify|char
            errorArr = validateString(node.attribValue, // value
            node.attribValueStartsAt, // offset
            {
              permittedValues: ["left", "center", "right", "justify", "char"],
              canBeCommaSeparated: false
            });
          }

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-align"
            }));
          });
        }
      }
    };
  }

  function validateColor(str, idxOffset, opts) {
    // we'll allow granular filtering of all color types
    // opts:
    // {
    //    namedCssLevel1OK: true,
    //    namedCssLevel2PlusOK: true,
    //    hexSixOK: true
    // }
    // we get trimmed string start and end positions, also an encountered errors array
    var _checkForWhitespace = checkForWhitespace(str, idxOffset),
        charStart = _checkForWhitespace.charStart,
        charEnd = _checkForWhitespace.charEnd,
        errorArr = _checkForWhitespace.errorArr; // now that we know where non-whitespace chars are, evaluate them


    if (Number.isInteger(charStart)) {
      // we need to extract the trimmed attribute's value
      // either it will be "str" (no inner whitespace) or
      // str.slice(charStart, charEnd) (whitespace found previously)
      var attrVal = errorArr.length ? str.slice(charStart, charEnd) : str;

      if (attrVal.length > 1 && isLetter(attrVal[0]) && isLetter(attrVal[1]) && Object.keys(extendedColorNames).includes(attrVal.toLowerCase())) {
        if (!opts.namedCssLevel1OK) {
          errorArr.push({
            idxFrom: idxOffset + charStart,
            idxTo: idxOffset + charEnd,
            message: "Named colors (CSS Level 1) not allowed.",
            fix: {
              ranges: [[idxOffset + charStart, idxOffset + charEnd, extendedColorNames[attrVal.toLowerCase()]]]
            }
          });
        } else if (!opts.namedCssLevel2PlusOK && (!opts.namedCssLevel1OK || !Object.keys(basicColorNames).includes(attrVal.toLowerCase()))) {
          errorArr.push({
            idxFrom: idxOffset + charStart,
            idxTo: idxOffset + charEnd,
            message: "Named colors (CSS Level 2+) not allowed.",
            fix: {
              ranges: [[idxOffset + charStart, idxOffset + charEnd, extendedColorNames[attrVal.toLowerCase()]]]
            }
          });
        }
      } else if (attrVal.startsWith("#")) {
        if (attrVal.length !== 7) {
          errorArr.push({
            idxFrom: idxOffset + charStart,
            idxTo: idxOffset + charEnd,
            message: "Hex color code should be 6 digits-long.",
            fix: null
          });
        } else if (!sixDigitHexColorRegex.test(attrVal)) {
          errorArr.push({
            idxFrom: idxOffset + charStart,
            idxTo: idxOffset + charEnd,
            message: "Unrecognised hex code.",
            fix: null
          });
        } else if (!opts.hexSixOK) {
          errorArr.push({
            idxFrom: idxOffset + charStart,
            idxTo: idxOffset + charEnd,
            message: "Hex colors not allowed.",
            fix: null
          });
        }
      } else if (attrVal.startsWith("rgb(")) {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: "rgb() is not allowed.",
          fix: null
        });
      } else {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: "Unrecognised color value.",
          fix: null
        });
      }
    }

    return errorArr;
  }

  // rule: attribute-validate-alink

  function attributeValidateAlink(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateAlink(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "alink") {
          // validate the parent
          if (node.parent.tagName !== "body") {
            context.report({
              ruleId: "attribute-validate-alink",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateColor(node.attribValue, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-alink"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-alt

  function attributeValidateAlt(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "alt") {
          // validate the parent
          if (!["applet", "area", "img", "input"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-alt",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-alt"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-archive

  function attributeValidateArchive(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "archive") {
          // validate the parent
          if (!["applet", "object"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-archive",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // it depends, which tag is this attribute on...
            if (node.parent.tagName === "applet") {
              // comma-separated list of archive URIs
              // Call validation upon the whole attribute's value. Validator includes
              // whitespace checks.
              validateUri(node.attribValue, {
                offset: node.attribValueStartsAt,
                separator: "comma",
                multipleOK: true
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-archive"
                }));
              });
            } else if (node.parent.tagName === "object") {
              // space-separated list of URIs
              // Call validation upon the whole attribute's value. Validator includes
              // whitespace checks.
              validateUri(node.attribValue, {
                offset: node.attribValueStartsAt,
                separator: "space",
                // or "comma"
                multipleOK: true
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-archive"
                }));
              });
            }
          }
        }
      }
    };
  }

  // rule: attribute-validate-axis

  function attributeValidateAxis(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "axis") {
          // validate the parent
          if (!["td", "th"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-axis",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-axis"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-background

  function attributeValidateBackground(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "background") {
          // validate the parent
          if (!["body", "td"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-background",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // Call validation upon the whole attribute's value. Validator includes
            // whitespace checks.
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-background"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-bgcolor

  function attributeValidateBgcolor(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateBgcolor(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "bgcolor") {
          // validate the parent
          if (!["table", "tr", "td", "th", "body"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-bgcolor",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateColor(node.attribValue, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-bgcolor"
            }));
          });
        }
      }
    };
  }

  function validateValue$2(_ref) {
    var str = _ref.str,
        opts = _ref.opts,
        charStart = _ref.charStart,
        charEnd = _ref.charEnd,
        idxOffset = _ref.idxOffset,
        errorArr = _ref.errorArr;

    // the rule is for pattern digit(s) + unit, so start from checking, does it
    // start with a digit
    // insurance
    if (typeof str !== "string") {
      return;
    } // applies to rational and integer types


    if (str[charStart] === "0") {
      if (charEnd === charStart + 1) {
        // so length === 1
        if (!opts.zeroOK) {
          errorArr.push({
            idxFrom: idxOffset + charStart,
            idxTo: idxOffset + charEnd,
            message: "Zero not allowed.",
            fix: null
          });
        }
      } else {
        // so length !== 1
        if ("0123456789".includes(str[charStart + 1])) {
          // we have padded cases like 08
          errorArr.push({
            idxFrom: idxOffset + charStart,
            idxTo: idxOffset + charEnd,
            message: "Number padded with zero.",
            fix: null
          });
        }
      }
    }

    if (!"0123456789".includes(str[charStart]) && !"0123456789".includes(str[charEnd - 1])) {
      // calculate the message
      var message = "Digits missing.";

      if (opts.customGenericValueError) {
        message = opts.customGenericValueError;
      } else if (Array.isArray(opts.theOnlyGoodUnits) && !opts.theOnlyGoodUnits.length && opts.type === "integer") {
        message = "Should be integer, no units.";
      }

      errorArr.push({
        idxFrom: idxOffset + charStart,
        idxTo: idxOffset + charEnd,
        message: message,
        fix: null
      });
    } else if ("0123456789".includes(str[charStart]) && "0123456789".includes(str[charEnd - 1]) && (!opts.noUnitsIsFine || opts.type === "integer" && opts.maxValue && str.slice(charStart, charEnd).match(/^\d+$/) && Number.parseInt(str.slice(charStart, charEnd), 10) > opts.maxValue)) {
      if (!opts.noUnitsIsFine) {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: opts.customGenericValueError || "Units missing.",
          fix: null
        });
      } else {
        errorArr.push({
          idxFrom: idxOffset + charStart,
          idxTo: idxOffset + charEnd,
          message: "Maximum, ".concat(opts.maxValue, " exceeded."),
          fix: null
        });
      }
    } else {
      for (var i = charStart; i < charEnd; i++) {
        if (!"0123456789".includes(str[i]) && (str[i] !== "." || opts.type !== "rational") && (str[i] !== "-" || !(opts.negativeOK && i === 0)) && (str[i] !== "+" || !(opts.plusOK && i === 0))) {
          // dash can be in the middle! For example, colspan="1-1"
          var endPart = str.slice(i, charEnd);

          if (isObj(opts) && (Array.isArray(opts.theOnlyGoodUnits) && !opts.theOnlyGoodUnits.includes(endPart) || Array.isArray(opts.badUnits) && opts.badUnits.includes(endPart))) {
            // special case for "px"
            if (endPart === "px") {
              var _message = opts.customPxMessage ? opts.customPxMessage : "Remove px.";

              errorArr.push({
                idxFrom: idxOffset + i,
                idxTo: idxOffset + charEnd,
                message: _message,
                fix: opts.customPxMessage ? null : {
                  ranges: [[idxOffset + i, idxOffset + charEnd]]
                }
              });
            } else {
              // validate against the known units and serve a separate
              // message, depending on was it recognised
              // calculate the message
              var _message2 = "Bad unit.";

              if (str.match(/-\s*-/g)) {
                _message2 = "Repeated minus.";
              } else if (str.match(/\+\s*\+/g)) {
                _message2 = "Repeated plus.";
              } else if (Array.isArray(opts.theOnlyGoodUnits) && opts.theOnlyGoodUnits.length && opts.theOnlyGoodUnits.includes(endPart.trim())) {
                // if trimmed end part matches "good" units, it's the whitespace
                _message2 = "Rogue whitespace.";
              } else if (opts.customGenericValueError) {
                _message2 = opts.customGenericValueError;
              } else if (Array.isArray(opts.theOnlyGoodUnits) && !opts.theOnlyGoodUnits.length && opts.type === "integer") {
                _message2 = "Should be integer, no units.";
              }

              errorArr.push({
                idxFrom: idxOffset + i,
                idxTo: idxOffset + charEnd,
                message: _message2,
                fix: null
              });
            }
          } else if (!knownUnits.includes(endPart)) {
            var _message3 = "Unrecognised unit.";

            if (/\d/.test(endPart)) {
              _message3 = "Messy value.";
            } else if (knownUnits.includes(endPart.trim())) {
              _message3 = "Rogue whitespace.";
            }

            errorArr.push({
              idxFrom: idxOffset + i,
              idxTo: idxOffset + charEnd,
              message: _message3,
              fix: null
            });
          } // stop the loop


          break;
        }
      }
    }
  } // function below is used to validate attribute values which contain
  // digits and a unit, for example, "100%" of an HTML attribute
  // width="100%"
  // or
  // "100%" of CSS head style "width:100%;"
  // it returns array of ready error objects, except without ruleId, something like:
  //
  // {
  //   idxFrom: 17,
  //   idxTo: 19,
  //   message: `Remove px.`,
  //   fix: {
  //     ranges: [[17, 19]]
  //   }
  // }
  //
  // if it can't fix, key "fix" value is null


  function validateDigitAndUnit(str, idxOffset, originalOpts) {
    if (typeof str !== "string") {
      return [];
    }

    var defaultOpts = {
      type: "integer",
      whitelistValues: [],
      theOnlyGoodUnits: null,
      plusOK: false,
      negativeOK: false,
      zeroOK: true,
      badUnits: [],
      enforceCount: null,
      noUnitsIsFine: true,
      canBeCommaSeparated: false,
      customGenericValueError: null,
      skipWhitespaceChecks: false,
      customPxMessage: null,
      maxValue: null
    };
    var opts = Object.assign({}, defaultOpts, originalOpts); // we get trimmed string start and end positions, also an encountered errors array

    var charStart = 0;
    var charEnd = str.length;
    var errorArr = [];

    if (!opts.skipWhitespaceChecks) {
      var retrievedWhitespaceChecksObj = checkForWhitespace(str, idxOffset);
      charStart = retrievedWhitespaceChecksObj.charStart;
      charEnd = retrievedWhitespaceChecksObj.charEnd;
      errorArr = retrievedWhitespaceChecksObj.errorArr;
    } // now that we know where non-whitespace chars are, evaluate them


    if (Number.isInteger(charStart)) {
      if (opts.canBeCommaSeparated) {
        // split by comma and process each
        var extractedValues = [];
        processCommaSeparated(str, {
          offset: idxOffset,
          oneSpaceAfterCommaOK: false,
          leadingWhitespaceOK: true,
          trailingWhitespaceOK: true,
          cb: function cb(idxFrom, idxTo) {
            var extractedValue = str.slice(idxFrom - idxOffset, idxTo - idxOffset); // if the value is not whitelisted, evaluate it

            if (!Array.isArray(opts.whitelistValues) || !opts.whitelistValues.includes(extractedValue)) {
              validateValue$2({
                str: str,
                opts: opts,
                charStart: idxFrom - idxOffset,
                charEnd: idxTo - idxOffset,
                idxOffset: idxOffset,
                errorArr: errorArr
              });
            }

            extractedValues.push(extractedValue);
          },
          errCb: function errCb(ranges, message) {
            errorArr.push({
              idxFrom: ranges[0][0],
              idxTo: ranges[ranges.length - 1][1],
              message: message,
              fix: {
                ranges: ranges
              }
            });
          }
        }); // enforce the "extractedValues" count

        if (Number.isInteger(opts.enforceCount) && extractedValues.length !== opts.enforceCount) {
          errorArr.push({
            idxFrom: charStart + idxOffset,
            idxTo: charEnd + idxOffset,
            message: "There should be ".concat(opts.enforceCount, " values."),
            fix: null
          });
        } else if (typeof opts.enforceCount === "string" && ["even", "odd", "uneven", "noneven"].includes(opts.enforceCount.toLowerCase())) {
          if (opts.enforceCount.toLowerCase() === "even" && extractedValues.length % 2 !== 0) {
            errorArr.push({
              idxFrom: charStart + idxOffset,
              idxTo: charEnd + idxOffset,
              message: "Should be an even number of values but found ".concat(extractedValues.length, "."),
              fix: null
            });
          } else if (opts.enforceCount.toLowerCase() !== "even" && extractedValues.length % 2 === 0) {
            errorArr.push({
              idxFrom: charStart + idxOffset,
              idxTo: charEnd + idxOffset,
              message: "Should be an odd number of values but found ".concat(extractedValues.length, "."),
              fix: null
            });
          }
        }
      } else {
        // if the value is not whitelisted, evaluate it
        if (!Array.isArray(opts.whitelistValues) || !opts.whitelistValues.includes(str.slice(charStart, charEnd))) {
          validateValue$2({
            str: str,
            opts: opts,
            charStart: charStart,
            charEnd: charEnd,
            idxOffset: idxOffset,
            errorArr: errorArr
          });
        }
      }
    }

    return errorArr;
  }

  // rule: attribute-validate-border

  function attributeValidateBorder(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateBorder(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "border") {
          // validate the parent
          if (!["table", "img", "object"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-border",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            negativeOK: false,
            theOnlyGoodUnits: [] // empty array means no units allowed

          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-border"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-cellspacing

  function attributeValidateCellpadding(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateCellpadding(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "cellpadding") {
          // validate the parent
          if (node.parent.tagName !== "table") {
            context.report({
              ruleId: "attribute-validate-cellpadding",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            negativeOK: false,
            theOnlyGoodUnits: ["%"],
            badUnits: ["px"],
            customGenericValueError: "Should be integer, either no units or percentage."
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-cellpadding"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-cellspacing

  function attributeValidateCellspacing(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateCellspacing(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "cellspacing") {
          // validate the parent
          if (node.parent.tagName !== "table") {
            context.report({
              ruleId: "attribute-validate-cellspacing",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            negativeOK: false,
            theOnlyGoodUnits: ["%"],
            badUnits: ["px"],
            customGenericValueError: "Should be integer, either no units or percentage."
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-cellspacing"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-char

  function attributeValidateChar(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "char") {
          // validate the parent
          if (!["col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-char",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr,
              trimmedVal = _checkForWhitespace.trimmedVal;

          if (Number.isInteger(charStart)) {
            // the value must be a character, raw or escaped, from ISO10646
            // https://www.w3.org/TR/html4/sgml/dtd.html#Character
            if (trimmedVal.length > 1 && !(trimmedVal.startsWith("&") && trimmedVal.endsWith(";"))) {
              errorArr.push({
                idxFrom: node.attribValueStartsAt + charStart,
                idxTo: node.attribValueStartsAt + charEnd,
                message: "Should be a single character.",
                fix: null
              });
            }
          }

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-char"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-charoff

  function attributeValidateCharoff(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "charoff") {
          // validate the parent
          if (!["col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-charoff",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            negativeOK: true,
            theOnlyGoodUnits: [],
            customGenericValueError: "Should be integer, no units."
          }); // tag has to have "char" attribute:

          if (!node.parent.attribs.some(function (attribObj) {
            return attribObj.attribName === "char";
          })) {
            errorArr.push({
              idxFrom: node.parent.start,
              idxTo: node.parent.end,
              message: "Attribute \"char\" missing.",
              fix: null
            });
          }

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-charoff"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-charset

  function attributeValidateCharset(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "charset") {
          // validate the parent
          if (!["a", "link", "script"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-charset",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // validate against the charsets list from IANA:
          // https://www.iana.org/assignments/character-sets/character-sets.xhtml
          // https://www.w3.org/TR/html4/interact/forms.html#adef-charset


          var errorArr = validateString(node.attribValue, node.attribValueStartsAt, {
            canBeCommaSeparated: false,
            noSpaceAfterComma: false,
            quickPermittedValues: [],
            permittedValues: knownCharsets
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-charset"
            }));
          });
        }
      }
    };
  }

  function validateVoid(node, context, errorArr, originalOpts) {
    var defaults = {
      xhtml: false,
      enforceSiblingAttributes: null
    };
    var opts = Object.assign({}, defaults, originalOpts); //
    // further validation only applicable to input tags:
    //

    if (opts.xhtml) {
      // XHTML mode - enforcing node.attribName="node.attribName"
      var quotesType = "\"";

      if (node.attribOpeningQuoteAt !== null && context.str[node.attribOpeningQuoteAt] === "'") {
        quotesType = "'";
      } else if (node.attribClosingQuoteAt !== null && context.str[node.attribClosingQuoteAt] === "'") {
        quotesType = "'";
      } // equal might be missing or there might be some rogue whitespace,
      // for example - only value check is not enough


      if (node.attribValue !== node.attribName || context.str.slice(node.attribNameEndsAt, node.attribEnd) !== "=".concat(quotesType).concat(node.attribName).concat(quotesType)) {
        errorArr.push({
          idxFrom: node.attribNameStartsAt,
          idxTo: node.attribNameEndsAt,
          message: "It's XHTML, add value, =\"".concat(node.attribName, "\"."),
          fix: {
            ranges: [[node.attribNameEndsAt, node.attribEnd, "=".concat(quotesType).concat(node.attribName).concat(quotesType)]]
          }
        });
      }
    } else if (node.attribValue !== null) {
      errorArr.push({
        idxFrom: node.attribNameEndsAt,
        idxTo: node.attribEnd,
        message: "Should have no value.",
        fix: {
          ranges: [[node.attribNameEndsAt, node.attribEnd]]
        }
      });
    }

    if (isObj(opts.enforceSiblingAttributes) && Object.keys(opts.enforceSiblingAttributes).length) {
      Object.keys(opts.enforceSiblingAttributes).forEach(function (siblingAttr) {
        if (Array.isArray(node.parent.attribs) && !node.parent.attribs.some(function (attribObj) {
          return attribObj.attribName === siblingAttr;
        })) {
          // parent tag is missing the requested attribute
          errorArr.push({
            idxFrom: node.parent.start,
            idxTo: node.parent.end,
            message: "Should have attribute \"".concat(siblingAttr, "\"."),
            fix: null
          });
        } else if (opts.enforceSiblingAttributes[siblingAttr] && Array.isArray(opts.enforceSiblingAttributes[siblingAttr]) && Array.isArray(node.parent.attribs) && !node.parent.attribs.some(function (attribObj) {
          return attribObj.attribName === siblingAttr && opts.enforceSiblingAttributes[siblingAttr].includes(attribObj.attribValue);
        })) {
          // enforce that, for example, "node.attribName"
          // should be present only on input tags of types
          // "checkbox" or "radio"
          // find out where that "type" attribute is located
          var idxFrom;
          var idxTo;

          for (var i = 0, len = node.parent.attribs.length; i < len; i++) {
            if (node.parent.attribs[i].attribName === siblingAttr) {
              idxFrom = node.parent.attribs[i].attribValueStartsAt;
              idxTo = node.parent.attribs[i].attribValueEndsAt;
              break;
            }
          }

          errorArr.push({
            idxFrom: idxFrom,
            idxTo: idxTo,
            message: "Only tags with ".concat(opts.enforceSiblingAttributes[siblingAttr].map(function (val) {
              return "\"".concat(val, "\"");
            }).join(" or "), " attributes can be ").concat(node.attribName, "."),
            fix: null
          });
        }
      });
    }

    return errorArr;
  }

  // rule: attribute-validate-checked

  function attributeValidateChecked(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "checked") {
          // validate the parent
          if (node.parent.tagName !== "input") {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: {
                type: ["checkbox", "radio"]
              }
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-checked"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-cite

  function attributeValidateCite(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "cite") {
          // validate the parent
          if (!["blockquote", "q", "del", "ins"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-cite",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // Call validation upon the whole attribute's value. Validator includes
            // whitespace checks.
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-cite"
              }));
            });
          }
        }
      }
    };
  }

  function checkClassOrIdValue(str, originalOpts, errorArr) {
    var defaults = {
      typeName: "class",
      from: 0,
      to: str.length,
      offset: 0
    };
    var opts = Object.assign({}, defaults, originalOpts);
    var listOfUniqueNames = new Set();
    splitByWhitespace( //
    //
    //
    //
    //
    //
    //
    str, //
    //
    //
    //
    //
    //
    //
    function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          charFrom = _ref2[0],
          charTo = _ref2[1];

      // value starts at "from" and ends at "to"
      // evaluate
      var extractedName = str.slice(charFrom, charTo);

      if (!classNameRegex.test(extractedName)) {
        errorArr.push({
          idxFrom: charFrom,
          idxTo: charTo,
          message: "Wrong ".concat(opts.typeName, " name."),
          fix: null
        });
      } // check for unique-ness


      if (!listOfUniqueNames.has(extractedName)) {
        listOfUniqueNames.add(extractedName);
      } else {
        var deleteFrom = charFrom;
        var deleteTo = charTo;
        var nonWhitespaceCharOnTheRight = right(str, deleteTo);

        if (deleteTo >= opts.to || !nonWhitespaceCharOnTheRight || nonWhitespaceCharOnTheRight > opts.to) {
          deleteFrom = left(str, charFrom) + 1; // +1 because left() stops
          // to the left of the character - if it was without, that first non-
          // whitespace character would have been included
        } else {
          deleteTo = nonWhitespaceCharOnTheRight;
        }

        errorArr.push({
          idxFrom: charFrom,
          idxTo: charTo,
          message: "Duplicate ".concat(opts.typeName, " \"").concat(extractedName, "\"."),
          fix: {
            ranges: [[deleteFrom, deleteTo]]
          }
        });
      }
    }, //
    //
    //
    //
    //
    //
    //
    function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          whitespaceFrom = _ref4[0],
          whitespaceTo = _ref4[1];

      return isSingleSpace(str, {
        from: whitespaceFrom,
        to: whitespaceTo,
        offset: opts.offset
      }, errorArr);
    }, //
    //
    //
    //
    //
    //
    //
    opts // whole opts object is being passed further
    );
  }

  // rule: attribute-validate-class

  function attributeValidateClass(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "class") {
          // validate the parent
          if (["base", "basefont", "head", "html", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-class",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
                charStart = _checkForWhitespace.charStart,
                charEnd = _checkForWhitespace.charEnd,
                errorArr = _checkForWhitespace.errorArr;

            checkClassOrIdValue(context.str, {
              typeName: node.attribName,
              // class|id|for
              from: node.attribValueStartsAt + charStart,
              to: node.attribValueStartsAt + charEnd,
              offset: 0
            }, errorArr // might be mutated, more errors pushed into
            );
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-class"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-classid

  function attributeValidateClassid(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "classid") {
          // validate the parent
          if (node.parent.tagName !== "object") {
            context.report({
              ruleId: "attribute-validate-classid",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // Call validation upon the whole attribute's value. Validator includes
            // whitespace checks.
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-classid"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-clear

  function attributeValidateClassid$1(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "clear") {
          // validate the parent
          if (node.parent.tagName !== "br") {
            context.report({
              ruleId: "attribute-validate-clear",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // beware, the charStart and charEnd are not offset, their "zero" is
          // start of an attribute's value, so if you use them, you need to
          // offset to the true index, you must add "node.attribValueStartsAt" value


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr;

          if (!["left", "all", "right", "none"].includes(context.str.slice(node.attribValueStartsAt + charStart, node.attribValueStartsAt + charEnd))) {
            errorArr.push({
              idxFrom: node.attribValueStartsAt + charStart,
              idxTo: node.attribValueStartsAt + charEnd,
              message: "Should be: left|all|right|none.",
              fix: null
            });
          }

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-clear"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-code

  function attributeValidateCode(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "code") {
          // validate the parent
          if (node.parent.tagName !== "applet") {
            context.report({
              ruleId: "attribute-validate-code",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only validate the whitespace


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-code"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-codebase

  function attributeValidateCodebase(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "codebase") {
          // validate the parent
          if (!["applet", "object"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-codebase",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-codebase"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-codetype

  function attributeValidateCodetype(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "codetype") {
          // validate the parent
          if (node.parent.tagName !== "object") {
            context.report({
              ruleId: "attribute-validate-codetype",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            quickPermittedValues: ["application/javascript", "application/json", "application/x-www-form-urlencoded", "application/xml", "application/zip", "application/pdf", "application/sql", "application/graphql", "application/ld+json", "application/msword", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.ms-excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.ms-powerpoint", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.oasis.opendocument.text", "application/zstd", "audio/mpeg", "audio/ogg", "multipart/form-data", "text/css", "text/html", "text/xml", "text/csv", "text/plain", "image/png", "image/jpeg", "image/gif", "application/vnd.api+json"],
            permittedValues: Object.keys(mimeDb),
            canBeCommaSeparated: false,
            noSpaceAfterComma: false
          }); // HTML attribute accept MIME types as values. Here we reference the given
          // value against all official MIME types, taken from IANA and other sources,
          // https://www.npmjs.com/package/mime-db

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-codetype"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-color

  function attributeValidateColor(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateColor(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "color") {
          // validate the parent
          if (!["basefont", "font"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-color",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateColor(node.attribValue, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-color"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-cols

  function attributeValidateCols(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateCols(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "cols") {
          // validate the parent
          if (!["frameset", "textarea"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-cols",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = [];

          if (node.parent.tagName === "frameset") {
            errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
              whitelistValues: ["*"],
              theOnlyGoodUnits: ["%"],
              badUnits: ["px"],
              noUnitsIsFine: true,
              canBeCommaSeparated: true,
              type: "rational",
              customGenericValueError: "Should be: pixels|%|*."
            });
          } else if (node.parent.tagName === "textarea") {
            // each character must be a digit
            errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
              type: "integer",
              theOnlyGoodUnits: [],
              customGenericValueError: "Should be integer, no units."
            });
          }

          if (Array.isArray(errorArr) && errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-cols"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-colspan

  function attributeValidateColspan(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateColspan(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "colspan") {
          // validate the parent
          if (!["th", "td"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-colspan",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            theOnlyGoodUnits: [],
            customGenericValueError: "Should be integer, no units."
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-colspan"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-compact

  function attributeValidateCompact(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "compact") {
          // validate the parent
          if (!["dir", "dl", "menu", "ol", "ul"].includes(node.parent.tagName)) {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-compact"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-content

  function attributeValidateContent(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "content") {
          // validate the parent
          if (node.parent.tagName !== "meta") {
            context.report({
              ruleId: "attribute-validate-content",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only validate the whitespace


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-content"
            }));
          });
        }
      }
    };
  } // TODO - add more checks from https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta

  // rule: attribute-validate-coords

  function attributeValidateCoords(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `020 attributeValidateCoords(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "coords") {
          // validate the parent
          if (!["area", "a"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-coords",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // "coords" values depend on "shape" attribute's value
            if (!Array.isArray(node.parent.attribs) || !node.parent.attribs.length || !node.parent.attribs.some(function (attrObj) {
              return attrObj.attribName === "shape";
            })) {
              // enforce "shape" attribute
              context.report({
                ruleId: "attribute-validate-coords",
                idxFrom: node.parent.start,
                idxTo: node.parent.end,
                message: "Missing \"shape\" attribute.",
                fix: null
              });
            } else {
              // extract "shape" attr's value
              var shapeAttr = node.parent.attribs.filter(function (attrObj) {
                return attrObj.attribName === "shape";
              })[0];
              var enforceCount = null;

              if (shapeAttr.attribValue === "rect") {
                // enforce the value count to be 4
                enforceCount = 4;
              } else if (shapeAttr.attribValue === "circle") {
                // enforce the value count to be 3
                enforceCount = 3;
              } else if (shapeAttr.attribValue === "poly") {
                // enforce the value count to be an even number
                enforceCount = "even";
              }

              var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
                whitelistValues: null,
                theOnlyGoodUnits: [],
                badUnits: null,
                noUnitsIsFine: true,
                canBeCommaSeparated: true,
                enforceCount: enforceCount,
                type: "integer",
                customGenericValueError: "Should be integer, no units."
              });

              if (Array.isArray(errorArr) && errorArr.length) {
                errorArr.forEach(function (errorObj) {
                  context.report(Object.assign({}, errorObj, {
                    ruleId: "attribute-validate-coords"
                  }));
                });
              }
            }
          }
        }
      }
    };
  }

  // rule: attribute-validate-data

  function attributeValidateData(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "data") {
          // validate the parent
          if (node.parent.tagName !== "object") {
            context.report({
              ruleId: "attribute-validate-data",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-data"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-datetime

  function attributeValidateDatetime(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "datetime") {
          // validate the parent
          if (!["del", "ins"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-datetime",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            quickPermittedValues: [isoDateRegex],
            permittedValues: null,
            canBeCommaSeparated: false,
            noSpaceAfterComma: false
          }); // HTML attribute accept MIME types as values. Here we reference the given
          // value against all official MIME types, taken from IANA and other sources,
          // https://www.npmjs.com/package/mime-db

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-datetime"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-declare

  function attributeValidateDeclare(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "declare") {
          // validate the parent
          if (node.parent.tagName !== "object") {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-declare"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-defer

  function attributeValidateDefer(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "defer") {
          // validate the parent
          if (node.parent.tagName !== "script") {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-defer"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-dir

  function attributeValidateDir(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "dir") {
          // validate the parent
          if (["applet", "base", "basefont", "br", "frame", "frameset", "iframe", "param", "script"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-dir",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["ltr", "rtl"],
            canBeCommaSeparated: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-dir"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-disabled

  function attributeValidateDisabled(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "disabled") {
          // validate the parent
          if (!["button", "input", "optgroup", "option", "select", "textarea"].includes(node.parent.tagName)) {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-disabled"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-enctype

  function attributeValidateEnctype(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "enctype") {
          // validate the parent
          if (node.parent.tagName !== "form") {
            context.report({
              ruleId: "attribute-validate-enctype",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            quickPermittedValues: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
            permittedValues: Object.keys(mimeDb),
            canBeCommaSeparated: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-enctype"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-face

  function attributeValidateFace(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "face") {
          // validate the parent
          if (node.parent.tagName !== "font") {
            context.report({
              ruleId: "attribute-validate-face",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only validate the whitespace


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-face"
            }));
          });
        }
      }
    };
  } // TODO - add more checks from https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta

  // rule: attribute-validate-for

  function attributeValidateFor(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "for") {
          // validate the parent
          if (node.parent.tagName !== "label") {
            context.report({
              ruleId: "attribute-validate-for",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
                charStart = _checkForWhitespace.charStart,
                charEnd = _checkForWhitespace.charEnd,
                errorArr = _checkForWhitespace.errorArr;

            var extractedValue = node.attribValue.slice(charStart, charEnd);
            var message = "Wrong id name.";
            var fix = null;
            var idxFrom = charStart + node.attribValueStartsAt;
            var idxTo = charEnd + node.attribValueStartsAt;

            if (Number.isInteger(charStart) && !classNameRegex.test(extractedValue)) {
              if (Array.from(extractedValue).some(function (val) {
                return !val.trim().length;
              })) {
                message = "Should be one value, no spaces.";
              } else if (extractedValue.includes("#")) {
                message = "Remove hash.";
                var firstHashAt = node.attribValue.indexOf("#");
                fix = {
                  ranges: [[node.attribValueStartsAt + firstHashAt, node.attribValueStartsAt + firstHashAt + 1]]
                };
                idxFrom = node.attribValueStartsAt + firstHashAt;
                idxTo = node.attribValueStartsAt + firstHashAt + 1;
              }

              errorArr.push({
                ruleId: "attribute-validate-for",
                idxFrom: idxFrom,
                idxTo: idxTo,
                message: message,
                fix: fix
              });
            }

            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-for"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-frame

  function attributeValidateFrame(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "frame") {
          // validate the parent
          if (node.parent.tagName !== "table") {
            context.report({
              ruleId: "attribute-validate-frame",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // https://www.w3.org/TR/html4/struct/tables.html#adef-frame


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["void", // No sides. This is the default value.
            "above", // The top side only.
            "below", // The bottom side only.
            "hsides", // The top and bottom sides only.
            "lhs", // The right and left sides only.
            "rhs", // The left-hand side only.
            "vsides", // The right-hand side only.
            "box", // All four sides.
            "border" // All four sides.
            ],
            canBeCommaSeparated: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-frame"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-frameborder

  function attributeValidateFrameborder(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "frameborder") {
          // validate the parent
          if (!["frame", "iframe"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-frameborder",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // https://www.w3.org/TR/html4/present/frames.html#adef-frameborder


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["0", "1"],
            canBeCommaSeparated: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-frameborder"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-headers

  function attributeValidateHeaders(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "headers") {
          // validate the parent
          if (!["td", "th"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-headers",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
                charStart = _checkForWhitespace.charStart,
                charEnd = _checkForWhitespace.charEnd,
                errorArr = _checkForWhitespace.errorArr;

            checkClassOrIdValue(context.str, {
              typeName: "id",
              // class|id|for
              from: node.attribValueStartsAt + charStart,
              to: node.attribValueStartsAt + charEnd,
              offset: 0
            }, errorArr // might be mutated, more errors pushed into
            );
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-headers"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-height

  function attributeValidateHeight(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "height") {
          // validate the parent
          if (!["iframe", "td", "th", "img", "object", "applet"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-height",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            badUnits: ["px"],
            theOnlyGoodUnits: ["%"],
            noUnitsIsFine: true,
            customGenericValueError: "Should be \"pixels|%\"."
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-height"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-href

  function attributeValidateHref(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "href") {
          // validate the parent
          if (!["a", "area", "link", "base"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-href",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-href"
              }));
            });
          }
        }
      }
    };
  }

  /**
   * is-language-code
   * Is given string a language code (as per IANA)
   * Version: 1.0.2
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/is-language-code
   */
  var language = ["aa", "aaa", "aab", "aac", "aad", "aae", "aaf", "aag", "aah", "aai", "aak", "aal", "aam", "aan", "aao", "aap", "aaq", "aas", "aat", "aau", "aav", "aaw", "aax", "aaz", "ab", "aba", "abb", "abc", "abd", "abe", "abf", "abg", "abh", "abi", "abj", "abl", "abm", "abn", "abo", "abp", "abq", "abr", "abs", "abt", "abu", "abv", "abw", "abx", "aby", "abz", "aca", "acb", "acd", "ace", "acf", "ach", "aci", "ack", "acl", "acm", "acn", "acp", "acq", "acr", "acs", "act", "acu", "acv", "acw", "acx", "acy", "acz", "ada", "adb", "add", "ade", "adf", "adg", "adh", "adi", "adj", "adl", "adn", "ado", "adp", "adq", "adr", "ads", "adt", "adu", "adw", "adx", "ady", "adz", "ae", "aea", "aeb", "aec", "aed", "aee", "aek", "ael", "aem", "aen", "aeq", "aer", "aes", "aeu", "aew", "aey", "aez", "af", "afa", "afb", "afd", "afe", "afg", "afh", "afi", "afk", "afn", "afo", "afp", "afs", "aft", "afu", "afz", "aga", "agb", "agc", "agd", "age", "agf", "agg", "agh", "agi", "agj", "agk", "agl", "agm", "agn", "ago", "agp", "agq", "agr", "ags", "agt", "agu", "agv", "agw", "agx", "agy", "agz", "aha", "ahb", "ahg", "ahh", "ahi", "ahk", "ahl", "ahm", "ahn", "aho", "ahp", "ahr", "ahs", "aht", "aia", "aib", "aic", "aid", "aie", "aif", "aig", "aih", "aii", "aij", "aik", "ail", "aim", "ain", "aio", "aip", "aiq", "air", "ais", "ait", "aiw", "aix", "aiy", "aja", "ajg", "aji", "ajn", "ajp", "ajt", "aju", "ajw", "ajz", "ak", "akb", "akc", "akd", "ake", "akf", "akg", "akh", "aki", "akj", "akk", "akl", "akm", "ako", "akp", "akq", "akr", "aks", "akt", "aku", "akv", "akw", "akx", "aky", "akz", "ala", "alc", "ald", "ale", "alf", "alg", "alh", "ali", "alj", "alk", "all", "alm", "aln", "alo", "alp", "alq", "alr", "als", "alt", "alu", "alv", "alw", "alx", "aly", "alz", "am", "ama", "amb", "amc", "ame", "amf", "amg", "ami", "amj", "amk", "aml", "amm", "amn", "amo", "amp", "amq", "amr", "ams", "amt", "amu", "amv", "amw", "amx", "amy", "amz", "an", "ana", "anb", "anc", "and", "ane", "anf", "ang", "anh", "ani", "anj", "ank", "anl", "anm", "ann", "ano", "anp", "anq", "anr", "ans", "ant", "anu", "anv", "anw", "anx", "any", "anz", "aoa", "aob", "aoc", "aod", "aoe", "aof", "aog", "aoh", "aoi", "aoj", "aok", "aol", "aom", "aon", "aor", "aos", "aot", "aou", "aox", "aoz", "apa", "apb", "apc", "apd", "ape", "apf", "apg", "aph", "api", "apj", "apk", "apl", "apm", "apn", "apo", "app", "apq", "apr", "aps", "apt", "apu", "apv", "apw", "apx", "apy", "apz", "aqa", "aqc", "aqd", "aqg", "aql", "aqm", "aqn", "aqp", "aqr", "aqt", "aqz", "ar", "arb", "arc", "ard", "are", "arh", "ari", "arj", "ark", "arl", "arn", "aro", "arp", "arq", "arr", "ars", "art", "aru", "arv", "arw", "arx", "ary", "arz", "as", "asa", "asb", "asc", "asd", "ase", "asf", "asg", "ash", "asi", "asj", "ask", "asl", "asn", "aso", "asp", "asq", "asr", "ass", "ast", "asu", "asv", "asw", "asx", "asy", "asz", "ata", "atb", "atc", "atd", "ate", "atg", "ath", "ati", "atj", "atk", "atl", "atm", "atn", "ato", "atp", "atq", "atr", "ats", "att", "atu", "atv", "atw", "atx", "aty", "atz", "aua", "aub", "auc", "aud", "aue", "auf", "aug", "auh", "aui", "auj", "auk", "aul", "aum", "aun", "auo", "aup", "auq", "aur", "aus", "aut", "auu", "auw", "aux", "auy", "auz", "av", "avb", "avd", "avi", "avk", "avl", "avm", "avn", "avo", "avs", "avt", "avu", "avv", "awa", "awb", "awc", "awd", "awe", "awg", "awh", "awi", "awk", "awm", "awn", "awo", "awr", "aws", "awt", "awu", "awv", "aww", "awx", "awy", "axb", "axe", "axg", "axk", "axl", "axm", "axx", "ay", "aya", "ayb", "ayc", "ayd", "aye", "ayg", "ayh", "ayi", "ayk", "ayl", "ayn", "ayo", "ayp", "ayq", "ayr", "ays", "ayt", "ayu", "ayx", "ayy", "ayz", "az", "aza", "azb", "azc", "azd", "azg", "azj", "azm", "azn", "azo", "azt", "azz", "ba", "baa", "bab", "bac", "bad", "bae", "baf", "bag", "bah", "bai", "baj", "bal", "ban", "bao", "bap", "bar", "bas", "bat", "bau", "bav", "baw", "bax", "bay", "baz", "bba", "bbb", "bbc", "bbd", "bbe", "bbf", "bbg", "bbh", "bbi", "bbj", "bbk", "bbl", "bbm", "bbn", "bbo", "bbp", "bbq", "bbr", "bbs", "bbt", "bbu", "bbv", "bbw", "bbx", "bby", "bbz", "bca", "bcb", "bcc", "bcd", "bce", "bcf", "bcg", "bch", "bci", "bcj", "bck", "bcl", "bcm", "bcn", "bco", "bcp", "bcq", "bcr", "bcs", "bct", "bcu", "bcv", "bcw", "bcy", "bcz", "bda", "bdb", "bdc", "bdd", "bde", "bdf", "bdg", "bdh", "bdi", "bdj", "bdk", "bdl", "bdm", "bdn", "bdo", "bdp", "bdq", "bdr", "bds", "bdt", "bdu", "bdv", "bdw", "bdx", "bdy", "bdz", "be", "bea", "beb", "bec", "bed", "bee", "bef", "beg", "beh", "bei", "bej", "bek", "bem", "beo", "bep", "beq", "ber", "bes", "bet", "beu", "bev", "bew", "bex", "bey", "bez", "bfa", "bfb", "bfc", "bfd", "bfe", "bff", "bfg", "bfh", "bfi", "bfj", "bfk", "bfl", "bfm", "bfn", "bfo", "bfp", "bfq", "bfr", "bfs", "bft", "bfu", "bfw", "bfx", "bfy", "bfz", "bg", "bga", "bgb", "bgc", "bgd", "bge", "bgf", "bgg", "bgi", "bgj", "bgk", "bgl", "bgm", "bgn", "bgo", "bgp", "bgq", "bgr", "bgs", "bgt", "bgu", "bgv", "bgw", "bgx", "bgy", "bgz", "bh", "bha", "bhb", "bhc", "bhd", "bhe", "bhf", "bhg", "bhh", "bhi", "bhj", "bhk", "bhl", "bhm", "bhn", "bho", "bhp", "bhq", "bhr", "bhs", "bht", "bhu", "bhv", "bhw", "bhx", "bhy", "bhz", "bi", "bia", "bib", "bic", "bid", "bie", "bif", "big", "bij", "bik", "bil", "bim", "bin", "bio", "bip", "biq", "bir", "bit", "biu", "biv", "biw", "bix", "biy", "biz", "bja", "bjb", "bjc", "bjd", "bje", "bjf", "bjg", "bjh", "bji", "bjj", "bjk", "bjl", "bjm", "bjn", "bjo", "bjp", "bjq", "bjr", "bjs", "bjt", "bju", "bjv", "bjw", "bjx", "bjy", "bjz", "bka", "bkb", "bkc", "bkd", "bkf", "bkg", "bkh", "bki", "bkj", "bkk", "bkl", "bkm", "bkn", "bko", "bkp", "bkq", "bkr", "bks", "bkt", "bku", "bkv", "bkw", "bkx", "bky", "bkz", "bla", "blb", "blc", "bld", "ble", "blf", "blg", "blh", "bli", "blj", "blk", "bll", "blm", "bln", "blo", "blp", "blq", "blr", "bls", "blt", "blv", "blw", "blx", "bly", "blz", "bm", "bma", "bmb", "bmc", "bmd", "bme", "bmf", "bmg", "bmh", "bmi", "bmj", "bmk", "bml", "bmm", "bmn", "bmo", "bmp", "bmq", "bmr", "bms", "bmt", "bmu", "bmv", "bmw", "bmx", "bmy", "bmz", "bn", "bna", "bnb", "bnc", "bnd", "bne", "bnf", "bng", "bni", "bnj", "bnk", "bnl", "bnm", "bnn", "bno", "bnp", "bnq", "bnr", "bns", "bnt", "bnu", "bnv", "bnw", "bnx", "bny", "bnz", "bo", "boa", "bob", "boe", "bof", "bog", "boh", "boi", "boj", "bok", "bol", "bom", "bon", "boo", "bop", "boq", "bor", "bot", "bou", "bov", "bow", "box", "boy", "boz", "bpa", "bpb", "bpd", "bpg", "bph", "bpi", "bpj", "bpk", "bpl", "bpm", "bpn", "bpo", "bpp", "bpq", "bpr", "bps", "bpt", "bpu", "bpv", "bpw", "bpx", "bpy", "bpz", "bqa", "bqb", "bqc", "bqd", "bqf", "bqg", "bqh", "bqi", "bqj", "bqk", "bql", "bqm", "bqn", "bqo", "bqp", "bqq", "bqr", "bqs", "bqt", "bqu", "bqv", "bqw", "bqx", "bqy", "bqz", "br", "bra", "brb", "brc", "brd", "brf", "brg", "brh", "bri", "brj", "brk", "brl", "brm", "brn", "bro", "brp", "brq", "brr", "brs", "brt", "bru", "brv", "brw", "brx", "bry", "brz", "bs", "bsa", "bsb", "bsc", "bse", "bsf", "bsg", "bsh", "bsi", "bsj", "bsk", "bsl", "bsm", "bsn", "bso", "bsp", "bsq", "bsr", "bss", "bst", "bsu", "bsv", "bsw", "bsx", "bsy", "bta", "btb", "btc", "btd", "bte", "btf", "btg", "bth", "bti", "btj", "btk", "btl", "btm", "btn", "bto", "btp", "btq", "btr", "bts", "btt", "btu", "btv", "btw", "btx", "bty", "btz", "bua", "bub", "buc", "bud", "bue", "buf", "bug", "buh", "bui", "buj", "buk", "bum", "bun", "buo", "bup", "buq", "bus", "but", "buu", "buv", "buw", "bux", "buy", "buz", "bva", "bvb", "bvc", "bvd", "bve", "bvf", "bvg", "bvh", "bvi", "bvj", "bvk", "bvl", "bvm", "bvn", "bvo", "bvp", "bvq", "bvr", "bvt", "bvu", "bvv", "bvw", "bvx", "bvy", "bvz", "bwa", "bwb", "bwc", "bwd", "bwe", "bwf", "bwg", "bwh", "bwi", "bwj", "bwk", "bwl", "bwm", "bwn", "bwo", "bwp", "bwq", "bwr", "bws", "bwt", "bwu", "bww", "bwx", "bwy", "bwz", "bxa", "bxb", "bxc", "bxd", "bxe", "bxf", "bxg", "bxh", "bxi", "bxj", "bxk", "bxl", "bxm", "bxn", "bxo", "bxp", "bxq", "bxr", "bxs", "bxu", "bxv", "bxw", "bxx", "bxz", "bya", "byb", "byc", "byd", "bye", "byf", "byg", "byh", "byi", "byj", "byk", "byl", "bym", "byn", "byo", "byp", "byq", "byr", "bys", "byt", "byv", "byw", "byx", "byy", "byz", "bza", "bzb", "bzc", "bzd", "bze", "bzf", "bzg", "bzh", "bzi", "bzj", "bzk", "bzl", "bzm", "bzn", "bzo", "bzp", "bzq", "bzr", "bzs", "bzt", "bzu", "bzv", "bzw", "bzx", "bzy", "bzz", "ca", "caa", "cab", "cac", "cad", "cae", "caf", "cag", "cah", "cai", "caj", "cak", "cal", "cam", "can", "cao", "cap", "caq", "car", "cas", "cau", "cav", "caw", "cax", "cay", "caz", "cba", "cbb", "cbc", "cbd", "cbe", "cbg", "cbh", "cbi", "cbj", "cbk", "cbl", "cbn", "cbo", "cbq", "cbr", "cbs", "cbt", "cbu", "cbv", "cbw", "cby", "cca", "ccc", "ccd", "cce", "ccg", "cch", "ccj", "ccl", "ccm", "ccn", "cco", "ccp", "ccq", "ccr", "ccs", "cda", "cdc", "cdd", "cde", "cdf", "cdg", "cdh", "cdi", "cdj", "cdm", "cdn", "cdo", "cdr", "cds", "cdy", "cdz", "ce", "cea", "ceb", "ceg", "cek", "cel", "cen", "cet", "cey", "cfa", "cfd", "cfg", "cfm", "cga", "cgc", "cgg", "cgk", "ch", "chb", "chc", "chd", "chf", "chg", "chh", "chj", "chk", "chl", "chm", "chn", "cho", "chp", "chq", "chr", "cht", "chw", "chx", "chy", "chz", "cia", "cib", "cic", "cid", "cie", "cih", "cik", "cim", "cin", "cip", "cir", "ciw", "ciy", "cja", "cje", "cjh", "cji", "cjk", "cjm", "cjn", "cjo", "cjp", "cjr", "cjs", "cjv", "cjy", "cka", "ckb", "ckh", "ckl", "ckn", "cko", "ckq", "ckr", "cks", "ckt", "cku", "ckv", "ckx", "cky", "ckz", "cla", "clc", "cld", "cle", "clh", "cli", "clj", "clk", "cll", "clm", "clo", "clt", "clu", "clw", "cly", "cma", "cmc", "cme", "cmg", "cmi", "cmk", "cml", "cmm", "cmn", "cmo", "cmr", "cms", "cmt", "cna", "cnb", "cnc", "cng", "cnh", "cni", "cnk", "cnl", "cno", "cnr", "cns", "cnt", "cnu", "cnw", "cnx", "co", "coa", "cob", "coc", "cod", "coe", "cof", "cog", "coh", "coj", "cok", "col", "com", "con", "coo", "cop", "coq", "cot", "cou", "cov", "cow", "cox", "coy", "coz", "cpa", "cpb", "cpc", "cpe", "cpf", "cpg", "cpi", "cpn", "cpo", "cpp", "cps", "cpu", "cpx", "cpy", "cqd", "cqu", "cr", "cra", "crb", "crc", "crd", "crf", "crg", "crh", "cri", "crj", "crk", "crl", "crm", "crn", "cro", "crp", "crq", "crr", "crs", "crt", "crv", "crw", "crx", "cry", "crz", "cs", "csa", "csb", "csc", "csd", "cse", "csf", "csg", "csh", "csi", "csj", "csk", "csl", "csm", "csn", "cso", "csq", "csr", "css", "cst", "csu", "csv", "csw", "csy", "csz", "cta", "ctc", "ctd", "cte", "ctg", "cth", "ctl", "ctm", "ctn", "cto", "ctp", "cts", "ctt", "ctu", "ctz", "cu", "cua", "cub", "cuc", "cug", "cuh", "cui", "cuj", "cuk", "cul", "cum", "cuo", "cup", "cuq", "cur", "cus", "cut", "cuu", "cuv", "cuw", "cux", "cuy", "cv", "cvg", "cvn", "cwa", "cwb", "cwd", "cwe", "cwg", "cwt", "cy", "cya", "cyb", "cyo", "czh", "czk", "czn", "czo", "czt", "da", "daa", "dac", "dad", "dae", "daf", "dag", "dah", "dai", "daj", "dak", "dal", "dam", "dao", "dap", "daq", "dar", "das", "dau", "dav", "daw", "dax", "day", "daz", "dba", "dbb", "dbd", "dbe", "dbf", "dbg", "dbi", "dbj", "dbl", "dbm", "dbn", "dbo", "dbp", "dbq", "dbr", "dbt", "dbu", "dbv", "dbw", "dby", "dcc", "dcr", "dda", "ddd", "dde", "ddg", "ddi", "ddj", "ddn", "ddo", "ddr", "dds", "ddw", "de", "dec", "ded", "dee", "def", "deg", "deh", "dei", "dek", "del", "dem", "den", "dep", "deq", "der", "des", "dev", "dez", "dga", "dgb", "dgc", "dgd", "dge", "dgg", "dgh", "dgi", "dgk", "dgl", "dgn", "dgo", "dgr", "dgs", "dgt", "dgu", "dgw", "dgx", "dgz", "dha", "dhd", "dhg", "dhi", "dhl", "dhm", "dhn", "dho", "dhr", "dhs", "dhu", "dhv", "dhw", "dhx", "dia", "dib", "dic", "did", "dif", "dig", "dih", "dii", "dij", "dik", "dil", "dim", "din", "dio", "dip", "diq", "dir", "dis", "dit", "diu", "diw", "dix", "diy", "diz", "dja", "djb", "djc", "djd", "dje", "djf", "dji", "djj", "djk", "djl", "djm", "djn", "djo", "djr", "dju", "djw", "dka", "dkk", "dkl", "dkr", "dks", "dkx", "dlg", "dlk", "dlm", "dln", "dma", "dmb", "dmc", "dmd", "dme", "dmg", "dmk", "dml", "dmm", "dmn", "dmo", "dmr", "dms", "dmu", "dmv", "dmw", "dmx", "dmy", "dna", "dnd", "dne", "dng", "dni", "dnj", "dnk", "dnn", "dno", "dnr", "dnt", "dnu", "dnv", "dnw", "dny", "doa", "dob", "doc", "doe", "dof", "doh", "doi", "dok", "dol", "don", "doo", "dop", "doq", "dor", "dos", "dot", "dov", "dow", "dox", "doy", "doz", "dpp", "dra", "drb", "drc", "drd", "dre", "drg", "drh", "dri", "drl", "drn", "dro", "drq", "drr", "drs", "drt", "dru", "drw", "dry", "dsb", "dse", "dsh", "dsi", "dsl", "dsn", "dso", "dsq", "dta", "dtb", "dtd", "dth", "dti", "dtk", "dtm", "dtn", "dto", "dtp", "dtr", "dts", "dtt", "dtu", "dty", "dua", "dub", "duc", "dud", "due", "duf", "dug", "duh", "dui", "duj", "duk", "dul", "dum", "dun", "duo", "dup", "duq", "dur", "dus", "duu", "duv", "duw", "dux", "duy", "duz", "dv", "dva", "dwa", "dwl", "dwr", "dws", "dwu", "dww", "dwy", "dwz", "dya", "dyb", "dyd", "dyg", "dyi", "dym", "dyn", "dyo", "dyu", "dyy", "dz", "dza", "dzd", "dze", "dzg", "dzl", "dzn", "eaa", "ebg", "ebk", "ebo", "ebr", "ebu", "ecr", "ecs", "ecy", "ee", "eee", "efa", "efe", "efi", "ega", "egl", "ego", "egx", "egy", "ehu", "eip", "eit", "eiv", "eja", "eka", "ekc", "eke", "ekg", "eki", "ekk", "ekl", "ekm", "eko", "ekp", "ekr", "eky", "el", "ele", "elh", "eli", "elk", "elm", "elo", "elp", "elu", "elx", "ema", "emb", "eme", "emg", "emi", "emk", "emm", "emn", "emo", "emp", "ems", "emu", "emw", "emx", "emy", "en", "ena", "enb", "enc", "end", "enf", "enh", "enl", "enm", "enn", "eno", "enq", "enr", "enu", "env", "enw", "enx", "eo", "eot", "epi", "era", "erg", "erh", "eri", "erk", "ero", "err", "ers", "ert", "erw", "es", "ese", "esg", "esh", "esi", "esk", "esl", "esm", "esn", "eso", "esq", "ess", "esu", "esx", "esy", "et", "etb", "etc", "eth", "etn", "eto", "etr", "ets", "ett", "etu", "etx", "etz", "eu", "euq", "eve", "evh", "evn", "ewo", "ext", "eya", "eyo", "eza", "eze", "fa", "faa", "fab", "fad", "faf", "fag", "fah", "fai", "faj", "fak", "fal", "fam", "fan", "fap", "far", "fat", "fau", "fax", "fay", "faz", "fbl", "fcs", "fer", "ff", "ffi", "ffm", "fgr", "fi", "fia", "fie", "fil", "fip", "fir", "fit", "fiu", "fiw", "fj", "fkk", "fkv", "fla", "flh", "fli", "fll", "fln", "flr", "fly", "fmp", "fmu", "fnb", "fng", "fni", "fo", "fod", "foi", "fom", "fon", "for", "fos", "fox", "fpe", "fqs", "fr", "frc", "frd", "frk", "frm", "fro", "frp", "frq", "frr", "frs", "frt", "fse", "fsl", "fss", "fub", "fuc", "fud", "fue", "fuf", "fuh", "fui", "fuj", "fum", "fun", "fuq", "fur", "fut", "fuu", "fuv", "fuy", "fvr", "fwa", "fwe", "fy", "ga", "gaa", "gab", "gac", "gad", "gae", "gaf", "gag", "gah", "gai", "gaj", "gak", "gal", "gam", "gan", "gao", "gap", "gaq", "gar", "gas", "gat", "gau", "gav", "gaw", "gax", "gay", "gaz", "gba", "gbb", "gbc", "gbd", "gbe", "gbf", "gbg", "gbh", "gbi", "gbj", "gbk", "gbl", "gbm", "gbn", "gbo", "gbp", "gbq", "gbr", "gbs", "gbu", "gbv", "gbw", "gbx", "gby", "gbz", "gcc", "gcd", "gce", "gcf", "gcl", "gcn", "gcr", "gct", "gd", "gda", "gdb", "gdc", "gdd", "gde", "gdf", "gdg", "gdh", "gdi", "gdj", "gdk", "gdl", "gdm", "gdn", "gdo", "gdq", "gdr", "gds", "gdt", "gdu", "gdx", "gea", "geb", "gec", "ged", "geg", "geh", "gei", "gej", "gek", "gel", "gem", "geq", "ges", "gev", "gew", "gex", "gey", "gez", "gfk", "gft", "gfx", "gga", "ggb", "ggd", "gge", "ggg", "ggk", "ggl", "ggn", "ggo", "ggr", "ggt", "ggu", "ggw", "gha", "ghc", "ghe", "ghh", "ghk", "ghl", "ghn", "gho", "ghr", "ghs", "ght", "gia", "gib", "gic", "gid", "gie", "gig", "gih", "gil", "gim", "gin", "gio", "gip", "giq", "gir", "gis", "git", "giu", "giw", "gix", "giy", "giz", "gji", "gjk", "gjm", "gjn", "gjr", "gju", "gka", "gkd", "gke", "gkn", "gko", "gkp", "gku", "gl", "glc", "gld", "glh", "gli", "glj", "glk", "gll", "glo", "glr", "glu", "glw", "gly", "gma", "gmb", "gmd", "gme", "gmg", "gmh", "gml", "gmm", "gmn", "gmq", "gmu", "gmv", "gmw", "gmx", "gmy", "gmz", "gn", "gna", "gnb", "gnc", "gnd", "gne", "gng", "gnh", "gni", "gnj", "gnk", "gnl", "gnm", "gnn", "gno", "gnq", "gnr", "gnt", "gnu", "gnw", "gnz", "goa", "gob", "goc", "god", "goe", "gof", "gog", "goh", "goi", "goj", "gok", "gol", "gom", "gon", "goo", "gop", "goq", "gor", "gos", "got", "gou", "gow", "gox", "goy", "goz", "gpa", "gpe", "gpn", "gqa", "gqi", "gqn", "gqr", "gqu", "gra", "grb", "grc", "grd", "grg", "grh", "gri", "grj", "grk", "grm", "gro", "grq", "grr", "grs", "grt", "gru", "grv", "grw", "grx", "gry", "grz", "gse", "gsg", "gsl", "gsm", "gsn", "gso", "gsp", "gss", "gsw", "gta", "gti", "gtu", "gu", "gua", "gub", "guc", "gud", "gue", "guf", "gug", "guh", "gui", "guk", "gul", "gum", "gun", "guo", "gup", "guq", "gur", "gus", "gut", "guu", "guv", "guw", "gux", "guz", "gv", "gva", "gvc", "gve", "gvf", "gvj", "gvl", "gvm", "gvn", "gvo", "gvp", "gvr", "gvs", "gvy", "gwa", "gwb", "gwc", "gwd", "gwe", "gwf", "gwg", "gwi", "gwj", "gwm", "gwn", "gwr", "gwt", "gwu", "gww", "gwx", "gxx", "gya", "gyb", "gyd", "gye", "gyf", "gyg", "gyi", "gyl", "gym", "gyn", "gyo", "gyr", "gyy", "gza", "gzi", "gzn", "ha", "haa", "hab", "hac", "had", "hae", "haf", "hag", "hah", "hai", "haj", "hak", "hal", "ham", "han", "hao", "hap", "haq", "har", "has", "hav", "haw", "hax", "hay", "haz", "hba", "hbb", "hbn", "hbo", "hbu", "hca", "hch", "hdn", "hds", "hdy", "he", "hea", "hed", "heg", "heh", "hei", "hem", "hgm", "hgw", "hhi", "hhr", "hhy", "hi", "hia", "hib", "hid", "hif", "hig", "hih", "hii", "hij", "hik", "hil", "him", "hio", "hir", "hit", "hiw", "hix", "hji", "hka", "hke", "hkk", "hkn", "hks", "hla", "hlb", "hld", "hle", "hlt", "hlu", "hma", "hmb", "hmc", "hmd", "hme", "hmf", "hmg", "hmh", "hmi", "hmj", "hmk", "hml", "hmm", "hmn", "hmp", "hmq", "hmr", "hms", "hmt", "hmu", "hmv", "hmw", "hmx", "hmy", "hmz", "hna", "hnd", "hne", "hnh", "hni", "hnj", "hnn", "hno", "hns", "hnu", "ho", "hoa", "hob", "hoc", "hod", "hoe", "hoh", "hoi", "hoj", "hok", "hol", "hom", "hoo", "hop", "hor", "hos", "hot", "hov", "how", "hoy", "hoz", "hpo", "hps", "hr", "hra", "hrc", "hre", "hrk", "hrm", "hro", "hrp", "hrr", "hrt", "hru", "hrw", "hrx", "hrz", "hsb", "hsh", "hsl", "hsn", "hss", "ht", "hti", "hto", "hts", "htu", "htx", "hu", "hub", "huc", "hud", "hue", "huf", "hug", "huh", "hui", "huj", "huk", "hul", "hum", "huo", "hup", "huq", "hur", "hus", "hut", "huu", "huv", "huw", "hux", "huy", "huz", "hvc", "hve", "hvk", "hvn", "hvv", "hwa", "hwc", "hwo", "hy", "hya", "hyw", "hyx", "hz", "ia", "iai", "ian", "iap", "iar", "iba", "ibb", "ibd", "ibe", "ibg", "ibh", "ibi", "ibl", "ibm", "ibn", "ibr", "ibu", "iby", "ica", "ich", "icl", "icr", "id", "ida", "idb", "idc", "idd", "ide", "idi", "idr", "ids", "idt", "idu", "ie", "ifa", "ifb", "ife", "iff", "ifk", "ifm", "ifu", "ify", "ig", "igb", "ige", "igg", "igl", "igm", "ign", "igo", "igs", "igw", "ihb", "ihi", "ihp", "ihw", "ii", "iin", "iir", "ijc", "ije", "ijj", "ijn", "ijo", "ijs", "ik", "ike", "iki", "ikk", "ikl", "iko", "ikp", "ikr", "iks", "ikt", "ikv", "ikw", "ikx", "ikz", "ila", "ilb", "ilg", "ili", "ilk", "ill", "ilm", "ilo", "ilp", "ils", "ilu", "ilv", "ilw", "ima", "ime", "imi", "iml", "imn", "imo", "imr", "ims", "imy", "in", "inb", "inc", "ine", "ing", "inh", "inj", "inl", "inm", "inn", "ino", "inp", "ins", "int", "inz", "io", "ior", "iou", "iow", "ipi", "ipo", "iqu", "iqw", "ira", "ire", "irh", "iri", "irk", "irn", "iro", "irr", "iru", "irx", "iry", "is", "isa", "isc", "isd", "ise", "isg", "ish", "isi", "isk", "ism", "isn", "iso", "isr", "ist", "isu", "it", "itb", "itc", "itd", "ite", "iti", "itk", "itl", "itm", "ito", "itr", "its", "itt", "itv", "itw", "itx", "ity", "itz", "iu", "ium", "ivb", "ivv", "iw", "iwk", "iwm", "iwo", "iws", "ixc", "ixl", "iya", "iyo", "iyx", "izh", "izi", "izr", "izz", "ja", "jaa", "jab", "jac", "jad", "jae", "jaf", "jah", "jaj", "jak", "jal", "jam", "jan", "jao", "jaq", "jar", "jas", "jat", "jau", "jax", "jay", "jaz", "jbe", "jbi", "jbj", "jbk", "jbn", "jbo", "jbr", "jbt", "jbu", "jbw", "jcs", "jct", "jda", "jdg", "jdt", "jeb", "jee", "jeg", "jeh", "jei", "jek", "jel", "jen", "jer", "jet", "jeu", "jgb", "jge", "jgk", "jgo", "jhi", "jhs", "ji", "jia", "jib", "jic", "jid", "jie", "jig", "jih", "jii", "jil", "jim", "jio", "jiq", "jit", "jiu", "jiv", "jiy", "jje", "jjr", "jka", "jkm", "jko", "jkp", "jkr", "jku", "jle", "jls", "jma", "jmb", "jmc", "jmd", "jmi", "jml", "jmn", "jmr", "jms", "jmw", "jmx", "jna", "jnd", "jng", "jni", "jnj", "jnl", "jns", "job", "jod", "jog", "jor", "jos", "jow", "jpa", "jpr", "jpx", "jqr", "jra", "jrb", "jrr", "jrt", "jru", "jsl", "jua", "jub", "juc", "jud", "juh", "jui", "juk", "jul", "jum", "jun", "juo", "jup", "jur", "jus", "jut", "juu", "juw", "juy", "jv", "jvd", "jvn", "jw", "jwi", "jya", "jye", "jyy", "ka", "kaa", "kab", "kac", "kad", "kae", "kaf", "kag", "kah", "kai", "kaj", "kak", "kam", "kao", "kap", "kaq", "kar", "kav", "kaw", "kax", "kay", "kba", "kbb", "kbc", "kbd", "kbe", "kbf", "kbg", "kbh", "kbi", "kbj", "kbk", "kbl", "kbm", "kbn", "kbo", "kbp", "kbq", "kbr", "kbs", "kbt", "kbu", "kbv", "kbw", "kbx", "kby", "kbz", "kca", "kcb", "kcc", "kcd", "kce", "kcf", "kcg", "kch", "kci", "kcj", "kck", "kcl", "kcm", "kcn", "kco", "kcp", "kcq", "kcr", "kcs", "kct", "kcu", "kcv", "kcw", "kcx", "kcy", "kcz", "kda", "kdc", "kdd", "kde", "kdf", "kdg", "kdh", "kdi", "kdj", "kdk", "kdl", "kdm", "kdn", "kdo", "kdp", "kdq", "kdr", "kdt", "kdu", "kdv", "kdw", "kdx", "kdy", "kdz", "kea", "keb", "kec", "ked", "kee", "kef", "keg", "keh", "kei", "kej", "kek", "kel", "kem", "ken", "keo", "kep", "keq", "ker", "kes", "ket", "keu", "kev", "kew", "kex", "key", "kez", "kfa", "kfb", "kfc", "kfd", "kfe", "kff", "kfg", "kfh", "kfi", "kfj", "kfk", "kfl", "kfm", "kfn", "kfo", "kfp", "kfq", "kfr", "kfs", "kft", "kfu", "kfv", "kfw", "kfx", "kfy", "kfz", "kg", "kga", "kgb", "kgc", "kgd", "kge", "kgf", "kgg", "kgh", "kgi", "kgj", "kgk", "kgl", "kgm", "kgn", "kgo", "kgp", "kgq", "kgr", "kgs", "kgt", "kgu", "kgv", "kgw", "kgx", "kgy", "kha", "khb", "khc", "khd", "khe", "khf", "khg", "khh", "khi", "khj", "khk", "khl", "khn", "kho", "khp", "khq", "khr", "khs", "kht", "khu", "khv", "khw", "khx", "khy", "khz", "ki", "kia", "kib", "kic", "kid", "kie", "kif", "kig", "kih", "kii", "kij", "kil", "kim", "kio", "kip", "kiq", "kis", "kit", "kiu", "kiv", "kiw", "kix", "kiy", "kiz", "kj", "kja", "kjb", "kjc", "kjd", "kje", "kjf", "kjg", "kjh", "kji", "kjj", "kjk", "kjl", "kjm", "kjn", "kjo", "kjp", "kjq", "kjr", "kjs", "kjt", "kju", "kjv", "kjx", "kjy", "kjz", "kk", "kka", "kkb", "kkc", "kkd", "kke", "kkf", "kkg", "kkh", "kki", "kkj", "kkk", "kkl", "kkm", "kkn", "kko", "kkp", "kkq", "kkr", "kks", "kkt", "kku", "kkv", "kkw", "kkx", "kky", "kkz", "kl", "kla", "klb", "klc", "kld", "kle", "klf", "klg", "klh", "kli", "klj", "klk", "kll", "klm", "kln", "klo", "klp", "klq", "klr", "kls", "klt", "klu", "klv", "klw", "klx", "kly", "klz", "km", "kma", "kmb", "kmc", "kmd", "kme", "kmf", "kmg", "kmh", "kmi", "kmj", "kmk", "kml", "kmm", "kmn", "kmo", "kmp", "kmq", "kmr", "kms", "kmt", "kmu", "kmv", "kmw", "kmx", "kmy", "kmz", "kn", "kna", "knb", "knc", "knd", "kne", "knf", "kng", "kni", "knj", "knk", "knl", "knm", "knn", "kno", "knp", "knq", "knr", "kns", "knt", "knu", "knv", "knw", "knx", "kny", "knz", "ko", "koa", "koc", "kod", "koe", "kof", "kog", "koh", "koi", "koj", "kok", "kol", "koo", "kop", "koq", "kos", "kot", "kou", "kov", "kow", "kox", "koy", "koz", "kpa", "kpb", "kpc", "kpd", "kpe", "kpf", "kpg", "kph", "kpi", "kpj", "kpk", "kpl", "kpm", "kpn", "kpo", "kpp", "kpq", "kpr", "kps", "kpt", "kpu", "kpv", "kpw", "kpx", "kpy", "kpz", "kqa", "kqb", "kqc", "kqd", "kqe", "kqf", "kqg", "kqh", "kqi", "kqj", "kqk", "kql", "kqm", "kqn", "kqo", "kqp", "kqq", "kqr", "kqs", "kqt", "kqu", "kqv", "kqw", "kqx", "kqy", "kqz", "kr", "kra", "krb", "krc", "krd", "kre", "krf", "krh", "kri", "krj", "krk", "krl", "krm", "krn", "kro", "krp", "krr", "krs", "krt", "kru", "krv", "krw", "krx", "kry", "krz", "ks", "ksa", "ksb", "ksc", "ksd", "kse", "ksf", "ksg", "ksh", "ksi", "ksj", "ksk", "ksl", "ksm", "ksn", "kso", "ksp", "ksq", "ksr", "kss", "kst", "ksu", "ksv", "ksw", "ksx", "ksy", "ksz", "kta", "ktb", "ktc", "ktd", "kte", "ktf", "ktg", "kth", "kti", "ktj", "ktk", "ktl", "ktm", "ktn", "kto", "ktp", "ktq", "ktr", "kts", "ktt", "ktu", "ktv", "ktw", "ktx", "kty", "ktz", "ku", "kub", "kuc", "kud", "kue", "kuf", "kug", "kuh", "kui", "kuj", "kuk", "kul", "kum", "kun", "kuo", "kup", "kuq", "kus", "kut", "kuu", "kuv", "kuw", "kux", "kuy", "kuz", "kv", "kva", "kvb", "kvc", "kvd", "kve", "kvf", "kvg", "kvh", "kvi", "kvj", "kvk", "kvl", "kvm", "kvn", "kvo", "kvp", "kvq", "kvr", "kvs", "kvt", "kvu", "kvv", "kvw", "kvx", "kvy", "kvz", "kw", "kwa", "kwb", "kwc", "kwd", "kwe", "kwf", "kwg", "kwh", "kwi", "kwj", "kwk", "kwl", "kwm", "kwn", "kwo", "kwp", "kwq", "kwr", "kws", "kwt", "kwu", "kwv", "kww", "kwx", "kwy", "kwz", "kxa", "kxb", "kxc", "kxd", "kxe", "kxf", "kxh", "kxi", "kxj", "kxk", "kxl", "kxm", "kxn", "kxo", "kxp", "kxq", "kxr", "kxs", "kxt", "kxu", "kxv", "kxw", "kxx", "kxy", "kxz", "ky", "kya", "kyb", "kyc", "kyd", "kye", "kyf", "kyg", "kyh", "kyi", "kyj", "kyk", "kyl", "kym", "kyn", "kyo", "kyp", "kyq", "kyr", "kys", "kyt", "kyu", "kyv", "kyw", "kyx", "kyy", "kyz", "kza", "kzb", "kzc", "kzd", "kze", "kzf", "kzg", "kzh", "kzi", "kzj", "kzk", "kzl", "kzm", "kzn", "kzo", "kzp", "kzq", "kzr", "kzs", "kzt", "kzu", "kzv", "kzw", "kzx", "kzy", "kzz", "la", "laa", "lab", "lac", "lad", "lae", "laf", "lag", "lah", "lai", "laj", "lak", "lal", "lam", "lan", "lap", "laq", "lar", "las", "lau", "law", "lax", "lay", "laz", "lb", "lba", "lbb", "lbc", "lbe", "lbf", "lbg", "lbi", "lbj", "lbk", "lbl", "lbm", "lbn", "lbo", "lbq", "lbr", "lbs", "lbt", "lbu", "lbv", "lbw", "lbx", "lby", "lbz", "lcc", "lcd", "lce", "lcf", "lch", "lcl", "lcm", "lcp", "lcq", "lcs", "lda", "ldb", "ldd", "ldg", "ldh", "ldi", "ldj", "ldk", "ldl", "ldm", "ldn", "ldo", "ldp", "ldq", "lea", "leb", "lec", "led", "lee", "lef", "leg", "leh", "lei", "lej", "lek", "lel", "lem", "len", "leo", "lep", "leq", "ler", "les", "let", "leu", "lev", "lew", "lex", "ley", "lez", "lfa", "lfn", "lg", "lga", "lgb", "lgg", "lgh", "lgi", "lgk", "lgl", "lgm", "lgn", "lgq", "lgr", "lgt", "lgu", "lgz", "lha", "lhh", "lhi", "lhl", "lhm", "lhn", "lhp", "lhs", "lht", "lhu", "li", "lia", "lib", "lic", "lid", "lie", "lif", "lig", "lih", "lii", "lij", "lik", "lil", "lio", "lip", "liq", "lir", "lis", "liu", "liv", "liw", "lix", "liy", "liz", "lja", "lje", "lji", "ljl", "ljp", "ljw", "ljx", "lka", "lkb", "lkc", "lkd", "lke", "lkh", "lki", "lkj", "lkl", "lkm", "lkn", "lko", "lkr", "lks", "lkt", "lku", "lky", "lla", "llb", "llc", "lld", "lle", "llf", "llg", "llh", "lli", "llj", "llk", "lll", "llm", "lln", "llo", "llp", "llq", "lls", "llu", "llx", "lma", "lmb", "lmc", "lmd", "lme", "lmf", "lmg", "lmh", "lmi", "lmj", "lmk", "lml", "lmm", "lmn", "lmo", "lmp", "lmq", "lmr", "lmu", "lmv", "lmw", "lmx", "lmy", "lmz", "ln", "lna", "lnb", "lnd", "lng", "lnh", "lni", "lnj", "lnl", "lnm", "lnn", "lno", "lns", "lnu", "lnw", "lnz", "lo", "loa", "lob", "loc", "loe", "lof", "log", "loh", "loi", "loj", "lok", "lol", "lom", "lon", "loo", "lop", "loq", "lor", "los", "lot", "lou", "lov", "low", "lox", "loy", "loz", "lpa", "lpe", "lpn", "lpo", "lpx", "lra", "lrc", "lre", "lrg", "lri", "lrk", "lrl", "lrm", "lrn", "lro", "lrr", "lrt", "lrv", "lrz", "lsa", "lsd", "lse", "lsg", "lsh", "lsi", "lsl", "lsm", "lsn", "lso", "lsp", "lsr", "lss", "lst", "lsv", "lsy", "lt", "ltc", "ltg", "lth", "lti", "ltn", "lto", "lts", "ltu", "lu", "lua", "luc", "lud", "lue", "luf", "lui", "luj", "luk", "lul", "lum", "lun", "luo", "lup", "luq", "lur", "lus", "lut", "luu", "luv", "luw", "luy", "luz", "lv", "lva", "lvi", "lvk", "lvs", "lvu", "lwa", "lwe", "lwg", "lwh", "lwl", "lwm", "lwo", "lws", "lwt", "lwu", "lww", "lya", "lyg", "lyn", "lzh", "lzl", "lzn", "lzz", "maa", "mab", "mad", "mae", "maf", "mag", "mai", "maj", "mak", "mam", "man", "map", "maq", "mas", "mat", "mau", "mav", "maw", "max", "maz", "mba", "mbb", "mbc", "mbd", "mbe", "mbf", "mbh", "mbi", "mbj", "mbk", "mbl", "mbm", "mbn", "mbo", "mbp", "mbq", "mbr", "mbs", "mbt", "mbu", "mbv", "mbw", "mbx", "mby", "mbz", "mca", "mcb", "mcc", "mcd", "mce", "mcf", "mcg", "mch", "mci", "mcj", "mck", "mcl", "mcm", "mcn", "mco", "mcp", "mcq", "mcr", "mcs", "mct", "mcu", "mcv", "mcw", "mcx", "mcy", "mcz", "mda", "mdb", "mdc", "mdd", "mde", "mdf", "mdg", "mdh", "mdi", "mdj", "mdk", "mdl", "mdm", "mdn", "mdp", "mdq", "mdr", "mds", "mdt", "mdu", "mdv", "mdw", "mdx", "mdy", "mdz", "mea", "meb", "mec", "med", "mee", "mef", "meg", "meh", "mei", "mej", "mek", "mel", "mem", "men", "meo", "mep", "meq", "mer", "mes", "met", "meu", "mev", "mew", "mey", "mez", "mfa", "mfb", "mfc", "mfd", "mfe", "mff", "mfg", "mfh", "mfi", "mfj", "mfk", "mfl", "mfm", "mfn", "mfo", "mfp", "mfq", "mfr", "mfs", "mft", "mfu", "mfv", "mfw", "mfx", "mfy", "mfz", "mg", "mga", "mgb", "mgc", "mgd", "mge", "mgf", "mgg", "mgh", "mgi", "mgj", "mgk", "mgl", "mgm", "mgn", "mgo", "mgp", "mgq", "mgr", "mgs", "mgt", "mgu", "mgv", "mgw", "mgx", "mgy", "mgz", "mh", "mha", "mhb", "mhc", "mhd", "mhe", "mhf", "mhg", "mhh", "mhi", "mhj", "mhk", "mhl", "mhm", "mhn", "mho", "mhp", "mhq", "mhr", "mhs", "mht", "mhu", "mhw", "mhx", "mhy", "mhz", "mi", "mia", "mib", "mic", "mid", "mie", "mif", "mig", "mih", "mii", "mij", "mik", "mil", "mim", "min", "mio", "mip", "miq", "mir", "mis", "mit", "miu", "miw", "mix", "miy", "miz", "mja", "mjb", "mjc", "mjd", "mje", "mjg", "mjh", "mji", "mjj", "mjk", "mjl", "mjm", "mjn", "mjo", "mjp", "mjq", "mjr", "mjs", "mjt", "mju", "mjv", "mjw", "mjx", "mjy", "mjz", "mk", "mka", "mkb", "mkc", "mke", "mkf", "mkg", "mkh", "mki", "mkj", "mkk", "mkl", "mkm", "mkn", "mko", "mkp", "mkq", "mkr", "mks", "mkt", "mku", "mkv", "mkw", "mkx", "mky", "mkz", "ml", "mla", "mlb", "mlc", "mld", "mle", "mlf", "mlh", "mli", "mlj", "mlk", "mll", "mlm", "mln", "mlo", "mlp", "mlq", "mlr", "mls", "mlu", "mlv", "mlw", "mlx", "mlz", "mma", "mmb", "mmc", "mmd", "mme", "mmf", "mmg", "mmh", "mmi", "mmj", "mmk", "mml", "mmm", "mmn", "mmo", "mmp", "mmq", "mmr", "mmt", "mmu", "mmv", "mmw", "mmx", "mmy", "mmz", "mn", "mna", "mnb", "mnc", "mnd", "mne", "mnf", "mng", "mnh", "mni", "mnj", "mnk", "mnl", "mnm", "mnn", "mno", "mnp", "mnq", "mnr", "mns", "mnt", "mnu", "mnv", "mnw", "mnx", "mny", "mnz", "mo", "moa", "moc", "mod", "moe", "mof", "mog", "moh", "moi", "moj", "mok", "mom", "moo", "mop", "moq", "mor", "mos", "mot", "mou", "mov", "mow", "mox", "moy", "moz", "mpa", "mpb", "mpc", "mpd", "mpe", "mpg", "mph", "mpi", "mpj", "mpk", "mpl", "mpm", "mpn", "mpo", "mpp", "mpq", "mpr", "mps", "mpt", "mpu", "mpv", "mpw", "mpx", "mpy", "mpz", "mqa", "mqb", "mqc", "mqe", "mqf", "mqg", "mqh", "mqi", "mqj", "mqk", "mql", "mqm", "mqn", "mqo", "mqp", "mqq", "mqr", "mqs", "mqt", "mqu", "mqv", "mqw", "mqx", "mqy", "mqz", "mr", "mra", "mrb", "mrc", "mrd", "mre", "mrf", "mrg", "mrh", "mrj", "mrk", "mrl", "mrm", "mrn", "mro", "mrp", "mrq", "mrr", "mrs", "mrt", "mru", "mrv", "mrw", "mrx", "mry", "mrz", "ms", "msb", "msc", "msd", "mse", "msf", "msg", "msh", "msi", "msj", "msk", "msl", "msm", "msn", "mso", "msp", "msq", "msr", "mss", "mst", "msu", "msv", "msw", "msx", "msy", "msz", "mt", "mta", "mtb", "mtc", "mtd", "mte", "mtf", "mtg", "mth", "mti", "mtj", "mtk", "mtl", "mtm", "mtn", "mto", "mtp", "mtq", "mtr", "mts", "mtt", "mtu", "mtv", "mtw", "mtx", "mty", "mua", "mub", "muc", "mud", "mue", "mug", "muh", "mui", "muj", "muk", "mul", "mum", "mun", "muo", "mup", "muq", "mur", "mus", "mut", "muu", "muv", "mux", "muy", "muz", "mva", "mvb", "mvd", "mve", "mvf", "mvg", "mvh", "mvi", "mvk", "mvl", "mvm", "mvn", "mvo", "mvp", "mvq", "mvr", "mvs", "mvt", "mvu", "mvv", "mvw", "mvx", "mvy", "mvz", "mwa", "mwb", "mwc", "mwd", "mwe", "mwf", "mwg", "mwh", "mwi", "mwj", "mwk", "mwl", "mwm", "mwn", "mwo", "mwp", "mwq", "mwr", "mws", "mwt", "mwu", "mwv", "mww", "mwx", "mwy", "mwz", "mxa", "mxb", "mxc", "mxd", "mxe", "mxf", "mxg", "mxh", "mxi", "mxj", "mxk", "mxl", "mxm", "mxn", "mxo", "mxp", "mxq", "mxr", "mxs", "mxt", "mxu", "mxv", "mxw", "mxx", "mxy", "mxz", "my", "myb", "myc", "myd", "mye", "myf", "myg", "myh", "myi", "myj", "myk", "myl", "mym", "myn", "myo", "myp", "myq", "myr", "mys", "myt", "myu", "myv", "myw", "myx", "myy", "myz", "mza", "mzb", "mzc", "mzd", "mze", "mzg", "mzh", "mzi", "mzj", "mzk", "mzl", "mzm", "mzn", "mzo", "mzp", "mzq", "mzr", "mzs", "mzt", "mzu", "mzv", "mzw", "mzx", "mzy", "mzz", "na", "naa", "nab", "nac", "nad", "nae", "naf", "nag", "nah", "nai", "naj", "nak", "nal", "nam", "nan", "nao", "nap", "naq", "nar", "nas", "nat", "naw", "nax", "nay", "naz", "nb", "nba", "nbb", "nbc", "nbd", "nbe", "nbf", "nbg", "nbh", "nbi", "nbj", "nbk", "nbm", "nbn", "nbo", "nbp", "nbq", "nbr", "nbs", "nbt", "nbu", "nbv", "nbw", "nbx", "nby", "nca", "ncb", "ncc", "ncd", "nce", "ncf", "ncg", "nch", "nci", "ncj", "nck", "ncl", "ncm", "ncn", "nco", "ncp", "ncq", "ncr", "ncs", "nct", "ncu", "ncx", "ncz", "nd", "nda", "ndb", "ndc", "ndd", "ndf", "ndg", "ndh", "ndi", "ndj", "ndk", "ndl", "ndm", "ndn", "ndp", "ndq", "ndr", "nds", "ndt", "ndu", "ndv", "ndw", "ndx", "ndy", "ndz", "ne", "nea", "neb", "nec", "ned", "nee", "nef", "neg", "neh", "nei", "nej", "nek", "nem", "nen", "neo", "neq", "ner", "nes", "net", "neu", "nev", "new", "nex", "ney", "nez", "nfa", "nfd", "nfl", "nfr", "nfu", "ng", "nga", "ngb", "ngc", "ngd", "nge", "ngf", "ngg", "ngh", "ngi", "ngj", "ngk", "ngl", "ngm", "ngn", "ngo", "ngp", "ngq", "ngr", "ngs", "ngt", "ngu", "ngv", "ngw", "ngx", "ngy", "ngz", "nha", "nhb", "nhc", "nhd", "nhe", "nhf", "nhg", "nhh", "nhi", "nhk", "nhm", "nhn", "nho", "nhp", "nhq", "nhr", "nht", "nhu", "nhv", "nhw", "nhx", "nhy", "nhz", "nia", "nib", "nic", "nid", "nie", "nif", "nig", "nih", "nii", "nij", "nik", "nil", "nim", "nin", "nio", "niq", "nir", "nis", "nit", "niu", "niv", "niw", "nix", "niy", "niz", "nja", "njb", "njd", "njh", "nji", "njj", "njl", "njm", "njn", "njo", "njr", "njs", "njt", "nju", "njx", "njy", "njz", "nka", "nkb", "nkc", "nkd", "nke", "nkf", "nkg", "nkh", "nki", "nkj", "nkk", "nkm", "nkn", "nko", "nkp", "nkq", "nkr", "nks", "nkt", "nku", "nkv", "nkw", "nkx", "nkz", "nl", "nla", "nlc", "nle", "nlg", "nli", "nlj", "nlk", "nll", "nlm", "nln", "nlo", "nlq", "nlr", "nlu", "nlv", "nlw", "nlx", "nly", "nlz", "nma", "nmb", "nmc", "nmd", "nme", "nmf", "nmg", "nmh", "nmi", "nmj", "nmk", "nml", "nmm", "nmn", "nmo", "nmp", "nmq", "nmr", "nms", "nmt", "nmu", "nmv", "nmw", "nmx", "nmy", "nmz", "nn", "nna", "nnb", "nnc", "nnd", "nne", "nnf", "nng", "nnh", "nni", "nnj", "nnk", "nnl", "nnm", "nnn", "nnp", "nnq", "nnr", "nns", "nnt", "nnu", "nnv", "nnw", "nnx", "nny", "nnz", "no", "noa", "noc", "nod", "noe", "nof", "nog", "noh", "noi", "noj", "nok", "nol", "nom", "non", "noo", "nop", "noq", "nos", "not", "nou", "nov", "now", "noy", "noz", "npa", "npb", "npg", "nph", "npi", "npl", "npn", "npo", "nps", "npu", "npx", "npy", "nqg", "nqk", "nql", "nqm", "nqn", "nqo", "nqq", "nqy", "nr", "nra", "nrb", "nrc", "nre", "nrf", "nrg", "nri", "nrk", "nrl", "nrm", "nrn", "nrp", "nrr", "nrt", "nru", "nrx", "nrz", "nsa", "nsc", "nsd", "nse", "nsf", "nsg", "nsh", "nsi", "nsk", "nsl", "nsm", "nsn", "nso", "nsp", "nsq", "nsr", "nss", "nst", "nsu", "nsv", "nsw", "nsx", "nsy", "nsz", "ntd", "nte", "ntg", "nti", "ntj", "ntk", "ntm", "nto", "ntp", "ntr", "nts", "ntu", "ntw", "ntx", "nty", "ntz", "nua", "nub", "nuc", "nud", "nue", "nuf", "nug", "nuh", "nui", "nuj", "nuk", "nul", "num", "nun", "nuo", "nup", "nuq", "nur", "nus", "nut", "nuu", "nuv", "nuw", "nux", "nuy", "nuz", "nv", "nvh", "nvm", "nvo", "nwa", "nwb", "nwc", "nwe", "nwg", "nwi", "nwm", "nwo", "nwr", "nwx", "nwy", "nxa", "nxd", "nxe", "nxg", "nxi", "nxk", "nxl", "nxm", "nxn", "nxo", "nxq", "nxr", "nxu", "nxx", "ny", "nyb", "nyc", "nyd", "nye", "nyf", "nyg", "nyh", "nyi", "nyj", "nyk", "nyl", "nym", "nyn", "nyo", "nyp", "nyq", "nyr", "nys", "nyt", "nyu", "nyv", "nyw", "nyx", "nyy", "nza", "nzb", "nzd", "nzi", "nzk", "nzm", "nzs", "nzu", "nzy", "nzz", "oaa", "oac", "oar", "oav", "obi", "obk", "obl", "obm", "obo", "obr", "obt", "obu", "oc", "oca", "och", "oco", "ocu", "oda", "odk", "odt", "odu", "ofo", "ofs", "ofu", "ogb", "ogc", "oge", "ogg", "ogo", "ogu", "oht", "ohu", "oia", "oin", "oj", "ojb", "ojc", "ojg", "ojp", "ojs", "ojv", "ojw", "oka", "okb", "okd", "oke", "okg", "okh", "oki", "okj", "okk", "okl", "okm", "okn", "oko", "okr", "oks", "oku", "okv", "okx", "ola", "old", "ole", "olk", "olm", "olo", "olr", "olt", "olu", "om", "oma", "omb", "omc", "ome", "omg", "omi", "omk", "oml", "omn", "omo", "omp", "omq", "omr", "omt", "omu", "omv", "omw", "omx", "ona", "onb", "one", "ong", "oni", "onj", "onk", "onn", "ono", "onp", "onr", "ons", "ont", "onu", "onw", "onx", "ood", "oog", "oon", "oor", "oos", "opa", "opk", "opm", "opo", "opt", "opy", "or", "ora", "orc", "ore", "org", "orh", "orn", "oro", "orr", "ors", "ort", "oru", "orv", "orw", "orx", "ory", "orz", "os", "osa", "osc", "osi", "oso", "osp", "ost", "osu", "osx", "ota", "otb", "otd", "ote", "oti", "otk", "otl", "otm", "otn", "oto", "otq", "otr", "ots", "ott", "otu", "otw", "otx", "oty", "otz", "oua", "oub", "oue", "oui", "oum", "oun", "ovd", "owi", "owl", "oyb", "oyd", "oym", "oyy", "ozm", "pa", "paa", "pab", "pac", "pad", "pae", "paf", "pag", "pah", "pai", "pak", "pal", "pam", "pao", "pap", "paq", "par", "pas", "pat", "pau", "pav", "paw", "pax", "pay", "paz", "pbb", "pbc", "pbe", "pbf", "pbg", "pbh", "pbi", "pbl", "pbm", "pbn", "pbo", "pbp", "pbr", "pbs", "pbt", "pbu", "pbv", "pby", "pbz", "pca", "pcb", "pcc", "pcd", "pce", "pcf", "pcg", "pch", "pci", "pcj", "pck", "pcl", "pcm", "pcn", "pcp", "pcr", "pcw", "pda", "pdc", "pdi", "pdn", "pdo", "pdt", "pdu", "pea", "peb", "ped", "pee", "pef", "peg", "peh", "pei", "pej", "pek", "pel", "pem", "peo", "pep", "peq", "pes", "pev", "pex", "pey", "pez", "pfa", "pfe", "pfl", "pga", "pgd", "pgg", "pgi", "pgk", "pgl", "pgn", "pgs", "pgu", "pgy", "pgz", "pha", "phd", "phg", "phh", "phi", "phk", "phl", "phm", "phn", "pho", "phq", "phr", "pht", "phu", "phv", "phw", "pi", "pia", "pib", "pic", "pid", "pie", "pif", "pig", "pih", "pii", "pij", "pil", "pim", "pin", "pio", "pip", "pir", "pis", "pit", "piu", "piv", "piw", "pix", "piy", "piz", "pjt", "pka", "pkb", "pkc", "pkg", "pkh", "pkn", "pko", "pkp", "pkr", "pks", "pkt", "pku", "pl", "pla", "plb", "plc", "pld", "ple", "plf", "plg", "plh", "plj", "plk", "pll", "pln", "plo", "plp", "plq", "plr", "pls", "plt", "plu", "plv", "plw", "ply", "plz", "pma", "pmb", "pmc", "pmd", "pme", "pmf", "pmh", "pmi", "pmj", "pmk", "pml", "pmm", "pmn", "pmo", "pmq", "pmr", "pms", "pmt", "pmu", "pmw", "pmx", "pmy", "pmz", "pna", "pnb", "pnc", "pnd", "pne", "png", "pnh", "pni", "pnj", "pnk", "pnl", "pnm", "pnn", "pno", "pnp", "pnq", "pnr", "pns", "pnt", "pnu", "pnv", "pnw", "pnx", "pny", "pnz", "poc", "pod", "poe", "pof", "pog", "poh", "poi", "pok", "pom", "pon", "poo", "pop", "poq", "pos", "pot", "pov", "pow", "pox", "poy", "poz", "ppa", "ppe", "ppi", "ppk", "ppl", "ppm", "ppn", "ppo", "ppp", "ppq", "ppr", "pps", "ppt", "ppu", "pqa", "pqe", "pqm", "pqw", "pra", "prb", "prc", "prd", "pre", "prf", "prg", "prh", "pri", "prk", "prl", "prm", "prn", "pro", "prp", "prq", "prr", "prs", "prt", "pru", "prw", "prx", "pry", "prz", "ps", "psa", "psc", "psd", "pse", "psg", "psh", "psi", "psl", "psm", "psn", "pso", "psp", "psq", "psr", "pss", "pst", "psu", "psw", "psy", "pt", "pta", "pth", "pti", "ptn", "pto", "ptp", "ptq", "ptr", "ptt", "ptu", "ptv", "ptw", "pty", "pua", "pub", "puc", "pud", "pue", "puf", "pug", "pui", "puj", "puk", "pum", "puo", "pup", "puq", "pur", "put", "puu", "puw", "pux", "puy", "puz", "pwa", "pwb", "pwg", "pwi", "pwm", "pwn", "pwo", "pwr", "pww", "pxm", "pye", "pym", "pyn", "pys", "pyu", "pyx", "pyy", "pzn", "qu", "qua", "qub", "quc", "qud", "quf", "qug", "quh", "qui", "quk", "qul", "qum", "qun", "qup", "quq", "qur", "qus", "quv", "quw", "qux", "quy", "quz", "qva", "qvc", "qve", "qvh", "qvi", "qvj", "qvl", "qvm", "qvn", "qvo", "qvp", "qvs", "qvw", "qvy", "qvz", "qwa", "qwc", "qwe", "qwh", "qwm", "qws", "qwt", "qxa", "qxc", "qxh", "qxl", "qxn", "qxo", "qxp", "qxq", "qxr", "qxs", "qxt", "qxu", "qxw", "qya", "qyp", "raa", "rab", "rac", "rad", "raf", "rag", "rah", "rai", "raj", "rak", "ral", "ram", "ran", "rao", "rap", "raq", "rar", "ras", "rat", "rau", "rav", "raw", "rax", "ray", "raz", "rbb", "rbk", "rbl", "rbp", "rcf", "rdb", "rea", "reb", "ree", "reg", "rei", "rej", "rel", "rem", "ren", "rer", "res", "ret", "rey", "rga", "rge", "rgk", "rgn", "rgr", "rgs", "rgu", "rhg", "rhp", "ria", "rie", "rif", "ril", "rim", "rin", "rir", "rit", "riu", "rjg", "rji", "rjs", "rka", "rkb", "rkh", "rki", "rkm", "rkt", "rkw", "rm", "rma", "rmb", "rmc", "rmd", "rme", "rmf", "rmg", "rmh", "rmi", "rmk", "rml", "rmm", "rmn", "rmo", "rmp", "rmq", "rmr", "rms", "rmt", "rmu", "rmv", "rmw", "rmx", "rmy", "rmz", "rn", "rna", "rnd", "rng", "rnl", "rnn", "rnp", "rnr", "rnw", "ro", "roa", "rob", "roc", "rod", "roe", "rof", "rog", "rol", "rom", "roo", "rop", "ror", "rou", "row", "rpn", "rpt", "rri", "rro", "rrt", "rsb", "rsi", "rsl", "rsm", "rtc", "rth", "rtm", "rts", "rtw", "ru", "rub", "ruc", "rue", "ruf", "rug", "ruh", "rui", "ruk", "ruo", "rup", "ruq", "rut", "ruu", "ruy", "ruz", "rw", "rwa", "rwk", "rwm", "rwo", "rwr", "rxd", "rxw", "ryn", "rys", "ryu", "rzh", "sa", "saa", "sab", "sac", "sad", "sae", "saf", "sah", "sai", "saj", "sak", "sal", "sam", "sao", "sap", "saq", "sar", "sas", "sat", "sau", "sav", "saw", "sax", "say", "saz", "sba", "sbb", "sbc", "sbd", "sbe", "sbf", "sbg", "sbh", "sbi", "sbj", "sbk", "sbl", "sbm", "sbn", "sbo", "sbp", "sbq", "sbr", "sbs", "sbt", "sbu", "sbv", "sbw", "sbx", "sby", "sbz", "sc", "sca", "scb", "sce", "scf", "scg", "sch", "sci", "sck", "scl", "scn", "sco", "scp", "scq", "scs", "sct", "scu", "scv", "scw", "scx", "sd", "sda", "sdb", "sdc", "sde", "sdf", "sdg", "sdh", "sdj", "sdk", "sdl", "sdm", "sdn", "sdo", "sdp", "sdr", "sds", "sdt", "sdu", "sdv", "sdx", "sdz", "se", "sea", "seb", "sec", "sed", "see", "sef", "seg", "seh", "sei", "sej", "sek", "sel", "sem", "sen", "seo", "sep", "seq", "ser", "ses", "set", "seu", "sev", "sew", "sey", "sez", "sfb", "sfe", "sfm", "sfs", "sfw", "sg", "sga", "sgb", "sgc", "sgd", "sge", "sgg", "sgh", "sgi", "sgj", "sgk", "sgl", "sgm", "sgn", "sgo", "sgp", "sgr", "sgs", "sgt", "sgu", "sgw", "sgx", "sgy", "sgz", "sh", "sha", "shb", "shc", "shd", "she", "shg", "shh", "shi", "shj", "shk", "shl", "shm", "shn", "sho", "shp", "shq", "shr", "shs", "sht", "shu", "shv", "shw", "shx", "shy", "shz", "si", "sia", "sib", "sid", "sie", "sif", "sig", "sih", "sii", "sij", "sik", "sil", "sim", "sio", "sip", "siq", "sir", "sis", "sit", "siu", "siv", "siw", "six", "siy", "siz", "sja", "sjb", "sjd", "sje", "sjg", "sjk", "sjl", "sjm", "sjn", "sjo", "sjp", "sjr", "sjs", "sjt", "sju", "sjw", "sk", "ska", "skb", "skc", "skd", "ske", "skf", "skg", "skh", "ski", "skj", "skk", "skm", "skn", "sko", "skp", "skq", "skr", "sks", "skt", "sku", "skv", "skw", "skx", "sky", "skz", "sl", "sla", "slc", "sld", "sle", "slf", "slg", "slh", "sli", "slj", "sll", "slm", "sln", "slp", "slq", "slr", "sls", "slt", "slu", "slw", "slx", "sly", "slz", "sm", "sma", "smb", "smc", "smd", "smf", "smg", "smh", "smi", "smj", "smk", "sml", "smm", "smn", "smp", "smq", "smr", "sms", "smt", "smu", "smv", "smw", "smx", "smy", "smz", "sn", "snb", "snc", "sne", "snf", "sng", "snh", "sni", "snj", "snk", "snl", "snm", "snn", "sno", "snp", "snq", "snr", "sns", "snu", "snv", "snw", "snx", "sny", "snz", "so", "soa", "sob", "soc", "sod", "soe", "sog", "soh", "soi", "soj", "sok", "sol", "son", "soo", "sop", "soq", "sor", "sos", "sou", "sov", "sow", "sox", "soy", "soz", "spb", "spc", "spd", "spe", "spg", "spi", "spk", "spl", "spm", "spn", "spo", "spp", "spq", "spr", "sps", "spt", "spu", "spv", "spx", "spy", "sq", "sqa", "sqh", "sqj", "sqk", "sqm", "sqn", "sqo", "sqq", "sqr", "sqs", "sqt", "squ", "sr", "sra", "srb", "src", "sre", "srf", "srg", "srh", "sri", "srk", "srl", "srm", "srn", "sro", "srq", "srr", "srs", "srt", "sru", "srv", "srw", "srx", "sry", "srz", "ss", "ssa", "ssb", "ssc", "ssd", "sse", "ssf", "ssg", "ssh", "ssi", "ssj", "ssk", "ssl", "ssm", "ssn", "sso", "ssp", "ssq", "ssr", "sss", "sst", "ssu", "ssv", "ssx", "ssy", "ssz", "st", "sta", "stb", "std", "ste", "stf", "stg", "sth", "sti", "stj", "stk", "stl", "stm", "stn", "sto", "stp", "stq", "str", "sts", "stt", "stu", "stv", "stw", "sty", "su", "sua", "sub", "suc", "sue", "sug", "sui", "suj", "suk", "sul", "sum", "suq", "sur", "sus", "sut", "suv", "suw", "sux", "suy", "suz", "sv", "sva", "svb", "svc", "sve", "svk", "svm", "svr", "svs", "svx", "sw", "swb", "swc", "swf", "swg", "swh", "swi", "swj", "swk", "swl", "swm", "swn", "swo", "swp", "swq", "swr", "sws", "swt", "swu", "swv", "sww", "swx", "swy", "sxb", "sxc", "sxe", "sxg", "sxk", "sxl", "sxm", "sxn", "sxo", "sxr", "sxs", "sxu", "sxw", "sya", "syb", "syc", "syd", "syi", "syk", "syl", "sym", "syn", "syo", "syr", "sys", "syw", "syx", "syy", "sza", "szb", "szc", "szd", "sze", "szg", "szl", "szn", "szp", "szs", "szv", "szw", "szy", "ta", "taa", "tab", "tac", "tad", "tae", "taf", "tag", "tai", "taj", "tak", "tal", "tan", "tao", "tap", "taq", "tar", "tas", "tau", "tav", "taw", "tax", "tay", "taz", "tba", "tbb", "tbc", "tbd", "tbe", "tbf", "tbg", "tbh", "tbi", "tbj", "tbk", "tbl", "tbm", "tbn", "tbo", "tbp", "tbq", "tbr", "tbs", "tbt", "tbu", "tbv", "tbw", "tbx", "tby", "tbz", "tca", "tcb", "tcc", "tcd", "tce", "tcf", "tcg", "tch", "tci", "tck", "tcl", "tcm", "tcn", "tco", "tcp", "tcq", "tcs", "tct", "tcu", "tcw", "tcx", "tcy", "tcz", "tda", "tdb", "tdc", "tdd", "tde", "tdf", "tdg", "tdh", "tdi", "tdj", "tdk", "tdl", "tdm", "tdn", "tdo", "tdq", "tdr", "tds", "tdt", "tdu", "tdv", "tdx", "tdy", "te", "tea", "teb", "tec", "ted", "tee", "tef", "teg", "teh", "tei", "tek", "tem", "ten", "teo", "tep", "teq", "ter", "tes", "tet", "teu", "tev", "tew", "tex", "tey", "tez", "tfi", "tfn", "tfo", "tfr", "tft", "tg", "tga", "tgb", "tgc", "tgd", "tge", "tgf", "tgg", "tgh", "tgi", "tgj", "tgn", "tgo", "tgp", "tgq", "tgr", "tgs", "tgt", "tgu", "tgv", "tgw", "tgx", "tgy", "tgz", "th", "thc", "thd", "the", "thf", "thh", "thi", "thk", "thl", "thm", "thn", "thp", "thq", "thr", "ths", "tht", "thu", "thv", "thw", "thx", "thy", "thz", "ti", "tia", "tic", "tid", "tie", "tif", "tig", "tih", "tii", "tij", "tik", "til", "tim", "tin", "tio", "tip", "tiq", "tis", "tit", "tiu", "tiv", "tiw", "tix", "tiy", "tiz", "tja", "tjg", "tji", "tjj", "tjl", "tjm", "tjn", "tjo", "tjp", "tjs", "tju", "tjw", "tk", "tka", "tkb", "tkd", "tke", "tkf", "tkg", "tkk", "tkl", "tkm", "tkn", "tkp", "tkq", "tkr", "tks", "tkt", "tku", "tkv", "tkw", "tkx", "tkz", "tl", "tla", "tlb", "tlc", "tld", "tlf", "tlg", "tlh", "tli", "tlj", "tlk", "tll", "tlm", "tln", "tlo", "tlp", "tlq", "tlr", "tls", "tlt", "tlu", "tlv", "tlw", "tlx", "tly", "tma", "tmb", "tmc", "tmd", "tme", "tmf", "tmg", "tmh", "tmi", "tmj", "tmk", "tml", "tmm", "tmn", "tmo", "tmp", "tmq", "tmr", "tms", "tmt", "tmu", "tmv", "tmw", "tmy", "tmz", "tn", "tna", "tnb", "tnc", "tnd", "tne", "tnf", "tng", "tnh", "tni", "tnk", "tnl", "tnm", "tnn", "tno", "tnp", "tnq", "tnr", "tns", "tnt", "tnu", "tnv", "tnw", "tnx", "tny", "tnz", "to", "tob", "toc", "tod", "toe", "tof", "tog", "toh", "toi", "toj", "tol", "tom", "too", "top", "toq", "tor", "tos", "tou", "tov", "tow", "tox", "toy", "toz", "tpa", "tpc", "tpe", "tpf", "tpg", "tpi", "tpj", "tpk", "tpl", "tpm", "tpn", "tpo", "tpp", "tpq", "tpr", "tpt", "tpu", "tpv", "tpw", "tpx", "tpy", "tpz", "tqb", "tql", "tqm", "tqn", "tqo", "tqp", "tqq", "tqr", "tqt", "tqu", "tqw", "tr", "tra", "trb", "trc", "trd", "tre", "trf", "trg", "trh", "tri", "trj", "trk", "trl", "trm", "trn", "tro", "trp", "trq", "trr", "trs", "trt", "tru", "trv", "trw", "trx", "try", "trz", "ts", "tsa", "tsb", "tsc", "tsd", "tse", "tsf", "tsg", "tsh", "tsi", "tsj", "tsk", "tsl", "tsm", "tsp", "tsq", "tsr", "tss", "tst", "tsu", "tsv", "tsw", "tsx", "tsy", "tsz", "tt", "tta", "ttb", "ttc", "ttd", "tte", "ttf", "ttg", "tth", "tti", "ttj", "ttk", "ttl", "ttm", "ttn", "tto", "ttp", "ttq", "ttr", "tts", "ttt", "ttu", "ttv", "ttw", "tty", "ttz", "tua", "tub", "tuc", "tud", "tue", "tuf", "tug", "tuh", "tui", "tuj", "tul", "tum", "tun", "tuo", "tup", "tuq", "tus", "tut", "tuu", "tuv", "tuw", "tux", "tuy", "tuz", "tva", "tvd", "tve", "tvk", "tvl", "tvm", "tvn", "tvo", "tvs", "tvt", "tvu", "tvw", "tvx", "tvy", "tw", "twa", "twb", "twc", "twd", "twe", "twf", "twg", "twh", "twl", "twm", "twn", "two", "twp", "twq", "twr", "twt", "twu", "tww", "twx", "twy", "txa", "txb", "txc", "txe", "txg", "txh", "txi", "txj", "txm", "txn", "txo", "txq", "txr", "txs", "txt", "txu", "txx", "txy", "ty", "tya", "tye", "tyh", "tyi", "tyj", "tyl", "tyn", "typ", "tyr", "tys", "tyt", "tyu", "tyv", "tyx", "tyz", "tza", "tzh", "tzj", "tzl", "tzm", "tzn", "tzo", "tzx", "uam", "uan", "uar", "uba", "ubi", "ubl", "ubr", "ubu", "uby", "uda", "ude", "udg", "udi", "udj", "udl", "udm", "udu", "ues", "ufi", "ug", "uga", "ugb", "uge", "ugn", "ugo", "ugy", "uha", "uhn", "uis", "uiv", "uji", "uk", "uka", "ukg", "ukh", "ukk", "ukl", "ukp", "ukq", "uks", "uku", "ukw", "uky", "ula", "ulb", "ulc", "ule", "ulf", "uli", "ulk", "ull", "ulm", "uln", "ulu", "ulw", "uma", "umb", "umc", "umd", "umg", "umi", "umm", "umn", "umo", "ump", "umr", "ums", "umu", "una", "und", "une", "ung", "unk", "unm", "unn", "unp", "unr", "unu", "unx", "unz", "uok", "upi", "upv", "ur", "ura", "urb", "urc", "ure", "urf", "urg", "urh", "uri", "urj", "urk", "url", "urm", "urn", "uro", "urp", "urr", "urt", "uru", "urv", "urw", "urx", "ury", "urz", "usa", "ush", "usi", "usk", "usp", "uss", "usu", "uta", "ute", "uth", "utp", "utr", "utu", "uum", "uun", "uur", "uuu", "uve", "uvh", "uvl", "uwa", "uya", "uz", "uzn", "uzs", "vaa", "vae", "vaf", "vag", "vah", "vai", "vaj", "val", "vam", "van", "vao", "vap", "var", "vas", "vau", "vav", "vay", "vbb", "vbk", "ve", "vec", "ved", "vel", "vem", "veo", "vep", "ver", "vgr", "vgt", "vi", "vic", "vid", "vif", "vig", "vil", "vin", "vis", "vit", "viv", "vka", "vki", "vkj", "vkk", "vkl", "vkm", "vko", "vkp", "vkt", "vku", "vlp", "vls", "vma", "vmb", "vmc", "vmd", "vme", "vmf", "vmg", "vmh", "vmi", "vmj", "vmk", "vml", "vmm", "vmp", "vmq", "vmr", "vms", "vmu", "vmv", "vmw", "vmx", "vmy", "vmz", "vnk", "vnm", "vnp", "vo", "vor", "vot", "vra", "vro", "vrs", "vrt", "vsi", "vsl", "vsv", "vto", "vum", "vun", "vut", "vwa", "wa", "waa", "wab", "wac", "wad", "wae", "waf", "wag", "wah", "wai", "waj", "wak", "wal", "wam", "wan", "wao", "wap", "waq", "war", "was", "wat", "wau", "wav", "waw", "wax", "way", "waz", "wba", "wbb", "wbe", "wbf", "wbh", "wbi", "wbj", "wbk", "wbl", "wbm", "wbp", "wbq", "wbr", "wbs", "wbt", "wbv", "wbw", "wca", "wci", "wdd", "wdg", "wdj", "wdk", "wdu", "wdy", "wea", "wec", "wed", "weg", "weh", "wei", "wem", "wen", "weo", "wep", "wer", "wes", "wet", "weu", "wew", "wfg", "wga", "wgb", "wgg", "wgi", "wgo", "wgu", "wgw", "wgy", "wha", "whg", "whk", "whu", "wib", "wic", "wie", "wif", "wig", "wih", "wii", "wij", "wik", "wil", "wim", "win", "wir", "wit", "wiu", "wiv", "wiw", "wiy", "wja", "wji", "wka", "wkb", "wkd", "wkl", "wkr", "wku", "wkw", "wky", "wla", "wlc", "wle", "wlg", "wli", "wlk", "wll", "wlm", "wlo", "wlr", "wls", "wlu", "wlv", "wlw", "wlx", "wly", "wma", "wmb", "wmc", "wmd", "wme", "wmh", "wmi", "wmm", "wmn", "wmo", "wms", "wmt", "wmw", "wmx", "wnb", "wnc", "wnd", "wne", "wng", "wni", "wnk", "wnm", "wnn", "wno", "wnp", "wnu", "wnw", "wny", "wo", "woa", "wob", "woc", "wod", "woe", "wof", "wog", "woi", "wok", "wom", "won", "woo", "wor", "wos", "wow", "woy", "wpc", "wra", "wrb", "wrd", "wrg", "wrh", "wri", "wrk", "wrl", "wrm", "wrn", "wro", "wrp", "wrr", "wrs", "wru", "wrv", "wrw", "wrx", "wry", "wrz", "wsa", "wsg", "wsi", "wsk", "wsr", "wss", "wsu", "wsv", "wtf", "wth", "wti", "wtk", "wtm", "wtw", "wua", "wub", "wud", "wuh", "wul", "wum", "wun", "wur", "wut", "wuu", "wuv", "wux", "wuy", "wwa", "wwb", "wwo", "wwr", "www", "wxa", "wxw", "wya", "wyb", "wyi", "wym", "wyr", "wyy", "xaa", "xab", "xac", "xad", "xae", "xag", "xai", "xaj", "xak", "xal", "xam", "xan", "xao", "xap", "xaq", "xar", "xas", "xat", "xau", "xav", "xaw", "xay", "xba", "xbb", "xbc", "xbd", "xbe", "xbg", "xbi", "xbj", "xbm", "xbn", "xbo", "xbp", "xbr", "xbw", "xbx", "xby", "xcb", "xcc", "xce", "xcg", "xch", "xcl", "xcm", "xcn", "xco", "xcr", "xct", "xcu", "xcv", "xcw", "xcy", "xda", "xdc", "xdk", "xdm", "xdo", "xdy", "xeb", "xed", "xeg", "xel", "xem", "xep", "xer", "xes", "xet", "xeu", "xfa", "xga", "xgb", "xgd", "xgf", "xgg", "xgi", "xgl", "xgm", "xgn", "xgr", "xgu", "xgw", "xh", "xha", "xhc", "xhd", "xhe", "xhr", "xht", "xhu", "xhv", "xia", "xib", "xii", "xil", "xin", "xip", "xir", "xis", "xiv", "xiy", "xjb", "xjt", "xka", "xkb", "xkc", "xkd", "xke", "xkf", "xkg", "xkh", "xki", "xkj", "xkk", "xkl", "xkn", "xko", "xkp", "xkq", "xkr", "xks", "xkt", "xku", "xkv", "xkw", "xkx", "xky", "xkz", "xla", "xlb", "xlc", "xld", "xle", "xlg", "xli", "xln", "xlo", "xlp", "xls", "xlu", "xly", "xma", "xmb", "xmc", "xmd", "xme", "xmf", "xmg", "xmh", "xmj", "xmk", "xml", "xmm", "xmn", "xmo", "xmp", "xmq", "xmr", "xms", "xmt", "xmu", "xmv", "xmw", "xmx", "xmy", "xmz", "xna", "xnb", "xnd", "xng", "xnh", "xni", "xnk", "xnn", "xno", "xnr", "xns", "xnt", "xnu", "xny", "xnz", "xoc", "xod", "xog", "xoi", "xok", "xom", "xon", "xoo", "xop", "xor", "xow", "xpa", "xpc", "xpe", "xpg", "xpi", "xpj", "xpk", "xpm", "xpn", "xpo", "xpp", "xpq", "xpr", "xps", "xpt", "xpu", "xpy", "xqa", "xqt", "xra", "xrb", "xrd", "xre", "xrg", "xri", "xrm", "xrn", "xrq", "xrr", "xrt", "xru", "xrw", "xsa", "xsb", "xsc", "xsd", "xse", "xsh", "xsi", "xsj", "xsl", "xsm", "xsn", "xso", "xsp", "xsq", "xsr", "xss", "xsu", "xsv", "xsy", "xta", "xtb", "xtc", "xtd", "xte", "xtg", "xth", "xti", "xtj", "xtl", "xtm", "xtn", "xto", "xtp", "xtq", "xtr", "xts", "xtt", "xtu", "xtv", "xtw", "xty", "xtz", "xua", "xub", "xud", "xug", "xuj", "xul", "xum", "xun", "xuo", "xup", "xur", "xut", "xuu", "xve", "xvi", "xvn", "xvo", "xvs", "xwa", "xwc", "xwd", "xwe", "xwg", "xwj", "xwk", "xwl", "xwo", "xwr", "xwt", "xww", "xxb", "xxk", "xxm", "xxr", "xxt", "xya", "xyb", "xyj", "xyk", "xyl", "xyt", "xyy", "xzh", "xzm", "xzp", "yaa", "yab", "yac", "yad", "yae", "yaf", "yag", "yah", "yai", "yaj", "yak", "yal", "yam", "yan", "yao", "yap", "yaq", "yar", "yas", "yat", "yau", "yav", "yaw", "yax", "yay", "yaz", "yba", "ybb", "ybd", "ybe", "ybh", "ybi", "ybj", "ybk", "ybl", "ybm", "ybn", "ybo", "ybx", "yby", "ych", "ycl", "ycn", "ycp", "yda", "ydd", "yde", "ydg", "ydk", "yds", "yea", "yec", "yee", "yei", "yej", "yel", "yen", "yer", "yes", "yet", "yeu", "yev", "yey", "yga", "ygi", "ygl", "ygm", "ygp", "ygr", "ygs", "ygu", "ygw", "yha", "yhd", "yhl", "yhs", "yi", "yia", "yif", "yig", "yih", "yii", "yij", "yik", "yil", "yim", "yin", "yip", "yiq", "yir", "yis", "yit", "yiu", "yiv", "yix", "yiy", "yiz", "yka", "ykg", "yki", "ykk", "ykl", "ykm", "ykn", "yko", "ykr", "ykt", "yku", "yky", "yla", "ylb", "yle", "ylg", "yli", "yll", "ylm", "yln", "ylo", "ylr", "ylu", "yly", "yma", "ymb", "ymc", "ymd", "yme", "ymg", "ymh", "ymi", "ymk", "yml", "ymm", "ymn", "ymo", "ymp", "ymq", "ymr", "yms", "ymt", "ymx", "ymz", "yna", "ynd", "yne", "yng", "ynh", "ynk", "ynl", "ynn", "yno", "ynq", "yns", "ynu", "yo", "yob", "yog", "yoi", "yok", "yol", "yom", "yon", "yos", "yot", "yox", "yoy", "ypa", "ypb", "ypg", "yph", "ypk", "ypm", "ypn", "ypo", "ypp", "ypz", "yra", "yrb", "yre", "yri", "yrk", "yrl", "yrm", "yrn", "yro", "yrs", "yrw", "yry", "ysc", "ysd", "ysg", "ysl", "ysn", "yso", "ysp", "ysr", "yss", "ysy", "yta", "ytl", "ytp", "ytw", "yty", "yua", "yub", "yuc", "yud", "yue", "yuf", "yug", "yui", "yuj", "yuk", "yul", "yum", "yun", "yup", "yuq", "yur", "yut", "yuu", "yuw", "yux", "yuy", "yuz", "yva", "yvt", "ywa", "ywg", "ywl", "ywn", "ywq", "ywr", "ywt", "ywu", "yww", "yxa", "yxg", "yxl", "yxm", "yxu", "yxy", "yyr", "yyu", "yyz", "yzg", "yzk", "za", "zaa", "zab", "zac", "zad", "zae", "zaf", "zag", "zah", "zai", "zaj", "zak", "zal", "zam", "zao", "zap", "zaq", "zar", "zas", "zat", "zau", "zav", "zaw", "zax", "zay", "zaz", "zbc", "zbe", "zbl", "zbt", "zbw", "zca", "zch", "zdj", "zea", "zeg", "zeh", "zen", "zga", "zgb", "zgh", "zgm", "zgn", "zgr", "zh", "zhb", "zhd", "zhi", "zhn", "zhw", "zhx", "zia", "zib", "zik", "zil", "zim", "zin", "zir", "ziw", "ziz", "zka", "zkb", "zkd", "zkg", "zkh", "zkk", "zkn", "zko", "zkp", "zkr", "zkt", "zku", "zkv", "zkz", "zle", "zlj", "zlm", "zln", "zlq", "zls", "zlw", "zma", "zmb", "zmc", "zmd", "zme", "zmf", "zmg", "zmh", "zmi", "zmj", "zmk", "zml", "zmm", "zmn", "zmo", "zmp", "zmq", "zmr", "zms", "zmt", "zmu", "zmv", "zmw", "zmx", "zmy", "zmz", "zna", "znd", "zne", "zng", "znk", "zns", "zoc", "zoh", "zom", "zoo", "zoq", "zor", "zos", "zpa", "zpb", "zpc", "zpd", "zpe", "zpf", "zpg", "zph", "zpi", "zpj", "zpk", "zpl", "zpm", "zpn", "zpo", "zpp", "zpq", "zpr", "zps", "zpt", "zpu", "zpv", "zpw", "zpx", "zpy", "zpz", "zqe", "zra", "zrg", "zrn", "zro", "zrp", "zrs", "zsa", "zsk", "zsl", "zsm", "zsr", "zsu", "zte", "ztg", "ztl", "ztm", "ztn", "ztp", "ztq", "zts", "ztt", "ztu", "ztx", "zty", "zu", "zua", "zuh", "zum", "zun", "zuy", "zwa", "zxx", "zyb", "zyg", "zyj", "zyn", "zyp", "zza", "zzj"];
  var extlang = ["aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "aed", "aen", "afb", "afg", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "ase", "asf", "asp", "asq", "asw", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "bfi", "bfk", "bjn", "bog", "bqn", "bqy", "btj", "bve", "bvl", "bvu", "bzs", "cdo", "cds", "cjy", "cmn", "coa", "cpx", "csc", "csd", "cse", "csf", "csg", "csl", "csn", "csq", "csr", "czh", "czo", "doq", "dse", "dsl", "dup", "ecs", "esl", "esn", "eso", "eth", "fcs", "fse", "fsl", "fss", "gan", "gds", "gom", "gse", "gsg", "gsm", "gss", "gus", "hab", "haf", "hak", "hds", "hji", "hks", "hos", "hps", "hsh", "hsl", "hsn", "icl", "iks", "ils", "inl", "ins", "ise", "isg", "isr", "jak", "jax", "jcs", "jhs", "jls", "jos", "jsl", "jus", "kgi", "knn", "kvb", "kvk", "kvr", "kxd", "lbs", "lce", "lcf", "liw", "lls", "lsg", "lsl", "lsn", "lso", "lsp", "lst", "lsv", "lsy", "ltg", "lvs", "lws", "lzh", "max", "mdl", "meo", "mfa", "mfb", "mfs", "min", "mnp", "mqg", "mre", "msd", "msi", "msr", "mui", "mzc", "mzg", "mzy", "nan", "nbs", "ncs", "nsi", "nsl", "nsp", "nsr", "nzs", "okl", "orn", "ors", "pel", "pga", "pgz", "pks", "prl", "prz", "psc", "psd", "pse", "psg", "psl", "pso", "psp", "psr", "pys", "rms", "rsi", "rsl", "rsm", "sdl", "sfb", "sfs", "sgg", "sgx", "shu", "slf", "sls", "sqk", "sqs", "ssh", "ssp", "ssr", "svk", "swc", "swh", "swl", "syy", "szs", "tmw", "tse", "tsm", "tsq", "tss", "tsy", "tza", "ugn", "ugy", "ukl", "uks", "urk", "uzn", "uzs", "vgt", "vkk", "vkt", "vsi", "vsl", "vsv", "wbs", "wuu", "xki", "xml", "xmm", "xms", "yds", "ygs", "yhs", "ysl", "yue", "zib", "zlm", "zmi", "zsl", "zsm"];
  var grandfathered = ["art-lojban", "cel-gaulish", "en-gb-oed", "i-ami", "i-bnn", "i-default", "i-enochian", "i-hak", "i-klingon", "i-lux", "i-mingo", "i-navajo", "i-pwn", "i-tao", "i-tay", "i-tsu", "no-bok", "no-nyn", "sgn-be-fr", "sgn-be-nl", "sgn-ch-de", "zh-guoyu", "zh-hakka", "zh-min", "zh-min-nan", "zh-xiang"];
  var region = ["001", "002", "003", "005", "009", "011", "013", "014", "015", "017", "018", "019", "021", "029", "030", "034", "035", "039", "053", "054", "057", "061", "142", "143", "145", "150", "151", "154", "155", "202", "419", "aa", "ac", "ad", "ae", "af", "ag", "ai", "al", "am", "an", "ao", "aq", "ar", "as", "at", "au", "aw", "ax", "az", "ba", "bb", "bd", "be", "bf", "bg", "bh", "bi", "bj", "bl", "bm", "bn", "bo", "bq", "br", "bs", "bt", "bu", "bv", "bw", "by", "bz", "ca", "cc", "cd", "cf", "cg", "ch", "ci", "ck", "cl", "cm", "cn", "co", "cp", "cr", "cs", "cu", "cv", "cw", "cx", "cy", "cz", "dd", "de", "dg", "dj", "dk", "dm", "do", "dz", "ea", "ec", "ee", "eg", "eh", "er", "es", "et", "eu", "ez", "fi", "fj", "fk", "fm", "fo", "fr", "fx", "ga", "gb", "gd", "ge", "gf", "gg", "gh", "gi", "gl", "gm", "gn", "gp", "gq", "gr", "gs", "gt", "gu", "gw", "gy", "hk", "hm", "hn", "hr", "ht", "hu", "ic", "id", "ie", "il", "im", "in", "io", "iq", "ir", "is", "it", "je", "jm", "jo", "jp", "ke", "kg", "kh", "ki", "km", "kn", "kp", "kr", "kw", "ky", "kz", "la", "lb", "lc", "li", "lk", "lr", "ls", "lt", "lu", "lv", "ly", "ma", "mc", "md", "me", "mf", "mg", "mh", "mk", "ml", "mm", "mn", "mo", "mp", "mq", "mr", "ms", "mt", "mu", "mv", "mw", "mx", "my", "mz", "na", "nc", "ne", "nf", "ng", "ni", "nl", "no", "np", "nr", "nt", "nu", "nz", "om", "pa", "pe", "pf", "pg", "ph", "pk", "pl", "pm", "pn", "pr", "ps", "pt", "pw", "py", "qa", "re", "ro", "rs", "ru", "rw", "sa", "sb", "sc", "sd", "se", "sg", "sh", "si", "sj", "sk", "sl", "sm", "sn", "so", "sr", "ss", "st", "su", "sv", "sx", "sy", "sz", "ta", "tc", "td", "tf", "tg", "th", "tj", "tk", "tl", "tm", "tn", "to", "tp", "tr", "tt", "tv", "tw", "tz", "ua", "ug", "um", "un", "us", "uy", "uz", "va", "vc", "ve", "vg", "vi", "vn", "vu", "wf", "ws", "yd", "ye", "yt", "yu", "za", "zm", "zr", "zw", "zz"];
  var script = ["adlm", "afak", "aghb", "ahom", "arab", "aran", "armi", "armn", "avst", "bali", "bamu", "bass", "batk", "beng", "bhks", "blis", "bopo", "brah", "brai", "bugi", "buhd", "cakm", "cans", "cari", "cham", "cher", "chrs", "cirt", "copt", "cpmn", "cprt", "cyrl", "cyrs", "deva", "diak", "dogr", "dsrt", "dupl", "egyd", "egyh", "egyp", "elba", "elym", "ethi", "geok", "geor", "glag", "gong", "gonm", "goth", "gran", "grek", "gujr", "guru", "hanb", "hang", "hani", "hano", "hans", "hant", "hatr", "hebr", "hira", "hluw", "hmng", "hmnp", "hrkt", "hung", "inds", "ital", "jamo", "java", "jpan", "jurc", "kali", "kana", "khar", "khmr", "khoj", "kitl", "kits", "knda", "kore", "kpel", "kthi", "lana", "laoo", "latf", "latg", "latn", "leke", "lepc", "limb", "lina", "linb", "lisu", "loma", "lyci", "lydi", "mahj", "maka", "mand", "mani", "marc", "maya", "medf", "mend", "merc", "mero", "mlym", "modi", "mong", "moon", "mroo", "mtei", "mult", "mymr", "nand", "narb", "nbat", "newa", "nkdb", "nkgb", "nkoo", "nshu", "ogam", "olck", "orkh", "orya", "osge", "osma", "palm", "pauc", "perm", "phag", "phli", "phlp", "phlv", "phnx", "piqd", "plrd", "prti", "rjng", "rohg", "roro", "runr", "samr", "sara", "sarb", "saur", "sgnw", "shaw", "shrd", "shui", "sidd", "sind", "sinh", "sogd", "sogo", "sora", "soyo", "sund", "sylo", "syrc", "syre", "syrj", "syrn", "tagb", "takr", "tale", "talu", "taml", "tang", "tavt", "telu", "teng", "tfng", "tglg", "thaa", "thai", "tibt", "tirh", "ugar", "vaii", "visp", "wara", "wcho", "wole", "xpeo", "xsux", "yezi", "yiii", "zanb", "zinh", "zmth", "zsye", "zsym", "zxxx", "zyyy", "zzzz"];
  var variant = ["1606nict", "1694acad", "1901", "1959acad", "1994", "1996", "abl1943", "akuapem", "alalc97", "aluku", "ao1990", "aranes", "arevela", "arevmda", "asante", "auvern", "baku1926", "balanka", "barla", "basiceng", "bauddha", "biscayan", "biske", "bohoric", "boont", "bornholm", "cisaup", "colb1945", "cornu", "creiss", "dajnko", "ekavsk", "emodeng", "fonipa", "fonkirsh", "fonnapa", "fonupa", "fonxsamp", "gascon", "grclass", "grital", "grmistr", "hepburn", "heploc", "hognorsk", "hsistemo", "ijekavsk", "itihasa", "ivanchov", "jauer", "jyutping", "kkcor", "kociewie", "kscor", "laukika", "lemosin", "lengadoc", "lipaw", "luna1918", "metelko", "monoton", "ndyuka", "nedis", "newfound", "nicard", "njiva", "nulik", "osojs", "oxendict", "pahawh2", "pahawh3", "pahawh4", "pamaka", "petr1708", "pinyin", "polyton", "provenc", "puter", "rigik", "rozaj", "rumgr", "scotland", "scouse", "simple", "solba", "sotav", "spanglis", "surmiran", "sursilv", "sutsilv", "tarask", "uccor", "ucrcor", "ulster", "unifon", "vaidika", "valencia", "vallader", "vivaraup", "wadegile", "xsistemo"];

  function isRegExp(something) {
    return something instanceof RegExp;
  }

  function includes(arr, whatToMatch) {
    if (!Array.isArray(arr) || !arr.length) {
      return false;
    }

    return arr.some(val => isRegExp(val) && whatToMatch.match(val) || typeof val === "string" && whatToMatch === val);
  }

  function isLangCode(str) {
    if (typeof str !== "string") {
      return {
        res: false,
        message: `Not a string given.`
      };
    } else if (!str.trim().length) {
      return {
        res: false,
        message: `Empty language tag string given.`
      };
    }

    const r1 = /^[a-z0-9]{1,8}(-[a-z0-9]{1,8})*$/gi;
    const r2 = /^q[a-t][a-z]$/gi;
    language.push(r2);
    const r3 = /^qa[a-b][a-x]$/gi;
    script.push(r3);
    const r4 = /^q[m-z]$/gi;
    region.push(r4);
    const r5 = /^x[a-z]$/gi;
    region.push(r5);
    const singletonRegex = /^[0-9a-wy-z]$/gi;

    if (!str.match(r1)) {
      return {
        res: false,
        message: `Does not resemble a language tag.`
      };
    }

    if (includes(grandfathered, str)) {
      return {
        res: true,
        message: null
      };
    }

    const split = str.toLowerCase().split("-");
    let type;
    let languageMatched = false;
    let scriptMatched = false;
    let regionMatched = false;
    let variantMatched = false;
    let extlangMatched = false;
    let allOK;
    const variantGathered = [];
    const singletonGathered = [];

    for (let i = 0, len = split.length; i < len; i++) {
      allOK = false;

      if (i === 0) {
        type = split[0] === "x" ? "private" : "normal";
      }

      if (split[i] === "x") {
        if (!split[i + 1]) {
          return {
            res: false,
            message: `Ends with private use subtag, "x".`
          };
        }

        return {
          res: true,
          message: null
        };
      }

      if (regionMatched && region.includes(split[i])) {
        return {
          res: false,
          message: `Two region subtags, "${regionMatched}" and "${split[i]}".`
        };
      }

      if (i === 0) {
        if (type === "normal") {
          if (includes(language, split[i])) {
            languageMatched = split[i];
            allOK = true;
          }
        }
      } else if (i === 1) {
        if (type === "normal") {
          if (includes(script, split[i])) {
            scriptMatched = split[i];
            allOK = true;
          } else if (includes(extlang, split[i])) {
            extlangMatched = split[i];
            allOK = true;
          } else if (includes(region, split[i])) {
            regionMatched = split[i];
            allOK = true;
          } else if (includes(variant, split[i])) {
            variantMatched = split[i];
            allOK = true;

            if (!variantGathered.includes(split[i])) {
              variantGathered.push(split[i]);
            } else {
              return {
                res: false,
                message: `Repeated variant subtag, "${split[i]}".`
              };
            }
          }
        }
      } else if (i === 2) {
        if (type === "normal") {
          if (languageMatched && extlangMatched) {
            if (includes(script, split[i])) {
              scriptMatched = split[i];
              allOK = true;
            } else if (includes(region, split[i])) {
              regionMatched = split[i];
              allOK = true;
            }
          } else if (languageMatched && scriptMatched) {
            if (includes(region, split[i])) {
              regionMatched = split[i];
              allOK = true;
            }
          } else if (languageMatched && regionMatched) {
            if (includes(variant, split[i])) {
              variantMatched = split[i];
              allOK = true;

              if (!variantGathered.includes(split[i])) {
                variantGathered.push(split[i]);
              } else {
                return {
                  res: false,
                  message: `Repeated variant subtag, "${split[i]}".`
                };
              }
            }
          }
        }
      } else if (i === 3) {
        if (type === "normal") {
          if (languageMatched && extlangMatched && scriptMatched) {
            if (includes(region, split[i])) {
              regionMatched = split[i];
              allOK = true;
            }
          } else if (languageMatched && scriptMatched && regionMatched) {
            if (includes(variant, split[i])) {
              variantMatched = split[i];
              allOK = true;
            }
          }
        }
      }

      if (split[i].match(singletonRegex)) {
        if (i === 0) {
          return {
            res: false,
            message: `Starts with singleton, "${split[i]}".`
          };
        }

        if (!languageMatched) {
          return {
            res: false,
            message: `Extension must follow at least a primary language subtag.`
          };
        }

        if (!singletonGathered.includes(split[i])) {
          singletonGathered.push(split[i]);
        } else {
          return {
            res: false,
            message: `Two extensions with same single-letter prefix "${split[i]}".`
          };
        }

        if (split[i + 1]) {
          if (!split[i + 1].match(singletonRegex)) {
            allOK = true;
            extlangMatched = split[i];
            i++;
            continue;
          } else {
            return {
              res: false,
              message: `Multiple singleton sequence "${split[i]}", "${split[i + 1]}".`
            };
          }
        } else {
          return {
            res: false,
            message: `Ends with singleton, "${split[i]}".`
          };
        }
      }

      if (!allOK && variantMatched && includes(variant, split[i])) {
        if (i && includes(variant, split[i - 1])) {
          if (!variantGathered.includes(split[i])) {
            variantGathered.push(split[i]);
          } else {
            return {
              res: false,
              message: `Repeated variant subtag, "${split[i]}".`
            };
          }

          allOK = true;
        } else {
          variantGathered.push(split[i]);
          return {
            res: false,
            message: `Variant subtags ${variantGathered.map(val => `"${val}"`).join(", ")}  not in a sequence.`
          };
        }
      }

      if (!allOK && languageMatched && extlangMatched) {
        if (split[i].length > 1) {
          allOK = true;
        }
      }

      if (!allOK) {
        return {
          res: false,
          message: `Unrecognised language subtag, "${split[i]}".`
        };
      }
    }

    return {
      res: true,
      message: null
    };
  }

  // rule: attribute-validate-hreflang

  function attributeValidateHreflang(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "hreflang") {
          // validate the parent
          if (!["a", "link"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-hreflang",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // beware, the charStart and charEnd are not offset, their "zero" is
          // start of an attribute's value, so if you use them, you need to
          // offset to the true index, you must add "node.attribValueStartsAt" value


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr; // validate using "ietf-language-tag-regex" from npm:


          var _isLangCode = isLangCode(node.attribValue.slice(charStart, charEnd)),
              message = _isLangCode.message;

          if (message) {
            errorArr.push({
              idxFrom: node.attribValueStartsAt + charStart,
              idxTo: node.attribValueStartsAt + charEnd,
              message: message,
              fix: null
            });
          }

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-hreflang"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-hspace

  function attributeValidateHspace(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateHspace(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "hspace") {
          // validate the parent
          if (!["applet", "img", "object"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-hspace",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            theOnlyGoodUnits: [],
            // all units are bad, value is in px which is omitted
            noUnitsIsFine: true
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-hspace"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-http-equiv

  function attributeValidateHttpequiv(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "http-equiv") {
          // validate the parent
          if (node.parent.tagName !== "meta") {
            context.report({
              ruleId: "attribute-validate-http-equiv",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["content-type", "default-style", "refresh", "X-UA-Compatible"],
            canBeCommaSeparated: false,
            caseInsensitive: true
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-http-equiv"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-id

  function attributeValidateId(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "id") {
          // validate the parent
          if (["base", "head", "html", "meta", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-id",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
                charStart = _checkForWhitespace.charStart,
                charEnd = _checkForWhitespace.charEnd,
                errorArr = _checkForWhitespace.errorArr;

            checkClassOrIdValue(context.str, {
              typeName: node.attribName,
              // class|id|for
              from: node.attribValueStartsAt + charStart,
              to: node.attribValueStartsAt + charEnd,
              offset: 0
            }, errorArr // might be mutated, more errors pushed into
            );
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-id"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-ismap

  function attributeValidateIsmap(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "ismap") {
          // validate the parent
          if (!["img", "input"].includes(node.parent.tagName)) {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-ismap"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-label

  function attributeValidateLabel(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "label") {
          // validate the parent
          if (!["option", "optgroup"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-label",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-label"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-lang

  function attributeValidateLang(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "lang") {
          // validate the parent
          if (["applet", "base", "basefont", "br", "frame", "frameset", "iframe", "param", "script"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-lang",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // beware, the charStart and charEnd are not offset, their "zero" is
          // start of an attribute's value, so if you use them, you need to
          // offset to the true index, you must add "node.attribValueStartsAt" value


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr; // validate using "is-language-code" from npm:


          var _isLangCode = isLangCode(node.attribValue.slice(charStart, charEnd)),
              message = _isLangCode.message;

          if (message) {
            errorArr.push({
              idxFrom: node.attribValueStartsAt + charStart,
              idxTo: node.attribValueStartsAt + charEnd,
              message: message,
              fix: null
            });
          }

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-lang"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-language

  function attributeValidateLanguage(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "language") {
          // validate the parent
          if (node.parent.tagName !== "script") {
            context.report({
              ruleId: "attribute-validate-language",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-language"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-link

  function attributeValidateLink(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateLink(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "link") {
          // validate the parent
          if (node.parent.tagName !== "body") {
            context.report({
              ruleId: "attribute-validate-link",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateColor(node.attribValue, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-link"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-longdesc

  function attributeValidateLongdesc(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "longdesc") {
          // validate the parent
          if (!["img", "frame", "iframe"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-longdesc",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace -
          // TODO - add more rules, https://www.w3schools.com/TagS/att_img_longdesc.asp


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-longdesc"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-marginheight

  function attributeValidateMarginheight(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateMarginheight(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "marginheight") {
          // validate the parent
          if (!["frame", "iframe"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-marginheight",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            theOnlyGoodUnits: [],
            // all units are bad, value is in px which is omitted
            noUnitsIsFine: true
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-marginheight"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-marginwidth

  function attributeValidateMarginwidth(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateMarginwidth(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "marginwidth") {
          // validate the parent
          if (!["frame", "iframe"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-marginwidth",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            theOnlyGoodUnits: [],
            // all units are bad, value is in px which is omitted
            noUnitsIsFine: true
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-marginwidth"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-maxlength

  function attributeValidateMaxlength(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateMaxlength(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "maxlength") {
          // validate the parent
          if (node.parent.tagName !== "input") {
            context.report({
              ruleId: "attribute-validate-maxlength",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            theOnlyGoodUnits: [],
            customGenericValueError: "Should be integer, no units."
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-maxlength"
            }));
          });
        }
      }
    };
  }

  /**
   * is-media-descriptor
   * Is given string a valid media descriptor (including media query)?
   * Version: 1.2.4
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/is-media-descriptor
   */
  const recognisedMediaTypes = ["all", "aural", "braille", "embossed", "handheld", "print", "projection", "screen", "speech", "tty", "tv"];
  const recognisedMediaFeatures = ["width", "min-width", "max-width", "height", "min-height", "max-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "orientation", "resolution", "min-resolution", "max-resolution", "scan", "grid", "update", "overflow-block", "overflow-inline", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "color-gamut", "pointer", "hover", "any-pointer", "any-hover"];
  const lettersOnlyRegex = /^\w+$/g;

  function loop(str, opts, res) {
    let chunkStartsAt = null;
    const gatheredChunksArr = [];
    let whitespaceStartsAt = null;
    let nextCanBeMediaType = true;
    let nextCanBeMediaCondition = true;
    let nextCanBeNotOrOnly = true;
    let nextCanBeAnd = false;
    const bracketOpeningIndexes = [];

    for (let i = opts.idxFrom; i <= opts.idxTo; i++) {
      if (str[i] === ")") {
        const lastOpening = bracketOpeningIndexes.pop();
        const extractedValueWithinBrackets = str.slice(lastOpening + 1, i);

        if (!extractedValueWithinBrackets.includes("(") && !extractedValueWithinBrackets.includes(")")) {
          if (extractedValueWithinBrackets.match(lettersOnlyRegex)) {
            if (!recognisedMediaFeatures.includes(extractedValueWithinBrackets.toLowerCase().trim())) {
              res.push({
                idxFrom: lastOpening + 1 + opts.offset,
                idxTo: i + opts.offset,
                message: `Unrecognised "${extractedValueWithinBrackets.trim()}".`,
                fix: null
              });
            }
          }
        }

        const regexFromAllKnownMediaTypes = new RegExp(recognisedMediaTypes.join("|"), "gi");
        const findings = extractedValueWithinBrackets.match(regexFromAllKnownMediaTypes) || [];
        findings.forEach(mediaTypeFound => {
          const startingIdx = str.indexOf(mediaTypeFound);
          res.push({
            idxFrom: startingIdx + opts.offset,
            idxTo: startingIdx + mediaTypeFound.length + opts.offset,
            message: `Media type "${mediaTypeFound}" inside brackets.`,
            fix: null
          });
        });
      }

      if (str[i] === "(") {
        bracketOpeningIndexes.push(i);
      }

      if (str[i] && str[i].trim().length && whitespaceStartsAt !== null) {
        if (str[whitespaceStartsAt - 1] === "(" || str[i] === ")") {
          res.push({
            idxFrom: whitespaceStartsAt + opts.offset,
            idxTo: i + opts.offset,
            message: `Bad whitespace.`,
            fix: {
              ranges: [[whitespaceStartsAt + opts.offset, i + opts.offset]]
            }
          });
        } else if (whitespaceStartsAt < i - 1 || str[i - 1] !== " ") {
          let rangesFrom = whitespaceStartsAt + opts.offset;
          let rangesTo = i + opts.offset;
          let rangesInsert = " ";

          if (whitespaceStartsAt !== i - 1) {
            if (str[whitespaceStartsAt] === " ") {
              rangesFrom++;
              rangesInsert = null;
            } else if (str[i - 1] === " ") {
              rangesTo--;
              rangesInsert = null;
            }
          }

          res.push({
            idxFrom: whitespaceStartsAt + opts.offset,
            idxTo: i + opts.offset,
            message: `Bad whitespace.`,
            fix: {
              ranges: [rangesInsert ? [rangesFrom, rangesTo, " "] : [rangesFrom, rangesTo]]
            }
          });
        }

        whitespaceStartsAt = null;
      }

      if (str[i] && !str[i].trim().length && whitespaceStartsAt === null) {
        whitespaceStartsAt = i;
      }

      if (chunkStartsAt !== null && (!str[i] || !str[i].trim().length) && !bracketOpeningIndexes.length) {
        const chunk = str.slice(chunkStartsAt, i);
        gatheredChunksArr.push(chunk.toLowerCase());

        if (nextCanBeAnd && (!(nextCanBeMediaType || nextCanBeMediaCondition) || chunk === "and")) {
          if (chunk.toLowerCase() !== "and") {
            res.push({
              idxFrom: chunkStartsAt + opts.offset,
              idxTo: i + opts.offset,
              message: `Expected "and", found "${chunk}".`,
              fix: null
            });
          } else if (!str[i]) {
            res.push({
              idxFrom: chunkStartsAt + opts.offset,
              idxTo: i + opts.offset,
              message: `Dangling "${chunk}".`,
              fix: {
                ranges: [[str.slice(0, chunkStartsAt).trimEnd().length + opts.offset, i + opts.offset]]
              }
            });
          }

          nextCanBeAnd = false;
          nextCanBeMediaCondition = true;
        } else if (nextCanBeNotOrOnly && ["not", "only"].includes(chunk)) {
          nextCanBeNotOrOnly = false;
          nextCanBeMediaCondition = false;
        } else if (nextCanBeMediaType || nextCanBeMediaCondition) {
          if (chunk.startsWith("(")) {
            if (nextCanBeMediaCondition) ;else {
              let message = `Media condition "${str.slice(chunkStartsAt, i)}" can't be here.`;

              if (gatheredChunksArr[gatheredChunksArr.length - 2] === "not") {
                message = `"not" can be only in front of media type.`;
              }

              res.push({
                idxFrom: chunkStartsAt + opts.offset,
                idxTo: i + opts.offset,
                message,
                fix: null
              });
            }
          } else {
            if (nextCanBeMediaType) {
              if (recognisedMediaTypes.includes(chunk.toLowerCase())) {
                nextCanBeMediaType = false;
                nextCanBeMediaCondition = false;
              } else {
                let message = `Unrecognised "${chunk}".`;

                if (!chunk.match(/\w/g)) {
                  message = `Strange symbol${chunk.trim().length === 1 ? "" : "s"} "${chunk}".`;
                } else if (["and", "only", "or", "not"].includes(chunk.toLowerCase())) {
                  message = `"${chunk}" instead of a media type.`;
                }

                res.push({
                  idxFrom: chunkStartsAt + opts.offset,
                  idxTo: i + opts.offset,
                  message,
                  fix: null
                });
              }
            } else {
              let message = `Expected brackets on "${chunk}".`;
              let fix = null;
              let idxTo = i + opts.offset;

              if (["not", "else", "or"].includes(chunk.toLowerCase())) {
                message = `"${chunk}" can't be here.`;
              } else if (recognisedMediaTypes.includes(chunk.toLowerCase())) {
                message = `Unexpected media type, try using a comma.`;
              } else if (recognisedMediaFeatures.includes(chunk.toLowerCase())) {
                message = `Missing brackets.`;
                fix = {
                  ranges: [[chunkStartsAt + opts.offset, chunkStartsAt + opts.offset, "("], [i + opts.offset, i + opts.offset, ")"]]
                };
              } else if (str.slice(i).trim().startsWith(":")) {
                const valueWithoutColon = chunk.slice(0, i).trim();
                message = `Expected brackets on "${valueWithoutColon}" and its value.`;
                idxTo = chunkStartsAt + valueWithoutColon.length + opts.offset;
              }

              res.push({
                idxFrom: chunkStartsAt + opts.offset,
                idxTo,
                message,
                fix
              });
              break;
            }
          }

          nextCanBeAnd = true;
        } else {
          res.push({
            idxFrom: chunkStartsAt + opts.offset,
            idxTo: i + opts.offset,
            message: `Unrecognised media type "${str.slice(chunkStartsAt, i)}".`,
            fix: null
          });
        }

        chunkStartsAt = null;

        if (nextCanBeNotOrOnly) {
          nextCanBeNotOrOnly = false;
        }
      }

      if (chunkStartsAt === null && str[i] && str[i].trim().length && str[i] !== ")") {
        if (str[i] === "(") ;
        chunkStartsAt = i;
      }
    }
  }

  function isMediaD(originalStr, originalOpts) {
    const defaults = {
      offset: 0
    };
    const opts = Object.assign({}, defaults, originalOpts);

    if (opts.offset && !Number.isInteger(opts.offset)) {
      throw new Error(`is-media-descriptor: [THROW_ID_01] opts.offset must be an integer, it was given as ${opts.offset} (type ${typeof opts.offset})`);
    }

    if (!opts.offset) {
      opts.offset = 0;
    }

    if (typeof originalStr !== "string") {
      return [];
    } else if (!originalStr.trim().length) {
      return [];
    }

    const res = [];
    let nonWhitespaceStart = 0;
    let nonWhitespaceEnd = originalStr.length;
    const str = originalStr.trim();

    if (originalStr !== originalStr.trim()) {
      const ranges = [];

      if (!originalStr[0].trim().length) {
        for (let i = 0, len = originalStr.length; i < len; i++) {
          if (originalStr[i].trim().length) {
            ranges.push([0 + opts.offset, i + opts.offset]);
            nonWhitespaceStart = i;
            break;
          }
        }
      }

      if (!originalStr[originalStr.length - 1].trim().length) {
        for (let i = originalStr.length; i--;) {
          if (originalStr[i].trim().length) {
            ranges.push([i + 1 + opts.offset, originalStr.length + opts.offset]);
            nonWhitespaceEnd = i + 1;
            break;
          }
        }
      }

      res.push({
        idxFrom: ranges[0][0],
        idxTo: ranges[ranges.length - 1][1],
        message: "Remove whitespace.",
        fix: {
          ranges
        }
      });
    }

    if (recognisedMediaTypes.includes(str)) {
      return res;
    } else if (["only", "not"].includes(str)) {
      res.push({
        idxFrom: nonWhitespaceStart + opts.offset,
        idxTo: nonWhitespaceEnd + opts.offset,
        message: `Missing media type or condition.`,
        fix: null
      });
    } else if (str.match(lettersOnlyRegex) && !str.includes("(") && !str.includes(")")) {
      for (let i = 0, len = recognisedMediaTypes.length; i < len; i++) {
        if (leven_1(recognisedMediaTypes[i], str) === 1) {
          res.push({
            idxFrom: nonWhitespaceStart + opts.offset,
            idxTo: nonWhitespaceEnd + opts.offset,
            message: `Did you mean "${recognisedMediaTypes[i]}"?`,
            fix: {
              ranges: [[nonWhitespaceStart + opts.offset, nonWhitespaceEnd + opts.offset, recognisedMediaTypes[i]]]
            }
          });
          break;
        }

        if (i === len - 1) {
          res.push({
            idxFrom: nonWhitespaceStart + opts.offset,
            idxTo: nonWhitespaceEnd + opts.offset,
            message: `Unrecognised media type "${str}".`,
            fix: null
          });
        }
      }
    } else {
      let wrongOrder = false;
      const [openingBracketCount, closingBracketCount] = Array.from(str).reduce((acc, curr, idx) => {
        if (curr === ")") {
          if (!wrongOrder && acc[1] + 1 > acc[0]) {
            wrongOrder = true;
          }

          return [acc[0], acc[1] + 1];
        } else if (curr === "(") {
          return [acc[0] + 1, acc[1]];
        } else if (curr === ";") {
          res.push({
            idxFrom: idx + opts.offset,
            idxTo: idx + 1 + opts.offset,
            message: "Semicolon found!",
            fix: null
          });
        }

        return acc;
      }, [0, 0]);

      if (wrongOrder && openingBracketCount === closingBracketCount) {
        res.push({
          idxFrom: nonWhitespaceStart + opts.offset,
          idxTo: nonWhitespaceEnd + opts.offset,
          message: "Some closing brackets are before their opening counterparts.",
          fix: null
        });
      }

      if (openingBracketCount > closingBracketCount) {
        res.push({
          idxFrom: nonWhitespaceStart + opts.offset,
          idxTo: nonWhitespaceEnd + opts.offset,
          message: "More opening brackets than closing.",
          fix: null
        });
      } else if (closingBracketCount > openingBracketCount) {
        res.push({
          idxFrom: nonWhitespaceStart + opts.offset,
          idxTo: nonWhitespaceEnd + opts.offset,
          message: "More closing brackets than opening.",
          fix: null
        });
      }

      if (!res.length && str.match(/\(\s*\)/g)) {
        let lastOpening = null;
        let nonWhitespaceFound;

        for (let i = 0, len = str.length; i < len; i++) {
          if (str[i] === "(") {
            lastOpening = i;
            nonWhitespaceFound = false;
          } else if (str[i] === ")") {
            if (!nonWhitespaceFound) {
              res.push({
                idxFrom: lastOpening + opts.offset,
                idxTo: i + 1 + opts.offset,
                message: "Empty bracket pair.",
                fix: null
              });
            } else {
              nonWhitespaceFound = true;
            }
          } else if (str[i].trim().length) {
            nonWhitespaceFound = true;
          }
        }
      }

      if (res.length) {
        return res;
      }

      processCommaSeparated(str, {
        offset: opts.offset,
        leadingWhitespaceOK: false,
        trailingWhitespaceOK: false,
        oneSpaceAfterCommaOK: true,
        innerWhitespaceAllowed: true,
        separator: ",",
        cb: (idxFrom, idxTo) => {
          loop(str, Object.assign({}, opts, {
            idxFrom: idxFrom - opts.offset,
            idxTo: idxTo - opts.offset
          }), res);
        },
        errCb: (ranges, message) => {}
      });
    }

    return res;
  }

  // rule: attribute-validate-media

  function attributeValidateMedia(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "media") {
          // validate the parent
          if (!["style", "link"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-media",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // beware, the charStart and charEnd are not offset, their "zero" is
          // start of an attribute's value, so if you use them, you need to
          // offset to the true index, you must add "node.attribValueStartsAt" value


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              charStart = _checkForWhitespace.charStart,
              charEnd = _checkForWhitespace.charEnd,
              errorArr = _checkForWhitespace.errorArr; // concat errors from "is-media-descriptor" and report all:


          errorArr.concat(isMediaD(node.attribValue.slice(charStart, charEnd), {
            offset: node.attribValueStartsAt
          })).forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-media"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-method

  function attributeValidateMethod(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "method") {
          // validate the parent
          if (node.parent.tagName !== "form") {
            context.report({
              ruleId: "attribute-validate-method",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["get", "post"],
            canBeCommaSeparated: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-method"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-multiple

  function attributeValidateMultiple(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "multiple") {
          // validate the parent
          if (node.parent.tagName !== "select") {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-multiple"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-name

  function attributeValidateName(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "name") {
          // validate the parent
          if (!["button", "textarea", "applet", "select", "form", "frame", "iframe", "img", "a", "input", "object", "map", "param", "meta"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-name",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace because value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-name"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-nohref

  function attributeValidateNohref(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "nohref") {
          // validate the parent
          if (node.parent.tagName !== "area") {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-nohref"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-noresize

  function attributeValidateNoresize(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "noresize") {
          // validate the parent
          if (node.parent.tagName !== "frame") {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-noresize"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-noshade

  function attributeValidateNoshade(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "noshade") {
          // validate the parent
          if (node.parent.tagName !== "hr") {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-noshade"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-nowrap

  function attributeValidateNowrap(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "nowrap") {
          // validate the parent
          if (!["td", "th"].includes(node.parent.tagName)) {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-nowrap"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-object

  function attributeValidateObject(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "object") {
          // validate the parent
          if (node.parent.tagName !== "applet") {
            context.report({
              ruleId: "attribute-validate-object",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-object"
            }));
          });
        }
      }
    };
  }

  function validateScript(str, idxOffset, opts) {
    // we get trimmed string start and end positions, also an encountered errors array
    // const { charStart, charEnd, errorArr } = checkForWhitespace(str, idxOffset);
    var _checkForWhitespace = checkForWhitespace(str, idxOffset),
        errorArr = _checkForWhitespace.errorArr; // now that we know where non-whitespace chars are, we can evaluate them
    // if (Number.isInteger(charStart)) {
    //   // DO SOMETHING MORE
    // }


    return errorArr;
  }

  // rule: attribute-validate-onblur

  function attributeValidateOnblur(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onblur") {
          // validate the parent
          if (!["a", "area", "button", "input", "label", "select", "textarea"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onblur",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onblur"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onchange

  function attributeValidateOnchange(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onchange") {
          // validate the parent
          if (!["input", "select", "textarea"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onchange",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onchange"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onclick

  function attributeValidateOnclick(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onclick") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onclick",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onclick"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-ondblclick

  function attributeValidateOndblclick(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "ondblclick") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-ondblclick",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-ondblclick"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onfocus

  function attributeValidateOnfocus(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onfocus") {
          // validate the parent
          if (!["a", "area", "button", "input", "label", "select", "textarea"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onfocus",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onfocus"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onkeydown

  function attributeValidateOnkeydown(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onkeydown") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onkeydown",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onkeydown"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onkeypress

  function attributeValidateOnkeypress(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onkeypress") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onkeypress",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onkeypress"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onkeyup

  function attributeValidateOnkeyup(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onkeyup") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onkeyup",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onkeyup"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onload

  function attributeValidateOnload(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onload") {
          // validate the parent
          if (!["frameset", "body"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onload",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onload"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onmousedown

  function attributeValidateOnmousedown(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onmousedown") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onmousedown",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onmousedown"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onmousemove

  function attributeValidateOnmousemove(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onmousemove") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onmousemove",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onmousemove"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onmouseout

  function attributeValidateOnmouseout(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onmouseout") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onmouseout",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onmouseout"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onmouseover

  function attributeValidateOnmouseover(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onmouseover") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onmouseover",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onmouseover"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onmouseup

  function attributeValidateOnmouseup(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onmouseup") {
          // validate the parent
          if (["applet", "base", "basefont", "bdo", "br", "font", "frame", "frameset", "head", "html", "iframe", "isindex", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onmouseup",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onmouseup"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onreset

  function attributeValidateOnreset(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onreset") {
          // validate the parent
          if (node.parent.tagName !== "form") {
            context.report({
              ruleId: "attribute-validate-onreset",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onreset"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onsubmit

  function attributeValidateOnsubmit(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onsubmit") {
          // validate the parent
          if (node.parent.tagName !== "form") {
            context.report({
              ruleId: "attribute-validate-onsubmit",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onsubmit"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onselect

  function attributeValidateOnselect(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onselect") {
          // validate the parent
          if (!["input", "textarea"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onselect",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onselect"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-onunload

  function attributeValidateOnunload(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        // preparing for the future:
        var opts = Object.assign({}, originalOpts);

        if (node.attribName === "onunload") {
          // validate the parent
          if (!["frameset", "body"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-onunload",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the script value
            var errorArr = validateScript(node.attribValue, node.attribValueStartsAt);
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-onunload"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-profile

  function attributeValidateProfile(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "profile") {
          // validate the parent
          if (node.parent.tagName !== "head") {
            context.report({
              ruleId: "attribute-validate-profile",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // Call validation upon whole attribute's value. Validator includes
            // whitespace checks.
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: true
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-profile"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-prompt

  function attributeValidatePrompt(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "prompt") {
          // validate the parent
          if (node.parent.tagName !== "isindex") {
            context.report({
              ruleId: "attribute-validate-prompt",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-prompt"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-readonly

  function attributeValidateReadonly(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "readonly") {
          // validate the parent
          if (!["textarea", "input"].includes(node.parent.tagName)) {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-readonly"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-rel

  function attributeValidateRel(context) {
    for (var _len = arguments.length, opts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      opts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var caseInsensitive = !Array.isArray(opts) || !opts.includes("enforceLowercase");

        if (node.attribName === "rel") {
          // validate the parent
          if (!["a", "link"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-rel",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: linkTypes,
            canBeCommaSeparated: false,
            caseInsensitive: caseInsensitive
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-rel"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-rev

  function attributeValidateRev(context) {
    for (var _len = arguments.length, opts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      opts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var caseInsensitive = !Array.isArray(opts) || !opts.includes("enforceLowercase");

        if (node.attribName === "rev") {
          // validate the parent
          if (!["a", "link"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-rev",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // check in two parts, first, a quick try, match the most common values only


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: linkTypes,
            canBeCommaSeparated: false,
            caseInsensitive: caseInsensitive
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-rev"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-rows

  function attributeValidateRows(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateRows(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "rows") {
          // validate the parent
          if (!["frameset", "textarea"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-rows",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = [];

          if (node.parent.tagName === "frameset") {
            errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
              whitelistValues: ["*"],
              theOnlyGoodUnits: ["%"],
              badUnits: ["px"],
              noUnitsIsFine: true,
              canBeCommaSeparated: true,
              type: "rational",
              customGenericValueError: "Should be: pixels|%|*."
            });
          } else if (node.parent.tagName === "textarea") {
            // each character must be a digit
            errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
              type: "integer",
              theOnlyGoodUnits: [],
              customGenericValueError: "Should be integer, no units."
            });
          }

          if (Array.isArray(errorArr) && errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-rows"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-rowspan

  function attributeValidateRowspan(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateRowspan(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "rowspan") {
          // validate the parent
          if (!["th", "td"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-rowspan",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            theOnlyGoodUnits: [],
            customGenericValueError: "Should be integer, no units."
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-rowspan"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-rules

  function attributeValidateRules(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "rules") {
          // validate the parent
          if (node.parent.tagName !== "table") {
            context.report({
              ruleId: "attribute-validate-rules",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // https://www.w3.org/TR/html4/struct/tables.html#adef-frame


          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["none", "groups", "rows", "cols", "all"],
            canBeCommaSeparated: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-rules"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-scheme

  function attributeValidateScheme(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "scheme") {
          // validate the parent
          if (node.parent.tagName !== "meta") {
            context.report({
              ruleId: "attribute-validate-scheme",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-scheme"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-scope

  function attributeValidateScope(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "scope") {
          // validate the parent
          if (!["td", "th"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-scope",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["row", "col", "rowgroup", "colgroup"],
            canBeCommaSeparated: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-scope"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-scrolling

  function attributeValidateScrolling(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "scrolling") {
          // validate the parent
          if (!["frame", "iframe"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-scrolling",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["auto", "yes", "no"],
            canBeCommaSeparated: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-scrolling"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-selected

  function attributeValidateSelected(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    return {
      attribute: function attribute(node) {
        var opts = {
          xhtml: false
        }; // normalize the given opts (array) and turn them
        // into a plain object

        if (Array.isArray(originalOpts) && originalOpts.length && originalOpts.some(function (val) {
          return val.toLowerCase() === "xhtml";
        })) {
          opts.xhtml = true;
        }

        var errorArr = [];

        if (node.attribName === "selected") {
          // validate the parent
          if (node.parent.tagName !== "option") {
            errorArr.push({
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate the value (or absence thereof)
            validateVoid(node, context, errorArr, Object.assign({}, opts, {
              enforceSiblingAttributes: null
            }));
          } // finally, report gathered errors:


          if (errorArr.length) {
            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-selected"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-shape

  function attributeValidateShape(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "shape") {
          // validate the parent
          if (!["area", "a"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-shape",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateString(node.attribValue, // value
          node.attribValueStartsAt, // offset
          {
            permittedValues: ["default", "rect", "circle", "poly"],
            canBeCommaSeparated: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-shape"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-size

  function attributeValidateSize(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateSize(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "size") {
          // validate the parent
          if (!["hr", "font", "input", "basefont", "select"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-size",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
                charStart = _checkForWhitespace.charStart,
                charEnd = _checkForWhitespace.charEnd,
                errorArr = _checkForWhitespace.errorArr; // sort errorArr right here because some of the values will be
            // checked with regex quickly and it would be burden to stick
            // this whitespace reporting on every size attribute tag's case


            errorArr.forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-size"
              }));
            }); //
            //
            // now process each case of "size", depending by tag name
            //
            //

            if (Number.isInteger(charStart)) {
              // the attribute's value is not empty
              var extractedVal = node.attribValue.slice(charStart, charEnd);

              if (["hr", "input", "select"].includes(node.parent.tagName)) {
                // no need to check whitespace, opts.skipWhitespaceChecks: true
                validateDigitAndUnit(extractedVal, node.attribValueStartsAt + charStart, {
                  type: "integer",
                  negativeOK: false,
                  theOnlyGoodUnits: [],
                  // empty array means no units allowed
                  skipWhitespaceChecks: true
                }).forEach(function (errorObj) {
                  context.report(Object.assign({}, errorObj, {
                    ruleId: "attribute-validate-size"
                  }));
                });
              } else if (["font", "basefont"].includes(node.parent.tagName)) {
                if (!extractedVal.match(fontSizeRegex)) {
                  var errorArr2 = validateDigitAndUnit(extractedVal, node.attribValueStartsAt + charStart, {
                    type: "integer",
                    negativeOK: false,
                    theOnlyGoodUnits: [],
                    // empty array means no units allowed
                    skipWhitespaceChecks: true,
                    customGenericValueError: "Should be integer 1-7, plus/minus are optional."
                  });

                  if (!errorArr2.length) {
                    // if validateDigitAndUnit() didn't pick up any errors that
                    // possibly because they are too specific, like <font size="8">
                    // in which case, we raise a generic error against whole
                    // attribute's value
                    errorArr2.push({
                      idxFrom: node.attribValueStartsAt + charStart,
                      idxTo: node.attribValueStartsAt + charEnd,
                      message: "Should be integer 1-7, plus/minus are optional.",
                      fix: null
                    });
                  }

                  errorArr2.forEach(function (errorObj) {
                    context.report(Object.assign({}, errorObj, {
                      ruleId: "attribute-validate-size"
                    }));
                  });
                }
              }
            }
          }
        }
      }
    };
  }

  // rule: attribute-validate-span

  function attributeValidateSpan(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "span") {
          // validate the parent
          if (!["col", "colgroup"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-span",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            theOnlyGoodUnits: [],
            customGenericValueError: "Should be integer, no units.",
            zeroOK: false,
            customPxMessage: "Columns number is not in pixels."
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-span"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-src

  function attributeValidateSrc(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "src") {
          // validate the parent
          if (!["script", "input", "frame", "iframe", "img"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-src",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-src"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-standby

  function attributeValidateStandby(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "standby") {
          // validate the parent
          if (node.parent.tagName !== "object") {
            context.report({
              ruleId: "attribute-validate-standby",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-standby"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-start

  function attributeValidateStart(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "start") {
          // validate the parent
          if (node.parent.tagName !== "ol") {
            context.report({
              ruleId: "attribute-validate-start",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            theOnlyGoodUnits: [],
            customGenericValueError: "Should be integer, no units.",
            zeroOK: false,
            customPxMessage: "Starting sequence number is not in pixels."
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-start"
            }));
          });
        }
      }
    };
  }

  function validateInlineStyle(str, idxOffset, opts) {
    // we get trimmed string start and end positions, also an encountered errors array
    // const { charStart, charEnd, errorArr } = checkForWhitespace(str, idxOffset);
    var _checkForWhitespace = checkForWhitespace(str, idxOffset),
        errorArr = _checkForWhitespace.errorArr; // now that we know where non-whitespace chars are, we can evaluate them
    // if (Number.isInteger(charStart)) {
    //   // DO SOMETHING MORE
    // }


    return errorArr;
  }

  // rule: attribute-validate-style

  function attributeValidateStyle(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "style") {
          // validate the parent
          if (["base", "basefont", "head", "html", "meta", "param", "script", "style", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-style",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateInlineStyle(node.attribValue, node.attribValueStartsAt);
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-style"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-summary

  function attributeValidateSummary(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "summary") {
          // validate the parent
          if (node.parent.tagName !== "table") {
            context.report({
              ruleId: "attribute-validate-summary",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-summary"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-tabindex

  function attributeValidateTabindex(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "tabindex") {
          // validate the parent
          if (!["a", "area", "button", "input", "object", "select", "textarea"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-tabindex",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            type: "integer",
            theOnlyGoodUnits: [],
            customGenericValueError: "Should be integer, no units.",
            zeroOK: true,
            customPxMessage: "Tabbing order number should not be in pixels.",
            maxValue: 32767
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-tabindex"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-target

  function attributeValidateTarget(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "target") {
          // validate the parent
          if (!["a", "area", "base", "form", "link"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-target",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace because value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-target"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-text

  function attributeValidateText(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateText(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "text") {
          // validate the parent
          if (node.parent.tagName !== "body") {
            context.report({
              ruleId: "attribute-validate-text",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateColor(node.attribValue, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-text"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-title

  function attributeValidateTitle(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "title") {
          // validate the parent
          if (["base", "basefont", "head", "html", "meta", "param", "script", "title"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-title",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace because value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-title"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-type

  function attributeValidateType(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "type") {
          // validate the parent
          if (!["a", "link", "object", "param", "script", "style", "input", "li", "ol", "ul", "button"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-type",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // validate depending on type
            if (["a", "link", "object", "param", "script", "style"].includes(node.parent.tagName)) {
              validateString(node.attribValue, // value
              node.attribValueStartsAt, // offset
              {
                quickPermittedValues: ["application/javascript", "application/json", "application/x-www-form-urlencoded", "application/xml", "application/zip", "application/pdf", "application/sql", "application/graphql", "application/ld+json", "application/msword", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.ms-excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.ms-powerpoint", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.oasis.opendocument.text", "application/zstd", "audio/mpeg", "audio/ogg", "multipart/form-data", "text/css", "text/html", "text/xml", "text/csv", "text/plain", "image/png", "image/jpeg", "image/gif", "application/vnd.api+json"],
                permittedValues: Object.keys(mimeDb),
                canBeCommaSeparated: false,
                noSpaceAfterComma: false
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-type"
                }));
              });
            } else if (node.parent.tagName === "input") {
              validateString(node.attribValue, // value
              node.attribValueStartsAt, // offset
              {
                quickPermittedValues: ["text", "password", "checkbox", "radio", "submit", "reset", "file", "hidden", "image", "button"],
                permittedValues: null,
                canBeCommaSeparated: false,
                noSpaceAfterComma: false
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-type"
                }));
              });
            } else if (node.parent.tagName === "li") {
              validateString(node.attribValue, // value
              node.attribValueStartsAt, // offset
              {
                quickPermittedValues: ["disc", "square", "circle", "1", "a", "A", "i", "I"],
                permittedValues: null,
                canBeCommaSeparated: false,
                noSpaceAfterComma: false
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-type"
                }));
              });
            } else if (node.parent.tagName === "ol") {
              validateString(node.attribValue, // value
              node.attribValueStartsAt, // offset
              {
                quickPermittedValues: ["1", "a", "A", "i", "I"],
                permittedValues: null,
                canBeCommaSeparated: false,
                noSpaceAfterComma: false
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-type"
                }));
              });
            } else if (node.parent.tagName === "ul") {
              validateString(node.attribValue, // value
              node.attribValueStartsAt, // offset
              {
                quickPermittedValues: ["disc", "square", "circle"],
                permittedValues: null,
                canBeCommaSeparated: false,
                noSpaceAfterComma: false
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-type"
                }));
              });
            } else if (node.parent.tagName === "button") {
              validateString(node.attribValue, // value
              node.attribValueStartsAt, // offset
              {
                quickPermittedValues: ["button", "submit", "reset"],
                permittedValues: null,
                canBeCommaSeparated: false,
                noSpaceAfterComma: false
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-type"
                }));
              });
            }
          }
        }
      }
    };
  }

  // rule: attribute-validate-usemap

  function attributeValidateUsemap(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "usemap") {
          // validate the parent
          if (!["img", "input", "object"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-usemap",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            validateUri(node.attribValue, {
              offset: node.attribValueStartsAt,
              multipleOK: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-usemap"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-valign

  function attributeValidateValign(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "valign") {
          // validate the parent
          if (!["col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-valign",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            validateString(node.attribValue, // value
            node.attribValueStartsAt, // offset
            {
              permittedValues: ["top", "middle", "bottom", "baseline"],
              canBeCommaSeparated: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-valign"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-value

  function attributeValidateValue(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateValue(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "value") {
          // validate the parent
          if (!["input", "option", "param", "button", "li"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-value",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            // if parent is OK
            if (node.parent.tagName === "li") {
              // value is number
              validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
                type: "integer",
                theOnlyGoodUnits: [],
                customGenericValueError: "Should be integer, no units.",
                zeroOK: false,
                customPxMessage: "Sequence number should not be in pixels."
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-value"
                }));
              });
            } else {
              // all others - value is CDATA
              var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
                  errorArr = _checkForWhitespace.errorArr;

              errorArr.forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-value"
                }));
              });
            }
          }
        }
      }
    };
  }

  // rule: attribute-validate-valuetype

  function attributeValidateValuetype(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "valuetype") {
          // validate the parent
          if (node.parent.tagName !== "param") {
            context.report({
              ruleId: "attribute-validate-valuetype",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            validateString(node.attribValue, // value
            node.attribValueStartsAt, // offset
            {
              permittedValues: ["data", "ref", "object"],
              canBeCommaSeparated: false
            }).forEach(function (errorObj) {
              context.report(Object.assign({}, errorObj, {
                ruleId: "attribute-validate-valuetype"
              }));
            });
          }
        }
      }
    };
  }

  // rule: attribute-validate-version

  function attributeValidateVersion(context) {
    return {
      attribute: function attribute(node) {
        if (node.attribName === "version") {
          // validate the parent
          if (node.parent.tagName !== "html") {
            context.report({
              ruleId: "attribute-validate-version",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } // only check for rogue whitespace - value can be any CDATA


          var _checkForWhitespace = checkForWhitespace(node.attribValue, node.attribValueStartsAt),
              errorArr = _checkForWhitespace.errorArr;

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-version"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-vlink

  function attributeValidateVlink(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateVlink(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "vlink") {
          // validate the parent
          if (node.parent.tagName !== "body") {
            context.report({
              ruleId: "attribute-validate-vlink",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateColor(node.attribValue, node.attribValueStartsAt, {
            namedCssLevel1OK: true,
            namedCssLevel2PlusOK: true,
            hexThreeOK: false,
            hexFourOK: false,
            hexSixOK: true,
            hexEightOK: false
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-vlink"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-vspace

  function attributeValidateVspace(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateVspace(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "vspace") {
          // validate the parent
          if (!["applet", "img", "object"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-vspace",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          }

          var errorArr = validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
            theOnlyGoodUnits: [],
            // all units are bad, value is in px which is omitted
            noUnitsIsFine: true
          });
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "attribute-validate-vspace"
            }));
          });
        }
      }
    };
  }

  // rule: attribute-validate-width

  function attributeValidateWidth(context) {
    return {
      attribute: function attribute(node) {
        // console.log(
        //   `015 attributeValidateWidth(): node = ${JSON.stringify(node, null, 4)}`
        // );
        if (node.attribName === "width") {
          // validate the parent
          if (!["hr", "iframe", "img", "object", "table", "td", "th", "applet", "col", "colgroup", "pre"].includes(node.parent.tagName)) {
            context.report({
              ruleId: "attribute-validate-width",
              idxFrom: node.attribStart,
              idxTo: node.attribEnd,
              message: "Tag \"".concat(node.parent.tagName, "\" can't have attribute \"").concat(node.attribName, "\"."),
              fix: null
            });
          } else {
            if (node.parent.tagName === "pre") {
              // number only
              validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
                theOnlyGoodUnits: [],
                noUnitsIsFine: true
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-width"
                }));
              });
            } else if (["colgroup", "col"].includes(node.parent.tagName)) {
              // multilength type
              validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
                badUnits: ["px"],
                theOnlyGoodUnits: ["*", "%"],
                noUnitsIsFine: true
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-width"
                }));
              });
            } else {
              // normal length
              validateDigitAndUnit(node.attribValue, node.attribValueStartsAt, {
                badUnits: ["px"],
                noUnitsIsFine: true
              }).forEach(function (errorObj) {
                context.report(Object.assign({}, errorObj, {
                  ruleId: "attribute-validate-width"
                }));
              });
            }
          }
        }
      }
    };
  }

  /**
   * html-entities-not-email-friendly
   * All HTML entities which are not email template friendly
   * Version: 0.1.14
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/all-named-html-entities
   */
  var AMP$1 = "amp";
  var Abreve$1 = "#x102";
  var Acy$1 = "#x410";
  var Afr$1 = "#x1D504";
  var Amacr$1 = "#x100";
  var And$2 = "#x2A53";
  var Aogon$1 = "#x104";
  var Aopf$1 = "#x1D538";
  var ApplyFunction$1 = "#x2061";
  var Ascr$2 = "#x1D49C";
  var Assign$2 = "#x2254";
  var Backslash$2 = "#x2216";
  var Barv$1 = "#x2AE7";
  var Barwed$1 = "#x2306";
  var Bcy$1 = "#x411";
  var Because$2 = "#x2235";
  var Bernoullis$2 = "#x212C";
  var Bfr$1 = "#x1D505";
  var Bopf$1 = "#x1D539";
  var Breve$1 = "#x2D8";
  var Bscr$1 = "#x212C";
  var Bumpeq$1 = "#x224E";
  var CHcy$1 = "#x427";
  var COPY$2 = "copy";
  var Cacute$1 = "#x106";
  var Cap$2 = "#x22D2";
  var CapitalDifferentialD$1 = "#x2145";
  var Cayleys$1 = "#x212D";
  var Ccaron$1 = "#x10C";
  var Ccirc$1 = "#x108";
  var Cconint$1 = "#x2230";
  var Cdot$1 = "#x10A";
  var Cedilla$2 = "cedil";
  var CenterDot$1 = "middot";
  var Cfr$1 = "#x212D";
  var CircleDot$1 = "#x2299";
  var CircleMinus$1 = "#x2296";
  var CirclePlus$1 = "oplus";
  var CircleTimes$1 = "otimes";
  var ClockwiseContourIntegral$1 = "#x2232";
  var CloseCurlyDoubleQuote$1 = "rdquo";
  var CloseCurlyQuote$1 = "rsquo";
  var Colon$2 = "#x2237";
  var Colone$2 = "#x2A74";
  var Congruent$2 = "equiv";
  var Conint$1 = "#x222F";
  var ContourIntegral$1 = "#x222E";
  var Copf$1 = "#x2102";
  var Coproduct$1 = "#x2210";
  var CounterClockwiseContourIntegral$1 = "#x2233";
  var Cross$2 = "#x2A2F";
  var Cscr$1 = "#x1D49E";
  var Cup$2 = "#x22D3";
  var CupCap$1 = "#x224D";
  var DD$2 = "#x2145";
  var DDotrahd$1 = "#x2911";
  var DJcy$1 = "#x402";
  var DScy$1 = "#x405";
  var DZcy$1 = "#x40F";
  var Darr$1 = "#x21A1";
  var Dashv$1 = "#x2AE4";
  var Dcaron$1 = "#x10E";
  var Dcy$1 = "#x414";
  var Del$2 = "#x2207";
  var Dfr$1 = "#x1D507";
  var DiacriticalAcute$1 = "acute";
  var DiacriticalDot$1 = "#x2D9";
  var DiacriticalDoubleAcute$1 = "#x2DD";
  var DiacriticalGrave$1 = "#x60";
  var DiacriticalTilde$1 = "tilde";
  var Diamond$2 = "#x22C4";
  var DifferentialD$1 = "#x2146";
  var Dopf$1 = "#x1D53B";
  var Dot$2 = "#xA8";
  var DotDot$1 = "#x20DC";
  var DotEqual$1 = "#x2250";
  var DoubleContourIntegral$1 = "#x222F";
  var DoubleDot$1 = "#xA8";
  var DoubleDownArrow$1 = "dArr";
  var DoubleLeftArrow$1 = "lArr";
  var DoubleLeftRightArrow$1 = "#x21D4";
  var DoubleLeftTee$1 = "#x2AE4";
  var DoubleLongLeftArrow$1 = "#x27F8";
  var DoubleLongLeftRightArrow$1 = "#x27FA";
  var DoubleLongRightArrow$1 = "#x27F9";
  var DoubleRightArrow$1 = "rArr";
  var DoubleRightTee$1 = "#x22A8";
  var DoubleUpArrow$1 = "uArr";
  var DoubleUpDownArrow$1 = "#x21D5";
  var DoubleVerticalBar$1 = "#x2225";
  var DownArrow$1 = "darr";
  var DownArrowBar$1 = "#x2913";
  var DownArrowUpArrow$1 = "#x21F5";
  var DownBreve$1 = "#x311";
  var DownLeftRightVector$1 = "#x2950";
  var DownLeftTeeVector$1 = "#x295E";
  var DownLeftVector$1 = "#x21BD";
  var DownLeftVectorBar$1 = "#x2956";
  var DownRightTeeVector$1 = "#x295F";
  var DownRightVector$1 = "#x21C1";
  var DownRightVectorBar$1 = "#x2957";
  var DownTee$1 = "#x22A4";
  var DownTeeArrow$1 = "#x21A7";
  var Downarrow$1 = "dArr";
  var Dscr$1 = "#x1D49F";
  var Dstrok$1 = "#x110";
  var ENG$2 = "#x14A";
  var Ecaron$1 = "#x11A";
  var Ecy$1 = "#x42D";
  var Edot$1 = "#x116";
  var Efr$1 = "#x1D508";
  var Element$1 = "#x2208";
  var Emacr$1 = "#x112";
  var EmptySmallSquare$1 = "#x25FB";
  var EmptyVerySmallSquare$1 = "#x25AB";
  var Eogon$1 = "#x118";
  var Eopf$1 = "#x1D53C";
  var Equal$2 = "#x2A75";
  var EqualTilde$1 = "#x2242";
  var Equilibrium$2 = "#x21CC";
  var Escr$1 = "#x2130";
  var Esim$1 = "#x2A73";
  var Exists$2 = "exist";
  var ExponentialE$1 = "#x2147";
  var Fcy$1 = "#x424";
  var Ffr$1 = "#x1D509";
  var FilledSmallSquare$1 = "#x25FC";
  var FilledVerySmallSquare$1 = "#x25AA";
  var Fopf$1 = "#x1D53D";
  var ForAll$1 = "forall";
  var Fouriertrf$1 = "#x2131";
  var Fscr$1 = "#x2131";
  var GJcy$1 = "#x403";
  var GT$2 = "gt";
  var Gammad$1 = "#x3DC";
  var Gbreve$1 = "#x11E";
  var Gcedil$1 = "#x122";
  var Gcirc$1 = "#x11C";
  var Gcy$1 = "#x413";
  var Gdot$1 = "#x120";
  var Gfr$1 = "#x1D50A";
  var Gg$1 = "#x22D9";
  var Gopf$1 = "#x1D53E";
  var GreaterEqual$1 = "ge";
  var GreaterEqualLess$1 = "#x22DB";
  var GreaterFullEqual$1 = "#x2267";
  var GreaterGreater$1 = "#x2AA2";
  var GreaterLess$1 = "#x2277";
  var GreaterSlantEqual$1 = "#x2A7E";
  var GreaterTilde$1 = "#x2273";
  var Gscr$1 = "#x1D4A2";
  var Gt$1 = "#x226B";
  var HARDcy$1 = "#x42A";
  var Hacek$1 = "#x2C7";
  var Hcirc$1 = "#x124";
  var Hfr$1 = "#x210C";
  var HilbertSpace$1 = "#x210B";
  var Hopf$1 = "#x210D";
  var HorizontalLine$1 = "#x2500";
  var Hscr$1 = "#x210B";
  var Hstrok$1 = "#x126";
  var HumpDownHump$1 = "#x224E";
  var HumpEqual$1 = "#x224F";
  var IEcy$1 = "#x415";
  var IJlig$1 = "#x132";
  var IOcy$1 = "#x401";
  var Icy$1 = "#x418";
  var Idot$1 = "#x130";
  var Ifr$1 = "#x2111";
  var Im$1 = "#x2111";
  var Imacr$1 = "#x12A";
  var ImaginaryI$1 = "#x2148";
  var Implies$1 = "rArr";
  var Int$1 = "#x222C";
  var Integral$1 = "int";
  var Intersection$1 = "#x22C2";
  var InvisibleComma$1 = "#x2063";
  var InvisibleTimes$1 = "#x2062";
  var Iogon$1 = "#x12E";
  var Iopf$1 = "#x1D540";
  var Iscr$1 = "#x2110";
  var Itilde$1 = "#x128";
  var Iukcy$1 = "#x406";
  var Jcirc$1 = "#x134";
  var Jcy$1 = "#x419";
  var Jfr$1 = "#x1D50D";
  var Jopf$1 = "#x1D541";
  var Jscr$1 = "#x1D4A5";
  var Jsercy$1 = "#x408";
  var Jukcy$1 = "#x404";
  var KHcy$1 = "#x425";
  var KJcy$1 = "#x40C";
  var Kcedil$1 = "#x136";
  var Kcy$1 = "#x41A";
  var Kfr$1 = "#x1D50E";
  var Kopf$1 = "#x1D542";
  var Kscr$1 = "#x1D4A6";
  var LJcy$1 = "#x409";
  var LT$2 = "lt";
  var Lacute$1 = "#x139";
  var Lang$1 = "#x27EA";
  var Laplacetrf$1 = "#x2112";
  var Larr$1 = "#x219E";
  var Lcaron$1 = "#x13D";
  var Lcedil$1 = "#x13B";
  var Lcy$1 = "#x41B";
  var LeftAngleBracket$1 = "lang";
  var LeftArrow$1 = "larr";
  var LeftArrowBar$1 = "#x21E4";
  var LeftArrowRightArrow$1 = "#x21C6";
  var LeftCeiling$1 = "lceil";
  var LeftDoubleBracket$1 = "#x27E6";
  var LeftDownTeeVector$1 = "#x2961";
  var LeftDownVector$1 = "#x21C3";
  var LeftDownVectorBar$1 = "#x2959";
  var LeftFloor$1 = "lfloor";
  var LeftRightArrow$1 = "harr";
  var LeftRightVector$1 = "#x294E";
  var LeftTee$1 = "#x22A3";
  var LeftTeeArrow$1 = "#x21A4";
  var LeftTeeVector$1 = "#x295A";
  var LeftTriangle$1 = "#x22B2";
  var LeftTriangleBar$1 = "#x29CF";
  var LeftTriangleEqual$1 = "#x22B4";
  var LeftUpDownVector$1 = "#x2951";
  var LeftUpTeeVector$1 = "#x2960";
  var LeftUpVector$1 = "#x21BF";
  var LeftUpVectorBar$1 = "#x2958";
  var LeftVector$1 = "#x21BC";
  var LeftVectorBar$1 = "#x2952";
  var Leftarrow$1 = "lArr";
  var Leftrightarrow$1 = "#x21D4";
  var LessEqualGreater$1 = "#x22DA";
  var LessFullEqual$1 = "#x2266";
  var LessGreater$1 = "#x2276";
  var LessLess$1 = "#x2AA1";
  var LessSlantEqual$1 = "#x2A7D";
  var LessTilde$1 = "#x2272";
  var Lfr$1 = "#x1D50F";
  var Ll$1 = "#x22D8";
  var Lleftarrow$1 = "#x21DA";
  var Lmidot$1 = "#x13F";
  var LongLeftArrow$1 = "#x27F5";
  var LongLeftRightArrow$1 = "#x27F7";
  var LongRightArrow$1 = "#x27F6";
  var Longleftarrow$1 = "#x27F8";
  var Longleftrightarrow$1 = "#x27FA";
  var Longrightarrow$1 = "#x27F9";
  var Lopf$1 = "#x1D543";
  var LowerLeftArrow$1 = "#x2199";
  var LowerRightArrow$1 = "#x2198";
  var Lscr$1 = "#x2112";
  var Lsh$1 = "#x21B0";
  var Lstrok$1 = "#x141";
  var Lt$1 = "#x226A";
  var Mcy$1 = "#x41C";
  var MediumSpace$1 = "#x205F";
  var Mellintrf$1 = "#x2133";
  var Mfr$1 = "#x1D510";
  var MinusPlus$1 = "#x2213";
  var Mopf$1 = "#x1D544";
  var Mscr$1 = "#x2133";
  var NJcy$1 = "#x40A";
  var Nacute$1 = "#x143";
  var Ncaron$1 = "#x147";
  var Ncedil$1 = "#x145";
  var Ncy$1 = "#x41D";
  var NegativeMediumSpace$1 = "#x200B";
  var NegativeThickSpace$1 = "#x200B";
  var NegativeThinSpace$1 = "#x200B";
  var NegativeVeryThinSpace$1 = "#x200B";
  var NestedGreaterGreater$1 = "#x226B";
  var NestedLessLess$1 = "#x226A";
  var Nfr$1 = "#x1D511";
  var NoBreak$1 = "#x2060";
  var NonBreakingSpace$1 = "nbsp";
  var Nopf$1 = "#x2115";
  var Not$2 = "#x2AEC";
  var NotCongruent$1 = "#x2262";
  var NotCupCap$1 = "#x226D";
  var NotDoubleVerticalBar$1 = "#x2226";
  var NotElement$1 = "notin";
  var NotEqual$1 = "ne";
  var NotEqualTilde$1 = "#x2242;&#x338";
  var NotExists$1 = "#x2204";
  var NotGreater$1 = "#x226F";
  var NotGreaterEqual$1 = "#x2271";
  var NotGreaterFullEqual$1 = "#x2267;&#x338";
  var NotGreaterGreater$1 = "#x226B;&#x338";
  var NotGreaterLess$1 = "#x2279";
  var NotGreaterSlantEqual$1 = "#x2A7E;&#x338";
  var NotGreaterTilde$1 = "#x2275";
  var NotHumpDownHump$1 = "#x224E;&#x338";
  var NotHumpEqual$1 = "#x224F;&#x338";
  var NotLeftTriangle$1 = "#x22EA";
  var NotLeftTriangleBar$1 = "#x29CF;&#x338";
  var NotLeftTriangleEqual$1 = "#x22EC";
  var NotLess$1 = "#x226E";
  var NotLessEqual$1 = "#x2270";
  var NotLessGreater$1 = "#x2278";
  var NotLessLess$1 = "#x226A;&#x338";
  var NotLessSlantEqual$1 = "#x2A7D;&#x338";
  var NotLessTilde$1 = "#x2274";
  var NotNestedGreaterGreater$1 = "#x2AA2;&#x338";
  var NotNestedLessLess$1 = "#x2AA1;&#x338";
  var NotPrecedes$1 = "#x2280";
  var NotPrecedesEqual$1 = "#x2AAF;&#x338";
  var NotPrecedesSlantEqual$1 = "#x22E0";
  var NotReverseElement$1 = "#x220C";
  var NotRightTriangle$1 = "#x22EB";
  var NotRightTriangleBar$1 = "#x29D0;&#x338";
  var NotRightTriangleEqual$1 = "#x22ED";
  var NotSquareSubset$1 = "#x228F;&#x338";
  var NotSquareSubsetEqual$1 = "#x22E2";
  var NotSquareSuperset$1 = "#x2290;&#x338";
  var NotSquareSupersetEqual$1 = "#x22E3";
  var NotSubset$1 = "#x2282;&#x20D2";
  var NotSubsetEqual$1 = "#x2288";
  var NotSucceeds$1 = "#x2281";
  var NotSucceedsEqual$1 = "#x2AB0;&#x338";
  var NotSucceedsSlantEqual$1 = "#x22E1";
  var NotSucceedsTilde$1 = "#x227F;&#x338";
  var NotSuperset$1 = "#x2283;&#x20D2";
  var NotSupersetEqual$1 = "#x2289";
  var NotTilde$1 = "#x2241";
  var NotTildeEqual$1 = "#x2244";
  var NotTildeFullEqual$1 = "#x2247";
  var NotTildeTilde$1 = "#x2249";
  var NotVerticalBar$1 = "#x2224";
  var Nscr$1 = "#x1D4A9";
  var Ocy$1 = "#x41E";
  var Odblac$1 = "#x150";
  var Ofr$1 = "#x1D512";
  var Omacr$1 = "#x14C";
  var Oopf$1 = "#x1D546";
  var OpenCurlyDoubleQuote$1 = "ldquo";
  var OpenCurlyQuote$1 = "lsquo";
  var Or$1 = "#x2A54";
  var Oscr$1 = "#x1D4AA";
  var Otimes$1 = "#x2A37";
  var OverBar$1 = "oline";
  var OverBrace$1 = "#x23DE";
  var OverBracket$1 = "#x23B4";
  var OverParenthesis$1 = "#x23DC";
  var PartialD$1 = "part";
  var Pcy$1 = "#x41F";
  var Pfr$1 = "#x1D513";
  var PlusMinus$1 = "#xB1";
  var Poincareplane$1 = "#x210C";
  var Popf$1 = "#x2119";
  var Pr$1 = "#x2ABB";
  var Precedes$1 = "#x227A";
  var PrecedesEqual$1 = "#x2AAF";
  var PrecedesSlantEqual$1 = "#x227C";
  var PrecedesTilde$1 = "#x227E";
  var Product$2 = "prod";
  var Proportion$2 = "#x2237";
  var Proportional$2 = "prop";
  var Pscr$1 = "#x1D4AB";
  var QUOT$2 = "quot";
  var Qfr$1 = "#x1D514";
  var Qopf$1 = "#x211A";
  var Qscr$1 = "#x1D4AC";
  var RBarr$1 = "#x2910";
  var REG$2 = "reg";
  var Racute$1 = "#x154";
  var Rang$1 = "#x27EB";
  var Rarr$1 = "#x21A0";
  var Rarrtl$1 = "#x2916";
  var Rcaron$1 = "#x158";
  var Rcedil$1 = "#x156";
  var Rcy$1 = "#x420";
  var Re$2 = "#x211C";
  var ReverseElement$1 = "ni";
  var ReverseEquilibrium$1 = "#x21CB";
  var ReverseUpEquilibrium$1 = "#x296F";
  var Rfr$1 = "#x211C";
  var RightAngleBracket$1 = "rang";
  var RightArrow$1 = "rarr";
  var RightArrowBar$1 = "#x21E5";
  var RightArrowLeftArrow$1 = "#x21C4";
  var RightCeiling$1 = "rceil";
  var RightDoubleBracket$1 = "#x27E7";
  var RightDownTeeVector$1 = "#x295D";
  var RightDownVector$1 = "#x21C2";
  var RightDownVectorBar$1 = "#x2955";
  var RightFloor$1 = "rfloor";
  var RightTee$1 = "#x22A2";
  var RightTeeArrow$1 = "#x21A6";
  var RightTeeVector$1 = "#x295B";
  var RightTriangle$1 = "#x22B3";
  var RightTriangleBar$1 = "#x29D0";
  var RightTriangleEqual$1 = "#x22B5";
  var RightUpDownVector$1 = "#x294F";
  var RightUpTeeVector$1 = "#x295C";
  var RightUpVector$1 = "#x21BE";
  var RightUpVectorBar$1 = "#x2954";
  var RightVector$1 = "#x21C0";
  var RightVectorBar$1 = "#x2953";
  var Rightarrow$1 = "rArr";
  var Ropf$1 = "#x211D";
  var RoundImplies$1 = "#x2970";
  var Rrightarrow$1 = "#x21DB";
  var Rscr$1 = "#x211B";
  var Rsh$1 = "#x21B1";
  var RuleDelayed$1 = "#x29F4";
  var SHCHcy$1 = "#x429";
  var SHcy$1 = "#x428";
  var SOFTcy$1 = "#x42C";
  var Sacute$1 = "#x15A";
  var Sc$1 = "#x2ABC";
  var Scedil$1 = "#x15E";
  var Scirc$1 = "#x15C";
  var Scy$1 = "#x421";
  var Sfr$1 = "#x1D516";
  var ShortDownArrow$1 = "darr";
  var ShortLeftArrow$1 = "larr";
  var ShortRightArrow$1 = "rarr";
  var ShortUpArrow$1 = "uarr";
  var SmallCircle$1 = "#x2218";
  var Sopf$1 = "#x1D54A";
  var Sqrt$1 = "#x221A";
  var Square$1 = "#x25A1";
  var SquareIntersection$1 = "#x2293";
  var SquareSubset$1 = "#x228F";
  var SquareSubsetEqual$1 = "#x2291";
  var SquareSuperset$1 = "#x2290";
  var SquareSupersetEqual$1 = "#x2292";
  var SquareUnion$1 = "#x2294";
  var Sscr$1 = "#x1D4AE";
  var Star$2 = "#x22C6";
  var Sub$2 = "#x22D0";
  var Subset$1 = "#x22D0";
  var SubsetEqual$1 = "sube";
  var Succeeds$1 = "#x227B";
  var SucceedsEqual$1 = "#x2AB0";
  var SucceedsSlantEqual$1 = "#x227D";
  var SucceedsTilde$1 = "#x227F";
  var SuchThat$1 = "ni";
  var Sum$2 = "sum";
  var Sup$1 = "#x22D1";
  var Superset$1 = "sup";
  var SupersetEqual$1 = "supe";
  var Supset$1 = "#x22D1";
  var TRADE$2 = "trade";
  var TSHcy$1 = "#x40B";
  var TScy$1 = "#x426";
  var Tab$2 = "#x9";
  var Tcaron$1 = "#x164";
  var Tcedil$1 = "#x162";
  var Tcy$1 = "#x422";
  var Tfr$1 = "#x1D517";
  var Therefore$1 = "there4";
  var ThickSpace$1 = "#x205F;&#x200A";
  var ThinSpace$1 = "thinsp";
  var Tilde$2 = "sim";
  var TildeEqual$1 = "#x2243";
  var TildeFullEqual$1 = "cong";
  var TildeTilde$1 = "#x2248";
  var Topf$1 = "#x1D54B";
  var TripleDot$1 = "#x20DB";
  var Tscr$1 = "#x1D4AF";
  var Tstrok$1 = "#x166";
  var Uarr$1 = "#x219F";
  var Uarrocir$1 = "#x2949";
  var Ubrcy$1 = "#x40E";
  var Ubreve$1 = "#x16C";
  var Ucy$1 = "#x423";
  var Udblac$1 = "#x170";
  var Ufr$1 = "#x1D518";
  var Umacr$1 = "#x16A";
  var UnderBrace$1 = "#x23DF";
  var UnderBracket$1 = "#x23B5";
  var UnderParenthesis$1 = "#x23DD";
  var Union$2 = "#x22C3";
  var UnionPlus$1 = "#x228E";
  var Uogon$1 = "#x172";
  var Uopf$1 = "#x1D54C";
  var UpArrow$1 = "uarr";
  var UpArrowBar$1 = "#x2912";
  var UpArrowDownArrow$1 = "#x21C5";
  var UpDownArrow$1 = "#x2195";
  var UpEquilibrium$1 = "#x296E";
  var UpTee$1 = "#x22A5";
  var UpTeeArrow$1 = "#x21A5";
  var Uparrow$1 = "uArr";
  var Updownarrow$1 = "#x21D5";
  var UpperLeftArrow$1 = "#x2196";
  var UpperRightArrow$1 = "#x2197";
  var Upsi$2 = "#x3D2";
  var Uring$1 = "#x16E";
  var Uscr$1 = "#x1D4B0";
  var Utilde$1 = "#x168";
  var VDash$1 = "#x22AB";
  var Vbar$1 = "#x2AEB";
  var Vcy$1 = "#x412";
  var Vdash$1 = "#x22A9";
  var Vdashl$1 = "#x2AE6";
  var Vee$1 = "#x22C1";
  var Verbar$1 = "#x2016";
  var Vert$2 = "#x2016";
  var VerticalBar$1 = "#x2223";
  var VerticalSeparator$1 = "#x2758";
  var VerticalTilde$1 = "#x2240";
  var VeryThinSpace$1 = "#x200A";
  var Vfr$1 = "#x1D519";
  var Vopf$1 = "#x1D54D";
  var Vscr$1 = "#x1D4B1";
  var Vvdash$1 = "#x22AA";
  var Wcirc$1 = "#x174";
  var Wedge$2 = "#x22C0";
  var Wfr$1 = "#x1D51A";
  var Wopf$1 = "#x1D54E";
  var Wscr$1 = "#x1D4B2";
  var Xfr$1 = "#x1D51B";
  var Xopf$1 = "#x1D54F";
  var Xscr$1 = "#x1D4B3";
  var YAcy$1 = "#x42F";
  var YIcy$1 = "#x407";
  var YUcy$1 = "#x42E";
  var Ycirc$2 = "#x176";
  var Ycy$1 = "#x42B";
  var Yfr$1 = "#x1D51C";
  var Yopf$1 = "#x1D550";
  var Yscr$1 = "#x1D4B4";
  var ZHcy$1 = "#x416";
  var Zacute$2 = "#x179";
  var Zcaron$1 = "#x17D";
  var Zcy$1 = "#x417";
  var Zdot$1 = "#x17B";
  var ZeroWidthSpace$1 = "#x200B";
  var Zfr$1 = "#x2128";
  var Zopf$1 = "#x2124";
  var Zscr$1 = "#x1D4B5";
  var abreve$1 = "#x103";
  var ac$2 = "#x223E";
  var acE$1 = "#x223E;&#x333";
  var acd$1 = "#x223F";
  var acy$1 = "#x430";
  var af$1 = "#x2061";
  var afr$1 = "#x1D51E";
  var aleph$1 = "#x2135";
  var amacr$1 = "#x101";
  var amalg$1 = "#x2A3F";
  var andand$1 = "#x2A55";
  var andd$1 = "#x2A5C";
  var andslope$1 = "#x2A58";
  var andv$1 = "#x2A5A";
  var ange$2 = "#x29A4";
  var angle$2 = "ang";
  var angmsd$1 = "#x2221";
  var angmsdaa$1 = "#x29A8";
  var angmsdab$1 = "#x29A9";
  var angmsdac$1 = "#x29AA";
  var angmsdad$1 = "#x29AB";
  var angmsdae$1 = "#x29AC";
  var angmsdaf$1 = "#x29AD";
  var angmsdag$1 = "#x29AE";
  var angmsdah$1 = "#x29AF";
  var angrt$1 = "#x221F";
  var angrtvb$1 = "#x22BE";
  var angrtvbd$1 = "#x299D";
  var angsph$1 = "#x2222";
  var angst$2 = "#xC5";
  var angzarr$1 = "#x237C";
  var aogon$1 = "#x105";
  var aopf$1 = "#x1D552";
  var ap$2 = "#x2248";
  var apE$1 = "#x2A70";
  var apacir$1 = "#x2A6F";
  var ape$2 = "#x224A";
  var apid$1 = "#x224B";
  var approx$2 = "#x2248";
  var approxeq$1 = "#x224A";
  var ascr$2 = "#x1D4B6";
  var asympeq$1 = "#x224D";
  var awconint$1 = "#x2233";
  var awint$1 = "#x2A11";
  var bNot$1 = "#x2AED";
  var backcong$1 = "#x224C";
  var backepsilon$1 = "#x3F6";
  var backprime$1 = "#x2035";
  var backsim$1 = "#x223D";
  var backsimeq$1 = "#x22CD";
  var barvee$1 = "#x22BD";
  var barwed$1 = "#x2305";
  var barwedge$2 = "#x2305";
  var bbrk$1 = "#x23B5";
  var bbrktbrk$1 = "#x23B6";
  var bcong$1 = "#x224C";
  var bcy$1 = "#x431";
  var becaus$2 = "#x2235";
  var because$2 = "#x2235";
  var bemptyv$1 = "#x29B0";
  var bepsi$2 = "#x3F6";
  var bernou$1 = "#x212C";
  var beth$2 = "#x2136";
  var between$2 = "#x226C";
  var bfr$1 = "#x1D51F";
  var bigcap$1 = "#x22C2";
  var bigcirc$1 = "#x25EF";
  var bigcup$1 = "#x22C3";
  var bigodot$1 = "#x2A00";
  var bigoplus$1 = "#x2A01";
  var bigotimes$1 = "#x2A02";
  var bigsqcup$1 = "#x2A06";
  var bigstar$1 = "#x2605";
  var bigtriangledown$1 = "#x25BD";
  var bigtriangleup$1 = "#x25B3";
  var biguplus$1 = "#x2A04";
  var bigvee$1 = "#x22C1";
  var bigwedge$1 = "#x22C0";
  var bkarow$1 = "#x290D";
  var blacklozenge$1 = "#x29EB";
  var blacksquare$1 = "#x25AA";
  var blacktriangle$1 = "#x25B4";
  var blacktriangledown$1 = "#x25BE";
  var blacktriangleleft$1 = "#x25C2";
  var blacktriangleright$1 = "#x25B8";
  var blank$2 = "#x2423";
  var blk12$1 = "#x2592";
  var blk14$1 = "#x2591";
  var blk34$1 = "#x2593";
  var block$2 = "#x2588";
  var bne$1 = "&#x20E5";
  var bnequiv$1 = "#x2261;&#x20E5";
  var bnot$1 = "#x2310";
  var bopf$1 = "#x1D553";
  var bot$2 = "#x22A5";
  var bottom$2 = "#x22A5";
  var bowtie$2 = "#x22C8";
  var boxDL$1 = "#x2557";
  var boxDR$1 = "#x2554";
  var boxDl$1 = "#x2556";
  var boxDr$1 = "#x2553";
  var boxH$1 = "#x2550";
  var boxHD$1 = "#x2566";
  var boxHU$1 = "#x2569";
  var boxHd$1 = "#x2564";
  var boxHu$1 = "#x2567";
  var boxUL$1 = "#x255D";
  var boxUR$1 = "#x255A";
  var boxUl$1 = "#x255C";
  var boxUr$1 = "#x2559";
  var boxV$1 = "#x2551";
  var boxVH$1 = "#x256C";
  var boxVL$1 = "#x2563";
  var boxVR$1 = "#x2560";
  var boxVh$1 = "#x256B";
  var boxVl$1 = "#x2562";
  var boxVr$1 = "#x255F";
  var boxbox$1 = "#x29C9";
  var boxdL$1 = "#x2555";
  var boxdR$1 = "#x2552";
  var boxdl$1 = "#x2510";
  var boxdr$1 = "#x250C";
  var boxh$1 = "#x2500";
  var boxhD$1 = "#x2565";
  var boxhU$1 = "#x2568";
  var boxhd$1 = "#x252C";
  var boxhu$1 = "#x2534";
  var boxminus$1 = "#x229F";
  var boxplus$1 = "#x229E";
  var boxtimes$1 = "#x22A0";
  var boxuL$1 = "#x255B";
  var boxuR$1 = "#x2558";
  var boxul$1 = "#x2518";
  var boxur$1 = "#x2514";
  var boxv$1 = "#x2502";
  var boxvH$1 = "#x256A";
  var boxvL$1 = "#x2561";
  var boxvR$1 = "#x255E";
  var boxvh$1 = "#x253C";
  var boxvl$1 = "#x2524";
  var boxvr$1 = "#x251C";
  var bprime$1 = "#x2035";
  var breve$2 = "#x2D8";
  var bscr$1 = "#x1D4B7";
  var bsemi$1 = "#x204F";
  var bsim$1 = "#x223D";
  var bsime$1 = "#x22CD";
  var bsolb$1 = "#x29C5";
  var bsolhsub$1 = "#x27C8";
  var bullet$2 = "bull";
  var bump$2 = "#x224E";
  var bumpE$1 = "#x2AAE";
  var bumpe$1 = "#x224F";
  var bumpeq$1 = "#x224F";
  var cacute$2 = "#x107";
  var capand$2 = "#x2A44";
  var capbrcup$1 = "#x2A49";
  var capcap$1 = "#x2A4B";
  var capcup$1 = "#x2A47";
  var capdot$1 = "#x2A40";
  var caps$2 = "#x2229;&#xFE00";
  var caret$2 = "#x2041";
  var caron$2 = "#x2C7";
  var ccaps$1 = "#x2A4D";
  var ccaron$1 = "#x10D";
  var ccirc$1 = "#x109";
  var ccups$1 = "#x2A4C";
  var ccupssm$1 = "#x2A50";
  var cdot$1 = "#x10B";
  var cemptyv$1 = "#x29B2";
  var centerdot$1 = "middot";
  var cfr$1 = "#x1D520";
  var chcy$1 = "#x447";
  var check$2 = "#x2713";
  var checkmark$2 = "#x2713";
  var cir$2 = "#x25CB";
  var cirE$1 = "#x29C3";
  var circeq$1 = "#x2257";
  var circlearrowleft$1 = "#x21BA";
  var circlearrowright$1 = "#x21BB";
  var circledR$1 = "reg";
  var circledS$1 = "#x24C8";
  var circledast$1 = "#x229B";
  var circledcirc$1 = "#x229A";
  var circleddash$1 = "#x229D";
  var cire$1 = "#x2257";
  var cirfnint$1 = "#x2A10";
  var cirmid$1 = "#x2AEF";
  var cirscir$1 = "#x29C2";
  var clubsuit$2 = "clubs";
  var colone$2 = "#x2254";
  var coloneq$1 = "#x2254";
  var comp$2 = "#x2201";
  var compfn$1 = "#x2218";
  var complement$2 = "#x2201";
  var complexes$2 = "#x2102";
  var congdot$1 = "#x2A6D";
  var conint$2 = "#x222E";
  var copf$2 = "#x1D554";
  var coprod$2 = "#x2210";
  var copysr$1 = "#x2117";
  var cross$2 = "#x2717";
  var cscr$1 = "#x1D4B8";
  var csub$1 = "#x2ACF";
  var csube$1 = "#x2AD1";
  var csup$1 = "#x2AD0";
  var csupe$1 = "#x2AD2";
  var ctdot$1 = "#x22EF";
  var cudarrl$1 = "#x2938";
  var cudarrr$1 = "#x2935";
  var cuepr$1 = "#x22DE";
  var cuesc$1 = "#x22DF";
  var cularr$1 = "#x21B6";
  var cularrp$1 = "#x293D";
  var cupbrcap$1 = "#x2A48";
  var cupcap$1 = "#x2A46";
  var cupcup$1 = "#x2A4A";
  var cupdot$1 = "#x228D";
  var cupor$1 = "#x2A45";
  var cups$2 = "#x222A;&#xFE00";
  var curarr$1 = "#x21B7";
  var curarrm$1 = "#x293C";
  var curlyeqprec$1 = "#x22DE";
  var curlyeqsucc$1 = "#x22DF";
  var curlyvee$1 = "#x22CE";
  var curlywedge$1 = "#x22CF";
  var curvearrowleft$1 = "#x21B6";
  var curvearrowright$1 = "#x21B7";
  var cuvee$1 = "#x22CE";
  var cuwed$1 = "#x22CF";
  var cwconint$1 = "#x2232";
  var cwint$1 = "#x2231";
  var cylcty$1 = "#x232D";
  var dHar$1 = "#x2965";
  var daleth$2 = "#x2138";
  var dash$2 = "#x2010";
  var dashv$1 = "#x22A3";
  var dbkarow$1 = "#x290F";
  var dblac$1 = "#x2DD";
  var dcaron$1 = "#x10F";
  var dcy$1 = "#x434";
  var dd$2 = "#x2146";
  var ddagger$1 = "Dagger";
  var ddarr$1 = "#x21CA";
  var ddotseq$1 = "#x2A77";
  var demptyv$1 = "#x29B1";
  var dfisht$1 = "#x297F";
  var dfr$1 = "#x1D521";
  var dharl$1 = "#x21C3";
  var dharr$2 = "#x21C2";
  var diam$2 = "#x22C4";
  var diamond$2 = "#x22C4";
  var diamondsuit$1 = "diams";
  var die$2 = "#xA8";
  var digamma$2 = "#x3DD";
  var disin$2 = "#x22F2";
  var div$2 = "#xF7";
  var divideontimes$1 = "#x22C7";
  var divonx$1 = "#x22C7";
  var djcy$1 = "#x452";
  var dlcorn$1 = "#x231E";
  var dlcrop$1 = "#x230D";
  var dopf$2 = "#x1D555";
  var dot$2 = "#x2D9";
  var doteq$1 = "#x2250";
  var doteqdot$1 = "#x2251";
  var dotminus$1 = "#x2238";
  var dotplus$1 = "#x2214";
  var dotsquare$1 = "#x22A1";
  var doublebarwedge$1 = "#x2306";
  var downarrow$1 = "darr";
  var downdownarrows$1 = "#x21CA";
  var downharpoonleft$1 = "#x21C3";
  var downharpoonright$1 = "#x21C2";
  var drbkarow$1 = "#x2910";
  var drcorn$1 = "#x231F";
  var drcrop$1 = "#x230C";
  var dscr$1 = "#x1D4B9";
  var dscy$1 = "#x455";
  var dsol$2 = "#x29F6";
  var dstrok$1 = "#x111";
  var dtdot$1 = "#x22F1";
  var dtri$2 = "#x25BF";
  var dtrif$1 = "#x25BE";
  var duarr$1 = "#x21F5";
  var duhar$1 = "#x296F";
  var dwangle$1 = "#x29A6";
  var dzcy$1 = "#x45F";
  var dzigrarr$1 = "#x27FF";
  var eDDot$1 = "#x2A77";
  var eDot$1 = "#x2251";
  var easter$2 = "#x2A6E";
  var ecaron$1 = "#x11B";
  var ecir$2 = "#x2256";
  var ecolon$2 = "#x2255";
  var ecy$2 = "#x44D";
  var edot$2 = "#x117";
  var ee$2 = "#x2147";
  var efDot$1 = "#x2252";
  var efr$2 = "#x1D522";
  var eg$2 = "#x2A9A";
  var egs$2 = "#x2A96";
  var egsdot$1 = "#x2A98";
  var el$2 = "#x2A99";
  var elinters$1 = "#x23E7";
  var ell$2 = "#x2113";
  var els$2 = "#x2A95";
  var elsdot$1 = "#x2A97";
  var emacr$1 = "#x113";
  var emptyset$1 = "empty";
  var emptyv$1 = "empty";
  var emsp13$1 = "#x2004";
  var emsp14$1 = "#x2005";
  var eng$2 = "#x14B";
  var eogon$1 = "#x119";
  var eopf$1 = "#x1D556";
  var epar$1 = "#x22D5";
  var eparsl$1 = "#x29E3";
  var eplus$1 = "#x2A71";
  var epsi$2 = "#x3B5";
  var epsiv$1 = "#x3F5";
  var eqcirc$1 = "#x2256";
  var eqcolon$1 = "#x2255";
  var eqsim$1 = "#x2242";
  var eqslantgtr$1 = "#x2A96";
  var eqslantless$1 = "#x2A95";
  var equest$2 = "#x225F";
  var equivDD$1 = "#x2A78";
  var eqvparsl$1 = "#x29E5";
  var erDot$1 = "#x2253";
  var erarr$1 = "#x2971";
  var escr$2 = "#x212F";
  var esdot$1 = "#x2250";
  var esim$2 = "#x2242";
  var expectation$2 = "#x2130";
  var exponentiale$1 = "#x2147";
  var fallingdotseq$1 = "#x2252";
  var fcy$1 = "#x444";
  var female$2 = "#x2640";
  var ffilig$1 = "#xFB03";
  var fflig$1 = "#xFB00";
  var ffllig$1 = "#xFB04";
  var ffr$1 = "#x1D523";
  var filig$1 = "#xFB01";
  var flat$2 = "#x266D";
  var fllig$1 = "#xFB02";
  var fltns$1 = "#x25B1";
  var fopf$1 = "#x1D557";
  var fork$2 = "#x22D4";
  var forkv$1 = "#x2AD9";
  var fpartint$1 = "#x2A0D";
  var frac13$1 = "#x2153";
  var frac15$1 = "#x2155";
  var frac16$1 = "#x2159";
  var frac18$1 = "#x215B";
  var frac23$1 = "#x2154";
  var frac25$1 = "#x2156";
  var frac35$1 = "#x2157";
  var frac38$1 = "#x215C";
  var frac45$1 = "#x2158";
  var frac56$1 = "#x215A";
  var frac58$1 = "#x215D";
  var frac78$1 = "#x215E";
  var frown$2 = "#x2322";
  var fscr$1 = "#x1D4BB";
  var gE$1 = "#x2267";
  var gEl$1 = "#x2A8C";
  var gacute$1 = "#x1F5";
  var gammad$1 = "#x3DD";
  var gap$2 = "#x2A86";
  var gbreve$1 = "#x11F";
  var gcirc$1 = "#x11D";
  var gcy$2 = "#x433";
  var gdot$1 = "#x121";
  var gel$2 = "#x22DB";
  var geq$2 = "ge";
  var geqq$1 = "#x2267";
  var geqslant$1 = "#x2A7E";
  var ges$2 = "#x2A7E";
  var gescc$1 = "#x2AA9";
  var gesdot$1 = "#x2A80";
  var gesdoto$1 = "#x2A82";
  var gesdotol$1 = "#x2A84";
  var gesl$2 = "#x22DB;&#xFE00";
  var gesles$1 = "#x2A94";
  var gfr$1 = "#x1D524";
  var gg$2 = "#x226B";
  var ggg$1 = "#x22D9";
  var gimel$1 = "#x2137";
  var gjcy$1 = "#x453";
  var gl$2 = "#x2277";
  var glE$1 = "#x2A92";
  var gla$2 = "#x2AA5";
  var glj$1 = "#x2AA4";
  var gnE$1 = "#x2269";
  var gnap$1 = "#x2A8A";
  var gnapprox$1 = "#x2A8A";
  var gne$2 = "#x2A88";
  var gneq$1 = "#x2A88";
  var gneqq$1 = "#x2269";
  var gnsim$1 = "#x22E7";
  var gopf$1 = "#x1D558";
  var grave$2 = "#x60";
  var gscr$1 = "#x210A";
  var gsim$1 = "#x2273";
  var gsime$1 = "#x2A8E";
  var gsiml$1 = "#x2A90";
  var gtcc$1 = "#x2AA7";
  var gtcir$1 = "#x2A7A";
  var gtdot$1 = "#x22D7";
  var gtlPar$1 = "#x2995";
  var gtquest$1 = "#x2A7C";
  var gtrapprox$1 = "#x2A86";
  var gtrarr$1 = "#x2978";
  var gtrdot$1 = "#x22D7";
  var gtreqless$1 = "#x22DB";
  var gtreqqless$1 = "#x2A8C";
  var gtrless$1 = "#x2277";
  var gtrsim$1 = "#x2273";
  var gvertneqq$1 = "#x2269;&#xFE00";
  var gvnE$1 = "#x2269;&#xFE00";
  var hairsp$1 = "#x200A";
  var half$2 = "#xBD";
  var hamilt$1 = "#x210B";
  var hardcy$1 = "#x44A";
  var harrcir$1 = "#x2948";
  var harrw$1 = "#x21AD";
  var hbar$1 = "#x210F";
  var hcirc$1 = "#x125";
  var heartsuit$1 = "hearts";
  var hercon$1 = "#x22B9";
  var hfr$1 = "#x1D525";
  var hksearow$1 = "#x2925";
  var hkswarow$1 = "#x2926";
  var hoarr$1 = "#x21FF";
  var homtht$1 = "#x223B";
  var hookleftarrow$1 = "#x21A9";
  var hookrightarrow$1 = "#x21AA";
  var hopf$2 = "#x1D559";
  var horbar$1 = "#x2015";
  var hscr$1 = "#x1D4BD";
  var hslash$1 = "#x210F";
  var hstrok$1 = "#x127";
  var hybull$1 = "#x2043";
  var hyphen$2 = "#x2010";
  var ic$2 = "#x2063";
  var icy$2 = "#x438";
  var iecy$1 = "#x435";
  var iff$2 = "#x21D4";
  var ifr$1 = "#x1D526";
  var ii$2 = "#x2148";
  var iiiint$1 = "#x2A0C";
  var iiint$1 = "#x222D";
  var iinfin$1 = "#x29DC";
  var iiota$1 = "#x2129";
  var ijlig$1 = "#x133";
  var imacr$1 = "#x12B";
  var imagline$1 = "#x2110";
  var imagpart$1 = "#x2111";
  var imath$1 = "#x131";
  var imof$1 = "#x22B7";
  var imped$2 = "#x1B5";
  var incare$1 = "#x2105";
  var infintie$1 = "#x29DD";
  var inodot$1 = "#x131";
  var intcal$1 = "#x22BA";
  var integers$2 = "#x2124";
  var intercal$1 = "#x22BA";
  var intlarhk$1 = "#x2A17";
  var intprod$1 = "#x2A3C";
  var iocy$2 = "#x451";
  var iogon$2 = "#x12F";
  var iopf$1 = "#x1D55A";
  var iprod$1 = "#x2A3C";
  var iscr$1 = "#x1D4BE";
  var isinE$1 = "#x22F9";
  var isindot$1 = "#x22F5";
  var isins$1 = "#x22F4";
  var isinsv$1 = "#x22F3";
  var isinv$1 = "#x2208";
  var it$2 = "#x2062";
  var itilde$1 = "#x129";
  var iukcy$1 = "#x456";
  var jcirc$1 = "#x135";
  var jcy$1 = "#x439";
  var jfr$1 = "#x1D527";
  var jmath$1 = "#x237";
  var jopf$1 = "#x1D55B";
  var jscr$1 = "#x1D4BF";
  var jsercy$1 = "#x458";
  var jukcy$1 = "#x454";
  var kappav$1 = "#x3F0";
  var kcedil$1 = "#x137";
  var kcy$1 = "#x43A";
  var kfr$1 = "#x1D528";
  var kgreen$1 = "#x138";
  var khcy$1 = "#x445";
  var kjcy$1 = "#x45C";
  var kopf$2 = "#x1D55C";
  var kscr$1 = "#x1D4C0";
  var lAarr$1 = "#x21DA";
  var lAtail$1 = "#x291B";
  var lBarr$1 = "#x290E";
  var lE$1 = "#x2266";
  var lEg$1 = "#x2A8B";
  var lHar$1 = "#x2962";
  var lacute$1 = "#x13A";
  var laemptyv$1 = "#x29B4";
  var lagran$1 = "#x2112";
  var langd$1 = "#x2991";
  var langle$1 = "lang";
  var lap$2 = "#x2A85";
  var larrb$1 = "#x21E4";
  var larrbfs$1 = "#x291F";
  var larrfs$1 = "#x291D";
  var larrhk$1 = "#x21A9";
  var larrlp$1 = "#x21AB";
  var larrpl$1 = "#x2939";
  var larrsim$1 = "#x2973";
  var larrtl$1 = "#x21A2";
  var lat$2 = "#x2AAB";
  var latail$1 = "#x2919";
  var late$2 = "#x2AAD";
  var lates$2 = "#x2AAD;&#xFE00";
  var lbarr$1 = "#x290C";
  var lbbrk$1 = "#x2772";
  var lbrace$1 = "{";
  var lbrack$1 = "[";
  var lbrke$1 = "#x298B";
  var lbrksld$1 = "#x298F";
  var lbrkslu$1 = "#x298D";
  var lcaron$1 = "#x13E";
  var lcedil$1 = "#x13C";
  var lcub$1 = "{";
  var lcy$1 = "#x43B";
  var ldca$1 = "#x2936";
  var ldquor$1 = "bdquo";
  var ldrdhar$1 = "#x2967";
  var ldrushar$1 = "#x294B";
  var ldsh$1 = "#x21B2";
  var leftarrow$1 = "larr";
  var leftarrowtail$1 = "#x21A2";
  var leftharpoondown$1 = "#x21BD";
  var leftharpoonup$1 = "#x21BC";
  var leftleftarrows$1 = "#x21C7";
  var leftrightarrow$1 = "harr";
  var leftrightarrows$1 = "#x21C6";
  var leftrightharpoons$1 = "#x21CB";
  var leftrightsquigarrow$1 = "#x21AD";
  var leftthreetimes$1 = "#x22CB";
  var leg$2 = "#x22DA";
  var leq$2 = "le";
  var leqq$1 = "#x2266";
  var leqslant$1 = "#x2A7D";
  var les$2 = "#x2A7D";
  var lescc$1 = "#x2AA8";
  var lesdot$1 = "#x2A7F";
  var lesdoto$1 = "#x2A81";
  var lesdotor$1 = "#x2A83";
  var lesg$1 = "#x22DA;&#xFE00";
  var lesges$1 = "#x2A93";
  var lessapprox$1 = "#x2A85";
  var lessdot$1 = "#x22D6";
  var lesseqgtr$1 = "#x22DA";
  var lesseqqgtr$1 = "#x2A8B";
  var lessgtr$1 = "#x2276";
  var lesssim$1 = "#x2272";
  var lfisht$1 = "#x297C";
  var lfr$1 = "#x1D529";
  var lg$2 = "#x2276";
  var lgE$1 = "#x2A91";
  var lhard$1 = "#x21BD";
  var lharu$1 = "#x21BC";
  var lharul$1 = "#x296A";
  var lhblk$1 = "#x2584";
  var ljcy$1 = "#x459";
  var ll$2 = "#x226A";
  var llarr$1 = "#x21C7";
  var llcorner$1 = "#x231E";
  var llhard$1 = "#x296B";
  var lltri$1 = "#x25FA";
  var lmidot$1 = "#x140";
  var lmoust$1 = "#x23B0";
  var lmoustache$1 = "#x23B0";
  var lnE$1 = "#x2268";
  var lnap$1 = "#x2A89";
  var lnapprox$1 = "#x2A89";
  var lne$2 = "#x2A87";
  var lneq$1 = "#x2A87";
  var lneqq$1 = "#x2268";
  var lnsim$1 = "#x22E6";
  var loang$1 = "#x27EC";
  var loarr$1 = "#x21FD";
  var lobrk$1 = "#x27E6";
  var longleftarrow$1 = "#x27F5";
  var longleftrightarrow$1 = "#x27F7";
  var longmapsto$1 = "#x27FC";
  var longrightarrow$1 = "#x27F6";
  var looparrowleft$1 = "#x21AB";
  var looparrowright$1 = "#x21AC";
  var lopar$1 = "#x2985";
  var lopf$1 = "#x1D55D";
  var loplus$1 = "#x2A2D";
  var lotimes$1 = "#x2A34";
  var lozenge$2 = "loz";
  var lozf$1 = "#x29EB";
  var lparlt$1 = "#x2993";
  var lrarr$1 = "#x21C6";
  var lrcorner$1 = "#x231F";
  var lrhar$1 = "#x21CB";
  var lrhard$1 = "#x296D";
  var lrtri$1 = "#x22BF";
  var lscr$1 = "#x1D4C1";
  var lsh$2 = "#x21B0";
  var lsim$1 = "#x2272";
  var lsime$1 = "#x2A8D";
  var lsimg$1 = "#x2A8F";
  var lsquor$1 = "sbquo";
  var lstrok$1 = "#x142";
  var ltcc$1 = "#x2AA6";
  var ltcir$1 = "#x2A79";
  var ltdot$1 = "#x22D6";
  var lthree$1 = "#x22CB";
  var ltimes$2 = "#x22C9";
  var ltlarr$1 = "#x2976";
  var ltquest$1 = "#x2A7B";
  var ltrPar$1 = "#x2996";
  var ltri$1 = "#x25C3";
  var ltrie$1 = "#x22B4";
  var ltrif$1 = "#x25C2";
  var lurdshar$1 = "#x294A";
  var luruhar$1 = "#x2966";
  var lvertneqq$1 = "#x2268;&#xFE00";
  var lvnE$1 = "#x2268;&#xFE00";
  var mDDot$1 = "#x223A";
  var male$2 = "#x2642";
  var malt$2 = "#x2720";
  var maltese$1 = "#x2720";
  var map$2 = "#x21A6";
  var mapsto$1 = "#x21A6";
  var mapstodown$1 = "#x21A7";
  var mapstoleft$1 = "#x21A4";
  var mapstoup$1 = "#x21A5";
  var marker$2 = "#x25AE";
  var mcomma$1 = "#x2A29";
  var mcy$1 = "#x43C";
  var measuredangle$1 = "#x2221";
  var mfr$1 = "#x1D52A";
  var mho$1 = "#x2127";
  var mid$2 = "#x2223";
  var midcir$1 = "#x2AF0";
  var minusb$1 = "#x229F";
  var minusd$1 = "#x2238";
  var minusdu$1 = "#x2A2A";
  var mlcp$1 = "#x2ADB";
  var mldr$1 = "#x2026";
  var mnplus$1 = "#x2213";
  var models$2 = "#x22A7";
  var mopf$1 = "#x1D55E";
  var mp$2 = "#x2213";
  var mscr$1 = "#x1D4C2";
  var mstpos$1 = "#x223E";
  var multimap$1 = "#x22B8";
  var mumap$1 = "#x22B8";
  var nGg$1 = "#x22D9;&#x338";
  var nGt$1 = "#x226B;&#x20D2";
  var nGtv$1 = "#x226B;&#x338";
  var nLeftarrow$1 = "#x21CD";
  var nLeftrightarrow$1 = "#x21CE";
  var nLl$1 = "#x22D8;&#x338";
  var nLt$1 = "#x226A;&#x20D2";
  var nLtv$1 = "#x226A;&#x338";
  var nRightarrow$1 = "#x21CF";
  var nVDash$1 = "#x22AF";
  var nVdash$1 = "#x22AE";
  var nacute$1 = "#x144";
  var nang$2 = "#x2220;&#x20D2";
  var nap$2 = "#x2249";
  var napE$1 = "#x2A70;&#x338";
  var napid$1 = "#x224B;&#x338";
  var napos$1 = "#x149";
  var napprox$1 = "#x2249";
  var natur$1 = "#x266E";
  var natural$2 = "#x266E";
  var naturals$2 = "#x2115";
  var nbump$1 = "#x224E;&#x338";
  var nbumpe$1 = "#x224F;&#x338";
  var ncap$1 = "#x2A43";
  var ncaron$1 = "#x148";
  var ncedil$1 = "#x146";
  var ncong$1 = "#x2247";
  var ncongdot$1 = "#x2A6D;&#x338";
  var ncup$1 = "#x2A42";
  var ncy$2 = "#x43D";
  var neArr$1 = "#x21D7";
  var nearhk$1 = "#x2924";
  var nearr$1 = "#x2197";
  var nearrow$1 = "#x2197";
  var nedot$1 = "#x2250;&#x338";
  var nequiv$1 = "#x2262";
  var nesear$1 = "#x2928";
  var nesim$1 = "#x2242;&#x338";
  var nexist$1 = "#x2204";
  var nexists$1 = "#x2204";
  var nfr$1 = "#x1D52B";
  var ngE$1 = "#x2267;&#x338";
  var nge$2 = "#x2271";
  var ngeq$1 = "#x2271";
  var ngeqq$1 = "#x2267;&#x338";
  var ngeqslant$1 = "#x2A7E;&#x338";
  var nges$1 = "#x2A7E;&#x338";
  var ngsim$1 = "#x2275";
  var ngt$2 = "#x226F";
  var ngtr$1 = "#x226F";
  var nhArr$1 = "#x21CE";
  var nharr$1 = "#x21AE";
  var nhpar$1 = "#x2AF2";
  var nis$2 = "#x22FC";
  var nisd$1 = "#x22FA";
  var niv$1 = "ni";
  var njcy$1 = "#x45A";
  var nlArr$1 = "#x21CD";
  var nlE$1 = "#x2266;&#x338";
  var nlarr$1 = "#x219A";
  var nldr$1 = "#x2025";
  var nle$2 = "#x2270";
  var nleftarrow$1 = "#x219A";
  var nleftrightarrow$1 = "#x21AE";
  var nleq$1 = "#x2270";
  var nleqq$1 = "#x2266;&#x338";
  var nleqslant$1 = "#x2A7D;&#x338";
  var nles$2 = "#x2A7D;&#x338";
  var nless$2 = "#x226E";
  var nlsim$1 = "#x2274";
  var nlt$2 = "#x226E";
  var nltri$1 = "#x22EA";
  var nltrie$1 = "#x22EC";
  var nmid$1 = "#x2224";
  var nopf$2 = "#x1D55F";
  var notinE$1 = "#x22F9;&#x338";
  var notindot$1 = "#x22F5;&#x338";
  var notinva$1 = "notin";
  var notinvb$1 = "#x22F7";
  var notinvc$1 = "#x22F6";
  var notni$1 = "#x220C";
  var notniva$1 = "#x220C";
  var notnivb$1 = "#x22FE";
  var notnivc$1 = "#x22FD";
  var npar$1 = "#x2226";
  var nparallel$1 = "#x2226";
  var nparsl$1 = "#x2AFD;&#x20E5";
  var npart$1 = "#x2202;&#x338";
  var npolint$1 = "#x2A14";
  var npr$1 = "#x2280";
  var nprcue$1 = "#x22E0";
  var npre$1 = "#x2AAF;&#x338";
  var nprec$1 = "#x2280";
  var npreceq$1 = "#x2AAF;&#x338";
  var nrArr$1 = "#x21CF";
  var nrarr$1 = "#x219B";
  var nrarrc$1 = "#x2933;&#x338";
  var nrarrw$1 = "#x219D;&#x338";
  var nrightarrow$1 = "#x219B";
  var nrtri$1 = "#x22EB";
  var nrtrie$1 = "#x22ED";
  var nsc$2 = "#x2281";
  var nsccue$1 = "#x22E1";
  var nsce$2 = "#x2AB0;&#x338";
  var nscr$1 = "#x1D4C3";
  var nshortmid$1 = "#x2224";
  var nshortparallel$1 = "#x2226";
  var nsim$1 = "#x2241";
  var nsime$1 = "#x2244";
  var nsimeq$1 = "#x2244";
  var nsmid$1 = "#x2224";
  var nspar$1 = "#x2226";
  var nsqsube$1 = "#x22E2";
  var nsqsupe$1 = "#x22E3";
  var nsubE$1 = "#x2AC5;&#x338";
  var nsube$1 = "#x2288";
  var nsubset$1 = "#x2282;&#x20D2";
  var nsubseteq$1 = "#x2288";
  var nsubseteqq$1 = "#x2AC5;&#x338";
  var nsucc$1 = "#x2281";
  var nsucceq$1 = "#x2AB0;&#x338";
  var nsup$1 = "#x2285";
  var nsupE$1 = "#x2AC6;&#x338";
  var nsupe$1 = "#x2289";
  var nsupset$1 = "#x2283;&#x20D2";
  var nsupseteq$1 = "#x2289";
  var nsupseteqq$1 = "#x2AC6;&#x338";
  var ntgl$1 = "#x2279";
  var ntlg$1 = "#x2278";
  var ntriangleleft$1 = "#x22EA";
  var ntrianglelefteq$1 = "#x22EC";
  var ntriangleright$1 = "#x22EB";
  var ntrianglerighteq$1 = "#x22ED";
  var numero$1 = "#x2116";
  var numsp$1 = "#x2007";
  var nvDash$1 = "#x22AD";
  var nvHarr$1 = "#x2904";
  var nvap$1 = "#x224D;&#x20D2";
  var nvdash$1 = "#x22AC";
  var nvge$1 = "#x2265;&#x20D2";
  var nvgt$1 = "#x3E;&#x20D2";
  var nvinfin$1 = "#x29DE";
  var nvlArr$1 = "#x2902";
  var nvle$1 = "#x2264;&#x20D2";
  var nvlt$1 = "#x3C;&#x20D2";
  var nvltrie$1 = "#x22B4;&#x20D2";
  var nvrArr$1 = "#x2903";
  var nvrtrie$1 = "#x22B5;&#x20D2";
  var nvsim$1 = "#x223C;&#x20D2";
  var nwArr$1 = "#x21D6";
  var nwarhk$1 = "#x2923";
  var nwarr$1 = "#x2196";
  var nwarrow$1 = "#x2196";
  var nwnear$1 = "#x2927";
  var oS$1 = "#x24C8";
  var oast$1 = "#x229B";
  var ocir$1 = "#x229A";
  var ocy$1 = "#x43E";
  var odash$1 = "#x229D";
  var odblac$1 = "#x151";
  var odiv$1 = "#x2A38";
  var odot$1 = "#x2299";
  var odsold$1 = "#x29BC";
  var ofcir$1 = "#x29BF";
  var ofr$1 = "#x1D52C";
  var ogon$1 = "#x2DB";
  var ogt$2 = "#x29C1";
  var ohbar$1 = "#x29B5";
  var ohm$2 = "#x3A9";
  var oint$1 = "#x222E";
  var olarr$1 = "#x21BA";
  var olcir$1 = "#x29BE";
  var olcross$1 = "#x29BB";
  var olt$2 = "#x29C0";
  var omacr$1 = "#x14D";
  var omid$1 = "#x29B6";
  var ominus$1 = "#x2296";
  var oopf$2 = "#x1D560";
  var opar$2 = "#x29B7";
  var operp$1 = "#x29B9";
  var orarr$1 = "#x21BB";
  var ord$1 = "#x2A5D";
  var order$2 = "#x2134";
  var orderof$1 = "#x2134";
  var origof$1 = "#x22B6";
  var oror$2 = "#x2A56";
  var orslope$1 = "#x2A57";
  var orv$2 = "#x2A5B";
  var oscr$1 = "#x2134";
  var osol$2 = "#x2298";
  var otimesas$1 = "#x2A36";
  var ovbar$1 = "#x233D";
  var par$2 = "#x2225";
  var parallel$2 = "#x2225";
  var parsim$1 = "#x2AF3";
  var parsl$1 = "#x2AFD";
  var pcy$1 = "#x43F";
  var pertenk$1 = "#x2031";
  var pfr$1 = "#x1D52D";
  var phiv$1 = "#x3D5";
  var phmmat$1 = "#x2133";
  var phone$2 = "#x260E";
  var pitchfork$2 = "#x22D4";
  var planck$1 = "#x210F";
  var planckh$1 = "#x210E";
  var plankv$1 = "#x210F";
  var plusacir$1 = "#x2A23";
  var plusb$1 = "#x229E";
  var pluscir$1 = "#x2A22";
  var plusdo$1 = "#x2214";
  var plusdu$1 = "#x2A25";
  var pluse$1 = "#x2A72";
  var plussim$1 = "#x2A26";
  var plustwo$1 = "#x2A27";
  var pm$2 = "#xB1";
  var pointint$1 = "#x2A15";
  var popf$2 = "#x1D561";
  var pr$2 = "#x227A";
  var prE$1 = "#x2AB3";
  var prap$1 = "#x2AB7";
  var prcue$1 = "#x227C";
  var pre$1 = "#x2AAF";
  var prec$1 = "#x227A";
  var precapprox$1 = "#x2AB7";
  var preccurlyeq$1 = "#x227C";
  var preceq$1 = "#x2AAF";
  var precnapprox$1 = "#x2AB9";
  var precneqq$1 = "#x2AB5";
  var precnsim$1 = "#x22E8";
  var precsim$1 = "#x227E";
  var primes$2 = "#x2119";
  var prnE$1 = "#x2AB5";
  var prnap$1 = "#x2AB9";
  var prnsim$1 = "#x22E8";
  var profalar$1 = "#x232E";
  var profline$1 = "#x2312";
  var profsurf$1 = "#x2313";
  var propto$1 = "prop";
  var prsim$1 = "#x227E";
  var prurel$1 = "#x22B0";
  var pscr$1 = "#x1D4C5";
  var puncsp$1 = "#x2008";
  var qfr$1 = "#x1D52E";
  var qint$1 = "#x2A0C";
  var qopf$1 = "#x1D562";
  var qprime$1 = "#x2057";
  var qscr$1 = "#x1D4C6";
  var quaternions$1 = "#x210D";
  var quatint$1 = "#x2A16";
  var questeq$1 = "#x225F";
  var rAarr$1 = "#x21DB";
  var rAtail$1 = "#x291C";
  var rBarr$1 = "#x290F";
  var rHar$1 = "#x2964";
  var race$2 = "#x223D;&#x331";
  var racute$1 = "#x155";
  var raemptyv$1 = "#x29B3";
  var rangd$1 = "#x2992";
  var range$2 = "#x29A5";
  var rangle$1 = "rang";
  var rarrap$1 = "#x2975";
  var rarrb$1 = "#x21E5";
  var rarrbfs$1 = "#x2920";
  var rarrc$1 = "#x2933";
  var rarrfs$1 = "#x291E";
  var rarrhk$1 = "#x21AA";
  var rarrlp$1 = "#x21AC";
  var rarrpl$1 = "#x2945";
  var rarrsim$1 = "#x2974";
  var rarrtl$1 = "#x21A3";
  var rarrw$1 = "#x219D";
  var ratail$1 = "#x291A";
  var ratio$2 = "#x2236";
  var rationals$1 = "#x211A";
  var rbarr$1 = "#x290D";
  var rbbrk$1 = "#x2773";
  var rbrke$1 = "#x298C";
  var rbrksld$1 = "#x298E";
  var rbrkslu$1 = "#x2990";
  var rcaron$1 = "#x159";
  var rcedil$1 = "#x157";
  var rcy$1 = "#x440";
  var rdca$1 = "#x2937";
  var rdldhar$1 = "#x2969";
  var rdquor$1 = "rdquo";
  var rdsh$1 = "#x21B3";
  var realine$1 = "#x211B";
  var realpart$1 = "#x211C";
  var reals$2 = "#x211D";
  var rect$2 = "#x25AD";
  var rfisht$1 = "#x297D";
  var rfr$1 = "#x1D52F";
  var rhard$1 = "#x21C1";
  var rharu$1 = "#x21C0";
  var rharul$1 = "#x296C";
  var rhov$1 = "#x3F1";
  var rightarrow$1 = "rarr";
  var rightarrowtail$1 = "#x21A3";
  var rightharpoondown$1 = "#x21C1";
  var rightharpoonup$1 = "#x21C0";
  var rightleftarrows$1 = "#x21C4";
  var rightleftharpoons$1 = "#x21CC";
  var rightrightarrows$1 = "#x21C9";
  var rightsquigarrow$1 = "#x219D";
  var rightthreetimes$1 = "#x22CC";
  var ring$2 = "#x2DA";
  var risingdotseq$1 = "#x2253";
  var rlarr$1 = "#x21C4";
  var rlhar$1 = "#x21CC";
  var rmoust$1 = "#x23B1";
  var rmoustache$1 = "#x23B1";
  var rnmid$1 = "#x2AEE";
  var roang$1 = "#x27ED";
  var roarr$1 = "#x21FE";
  var robrk$1 = "#x27E7";
  var ropar$1 = "#x2986";
  var ropf$1 = "#x1D563";
  var roplus$1 = "#x2A2E";
  var rotimes$1 = "#x2A35";
  var rpargt$1 = "#x2994";
  var rppolint$1 = "#x2A12";
  var rrarr$1 = "#x21C9";
  var rscr$1 = "#x1D4C7";
  var rsh$2 = "#x21B1";
  var rsquor$1 = "rsquo";
  var rthree$1 = "#x22CC";
  var rtimes$1 = "#x22CA";
  var rtri$1 = "#x25B9";
  var rtrie$1 = "#x22B5";
  var rtrif$1 = "#x25B8";
  var rtriltri$1 = "#x29CE";
  var ruluhar$1 = "#x2968";
  var rx$1 = "#x211E";
  var sacute$1 = "#x15B";
  var sc$2 = "#x227B";
  var scE$1 = "#x2AB4";
  var scap$2 = "#x2AB8";
  var sccue$1 = "#x227D";
  var sce$2 = "#x2AB0";
  var scedil$1 = "#x15F";
  var scirc$1 = "#x15D";
  var scnE$1 = "#x2AB6";
  var scnap$1 = "#x2ABA";
  var scnsim$1 = "#x22E9";
  var scpolint$1 = "#x2A13";
  var scsim$1 = "#x227F";
  var scy$2 = "#x441";
  var sdotb$1 = "#x22A1";
  var sdote$1 = "#x2A66";
  var seArr$1 = "#x21D8";
  var searhk$1 = "#x2925";
  var searr$1 = "#x2198";
  var searrow$1 = "#x2198";
  var seswar$1 = "#x2929";
  var setminus$1 = "#x2216";
  var setmn$1 = "#x2216";
  var sext$1 = "#x2736";
  var sfr$1 = "#x1D530";
  var sfrown$1 = "#x2322";
  var sharp$2 = "#x266F";
  var shchcy$1 = "#x449";
  var shcy$1 = "#x448";
  var shortmid$1 = "#x2223";
  var shortparallel$1 = "#x2225";
  var sigmav$1 = "sigmaf";
  var simdot$1 = "#x2A6A";
  var sime$1 = "#x2243";
  var simeq$1 = "#x2243";
  var simg$1 = "#x2A9E";
  var simgE$1 = "#x2AA0";
  var siml$1 = "#x2A9D";
  var simlE$1 = "#x2A9F";
  var simne$1 = "#x2246";
  var simplus$1 = "#x2A24";
  var simrarr$1 = "#x2972";
  var slarr$1 = "larr";
  var smallsetminus$1 = "#x2216";
  var smashp$1 = "#x2A33";
  var smeparsl$1 = "#x29E4";
  var smid$1 = "#x2223";
  var smile$1 = "#x2323";
  var smt$1 = "#x2AAA";
  var smte$1 = "#x2AAC";
  var smtes$1 = "#x2AAC;&#xFE00";
  var softcy$1 = "#x44C";
  var solb$1 = "#x29C4";
  var solbar$1 = "#x233F";
  var sopf$1 = "#x1D564";
  var spadesuit$1 = "spades";
  var spar$1 = "#x2225";
  var sqcap$1 = "#x2293";
  var sqcaps$1 = "#x2293;&#xFE00";
  var sqcup$1 = "#x2294";
  var sqcups$1 = "#x2294;&#xFE00";
  var sqsub$1 = "#x228F";
  var sqsube$1 = "#x2291";
  var sqsubset$1 = "#x228F";
  var sqsubseteq$1 = "#x2291";
  var sqsup$1 = "#x2290";
  var sqsupe$1 = "#x2292";
  var sqsupset$1 = "#x2290";
  var sqsupseteq$1 = "#x2292";
  var squ$1 = "#x25A1";
  var square$2 = "#x25A1";
  var squarf$1 = "#x25AA";
  var squf$1 = "#x25AA";
  var srarr$1 = "rarr";
  var sscr$1 = "#x1D4C8";
  var ssetmn$1 = "#x2216";
  var ssmile$1 = "#x2323";
  var sstarf$1 = "#x22C6";
  var star$2 = "#x2606";
  var starf$1 = "#x2605";
  var straightepsilon$1 = "#x3F5";
  var straightphi$1 = "#x3D5";
  var strns$1 = "macr";
  var subE$1 = "#x2AC5";
  var subdot$1 = "#x2ABD";
  var subedot$1 = "#x2AC3";
  var submult$1 = "#x2AC1";
  var subnE$1 = "#x2ACB";
  var subne$1 = "#x228A";
  var subplus$1 = "#x2ABF";
  var subrarr$1 = "#x2979";
  var subset$1 = "sub";
  var subseteq$1 = "sube";
  var subseteqq$1 = "#x2AC5";
  var subsetneq$1 = "#x228A";
  var subsetneqq$1 = "#x2ACB";
  var subsim$1 = "#x2AC7";
  var subsub$1 = "#x2AD5";
  var subsup$1 = "#x2AD3";
  var succ$1 = "#x227B";
  var succapprox$1 = "#x2AB8";
  var succcurlyeq$1 = "#x227D";
  var succeq$1 = "#x2AB0";
  var succnapprox$1 = "#x2ABA";
  var succneqq$1 = "#x2AB6";
  var succnsim$1 = "#x22E9";
  var succsim$1 = "#x227F";
  var sung$1 = "#x266A";
  var supE$1 = "#x2AC6";
  var supdot$1 = "#x2ABE";
  var supdsub$1 = "#x2AD8";
  var supedot$1 = "#x2AC4";
  var suphsol$1 = "#x27C9";
  var suphsub$1 = "#x2AD7";
  var suplarr$1 = "#x297B";
  var supmult$1 = "#x2AC2";
  var supnE$1 = "#x2ACC";
  var supne$1 = "#x228B";
  var supplus$1 = "#x2AC0";
  var supset$1 = "sup";
  var supseteq$1 = "supe";
  var supseteqq$1 = "#x2AC6";
  var supsetneq$1 = "#x228B";
  var supsetneqq$1 = "#x2ACC";
  var supsim$1 = "#x2AC8";
  var supsub$1 = "#x2AD4";
  var supsup$1 = "#x2AD6";
  var swArr$1 = "#x21D9";
  var swarhk$1 = "#x2926";
  var swarr$1 = "#x2199";
  var swarrow$1 = "#x2199";
  var swnwar$1 = "#x292A";
  var target$2 = "#x2316";
  var tbrk$1 = "#x23B4";
  var tcaron$1 = "#x165";
  var tcedil$1 = "#x163";
  var tcy$1 = "#x442";
  var tdot$1 = "#x20DB";
  var telrec$1 = "#x2315";
  var tfr$1 = "#x1D531";
  var therefore$2 = "there4";
  var thetav$1 = "#x3D1";
  var thickapprox$1 = "#x2248";
  var thicksim$1 = "sim";
  var thkap$1 = "#x2248";
  var thksim$1 = "sim";
  var timesb$1 = "#x22A0";
  var timesbar$1 = "#x2A31";
  var timesd$1 = "#x2A30";
  var tint$2 = "#x222D";
  var toea$1 = "#x2928";
  var top$2 = "#x22A4";
  var topbot$1 = "#x2336";
  var topcir$1 = "#x2AF1";
  var topf$1 = "#x1D565";
  var topfork$1 = "#x2ADA";
  var tosa$2 = "#x2929";
  var tprime$1 = "#x2034";
  var triangle$2 = "#x25B5";
  var triangledown$1 = "#x25BF";
  var triangleleft$1 = "#x25C3";
  var trianglelefteq$1 = "#x22B4";
  var triangleq$1 = "#x225C";
  var triangleright$1 = "#x25B9";
  var trianglerighteq$1 = "#x22B5";
  var tridot$1 = "#x25EC";
  var trie$2 = "#x225C";
  var triminus$1 = "#x2A3A";
  var triplus$1 = "#x2A39";
  var trisb$1 = "#x29CD";
  var tritime$1 = "#x2A3B";
  var trpezium$1 = "#x23E2";
  var tscr$1 = "#x1D4C9";
  var tscy$1 = "#x446";
  var tshcy$1 = "#x45B";
  var tstrok$1 = "#x167";
  var twixt$1 = "#x226C";
  var twoheadleftarrow$1 = "#x219E";
  var twoheadrightarrow$1 = "#x21A0";
  var uHar$1 = "#x2963";
  var ubrcy$1 = "#x45E";
  var ubreve$1 = "#x16D";
  var ucy$2 = "#x443";
  var udarr$1 = "#x21C5";
  var udblac$1 = "#x171";
  var udhar$1 = "#x296E";
  var ufisht$1 = "#x297E";
  var ufr$1 = "#x1D532";
  var uharl$1 = "#x21BF";
  var uharr$1 = "#x21BE";
  var uhblk$1 = "#x2580";
  var ulcorn$1 = "#x231C";
  var ulcorner$1 = "#x231C";
  var ulcrop$1 = "#x230F";
  var ultri$1 = "#x25F8";
  var umacr$1 = "#x16B";
  var uogon$1 = "#x173";
  var uopf$1 = "#x1D566";
  var uparrow$1 = "uarr";
  var updownarrow$1 = "#x2195";
  var upharpoonleft$1 = "#x21BF";
  var upharpoonright$1 = "#x21BE";
  var uplus$2 = "#x228E";
  var upsi$2 = "#x3C5";
  var upuparrows$1 = "#x21C8";
  var urcorn$1 = "#x231D";
  var urcorner$1 = "#x231D";
  var urcrop$1 = "#x230E";
  var uring$2 = "#x16F";
  var urtri$1 = "#x25F9";
  var uscr$1 = "#x1D4CA";
  var utdot$1 = "#x22F0";
  var utilde$1 = "#x169";
  var utri$1 = "#x25B5";
  var utrif$1 = "#x25B4";
  var uuarr$1 = "#x21C8";
  var uwangle$1 = "#x29A7";
  var vArr$1 = "#x21D5";
  var vBar$1 = "#x2AE8";
  var vBarv$1 = "#x2AE9";
  var vDash$1 = "#x22A8";
  var vangrt$1 = "#x299C";
  var varepsilon$1 = "#x3F5";
  var varkappa$1 = "#x3F0";
  var varnothing$1 = "empty";
  var varphi$1 = "#x3D5";
  var varpi$1 = "piv";
  var varpropto$1 = "prop";
  var varr$1 = "#x2195";
  var varrho$1 = "#x3F1";
  var varsigma$1 = "sigmaf";
  var varsubsetneq$1 = "#x228A;&#xFE00";
  var varsubsetneqq$1 = "#x2ACB;&#xFE00";
  var varsupsetneq$1 = "#x228B;&#xFE00";
  var varsupsetneqq$1 = "#x2ACC;&#xFE00";
  var vartheta$1 = "#x3D1";
  var vartriangleleft$1 = "#x22B2";
  var vartriangleright$1 = "#x22B3";
  var vcy$1 = "#x432";
  var vdash$1 = "#x22A2";
  var vee$2 = "or";
  var veebar$1 = "#x22BB";
  var veeeq$1 = "#x225A";
  var vellip$1 = "#x22EE";
  var vfr$1 = "#x1D533";
  var vltri$1 = "#x22B2";
  var vnsub$1 = "#x2282;&#x20D2";
  var vnsup$1 = "#x2283;&#x20D2";
  var vopf$1 = "#x1D567";
  var vprop$1 = "prop";
  var vrtri$1 = "#x22B3";
  var vscr$1 = "#x1D4CB";
  var vsubnE$1 = "#x2ACB;&#xFE00";
  var vsubne$1 = "#x228A;&#xFE00";
  var vsupnE$1 = "#x2ACC;&#xFE00";
  var vsupne$1 = "#x228B;&#xFE00";
  var vzigzag$1 = "#x299A";
  var wcirc$1 = "#x175";
  var wedbar$1 = "#x2A5F";
  var wedge$2 = "and";
  var wedgeq$1 = "#x2259";
  var wfr$1 = "#x1D534";
  var wopf$1 = "#x1D568";
  var wp$1 = "#x2118";
  var wr$1 = "#x2240";
  var wreath$2 = "#x2240";
  var wscr$1 = "#x1D4CC";
  var xcap$1 = "#x22C2";
  var xcirc$1 = "#x25EF";
  var xcup$1 = "#x22C3";
  var xdtri$1 = "#x25BD";
  var xfr$1 = "#x1D535";
  var xhArr$1 = "#x27FA";
  var xharr$1 = "#x27F7";
  var xlArr$1 = "#x27F8";
  var xlarr$1 = "#x27F5";
  var xmap$1 = "#x27FC";
  var xnis$1 = "#x22FB";
  var xodot$1 = "#x2A00";
  var xopf$1 = "#x1D569";
  var xoplus$1 = "#x2A01";
  var xotime$1 = "#x2A02";
  var xrArr$1 = "#x27F9";
  var xrarr$1 = "#x27F6";
  var xscr$1 = "#x1D4CD";
  var xsqcup$1 = "#x2A06";
  var xuplus$1 = "#x2A04";
  var xutri$1 = "#x25B3";
  var xvee$1 = "#x22C1";
  var xwedge$1 = "#x22C0";
  var yacy$1 = "#x44F";
  var ycirc$2 = "#x177";
  var ycy$2 = "#x44B";
  var yfr$1 = "#x1D536";
  var yicy$1 = "#x457";
  var yopf$1 = "#x1D56A";
  var yscr$1 = "#x1D4CE";
  var yucy$1 = "#x44E";
  var zacute$2 = "#x17A";
  var zcaron$1 = "#x17E";
  var zcy$1 = "#x437";
  var zdot$1 = "#x17C";
  var zeetrf$1 = "#x2128";
  var zfr$1 = "#x1D537";
  var zhcy$1 = "#x436";
  var zigrarr$1 = "#x21DD";
  var zopf$1 = "#x1D56B";
  var zscr$1 = "#x1D4CF";
  var notEmailFriendly = {
    AMP: AMP$1,
    Abreve: Abreve$1,
    Acy: Acy$1,
    Afr: Afr$1,
    Amacr: Amacr$1,
    And: And$2,
    Aogon: Aogon$1,
    Aopf: Aopf$1,
    ApplyFunction: ApplyFunction$1,
    Ascr: Ascr$2,
    Assign: Assign$2,
    Backslash: Backslash$2,
    Barv: Barv$1,
    Barwed: Barwed$1,
    Bcy: Bcy$1,
    Because: Because$2,
    Bernoullis: Bernoullis$2,
    Bfr: Bfr$1,
    Bopf: Bopf$1,
    Breve: Breve$1,
    Bscr: Bscr$1,
    Bumpeq: Bumpeq$1,
    CHcy: CHcy$1,
    COPY: COPY$2,
    Cacute: Cacute$1,
    Cap: Cap$2,
    CapitalDifferentialD: CapitalDifferentialD$1,
    Cayleys: Cayleys$1,
    Ccaron: Ccaron$1,
    Ccirc: Ccirc$1,
    Cconint: Cconint$1,
    Cdot: Cdot$1,
    Cedilla: Cedilla$2,
    CenterDot: CenterDot$1,
    Cfr: Cfr$1,
    CircleDot: CircleDot$1,
    CircleMinus: CircleMinus$1,
    CirclePlus: CirclePlus$1,
    CircleTimes: CircleTimes$1,
    ClockwiseContourIntegral: ClockwiseContourIntegral$1,
    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote$1,
    CloseCurlyQuote: CloseCurlyQuote$1,
    Colon: Colon$2,
    Colone: Colone$2,
    Congruent: Congruent$2,
    Conint: Conint$1,
    ContourIntegral: ContourIntegral$1,
    Copf: Copf$1,
    Coproduct: Coproduct$1,
    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral$1,
    Cross: Cross$2,
    Cscr: Cscr$1,
    Cup: Cup$2,
    CupCap: CupCap$1,
    DD: DD$2,
    DDotrahd: DDotrahd$1,
    DJcy: DJcy$1,
    DScy: DScy$1,
    DZcy: DZcy$1,
    Darr: Darr$1,
    Dashv: Dashv$1,
    Dcaron: Dcaron$1,
    Dcy: Dcy$1,
    Del: Del$2,
    Dfr: Dfr$1,
    DiacriticalAcute: DiacriticalAcute$1,
    DiacriticalDot: DiacriticalDot$1,
    DiacriticalDoubleAcute: DiacriticalDoubleAcute$1,
    DiacriticalGrave: DiacriticalGrave$1,
    DiacriticalTilde: DiacriticalTilde$1,
    Diamond: Diamond$2,
    DifferentialD: DifferentialD$1,
    Dopf: Dopf$1,
    Dot: Dot$2,
    DotDot: DotDot$1,
    DotEqual: DotEqual$1,
    DoubleContourIntegral: DoubleContourIntegral$1,
    DoubleDot: DoubleDot$1,
    DoubleDownArrow: DoubleDownArrow$1,
    DoubleLeftArrow: DoubleLeftArrow$1,
    DoubleLeftRightArrow: DoubleLeftRightArrow$1,
    DoubleLeftTee: DoubleLeftTee$1,
    DoubleLongLeftArrow: DoubleLongLeftArrow$1,
    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow$1,
    DoubleLongRightArrow: DoubleLongRightArrow$1,
    DoubleRightArrow: DoubleRightArrow$1,
    DoubleRightTee: DoubleRightTee$1,
    DoubleUpArrow: DoubleUpArrow$1,
    DoubleUpDownArrow: DoubleUpDownArrow$1,
    DoubleVerticalBar: DoubleVerticalBar$1,
    DownArrow: DownArrow$1,
    DownArrowBar: DownArrowBar$1,
    DownArrowUpArrow: DownArrowUpArrow$1,
    DownBreve: DownBreve$1,
    DownLeftRightVector: DownLeftRightVector$1,
    DownLeftTeeVector: DownLeftTeeVector$1,
    DownLeftVector: DownLeftVector$1,
    DownLeftVectorBar: DownLeftVectorBar$1,
    DownRightTeeVector: DownRightTeeVector$1,
    DownRightVector: DownRightVector$1,
    DownRightVectorBar: DownRightVectorBar$1,
    DownTee: DownTee$1,
    DownTeeArrow: DownTeeArrow$1,
    Downarrow: Downarrow$1,
    Dscr: Dscr$1,
    Dstrok: Dstrok$1,
    ENG: ENG$2,
    Ecaron: Ecaron$1,
    Ecy: Ecy$1,
    Edot: Edot$1,
    Efr: Efr$1,
    Element: Element$1,
    Emacr: Emacr$1,
    EmptySmallSquare: EmptySmallSquare$1,
    EmptyVerySmallSquare: EmptyVerySmallSquare$1,
    Eogon: Eogon$1,
    Eopf: Eopf$1,
    Equal: Equal$2,
    EqualTilde: EqualTilde$1,
    Equilibrium: Equilibrium$2,
    Escr: Escr$1,
    Esim: Esim$1,
    Exists: Exists$2,
    ExponentialE: ExponentialE$1,
    Fcy: Fcy$1,
    Ffr: Ffr$1,
    FilledSmallSquare: FilledSmallSquare$1,
    FilledVerySmallSquare: FilledVerySmallSquare$1,
    Fopf: Fopf$1,
    ForAll: ForAll$1,
    Fouriertrf: Fouriertrf$1,
    Fscr: Fscr$1,
    GJcy: GJcy$1,
    GT: GT$2,
    Gammad: Gammad$1,
    Gbreve: Gbreve$1,
    Gcedil: Gcedil$1,
    Gcirc: Gcirc$1,
    Gcy: Gcy$1,
    Gdot: Gdot$1,
    Gfr: Gfr$1,
    Gg: Gg$1,
    Gopf: Gopf$1,
    GreaterEqual: GreaterEqual$1,
    GreaterEqualLess: GreaterEqualLess$1,
    GreaterFullEqual: GreaterFullEqual$1,
    GreaterGreater: GreaterGreater$1,
    GreaterLess: GreaterLess$1,
    GreaterSlantEqual: GreaterSlantEqual$1,
    GreaterTilde: GreaterTilde$1,
    Gscr: Gscr$1,
    Gt: Gt$1,
    HARDcy: HARDcy$1,
    Hacek: Hacek$1,
    Hcirc: Hcirc$1,
    Hfr: Hfr$1,
    HilbertSpace: HilbertSpace$1,
    Hopf: Hopf$1,
    HorizontalLine: HorizontalLine$1,
    Hscr: Hscr$1,
    Hstrok: Hstrok$1,
    HumpDownHump: HumpDownHump$1,
    HumpEqual: HumpEqual$1,
    IEcy: IEcy$1,
    IJlig: IJlig$1,
    IOcy: IOcy$1,
    Icy: Icy$1,
    Idot: Idot$1,
    Ifr: Ifr$1,
    Im: Im$1,
    Imacr: Imacr$1,
    ImaginaryI: ImaginaryI$1,
    Implies: Implies$1,
    Int: Int$1,
    Integral: Integral$1,
    Intersection: Intersection$1,
    InvisibleComma: InvisibleComma$1,
    InvisibleTimes: InvisibleTimes$1,
    Iogon: Iogon$1,
    Iopf: Iopf$1,
    Iscr: Iscr$1,
    Itilde: Itilde$1,
    Iukcy: Iukcy$1,
    Jcirc: Jcirc$1,
    Jcy: Jcy$1,
    Jfr: Jfr$1,
    Jopf: Jopf$1,
    Jscr: Jscr$1,
    Jsercy: Jsercy$1,
    Jukcy: Jukcy$1,
    KHcy: KHcy$1,
    KJcy: KJcy$1,
    Kcedil: Kcedil$1,
    Kcy: Kcy$1,
    Kfr: Kfr$1,
    Kopf: Kopf$1,
    Kscr: Kscr$1,
    LJcy: LJcy$1,
    LT: LT$2,
    Lacute: Lacute$1,
    Lang: Lang$1,
    Laplacetrf: Laplacetrf$1,
    Larr: Larr$1,
    Lcaron: Lcaron$1,
    Lcedil: Lcedil$1,
    Lcy: Lcy$1,
    LeftAngleBracket: LeftAngleBracket$1,
    LeftArrow: LeftArrow$1,
    LeftArrowBar: LeftArrowBar$1,
    LeftArrowRightArrow: LeftArrowRightArrow$1,
    LeftCeiling: LeftCeiling$1,
    LeftDoubleBracket: LeftDoubleBracket$1,
    LeftDownTeeVector: LeftDownTeeVector$1,
    LeftDownVector: LeftDownVector$1,
    LeftDownVectorBar: LeftDownVectorBar$1,
    LeftFloor: LeftFloor$1,
    LeftRightArrow: LeftRightArrow$1,
    LeftRightVector: LeftRightVector$1,
    LeftTee: LeftTee$1,
    LeftTeeArrow: LeftTeeArrow$1,
    LeftTeeVector: LeftTeeVector$1,
    LeftTriangle: LeftTriangle$1,
    LeftTriangleBar: LeftTriangleBar$1,
    LeftTriangleEqual: LeftTriangleEqual$1,
    LeftUpDownVector: LeftUpDownVector$1,
    LeftUpTeeVector: LeftUpTeeVector$1,
    LeftUpVector: LeftUpVector$1,
    LeftUpVectorBar: LeftUpVectorBar$1,
    LeftVector: LeftVector$1,
    LeftVectorBar: LeftVectorBar$1,
    Leftarrow: Leftarrow$1,
    Leftrightarrow: Leftrightarrow$1,
    LessEqualGreater: LessEqualGreater$1,
    LessFullEqual: LessFullEqual$1,
    LessGreater: LessGreater$1,
    LessLess: LessLess$1,
    LessSlantEqual: LessSlantEqual$1,
    LessTilde: LessTilde$1,
    Lfr: Lfr$1,
    Ll: Ll$1,
    Lleftarrow: Lleftarrow$1,
    Lmidot: Lmidot$1,
    LongLeftArrow: LongLeftArrow$1,
    LongLeftRightArrow: LongLeftRightArrow$1,
    LongRightArrow: LongRightArrow$1,
    Longleftarrow: Longleftarrow$1,
    Longleftrightarrow: Longleftrightarrow$1,
    Longrightarrow: Longrightarrow$1,
    Lopf: Lopf$1,
    LowerLeftArrow: LowerLeftArrow$1,
    LowerRightArrow: LowerRightArrow$1,
    Lscr: Lscr$1,
    Lsh: Lsh$1,
    Lstrok: Lstrok$1,
    Lt: Lt$1,
    "Map": "#x2905",
    Mcy: Mcy$1,
    MediumSpace: MediumSpace$1,
    Mellintrf: Mellintrf$1,
    Mfr: Mfr$1,
    MinusPlus: MinusPlus$1,
    Mopf: Mopf$1,
    Mscr: Mscr$1,
    NJcy: NJcy$1,
    Nacute: Nacute$1,
    Ncaron: Ncaron$1,
    Ncedil: Ncedil$1,
    Ncy: Ncy$1,
    NegativeMediumSpace: NegativeMediumSpace$1,
    NegativeThickSpace: NegativeThickSpace$1,
    NegativeThinSpace: NegativeThinSpace$1,
    NegativeVeryThinSpace: NegativeVeryThinSpace$1,
    NestedGreaterGreater: NestedGreaterGreater$1,
    NestedLessLess: NestedLessLess$1,
    Nfr: Nfr$1,
    NoBreak: NoBreak$1,
    NonBreakingSpace: NonBreakingSpace$1,
    Nopf: Nopf$1,
    Not: Not$2,
    NotCongruent: NotCongruent$1,
    NotCupCap: NotCupCap$1,
    NotDoubleVerticalBar: NotDoubleVerticalBar$1,
    NotElement: NotElement$1,
    NotEqual: NotEqual$1,
    NotEqualTilde: NotEqualTilde$1,
    NotExists: NotExists$1,
    NotGreater: NotGreater$1,
    NotGreaterEqual: NotGreaterEqual$1,
    NotGreaterFullEqual: NotGreaterFullEqual$1,
    NotGreaterGreater: NotGreaterGreater$1,
    NotGreaterLess: NotGreaterLess$1,
    NotGreaterSlantEqual: NotGreaterSlantEqual$1,
    NotGreaterTilde: NotGreaterTilde$1,
    NotHumpDownHump: NotHumpDownHump$1,
    NotHumpEqual: NotHumpEqual$1,
    NotLeftTriangle: NotLeftTriangle$1,
    NotLeftTriangleBar: NotLeftTriangleBar$1,
    NotLeftTriangleEqual: NotLeftTriangleEqual$1,
    NotLess: NotLess$1,
    NotLessEqual: NotLessEqual$1,
    NotLessGreater: NotLessGreater$1,
    NotLessLess: NotLessLess$1,
    NotLessSlantEqual: NotLessSlantEqual$1,
    NotLessTilde: NotLessTilde$1,
    NotNestedGreaterGreater: NotNestedGreaterGreater$1,
    NotNestedLessLess: NotNestedLessLess$1,
    NotPrecedes: NotPrecedes$1,
    NotPrecedesEqual: NotPrecedesEqual$1,
    NotPrecedesSlantEqual: NotPrecedesSlantEqual$1,
    NotReverseElement: NotReverseElement$1,
    NotRightTriangle: NotRightTriangle$1,
    NotRightTriangleBar: NotRightTriangleBar$1,
    NotRightTriangleEqual: NotRightTriangleEqual$1,
    NotSquareSubset: NotSquareSubset$1,
    NotSquareSubsetEqual: NotSquareSubsetEqual$1,
    NotSquareSuperset: NotSquareSuperset$1,
    NotSquareSupersetEqual: NotSquareSupersetEqual$1,
    NotSubset: NotSubset$1,
    NotSubsetEqual: NotSubsetEqual$1,
    NotSucceeds: NotSucceeds$1,
    NotSucceedsEqual: NotSucceedsEqual$1,
    NotSucceedsSlantEqual: NotSucceedsSlantEqual$1,
    NotSucceedsTilde: NotSucceedsTilde$1,
    NotSuperset: NotSuperset$1,
    NotSupersetEqual: NotSupersetEqual$1,
    NotTilde: NotTilde$1,
    NotTildeEqual: NotTildeEqual$1,
    NotTildeFullEqual: NotTildeFullEqual$1,
    NotTildeTilde: NotTildeTilde$1,
    NotVerticalBar: NotVerticalBar$1,
    Nscr: Nscr$1,
    Ocy: Ocy$1,
    Odblac: Odblac$1,
    Ofr: Ofr$1,
    Omacr: Omacr$1,
    Oopf: Oopf$1,
    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote$1,
    OpenCurlyQuote: OpenCurlyQuote$1,
    Or: Or$1,
    Oscr: Oscr$1,
    Otimes: Otimes$1,
    OverBar: OverBar$1,
    OverBrace: OverBrace$1,
    OverBracket: OverBracket$1,
    OverParenthesis: OverParenthesis$1,
    PartialD: PartialD$1,
    Pcy: Pcy$1,
    Pfr: Pfr$1,
    PlusMinus: PlusMinus$1,
    Poincareplane: Poincareplane$1,
    Popf: Popf$1,
    Pr: Pr$1,
    Precedes: Precedes$1,
    PrecedesEqual: PrecedesEqual$1,
    PrecedesSlantEqual: PrecedesSlantEqual$1,
    PrecedesTilde: PrecedesTilde$1,
    Product: Product$2,
    Proportion: Proportion$2,
    Proportional: Proportional$2,
    Pscr: Pscr$1,
    QUOT: QUOT$2,
    Qfr: Qfr$1,
    Qopf: Qopf$1,
    Qscr: Qscr$1,
    RBarr: RBarr$1,
    REG: REG$2,
    Racute: Racute$1,
    Rang: Rang$1,
    Rarr: Rarr$1,
    Rarrtl: Rarrtl$1,
    Rcaron: Rcaron$1,
    Rcedil: Rcedil$1,
    Rcy: Rcy$1,
    Re: Re$2,
    ReverseElement: ReverseElement$1,
    ReverseEquilibrium: ReverseEquilibrium$1,
    ReverseUpEquilibrium: ReverseUpEquilibrium$1,
    Rfr: Rfr$1,
    RightAngleBracket: RightAngleBracket$1,
    RightArrow: RightArrow$1,
    RightArrowBar: RightArrowBar$1,
    RightArrowLeftArrow: RightArrowLeftArrow$1,
    RightCeiling: RightCeiling$1,
    RightDoubleBracket: RightDoubleBracket$1,
    RightDownTeeVector: RightDownTeeVector$1,
    RightDownVector: RightDownVector$1,
    RightDownVectorBar: RightDownVectorBar$1,
    RightFloor: RightFloor$1,
    RightTee: RightTee$1,
    RightTeeArrow: RightTeeArrow$1,
    RightTeeVector: RightTeeVector$1,
    RightTriangle: RightTriangle$1,
    RightTriangleBar: RightTriangleBar$1,
    RightTriangleEqual: RightTriangleEqual$1,
    RightUpDownVector: RightUpDownVector$1,
    RightUpTeeVector: RightUpTeeVector$1,
    RightUpVector: RightUpVector$1,
    RightUpVectorBar: RightUpVectorBar$1,
    RightVector: RightVector$1,
    RightVectorBar: RightVectorBar$1,
    Rightarrow: Rightarrow$1,
    Ropf: Ropf$1,
    RoundImplies: RoundImplies$1,
    Rrightarrow: Rrightarrow$1,
    Rscr: Rscr$1,
    Rsh: Rsh$1,
    RuleDelayed: RuleDelayed$1,
    SHCHcy: SHCHcy$1,
    SHcy: SHcy$1,
    SOFTcy: SOFTcy$1,
    Sacute: Sacute$1,
    Sc: Sc$1,
    Scedil: Scedil$1,
    Scirc: Scirc$1,
    Scy: Scy$1,
    Sfr: Sfr$1,
    ShortDownArrow: ShortDownArrow$1,
    ShortLeftArrow: ShortLeftArrow$1,
    ShortRightArrow: ShortRightArrow$1,
    ShortUpArrow: ShortUpArrow$1,
    SmallCircle: SmallCircle$1,
    Sopf: Sopf$1,
    Sqrt: Sqrt$1,
    Square: Square$1,
    SquareIntersection: SquareIntersection$1,
    SquareSubset: SquareSubset$1,
    SquareSubsetEqual: SquareSubsetEqual$1,
    SquareSuperset: SquareSuperset$1,
    SquareSupersetEqual: SquareSupersetEqual$1,
    SquareUnion: SquareUnion$1,
    Sscr: Sscr$1,
    Star: Star$2,
    Sub: Sub$2,
    Subset: Subset$1,
    SubsetEqual: SubsetEqual$1,
    Succeeds: Succeeds$1,
    SucceedsEqual: SucceedsEqual$1,
    SucceedsSlantEqual: SucceedsSlantEqual$1,
    SucceedsTilde: SucceedsTilde$1,
    SuchThat: SuchThat$1,
    Sum: Sum$2,
    Sup: Sup$1,
    Superset: Superset$1,
    SupersetEqual: SupersetEqual$1,
    Supset: Supset$1,
    TRADE: TRADE$2,
    TSHcy: TSHcy$1,
    TScy: TScy$1,
    Tab: Tab$2,
    Tcaron: Tcaron$1,
    Tcedil: Tcedil$1,
    Tcy: Tcy$1,
    Tfr: Tfr$1,
    Therefore: Therefore$1,
    ThickSpace: ThickSpace$1,
    ThinSpace: ThinSpace$1,
    Tilde: Tilde$2,
    TildeEqual: TildeEqual$1,
    TildeFullEqual: TildeFullEqual$1,
    TildeTilde: TildeTilde$1,
    Topf: Topf$1,
    TripleDot: TripleDot$1,
    Tscr: Tscr$1,
    Tstrok: Tstrok$1,
    Uarr: Uarr$1,
    Uarrocir: Uarrocir$1,
    Ubrcy: Ubrcy$1,
    Ubreve: Ubreve$1,
    Ucy: Ucy$1,
    Udblac: Udblac$1,
    Ufr: Ufr$1,
    Umacr: Umacr$1,
    UnderBrace: UnderBrace$1,
    UnderBracket: UnderBracket$1,
    UnderParenthesis: UnderParenthesis$1,
    Union: Union$2,
    UnionPlus: UnionPlus$1,
    Uogon: Uogon$1,
    Uopf: Uopf$1,
    UpArrow: UpArrow$1,
    UpArrowBar: UpArrowBar$1,
    UpArrowDownArrow: UpArrowDownArrow$1,
    UpDownArrow: UpDownArrow$1,
    UpEquilibrium: UpEquilibrium$1,
    UpTee: UpTee$1,
    UpTeeArrow: UpTeeArrow$1,
    Uparrow: Uparrow$1,
    Updownarrow: Updownarrow$1,
    UpperLeftArrow: UpperLeftArrow$1,
    UpperRightArrow: UpperRightArrow$1,
    Upsi: Upsi$2,
    Uring: Uring$1,
    Uscr: Uscr$1,
    Utilde: Utilde$1,
    VDash: VDash$1,
    Vbar: Vbar$1,
    Vcy: Vcy$1,
    Vdash: Vdash$1,
    Vdashl: Vdashl$1,
    Vee: Vee$1,
    Verbar: Verbar$1,
    Vert: Vert$2,
    VerticalBar: VerticalBar$1,
    VerticalSeparator: VerticalSeparator$1,
    VerticalTilde: VerticalTilde$1,
    VeryThinSpace: VeryThinSpace$1,
    Vfr: Vfr$1,
    Vopf: Vopf$1,
    Vscr: Vscr$1,
    Vvdash: Vvdash$1,
    Wcirc: Wcirc$1,
    Wedge: Wedge$2,
    Wfr: Wfr$1,
    Wopf: Wopf$1,
    Wscr: Wscr$1,
    Xfr: Xfr$1,
    Xopf: Xopf$1,
    Xscr: Xscr$1,
    YAcy: YAcy$1,
    YIcy: YIcy$1,
    YUcy: YUcy$1,
    Ycirc: Ycirc$2,
    Ycy: Ycy$1,
    Yfr: Yfr$1,
    Yopf: Yopf$1,
    Yscr: Yscr$1,
    ZHcy: ZHcy$1,
    Zacute: Zacute$2,
    Zcaron: Zcaron$1,
    Zcy: Zcy$1,
    Zdot: Zdot$1,
    ZeroWidthSpace: ZeroWidthSpace$1,
    Zfr: Zfr$1,
    Zopf: Zopf$1,
    Zscr: Zscr$1,
    abreve: abreve$1,
    ac: ac$2,
    acE: acE$1,
    acd: acd$1,
    acy: acy$1,
    af: af$1,
    afr: afr$1,
    aleph: aleph$1,
    amacr: amacr$1,
    amalg: amalg$1,
    andand: andand$1,
    andd: andd$1,
    andslope: andslope$1,
    andv: andv$1,
    ange: ange$2,
    angle: angle$2,
    angmsd: angmsd$1,
    angmsdaa: angmsdaa$1,
    angmsdab: angmsdab$1,
    angmsdac: angmsdac$1,
    angmsdad: angmsdad$1,
    angmsdae: angmsdae$1,
    angmsdaf: angmsdaf$1,
    angmsdag: angmsdag$1,
    angmsdah: angmsdah$1,
    angrt: angrt$1,
    angrtvb: angrtvb$1,
    angrtvbd: angrtvbd$1,
    angsph: angsph$1,
    angst: angst$2,
    angzarr: angzarr$1,
    aogon: aogon$1,
    aopf: aopf$1,
    ap: ap$2,
    apE: apE$1,
    apacir: apacir$1,
    ape: ape$2,
    apid: apid$1,
    approx: approx$2,
    approxeq: approxeq$1,
    ascr: ascr$2,
    asympeq: asympeq$1,
    awconint: awconint$1,
    awint: awint$1,
    bNot: bNot$1,
    backcong: backcong$1,
    backepsilon: backepsilon$1,
    backprime: backprime$1,
    backsim: backsim$1,
    backsimeq: backsimeq$1,
    barvee: barvee$1,
    barwed: barwed$1,
    barwedge: barwedge$2,
    bbrk: bbrk$1,
    bbrktbrk: bbrktbrk$1,
    bcong: bcong$1,
    bcy: bcy$1,
    becaus: becaus$2,
    because: because$2,
    bemptyv: bemptyv$1,
    bepsi: bepsi$2,
    bernou: bernou$1,
    beth: beth$2,
    between: between$2,
    bfr: bfr$1,
    bigcap: bigcap$1,
    bigcirc: bigcirc$1,
    bigcup: bigcup$1,
    bigodot: bigodot$1,
    bigoplus: bigoplus$1,
    bigotimes: bigotimes$1,
    bigsqcup: bigsqcup$1,
    bigstar: bigstar$1,
    bigtriangledown: bigtriangledown$1,
    bigtriangleup: bigtriangleup$1,
    biguplus: biguplus$1,
    bigvee: bigvee$1,
    bigwedge: bigwedge$1,
    bkarow: bkarow$1,
    blacklozenge: blacklozenge$1,
    blacksquare: blacksquare$1,
    blacktriangle: blacktriangle$1,
    blacktriangledown: blacktriangledown$1,
    blacktriangleleft: blacktriangleleft$1,
    blacktriangleright: blacktriangleright$1,
    blank: blank$2,
    blk12: blk12$1,
    blk14: blk14$1,
    blk34: blk34$1,
    block: block$2,
    bne: bne$1,
    bnequiv: bnequiv$1,
    bnot: bnot$1,
    bopf: bopf$1,
    bot: bot$2,
    bottom: bottom$2,
    bowtie: bowtie$2,
    boxDL: boxDL$1,
    boxDR: boxDR$1,
    boxDl: boxDl$1,
    boxDr: boxDr$1,
    boxH: boxH$1,
    boxHD: boxHD$1,
    boxHU: boxHU$1,
    boxHd: boxHd$1,
    boxHu: boxHu$1,
    boxUL: boxUL$1,
    boxUR: boxUR$1,
    boxUl: boxUl$1,
    boxUr: boxUr$1,
    boxV: boxV$1,
    boxVH: boxVH$1,
    boxVL: boxVL$1,
    boxVR: boxVR$1,
    boxVh: boxVh$1,
    boxVl: boxVl$1,
    boxVr: boxVr$1,
    boxbox: boxbox$1,
    boxdL: boxdL$1,
    boxdR: boxdR$1,
    boxdl: boxdl$1,
    boxdr: boxdr$1,
    boxh: boxh$1,
    boxhD: boxhD$1,
    boxhU: boxhU$1,
    boxhd: boxhd$1,
    boxhu: boxhu$1,
    boxminus: boxminus$1,
    boxplus: boxplus$1,
    boxtimes: boxtimes$1,
    boxuL: boxuL$1,
    boxuR: boxuR$1,
    boxul: boxul$1,
    boxur: boxur$1,
    boxv: boxv$1,
    boxvH: boxvH$1,
    boxvL: boxvL$1,
    boxvR: boxvR$1,
    boxvh: boxvh$1,
    boxvl: boxvl$1,
    boxvr: boxvr$1,
    bprime: bprime$1,
    breve: breve$2,
    bscr: bscr$1,
    bsemi: bsemi$1,
    bsim: bsim$1,
    bsime: bsime$1,
    bsolb: bsolb$1,
    bsolhsub: bsolhsub$1,
    bullet: bullet$2,
    bump: bump$2,
    bumpE: bumpE$1,
    bumpe: bumpe$1,
    bumpeq: bumpeq$1,
    cacute: cacute$2,
    capand: capand$2,
    capbrcup: capbrcup$1,
    capcap: capcap$1,
    capcup: capcup$1,
    capdot: capdot$1,
    caps: caps$2,
    caret: caret$2,
    caron: caron$2,
    ccaps: ccaps$1,
    ccaron: ccaron$1,
    ccirc: ccirc$1,
    ccups: ccups$1,
    ccupssm: ccupssm$1,
    cdot: cdot$1,
    cemptyv: cemptyv$1,
    centerdot: centerdot$1,
    cfr: cfr$1,
    chcy: chcy$1,
    check: check$2,
    checkmark: checkmark$2,
    cir: cir$2,
    cirE: cirE$1,
    circeq: circeq$1,
    circlearrowleft: circlearrowleft$1,
    circlearrowright: circlearrowright$1,
    circledR: circledR$1,
    circledS: circledS$1,
    circledast: circledast$1,
    circledcirc: circledcirc$1,
    circleddash: circleddash$1,
    cire: cire$1,
    cirfnint: cirfnint$1,
    cirmid: cirmid$1,
    cirscir: cirscir$1,
    clubsuit: clubsuit$2,
    colone: colone$2,
    coloneq: coloneq$1,
    comp: comp$2,
    compfn: compfn$1,
    complement: complement$2,
    complexes: complexes$2,
    congdot: congdot$1,
    conint: conint$2,
    copf: copf$2,
    coprod: coprod$2,
    copysr: copysr$1,
    cross: cross$2,
    cscr: cscr$1,
    csub: csub$1,
    csube: csube$1,
    csup: csup$1,
    csupe: csupe$1,
    ctdot: ctdot$1,
    cudarrl: cudarrl$1,
    cudarrr: cudarrr$1,
    cuepr: cuepr$1,
    cuesc: cuesc$1,
    cularr: cularr$1,
    cularrp: cularrp$1,
    cupbrcap: cupbrcap$1,
    cupcap: cupcap$1,
    cupcup: cupcup$1,
    cupdot: cupdot$1,
    cupor: cupor$1,
    cups: cups$2,
    curarr: curarr$1,
    curarrm: curarrm$1,
    curlyeqprec: curlyeqprec$1,
    curlyeqsucc: curlyeqsucc$1,
    curlyvee: curlyvee$1,
    curlywedge: curlywedge$1,
    curvearrowleft: curvearrowleft$1,
    curvearrowright: curvearrowright$1,
    cuvee: cuvee$1,
    cuwed: cuwed$1,
    cwconint: cwconint$1,
    cwint: cwint$1,
    cylcty: cylcty$1,
    dHar: dHar$1,
    daleth: daleth$2,
    dash: dash$2,
    dashv: dashv$1,
    dbkarow: dbkarow$1,
    dblac: dblac$1,
    dcaron: dcaron$1,
    dcy: dcy$1,
    dd: dd$2,
    ddagger: ddagger$1,
    ddarr: ddarr$1,
    ddotseq: ddotseq$1,
    demptyv: demptyv$1,
    dfisht: dfisht$1,
    dfr: dfr$1,
    dharl: dharl$1,
    dharr: dharr$2,
    diam: diam$2,
    diamond: diamond$2,
    diamondsuit: diamondsuit$1,
    die: die$2,
    digamma: digamma$2,
    disin: disin$2,
    div: div$2,
    divideontimes: divideontimes$1,
    divonx: divonx$1,
    djcy: djcy$1,
    dlcorn: dlcorn$1,
    dlcrop: dlcrop$1,
    dopf: dopf$2,
    dot: dot$2,
    doteq: doteq$1,
    doteqdot: doteqdot$1,
    dotminus: dotminus$1,
    dotplus: dotplus$1,
    dotsquare: dotsquare$1,
    doublebarwedge: doublebarwedge$1,
    downarrow: downarrow$1,
    downdownarrows: downdownarrows$1,
    downharpoonleft: downharpoonleft$1,
    downharpoonright: downharpoonright$1,
    drbkarow: drbkarow$1,
    drcorn: drcorn$1,
    drcrop: drcrop$1,
    dscr: dscr$1,
    dscy: dscy$1,
    dsol: dsol$2,
    dstrok: dstrok$1,
    dtdot: dtdot$1,
    dtri: dtri$2,
    dtrif: dtrif$1,
    duarr: duarr$1,
    duhar: duhar$1,
    dwangle: dwangle$1,
    dzcy: dzcy$1,
    dzigrarr: dzigrarr$1,
    eDDot: eDDot$1,
    eDot: eDot$1,
    easter: easter$2,
    ecaron: ecaron$1,
    ecir: ecir$2,
    ecolon: ecolon$2,
    ecy: ecy$2,
    edot: edot$2,
    ee: ee$2,
    efDot: efDot$1,
    efr: efr$2,
    eg: eg$2,
    egs: egs$2,
    egsdot: egsdot$1,
    el: el$2,
    elinters: elinters$1,
    ell: ell$2,
    els: els$2,
    elsdot: elsdot$1,
    emacr: emacr$1,
    emptyset: emptyset$1,
    emptyv: emptyv$1,
    emsp13: emsp13$1,
    emsp14: emsp14$1,
    eng: eng$2,
    eogon: eogon$1,
    eopf: eopf$1,
    epar: epar$1,
    eparsl: eparsl$1,
    eplus: eplus$1,
    epsi: epsi$2,
    epsiv: epsiv$1,
    eqcirc: eqcirc$1,
    eqcolon: eqcolon$1,
    eqsim: eqsim$1,
    eqslantgtr: eqslantgtr$1,
    eqslantless: eqslantless$1,
    equest: equest$2,
    equivDD: equivDD$1,
    eqvparsl: eqvparsl$1,
    erDot: erDot$1,
    erarr: erarr$1,
    escr: escr$2,
    esdot: esdot$1,
    esim: esim$2,
    expectation: expectation$2,
    exponentiale: exponentiale$1,
    fallingdotseq: fallingdotseq$1,
    fcy: fcy$1,
    female: female$2,
    ffilig: ffilig$1,
    fflig: fflig$1,
    ffllig: ffllig$1,
    ffr: ffr$1,
    filig: filig$1,
    flat: flat$2,
    fllig: fllig$1,
    fltns: fltns$1,
    fopf: fopf$1,
    fork: fork$2,
    forkv: forkv$1,
    fpartint: fpartint$1,
    frac13: frac13$1,
    frac15: frac15$1,
    frac16: frac16$1,
    frac18: frac18$1,
    frac23: frac23$1,
    frac25: frac25$1,
    frac35: frac35$1,
    frac38: frac38$1,
    frac45: frac45$1,
    frac56: frac56$1,
    frac58: frac58$1,
    frac78: frac78$1,
    frown: frown$2,
    fscr: fscr$1,
    gE: gE$1,
    gEl: gEl$1,
    gacute: gacute$1,
    gammad: gammad$1,
    gap: gap$2,
    gbreve: gbreve$1,
    gcirc: gcirc$1,
    gcy: gcy$2,
    gdot: gdot$1,
    gel: gel$2,
    geq: geq$2,
    geqq: geqq$1,
    geqslant: geqslant$1,
    ges: ges$2,
    gescc: gescc$1,
    gesdot: gesdot$1,
    gesdoto: gesdoto$1,
    gesdotol: gesdotol$1,
    gesl: gesl$2,
    gesles: gesles$1,
    gfr: gfr$1,
    gg: gg$2,
    ggg: ggg$1,
    gimel: gimel$1,
    gjcy: gjcy$1,
    gl: gl$2,
    glE: glE$1,
    gla: gla$2,
    glj: glj$1,
    gnE: gnE$1,
    gnap: gnap$1,
    gnapprox: gnapprox$1,
    gne: gne$2,
    gneq: gneq$1,
    gneqq: gneqq$1,
    gnsim: gnsim$1,
    gopf: gopf$1,
    grave: grave$2,
    gscr: gscr$1,
    gsim: gsim$1,
    gsime: gsime$1,
    gsiml: gsiml$1,
    gtcc: gtcc$1,
    gtcir: gtcir$1,
    gtdot: gtdot$1,
    gtlPar: gtlPar$1,
    gtquest: gtquest$1,
    gtrapprox: gtrapprox$1,
    gtrarr: gtrarr$1,
    gtrdot: gtrdot$1,
    gtreqless: gtreqless$1,
    gtreqqless: gtreqqless$1,
    gtrless: gtrless$1,
    gtrsim: gtrsim$1,
    gvertneqq: gvertneqq$1,
    gvnE: gvnE$1,
    hairsp: hairsp$1,
    half: half$2,
    hamilt: hamilt$1,
    hardcy: hardcy$1,
    harrcir: harrcir$1,
    harrw: harrw$1,
    hbar: hbar$1,
    hcirc: hcirc$1,
    heartsuit: heartsuit$1,
    hercon: hercon$1,
    hfr: hfr$1,
    hksearow: hksearow$1,
    hkswarow: hkswarow$1,
    hoarr: hoarr$1,
    homtht: homtht$1,
    hookleftarrow: hookleftarrow$1,
    hookrightarrow: hookrightarrow$1,
    hopf: hopf$2,
    horbar: horbar$1,
    hscr: hscr$1,
    hslash: hslash$1,
    hstrok: hstrok$1,
    hybull: hybull$1,
    hyphen: hyphen$2,
    ic: ic$2,
    icy: icy$2,
    iecy: iecy$1,
    iff: iff$2,
    ifr: ifr$1,
    ii: ii$2,
    iiiint: iiiint$1,
    iiint: iiint$1,
    iinfin: iinfin$1,
    iiota: iiota$1,
    ijlig: ijlig$1,
    imacr: imacr$1,
    imagline: imagline$1,
    imagpart: imagpart$1,
    imath: imath$1,
    imof: imof$1,
    imped: imped$2,
    "in": "#x2208",
    incare: incare$1,
    infintie: infintie$1,
    inodot: inodot$1,
    intcal: intcal$1,
    integers: integers$2,
    intercal: intercal$1,
    intlarhk: intlarhk$1,
    intprod: intprod$1,
    iocy: iocy$2,
    iogon: iogon$2,
    iopf: iopf$1,
    iprod: iprod$1,
    iscr: iscr$1,
    isinE: isinE$1,
    isindot: isindot$1,
    isins: isins$1,
    isinsv: isinsv$1,
    isinv: isinv$1,
    it: it$2,
    itilde: itilde$1,
    iukcy: iukcy$1,
    jcirc: jcirc$1,
    jcy: jcy$1,
    jfr: jfr$1,
    jmath: jmath$1,
    jopf: jopf$1,
    jscr: jscr$1,
    jsercy: jsercy$1,
    jukcy: jukcy$1,
    kappav: kappav$1,
    kcedil: kcedil$1,
    kcy: kcy$1,
    kfr: kfr$1,
    kgreen: kgreen$1,
    khcy: khcy$1,
    kjcy: kjcy$1,
    kopf: kopf$2,
    kscr: kscr$1,
    lAarr: lAarr$1,
    lAtail: lAtail$1,
    lBarr: lBarr$1,
    lE: lE$1,
    lEg: lEg$1,
    lHar: lHar$1,
    lacute: lacute$1,
    laemptyv: laemptyv$1,
    lagran: lagran$1,
    langd: langd$1,
    langle: langle$1,
    lap: lap$2,
    larrb: larrb$1,
    larrbfs: larrbfs$1,
    larrfs: larrfs$1,
    larrhk: larrhk$1,
    larrlp: larrlp$1,
    larrpl: larrpl$1,
    larrsim: larrsim$1,
    larrtl: larrtl$1,
    lat: lat$2,
    latail: latail$1,
    late: late$2,
    lates: lates$2,
    lbarr: lbarr$1,
    lbbrk: lbbrk$1,
    lbrace: lbrace$1,
    lbrack: lbrack$1,
    lbrke: lbrke$1,
    lbrksld: lbrksld$1,
    lbrkslu: lbrkslu$1,
    lcaron: lcaron$1,
    lcedil: lcedil$1,
    lcub: lcub$1,
    lcy: lcy$1,
    ldca: ldca$1,
    ldquor: ldquor$1,
    ldrdhar: ldrdhar$1,
    ldrushar: ldrushar$1,
    ldsh: ldsh$1,
    leftarrow: leftarrow$1,
    leftarrowtail: leftarrowtail$1,
    leftharpoondown: leftharpoondown$1,
    leftharpoonup: leftharpoonup$1,
    leftleftarrows: leftleftarrows$1,
    leftrightarrow: leftrightarrow$1,
    leftrightarrows: leftrightarrows$1,
    leftrightharpoons: leftrightharpoons$1,
    leftrightsquigarrow: leftrightsquigarrow$1,
    leftthreetimes: leftthreetimes$1,
    leg: leg$2,
    leq: leq$2,
    leqq: leqq$1,
    leqslant: leqslant$1,
    les: les$2,
    lescc: lescc$1,
    lesdot: lesdot$1,
    lesdoto: lesdoto$1,
    lesdotor: lesdotor$1,
    lesg: lesg$1,
    lesges: lesges$1,
    lessapprox: lessapprox$1,
    lessdot: lessdot$1,
    lesseqgtr: lesseqgtr$1,
    lesseqqgtr: lesseqqgtr$1,
    lessgtr: lessgtr$1,
    lesssim: lesssim$1,
    lfisht: lfisht$1,
    lfr: lfr$1,
    lg: lg$2,
    lgE: lgE$1,
    lhard: lhard$1,
    lharu: lharu$1,
    lharul: lharul$1,
    lhblk: lhblk$1,
    ljcy: ljcy$1,
    ll: ll$2,
    llarr: llarr$1,
    llcorner: llcorner$1,
    llhard: llhard$1,
    lltri: lltri$1,
    lmidot: lmidot$1,
    lmoust: lmoust$1,
    lmoustache: lmoustache$1,
    lnE: lnE$1,
    lnap: lnap$1,
    lnapprox: lnapprox$1,
    lne: lne$2,
    lneq: lneq$1,
    lneqq: lneqq$1,
    lnsim: lnsim$1,
    loang: loang$1,
    loarr: loarr$1,
    lobrk: lobrk$1,
    longleftarrow: longleftarrow$1,
    longleftrightarrow: longleftrightarrow$1,
    longmapsto: longmapsto$1,
    longrightarrow: longrightarrow$1,
    looparrowleft: looparrowleft$1,
    looparrowright: looparrowright$1,
    lopar: lopar$1,
    lopf: lopf$1,
    loplus: loplus$1,
    lotimes: lotimes$1,
    lozenge: lozenge$2,
    lozf: lozf$1,
    lparlt: lparlt$1,
    lrarr: lrarr$1,
    lrcorner: lrcorner$1,
    lrhar: lrhar$1,
    lrhard: lrhard$1,
    lrtri: lrtri$1,
    lscr: lscr$1,
    lsh: lsh$2,
    lsim: lsim$1,
    lsime: lsime$1,
    lsimg: lsimg$1,
    lsquor: lsquor$1,
    lstrok: lstrok$1,
    ltcc: ltcc$1,
    ltcir: ltcir$1,
    ltdot: ltdot$1,
    lthree: lthree$1,
    ltimes: ltimes$2,
    ltlarr: ltlarr$1,
    ltquest: ltquest$1,
    ltrPar: ltrPar$1,
    ltri: ltri$1,
    ltrie: ltrie$1,
    ltrif: ltrif$1,
    lurdshar: lurdshar$1,
    luruhar: luruhar$1,
    lvertneqq: lvertneqq$1,
    lvnE: lvnE$1,
    mDDot: mDDot$1,
    male: male$2,
    malt: malt$2,
    maltese: maltese$1,
    map: map$2,
    mapsto: mapsto$1,
    mapstodown: mapstodown$1,
    mapstoleft: mapstoleft$1,
    mapstoup: mapstoup$1,
    marker: marker$2,
    mcomma: mcomma$1,
    mcy: mcy$1,
    measuredangle: measuredangle$1,
    mfr: mfr$1,
    mho: mho$1,
    mid: mid$2,
    midcir: midcir$1,
    minusb: minusb$1,
    minusd: minusd$1,
    minusdu: minusdu$1,
    mlcp: mlcp$1,
    mldr: mldr$1,
    mnplus: mnplus$1,
    models: models$2,
    mopf: mopf$1,
    mp: mp$2,
    mscr: mscr$1,
    mstpos: mstpos$1,
    multimap: multimap$1,
    mumap: mumap$1,
    nGg: nGg$1,
    nGt: nGt$1,
    nGtv: nGtv$1,
    nLeftarrow: nLeftarrow$1,
    nLeftrightarrow: nLeftrightarrow$1,
    nLl: nLl$1,
    nLt: nLt$1,
    nLtv: nLtv$1,
    nRightarrow: nRightarrow$1,
    nVDash: nVDash$1,
    nVdash: nVdash$1,
    nacute: nacute$1,
    nang: nang$2,
    nap: nap$2,
    napE: napE$1,
    napid: napid$1,
    napos: napos$1,
    napprox: napprox$1,
    natur: natur$1,
    natural: natural$2,
    naturals: naturals$2,
    nbump: nbump$1,
    nbumpe: nbumpe$1,
    ncap: ncap$1,
    ncaron: ncaron$1,
    ncedil: ncedil$1,
    ncong: ncong$1,
    ncongdot: ncongdot$1,
    ncup: ncup$1,
    ncy: ncy$2,
    neArr: neArr$1,
    nearhk: nearhk$1,
    nearr: nearr$1,
    nearrow: nearrow$1,
    nedot: nedot$1,
    nequiv: nequiv$1,
    nesear: nesear$1,
    nesim: nesim$1,
    nexist: nexist$1,
    nexists: nexists$1,
    nfr: nfr$1,
    ngE: ngE$1,
    nge: nge$2,
    ngeq: ngeq$1,
    ngeqq: ngeqq$1,
    ngeqslant: ngeqslant$1,
    nges: nges$1,
    ngsim: ngsim$1,
    ngt: ngt$2,
    ngtr: ngtr$1,
    nhArr: nhArr$1,
    nharr: nharr$1,
    nhpar: nhpar$1,
    nis: nis$2,
    nisd: nisd$1,
    niv: niv$1,
    njcy: njcy$1,
    nlArr: nlArr$1,
    nlE: nlE$1,
    nlarr: nlarr$1,
    nldr: nldr$1,
    nle: nle$2,
    nleftarrow: nleftarrow$1,
    nleftrightarrow: nleftrightarrow$1,
    nleq: nleq$1,
    nleqq: nleqq$1,
    nleqslant: nleqslant$1,
    nles: nles$2,
    nless: nless$2,
    nlsim: nlsim$1,
    nlt: nlt$2,
    nltri: nltri$1,
    nltrie: nltrie$1,
    nmid: nmid$1,
    nopf: nopf$2,
    notinE: notinE$1,
    notindot: notindot$1,
    notinva: notinva$1,
    notinvb: notinvb$1,
    notinvc: notinvc$1,
    notni: notni$1,
    notniva: notniva$1,
    notnivb: notnivb$1,
    notnivc: notnivc$1,
    npar: npar$1,
    nparallel: nparallel$1,
    nparsl: nparsl$1,
    npart: npart$1,
    npolint: npolint$1,
    npr: npr$1,
    nprcue: nprcue$1,
    npre: npre$1,
    nprec: nprec$1,
    npreceq: npreceq$1,
    nrArr: nrArr$1,
    nrarr: nrarr$1,
    nrarrc: nrarrc$1,
    nrarrw: nrarrw$1,
    nrightarrow: nrightarrow$1,
    nrtri: nrtri$1,
    nrtrie: nrtrie$1,
    nsc: nsc$2,
    nsccue: nsccue$1,
    nsce: nsce$2,
    nscr: nscr$1,
    nshortmid: nshortmid$1,
    nshortparallel: nshortparallel$1,
    nsim: nsim$1,
    nsime: nsime$1,
    nsimeq: nsimeq$1,
    nsmid: nsmid$1,
    nspar: nspar$1,
    nsqsube: nsqsube$1,
    nsqsupe: nsqsupe$1,
    nsubE: nsubE$1,
    nsube: nsube$1,
    nsubset: nsubset$1,
    nsubseteq: nsubseteq$1,
    nsubseteqq: nsubseteqq$1,
    nsucc: nsucc$1,
    nsucceq: nsucceq$1,
    nsup: nsup$1,
    nsupE: nsupE$1,
    nsupe: nsupe$1,
    nsupset: nsupset$1,
    nsupseteq: nsupseteq$1,
    nsupseteqq: nsupseteqq$1,
    ntgl: ntgl$1,
    ntlg: ntlg$1,
    ntriangleleft: ntriangleleft$1,
    ntrianglelefteq: ntrianglelefteq$1,
    ntriangleright: ntriangleright$1,
    ntrianglerighteq: ntrianglerighteq$1,
    numero: numero$1,
    numsp: numsp$1,
    nvDash: nvDash$1,
    nvHarr: nvHarr$1,
    nvap: nvap$1,
    nvdash: nvdash$1,
    nvge: nvge$1,
    nvgt: nvgt$1,
    nvinfin: nvinfin$1,
    nvlArr: nvlArr$1,
    nvle: nvle$1,
    nvlt: nvlt$1,
    nvltrie: nvltrie$1,
    nvrArr: nvrArr$1,
    nvrtrie: nvrtrie$1,
    nvsim: nvsim$1,
    nwArr: nwArr$1,
    nwarhk: nwarhk$1,
    nwarr: nwarr$1,
    nwarrow: nwarrow$1,
    nwnear: nwnear$1,
    oS: oS$1,
    oast: oast$1,
    ocir: ocir$1,
    ocy: ocy$1,
    odash: odash$1,
    odblac: odblac$1,
    odiv: odiv$1,
    odot: odot$1,
    odsold: odsold$1,
    ofcir: ofcir$1,
    ofr: ofr$1,
    ogon: ogon$1,
    ogt: ogt$2,
    ohbar: ohbar$1,
    ohm: ohm$2,
    oint: oint$1,
    olarr: olarr$1,
    olcir: olcir$1,
    olcross: olcross$1,
    olt: olt$2,
    omacr: omacr$1,
    omid: omid$1,
    ominus: ominus$1,
    oopf: oopf$2,
    opar: opar$2,
    operp: operp$1,
    orarr: orarr$1,
    ord: ord$1,
    order: order$2,
    orderof: orderof$1,
    origof: origof$1,
    oror: oror$2,
    orslope: orslope$1,
    orv: orv$2,
    oscr: oscr$1,
    osol: osol$2,
    otimesas: otimesas$1,
    ovbar: ovbar$1,
    par: par$2,
    parallel: parallel$2,
    parsim: parsim$1,
    parsl: parsl$1,
    pcy: pcy$1,
    pertenk: pertenk$1,
    pfr: pfr$1,
    phiv: phiv$1,
    phmmat: phmmat$1,
    phone: phone$2,
    pitchfork: pitchfork$2,
    planck: planck$1,
    planckh: planckh$1,
    plankv: plankv$1,
    plusacir: plusacir$1,
    plusb: plusb$1,
    pluscir: pluscir$1,
    plusdo: plusdo$1,
    plusdu: plusdu$1,
    pluse: pluse$1,
    plussim: plussim$1,
    plustwo: plustwo$1,
    pm: pm$2,
    pointint: pointint$1,
    popf: popf$2,
    pr: pr$2,
    prE: prE$1,
    prap: prap$1,
    prcue: prcue$1,
    pre: pre$1,
    prec: prec$1,
    precapprox: precapprox$1,
    preccurlyeq: preccurlyeq$1,
    preceq: preceq$1,
    precnapprox: precnapprox$1,
    precneqq: precneqq$1,
    precnsim: precnsim$1,
    precsim: precsim$1,
    primes: primes$2,
    prnE: prnE$1,
    prnap: prnap$1,
    prnsim: prnsim$1,
    profalar: profalar$1,
    profline: profline$1,
    profsurf: profsurf$1,
    propto: propto$1,
    prsim: prsim$1,
    prurel: prurel$1,
    pscr: pscr$1,
    puncsp: puncsp$1,
    qfr: qfr$1,
    qint: qint$1,
    qopf: qopf$1,
    qprime: qprime$1,
    qscr: qscr$1,
    quaternions: quaternions$1,
    quatint: quatint$1,
    questeq: questeq$1,
    rAarr: rAarr$1,
    rAtail: rAtail$1,
    rBarr: rBarr$1,
    rHar: rHar$1,
    race: race$2,
    racute: racute$1,
    raemptyv: raemptyv$1,
    rangd: rangd$1,
    range: range$2,
    rangle: rangle$1,
    rarrap: rarrap$1,
    rarrb: rarrb$1,
    rarrbfs: rarrbfs$1,
    rarrc: rarrc$1,
    rarrfs: rarrfs$1,
    rarrhk: rarrhk$1,
    rarrlp: rarrlp$1,
    rarrpl: rarrpl$1,
    rarrsim: rarrsim$1,
    rarrtl: rarrtl$1,
    rarrw: rarrw$1,
    ratail: ratail$1,
    ratio: ratio$2,
    rationals: rationals$1,
    rbarr: rbarr$1,
    rbbrk: rbbrk$1,
    rbrke: rbrke$1,
    rbrksld: rbrksld$1,
    rbrkslu: rbrkslu$1,
    rcaron: rcaron$1,
    rcedil: rcedil$1,
    rcy: rcy$1,
    rdca: rdca$1,
    rdldhar: rdldhar$1,
    rdquor: rdquor$1,
    rdsh: rdsh$1,
    realine: realine$1,
    realpart: realpart$1,
    reals: reals$2,
    rect: rect$2,
    rfisht: rfisht$1,
    rfr: rfr$1,
    rhard: rhard$1,
    rharu: rharu$1,
    rharul: rharul$1,
    rhov: rhov$1,
    rightarrow: rightarrow$1,
    rightarrowtail: rightarrowtail$1,
    rightharpoondown: rightharpoondown$1,
    rightharpoonup: rightharpoonup$1,
    rightleftarrows: rightleftarrows$1,
    rightleftharpoons: rightleftharpoons$1,
    rightrightarrows: rightrightarrows$1,
    rightsquigarrow: rightsquigarrow$1,
    rightthreetimes: rightthreetimes$1,
    ring: ring$2,
    risingdotseq: risingdotseq$1,
    rlarr: rlarr$1,
    rlhar: rlhar$1,
    rmoust: rmoust$1,
    rmoustache: rmoustache$1,
    rnmid: rnmid$1,
    roang: roang$1,
    roarr: roarr$1,
    robrk: robrk$1,
    ropar: ropar$1,
    ropf: ropf$1,
    roplus: roplus$1,
    rotimes: rotimes$1,
    rpargt: rpargt$1,
    rppolint: rppolint$1,
    rrarr: rrarr$1,
    rscr: rscr$1,
    rsh: rsh$2,
    rsquor: rsquor$1,
    rthree: rthree$1,
    rtimes: rtimes$1,
    rtri: rtri$1,
    rtrie: rtrie$1,
    rtrif: rtrif$1,
    rtriltri: rtriltri$1,
    ruluhar: ruluhar$1,
    rx: rx$1,
    sacute: sacute$1,
    sc: sc$2,
    scE: scE$1,
    scap: scap$2,
    sccue: sccue$1,
    sce: sce$2,
    scedil: scedil$1,
    scirc: scirc$1,
    scnE: scnE$1,
    scnap: scnap$1,
    scnsim: scnsim$1,
    scpolint: scpolint$1,
    scsim: scsim$1,
    scy: scy$2,
    sdotb: sdotb$1,
    sdote: sdote$1,
    seArr: seArr$1,
    searhk: searhk$1,
    searr: searr$1,
    searrow: searrow$1,
    seswar: seswar$1,
    setminus: setminus$1,
    setmn: setmn$1,
    sext: sext$1,
    sfr: sfr$1,
    sfrown: sfrown$1,
    sharp: sharp$2,
    shchcy: shchcy$1,
    shcy: shcy$1,
    shortmid: shortmid$1,
    shortparallel: shortparallel$1,
    sigmav: sigmav$1,
    simdot: simdot$1,
    sime: sime$1,
    simeq: simeq$1,
    simg: simg$1,
    simgE: simgE$1,
    siml: siml$1,
    simlE: simlE$1,
    simne: simne$1,
    simplus: simplus$1,
    simrarr: simrarr$1,
    slarr: slarr$1,
    smallsetminus: smallsetminus$1,
    smashp: smashp$1,
    smeparsl: smeparsl$1,
    smid: smid$1,
    smile: smile$1,
    smt: smt$1,
    smte: smte$1,
    smtes: smtes$1,
    softcy: softcy$1,
    solb: solb$1,
    solbar: solbar$1,
    sopf: sopf$1,
    spadesuit: spadesuit$1,
    spar: spar$1,
    sqcap: sqcap$1,
    sqcaps: sqcaps$1,
    sqcup: sqcup$1,
    sqcups: sqcups$1,
    sqsub: sqsub$1,
    sqsube: sqsube$1,
    sqsubset: sqsubset$1,
    sqsubseteq: sqsubseteq$1,
    sqsup: sqsup$1,
    sqsupe: sqsupe$1,
    sqsupset: sqsupset$1,
    sqsupseteq: sqsupseteq$1,
    squ: squ$1,
    square: square$2,
    squarf: squarf$1,
    squf: squf$1,
    srarr: srarr$1,
    sscr: sscr$1,
    ssetmn: ssetmn$1,
    ssmile: ssmile$1,
    sstarf: sstarf$1,
    star: star$2,
    starf: starf$1,
    straightepsilon: straightepsilon$1,
    straightphi: straightphi$1,
    strns: strns$1,
    subE: subE$1,
    subdot: subdot$1,
    subedot: subedot$1,
    submult: submult$1,
    subnE: subnE$1,
    subne: subne$1,
    subplus: subplus$1,
    subrarr: subrarr$1,
    subset: subset$1,
    subseteq: subseteq$1,
    subseteqq: subseteqq$1,
    subsetneq: subsetneq$1,
    subsetneqq: subsetneqq$1,
    subsim: subsim$1,
    subsub: subsub$1,
    subsup: subsup$1,
    succ: succ$1,
    succapprox: succapprox$1,
    succcurlyeq: succcurlyeq$1,
    succeq: succeq$1,
    succnapprox: succnapprox$1,
    succneqq: succneqq$1,
    succnsim: succnsim$1,
    succsim: succsim$1,
    sung: sung$1,
    supE: supE$1,
    supdot: supdot$1,
    supdsub: supdsub$1,
    supedot: supedot$1,
    suphsol: suphsol$1,
    suphsub: suphsub$1,
    suplarr: suplarr$1,
    supmult: supmult$1,
    supnE: supnE$1,
    supne: supne$1,
    supplus: supplus$1,
    supset: supset$1,
    supseteq: supseteq$1,
    supseteqq: supseteqq$1,
    supsetneq: supsetneq$1,
    supsetneqq: supsetneqq$1,
    supsim: supsim$1,
    supsub: supsub$1,
    supsup: supsup$1,
    swArr: swArr$1,
    swarhk: swarhk$1,
    swarr: swarr$1,
    swarrow: swarrow$1,
    swnwar: swnwar$1,
    target: target$2,
    tbrk: tbrk$1,
    tcaron: tcaron$1,
    tcedil: tcedil$1,
    tcy: tcy$1,
    tdot: tdot$1,
    telrec: telrec$1,
    tfr: tfr$1,
    therefore: therefore$2,
    thetav: thetav$1,
    thickapprox: thickapprox$1,
    thicksim: thicksim$1,
    thkap: thkap$1,
    thksim: thksim$1,
    timesb: timesb$1,
    timesbar: timesbar$1,
    timesd: timesd$1,
    tint: tint$2,
    toea: toea$1,
    top: top$2,
    topbot: topbot$1,
    topcir: topcir$1,
    topf: topf$1,
    topfork: topfork$1,
    tosa: tosa$2,
    tprime: tprime$1,
    triangle: triangle$2,
    triangledown: triangledown$1,
    triangleleft: triangleleft$1,
    trianglelefteq: trianglelefteq$1,
    triangleq: triangleq$1,
    triangleright: triangleright$1,
    trianglerighteq: trianglerighteq$1,
    tridot: tridot$1,
    trie: trie$2,
    triminus: triminus$1,
    triplus: triplus$1,
    trisb: trisb$1,
    tritime: tritime$1,
    trpezium: trpezium$1,
    tscr: tscr$1,
    tscy: tscy$1,
    tshcy: tshcy$1,
    tstrok: tstrok$1,
    twixt: twixt$1,
    twoheadleftarrow: twoheadleftarrow$1,
    twoheadrightarrow: twoheadrightarrow$1,
    uHar: uHar$1,
    ubrcy: ubrcy$1,
    ubreve: ubreve$1,
    ucy: ucy$2,
    udarr: udarr$1,
    udblac: udblac$1,
    udhar: udhar$1,
    ufisht: ufisht$1,
    ufr: ufr$1,
    uharl: uharl$1,
    uharr: uharr$1,
    uhblk: uhblk$1,
    ulcorn: ulcorn$1,
    ulcorner: ulcorner$1,
    ulcrop: ulcrop$1,
    ultri: ultri$1,
    umacr: umacr$1,
    uogon: uogon$1,
    uopf: uopf$1,
    uparrow: uparrow$1,
    updownarrow: updownarrow$1,
    upharpoonleft: upharpoonleft$1,
    upharpoonright: upharpoonright$1,
    uplus: uplus$2,
    upsi: upsi$2,
    upuparrows: upuparrows$1,
    urcorn: urcorn$1,
    urcorner: urcorner$1,
    urcrop: urcrop$1,
    uring: uring$2,
    urtri: urtri$1,
    uscr: uscr$1,
    utdot: utdot$1,
    utilde: utilde$1,
    utri: utri$1,
    utrif: utrif$1,
    uuarr: uuarr$1,
    uwangle: uwangle$1,
    vArr: vArr$1,
    vBar: vBar$1,
    vBarv: vBarv$1,
    vDash: vDash$1,
    vangrt: vangrt$1,
    varepsilon: varepsilon$1,
    varkappa: varkappa$1,
    varnothing: varnothing$1,
    varphi: varphi$1,
    varpi: varpi$1,
    varpropto: varpropto$1,
    varr: varr$1,
    varrho: varrho$1,
    varsigma: varsigma$1,
    varsubsetneq: varsubsetneq$1,
    varsubsetneqq: varsubsetneqq$1,
    varsupsetneq: varsupsetneq$1,
    varsupsetneqq: varsupsetneqq$1,
    vartheta: vartheta$1,
    vartriangleleft: vartriangleleft$1,
    vartriangleright: vartriangleright$1,
    vcy: vcy$1,
    vdash: vdash$1,
    vee: vee$2,
    veebar: veebar$1,
    veeeq: veeeq$1,
    vellip: vellip$1,
    vfr: vfr$1,
    vltri: vltri$1,
    vnsub: vnsub$1,
    vnsup: vnsup$1,
    vopf: vopf$1,
    vprop: vprop$1,
    vrtri: vrtri$1,
    vscr: vscr$1,
    vsubnE: vsubnE$1,
    vsubne: vsubne$1,
    vsupnE: vsupnE$1,
    vsupne: vsupne$1,
    vzigzag: vzigzag$1,
    wcirc: wcirc$1,
    wedbar: wedbar$1,
    wedge: wedge$2,
    wedgeq: wedgeq$1,
    wfr: wfr$1,
    wopf: wopf$1,
    wp: wp$1,
    wr: wr$1,
    wreath: wreath$2,
    wscr: wscr$1,
    xcap: xcap$1,
    xcirc: xcirc$1,
    xcup: xcup$1,
    xdtri: xdtri$1,
    xfr: xfr$1,
    xhArr: xhArr$1,
    xharr: xharr$1,
    xlArr: xlArr$1,
    xlarr: xlarr$1,
    xmap: xmap$1,
    xnis: xnis$1,
    xodot: xodot$1,
    xopf: xopf$1,
    xoplus: xoplus$1,
    xotime: xotime$1,
    xrArr: xrArr$1,
    xrarr: xrarr$1,
    xscr: xscr$1,
    xsqcup: xsqcup$1,
    xuplus: xuplus$1,
    xutri: xutri$1,
    xvee: xvee$1,
    xwedge: xwedge$1,
    yacy: yacy$1,
    ycirc: ycirc$2,
    ycy: ycy$2,
    yfr: yfr$1,
    yicy: yicy$1,
    yopf: yopf$1,
    yscr: yscr$1,
    yucy: yucy$1,
    zacute: zacute$2,
    zcaron: zcaron$1,
    zcy: zcy$1,
    zdot: zdot$1,
    zeetrf: zeetrf$1,
    zfr: zfr$1,
    zhcy: zhcy$1,
    zigrarr: zigrarr$1,
    zopf: zopf$1,
    zscr: zscr$1
  };

  // rule: bad-named-html-entity-not-email-friendly

  function htmlEntitiesNotEmailFriendly(context) {
    return {
      entity: function entity(_ref) {
        var idxFrom = _ref.idxFrom,
            idxTo = _ref.idxTo;

        if (Object.keys(notEmailFriendly).includes(context.str.slice(idxFrom + 1, idxTo - 1))) {
          context.report({
            ruleId: "bad-named-html-entity-not-email-friendly",
            message: "Email-unfriendly named HTML entity.",
            idxFrom: idxFrom,
            idxTo: idxTo,
            fix: {
              ranges: [[idxFrom, idxTo, "&".concat(notEmailFriendly[context.str.slice(idxFrom + 1, idxTo - 1)], ";")]]
            }
          });
        }
      }
    };
  }

  var he = createCommonjsModule(function (module, exports) {

    (function (root) {
      // Detect free variables `exports`.
      var freeExports =  exports; // Detect free variable `module`.

      var freeModule =  module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code,
      // and use it as `root`.

      var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;

      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      /*--------------------------------------------------------------------------*/
      // All astral symbols.


      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g; // All ASCII symbols (not just printable ASCII) except those listed in the
      // first column of the overrides table.
      // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides

      var regexAsciiWhitelist = /[\x01-\x7F]/g; // All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
      // code points listed in the first column of the overrides table on
      // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.

      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = {
        '\xAD': 'shy',
        '\u200C': 'zwnj',
        '\u200D': 'zwj',
        '\u200E': 'lrm',
        '\u2063': 'ic',
        '\u2062': 'it',
        '\u2061': 'af',
        '\u200F': 'rlm',
        '\u200B': 'ZeroWidthSpace',
        '\u2060': 'NoBreak',
        '\u0311': 'DownBreve',
        '\u20DB': 'tdot',
        '\u20DC': 'DotDot',
        '\t': 'Tab',
        '\n': 'NewLine',
        '\u2008': 'puncsp',
        '\u205F': 'MediumSpace',
        '\u2009': 'thinsp',
        '\u200A': 'hairsp',
        '\u2004': 'emsp13',
        '\u2002': 'ensp',
        '\u2005': 'emsp14',
        '\u2003': 'emsp',
        '\u2007': 'numsp',
        '\xA0': 'nbsp',
        '\u205F\u200A': 'ThickSpace',
        '\u203E': 'oline',
        '_': 'lowbar',
        '\u2010': 'dash',
        '\u2013': 'ndash',
        '\u2014': 'mdash',
        '\u2015': 'horbar',
        ',': 'comma',
        ';': 'semi',
        '\u204F': 'bsemi',
        ':': 'colon',
        '\u2A74': 'Colone',
        '!': 'excl',
        '\xA1': 'iexcl',
        '?': 'quest',
        '\xBF': 'iquest',
        '.': 'period',
        '\u2025': 'nldr',
        '\u2026': 'mldr',
        '\xB7': 'middot',
        '\'': 'apos',
        '\u2018': 'lsquo',
        '\u2019': 'rsquo',
        '\u201A': 'sbquo',
        '\u2039': 'lsaquo',
        '\u203A': 'rsaquo',
        '"': 'quot',
        '\u201C': 'ldquo',
        '\u201D': 'rdquo',
        '\u201E': 'bdquo',
        '\xAB': 'laquo',
        '\xBB': 'raquo',
        '(': 'lpar',
        ')': 'rpar',
        '[': 'lsqb',
        ']': 'rsqb',
        '{': 'lcub',
        '}': 'rcub',
        '\u2308': 'lceil',
        '\u2309': 'rceil',
        '\u230A': 'lfloor',
        '\u230B': 'rfloor',
        '\u2985': 'lopar',
        '\u2986': 'ropar',
        '\u298B': 'lbrke',
        '\u298C': 'rbrke',
        '\u298D': 'lbrkslu',
        '\u298E': 'rbrksld',
        '\u298F': 'lbrksld',
        '\u2990': 'rbrkslu',
        '\u2991': 'langd',
        '\u2992': 'rangd',
        '\u2993': 'lparlt',
        '\u2994': 'rpargt',
        '\u2995': 'gtlPar',
        '\u2996': 'ltrPar',
        '\u27E6': 'lobrk',
        '\u27E7': 'robrk',
        '\u27E8': 'lang',
        '\u27E9': 'rang',
        '\u27EA': 'Lang',
        '\u27EB': 'Rang',
        '\u27EC': 'loang',
        '\u27ED': 'roang',
        '\u2772': 'lbbrk',
        '\u2773': 'rbbrk',
        '\u2016': 'Vert',
        '\xA7': 'sect',
        '\xB6': 'para',
        '@': 'commat',
        '*': 'ast',
        '/': 'sol',
        'undefined': null,
        '&': 'amp',
        '#': 'num',
        '%': 'percnt',
        '\u2030': 'permil',
        '\u2031': 'pertenk',
        '\u2020': 'dagger',
        '\u2021': 'Dagger',
        '\u2022': 'bull',
        '\u2043': 'hybull',
        '\u2032': 'prime',
        '\u2033': 'Prime',
        '\u2034': 'tprime',
        '\u2057': 'qprime',
        '\u2035': 'bprime',
        '\u2041': 'caret',
        '`': 'grave',
        '\xB4': 'acute',
        '\u02DC': 'tilde',
        '^': 'Hat',
        '\xAF': 'macr',
        '\u02D8': 'breve',
        '\u02D9': 'dot',
        '\xA8': 'die',
        '\u02DA': 'ring',
        '\u02DD': 'dblac',
        '\xB8': 'cedil',
        '\u02DB': 'ogon',
        '\u02C6': 'circ',
        '\u02C7': 'caron',
        '\xB0': 'deg',
        '\xA9': 'copy',
        '\xAE': 'reg',
        '\u2117': 'copysr',
        '\u2118': 'wp',
        '\u211E': 'rx',
        '\u2127': 'mho',
        '\u2129': 'iiota',
        '\u2190': 'larr',
        '\u219A': 'nlarr',
        '\u2192': 'rarr',
        '\u219B': 'nrarr',
        '\u2191': 'uarr',
        '\u2193': 'darr',
        '\u2194': 'harr',
        '\u21AE': 'nharr',
        '\u2195': 'varr',
        '\u2196': 'nwarr',
        '\u2197': 'nearr',
        '\u2198': 'searr',
        '\u2199': 'swarr',
        '\u219D': 'rarrw',
        '\u219D\u0338': 'nrarrw',
        '\u219E': 'Larr',
        '\u219F': 'Uarr',
        '\u21A0': 'Rarr',
        '\u21A1': 'Darr',
        '\u21A2': 'larrtl',
        '\u21A3': 'rarrtl',
        '\u21A4': 'mapstoleft',
        '\u21A5': 'mapstoup',
        '\u21A6': 'map',
        '\u21A7': 'mapstodown',
        '\u21A9': 'larrhk',
        '\u21AA': 'rarrhk',
        '\u21AB': 'larrlp',
        '\u21AC': 'rarrlp',
        '\u21AD': 'harrw',
        '\u21B0': 'lsh',
        '\u21B1': 'rsh',
        '\u21B2': 'ldsh',
        '\u21B3': 'rdsh',
        '\u21B5': 'crarr',
        '\u21B6': 'cularr',
        '\u21B7': 'curarr',
        '\u21BA': 'olarr',
        '\u21BB': 'orarr',
        '\u21BC': 'lharu',
        '\u21BD': 'lhard',
        '\u21BE': 'uharr',
        '\u21BF': 'uharl',
        '\u21C0': 'rharu',
        '\u21C1': 'rhard',
        '\u21C2': 'dharr',
        '\u21C3': 'dharl',
        '\u21C4': 'rlarr',
        '\u21C5': 'udarr',
        '\u21C6': 'lrarr',
        '\u21C7': 'llarr',
        '\u21C8': 'uuarr',
        '\u21C9': 'rrarr',
        '\u21CA': 'ddarr',
        '\u21CB': 'lrhar',
        '\u21CC': 'rlhar',
        '\u21D0': 'lArr',
        '\u21CD': 'nlArr',
        '\u21D1': 'uArr',
        '\u21D2': 'rArr',
        '\u21CF': 'nrArr',
        '\u21D3': 'dArr',
        '\u21D4': 'iff',
        '\u21CE': 'nhArr',
        '\u21D5': 'vArr',
        '\u21D6': 'nwArr',
        '\u21D7': 'neArr',
        '\u21D8': 'seArr',
        '\u21D9': 'swArr',
        '\u21DA': 'lAarr',
        '\u21DB': 'rAarr',
        '\u21DD': 'zigrarr',
        '\u21E4': 'larrb',
        '\u21E5': 'rarrb',
        '\u21F5': 'duarr',
        '\u21FD': 'loarr',
        '\u21FE': 'roarr',
        '\u21FF': 'hoarr',
        '\u2200': 'forall',
        '\u2201': 'comp',
        '\u2202': 'part',
        '\u2202\u0338': 'npart',
        '\u2203': 'exist',
        '\u2204': 'nexist',
        '\u2205': 'empty',
        '\u2207': 'Del',
        '\u2208': 'in',
        '\u2209': 'notin',
        '\u220B': 'ni',
        '\u220C': 'notni',
        '\u03F6': 'bepsi',
        '\u220F': 'prod',
        '\u2210': 'coprod',
        '\u2211': 'sum',
        '+': 'plus',
        '\xB1': 'pm',
        '\xF7': 'div',
        '\xD7': 'times',
        '<': 'lt',
        '\u226E': 'nlt',
        '<\u20D2': 'nvlt',
        '=': 'equals',
        '\u2260': 'ne',
        '=\u20E5': 'bne',
        '\u2A75': 'Equal',
        '>': 'gt',
        '\u226F': 'ngt',
        '>\u20D2': 'nvgt',
        '\xAC': 'not',
        '|': 'vert',
        '\xA6': 'brvbar',
        '\u2212': 'minus',
        '\u2213': 'mp',
        '\u2214': 'plusdo',
        '\u2044': 'frasl',
        '\u2216': 'setmn',
        '\u2217': 'lowast',
        '\u2218': 'compfn',
        '\u221A': 'Sqrt',
        '\u221D': 'prop',
        '\u221E': 'infin',
        '\u221F': 'angrt',
        '\u2220': 'ang',
        '\u2220\u20D2': 'nang',
        '\u2221': 'angmsd',
        '\u2222': 'angsph',
        '\u2223': 'mid',
        '\u2224': 'nmid',
        '\u2225': 'par',
        '\u2226': 'npar',
        '\u2227': 'and',
        '\u2228': 'or',
        '\u2229': 'cap',
        '\u2229\uFE00': 'caps',
        '\u222A': 'cup',
        '\u222A\uFE00': 'cups',
        '\u222B': 'int',
        '\u222C': 'Int',
        '\u222D': 'tint',
        '\u2A0C': 'qint',
        '\u222E': 'oint',
        '\u222F': 'Conint',
        '\u2230': 'Cconint',
        '\u2231': 'cwint',
        '\u2232': 'cwconint',
        '\u2233': 'awconint',
        '\u2234': 'there4',
        '\u2235': 'becaus',
        '\u2236': 'ratio',
        '\u2237': 'Colon',
        '\u2238': 'minusd',
        '\u223A': 'mDDot',
        '\u223B': 'homtht',
        '\u223C': 'sim',
        '\u2241': 'nsim',
        '\u223C\u20D2': 'nvsim',
        '\u223D': 'bsim',
        '\u223D\u0331': 'race',
        '\u223E': 'ac',
        '\u223E\u0333': 'acE',
        '\u223F': 'acd',
        '\u2240': 'wr',
        '\u2242': 'esim',
        '\u2242\u0338': 'nesim',
        '\u2243': 'sime',
        '\u2244': 'nsime',
        '\u2245': 'cong',
        '\u2247': 'ncong',
        '\u2246': 'simne',
        '\u2248': 'ap',
        '\u2249': 'nap',
        '\u224A': 'ape',
        '\u224B': 'apid',
        '\u224B\u0338': 'napid',
        '\u224C': 'bcong',
        '\u224D': 'CupCap',
        '\u226D': 'NotCupCap',
        '\u224D\u20D2': 'nvap',
        '\u224E': 'bump',
        '\u224E\u0338': 'nbump',
        '\u224F': 'bumpe',
        '\u224F\u0338': 'nbumpe',
        '\u2250': 'doteq',
        '\u2250\u0338': 'nedot',
        '\u2251': 'eDot',
        '\u2252': 'efDot',
        '\u2253': 'erDot',
        '\u2254': 'colone',
        '\u2255': 'ecolon',
        '\u2256': 'ecir',
        '\u2257': 'cire',
        '\u2259': 'wedgeq',
        '\u225A': 'veeeq',
        '\u225C': 'trie',
        '\u225F': 'equest',
        '\u2261': 'equiv',
        '\u2262': 'nequiv',
        '\u2261\u20E5': 'bnequiv',
        '\u2264': 'le',
        '\u2270': 'nle',
        '\u2264\u20D2': 'nvle',
        '\u2265': 'ge',
        '\u2271': 'nge',
        '\u2265\u20D2': 'nvge',
        '\u2266': 'lE',
        '\u2266\u0338': 'nlE',
        '\u2267': 'gE',
        '\u2267\u0338': 'ngE',
        '\u2268\uFE00': 'lvnE',
        '\u2268': 'lnE',
        '\u2269': 'gnE',
        '\u2269\uFE00': 'gvnE',
        '\u226A': 'll',
        '\u226A\u0338': 'nLtv',
        '\u226A\u20D2': 'nLt',
        '\u226B': 'gg',
        '\u226B\u0338': 'nGtv',
        '\u226B\u20D2': 'nGt',
        '\u226C': 'twixt',
        '\u2272': 'lsim',
        '\u2274': 'nlsim',
        '\u2273': 'gsim',
        '\u2275': 'ngsim',
        '\u2276': 'lg',
        '\u2278': 'ntlg',
        '\u2277': 'gl',
        '\u2279': 'ntgl',
        '\u227A': 'pr',
        '\u2280': 'npr',
        '\u227B': 'sc',
        '\u2281': 'nsc',
        '\u227C': 'prcue',
        '\u22E0': 'nprcue',
        '\u227D': 'sccue',
        '\u22E1': 'nsccue',
        '\u227E': 'prsim',
        '\u227F': 'scsim',
        '\u227F\u0338': 'NotSucceedsTilde',
        '\u2282': 'sub',
        '\u2284': 'nsub',
        '\u2282\u20D2': 'vnsub',
        '\u2283': 'sup',
        '\u2285': 'nsup',
        '\u2283\u20D2': 'vnsup',
        '\u2286': 'sube',
        '\u2288': 'nsube',
        '\u2287': 'supe',
        '\u2289': 'nsupe',
        '\u228A\uFE00': 'vsubne',
        '\u228A': 'subne',
        '\u228B\uFE00': 'vsupne',
        '\u228B': 'supne',
        '\u228D': 'cupdot',
        '\u228E': 'uplus',
        '\u228F': 'sqsub',
        '\u228F\u0338': 'NotSquareSubset',
        '\u2290': 'sqsup',
        '\u2290\u0338': 'NotSquareSuperset',
        '\u2291': 'sqsube',
        '\u22E2': 'nsqsube',
        '\u2292': 'sqsupe',
        '\u22E3': 'nsqsupe',
        '\u2293': 'sqcap',
        '\u2293\uFE00': 'sqcaps',
        '\u2294': 'sqcup',
        '\u2294\uFE00': 'sqcups',
        '\u2295': 'oplus',
        '\u2296': 'ominus',
        '\u2297': 'otimes',
        '\u2298': 'osol',
        '\u2299': 'odot',
        '\u229A': 'ocir',
        '\u229B': 'oast',
        '\u229D': 'odash',
        '\u229E': 'plusb',
        '\u229F': 'minusb',
        '\u22A0': 'timesb',
        '\u22A1': 'sdotb',
        '\u22A2': 'vdash',
        '\u22AC': 'nvdash',
        '\u22A3': 'dashv',
        '\u22A4': 'top',
        '\u22A5': 'bot',
        '\u22A7': 'models',
        '\u22A8': 'vDash',
        '\u22AD': 'nvDash',
        '\u22A9': 'Vdash',
        '\u22AE': 'nVdash',
        '\u22AA': 'Vvdash',
        '\u22AB': 'VDash',
        '\u22AF': 'nVDash',
        '\u22B0': 'prurel',
        '\u22B2': 'vltri',
        '\u22EA': 'nltri',
        '\u22B3': 'vrtri',
        '\u22EB': 'nrtri',
        '\u22B4': 'ltrie',
        '\u22EC': 'nltrie',
        '\u22B4\u20D2': 'nvltrie',
        '\u22B5': 'rtrie',
        '\u22ED': 'nrtrie',
        '\u22B5\u20D2': 'nvrtrie',
        '\u22B6': 'origof',
        '\u22B7': 'imof',
        '\u22B8': 'mumap',
        '\u22B9': 'hercon',
        '\u22BA': 'intcal',
        '\u22BB': 'veebar',
        '\u22BD': 'barvee',
        '\u22BE': 'angrtvb',
        '\u22BF': 'lrtri',
        '\u22C0': 'Wedge',
        '\u22C1': 'Vee',
        '\u22C2': 'xcap',
        '\u22C3': 'xcup',
        '\u22C4': 'diam',
        '\u22C5': 'sdot',
        '\u22C6': 'Star',
        '\u22C7': 'divonx',
        '\u22C8': 'bowtie',
        '\u22C9': 'ltimes',
        '\u22CA': 'rtimes',
        '\u22CB': 'lthree',
        '\u22CC': 'rthree',
        '\u22CD': 'bsime',
        '\u22CE': 'cuvee',
        '\u22CF': 'cuwed',
        '\u22D0': 'Sub',
        '\u22D1': 'Sup',
        '\u22D2': 'Cap',
        '\u22D3': 'Cup',
        '\u22D4': 'fork',
        '\u22D5': 'epar',
        '\u22D6': 'ltdot',
        '\u22D7': 'gtdot',
        '\u22D8': 'Ll',
        '\u22D8\u0338': 'nLl',
        '\u22D9': 'Gg',
        '\u22D9\u0338': 'nGg',
        '\u22DA\uFE00': 'lesg',
        '\u22DA': 'leg',
        '\u22DB': 'gel',
        '\u22DB\uFE00': 'gesl',
        '\u22DE': 'cuepr',
        '\u22DF': 'cuesc',
        '\u22E6': 'lnsim',
        '\u22E7': 'gnsim',
        '\u22E8': 'prnsim',
        '\u22E9': 'scnsim',
        '\u22EE': 'vellip',
        '\u22EF': 'ctdot',
        '\u22F0': 'utdot',
        '\u22F1': 'dtdot',
        '\u22F2': 'disin',
        '\u22F3': 'isinsv',
        '\u22F4': 'isins',
        '\u22F5': 'isindot',
        '\u22F5\u0338': 'notindot',
        '\u22F6': 'notinvc',
        '\u22F7': 'notinvb',
        '\u22F9': 'isinE',
        '\u22F9\u0338': 'notinE',
        '\u22FA': 'nisd',
        '\u22FB': 'xnis',
        '\u22FC': 'nis',
        '\u22FD': 'notnivc',
        '\u22FE': 'notnivb',
        '\u2305': 'barwed',
        '\u2306': 'Barwed',
        '\u230C': 'drcrop',
        '\u230D': 'dlcrop',
        '\u230E': 'urcrop',
        '\u230F': 'ulcrop',
        '\u2310': 'bnot',
        '\u2312': 'profline',
        '\u2313': 'profsurf',
        '\u2315': 'telrec',
        '\u2316': 'target',
        '\u231C': 'ulcorn',
        '\u231D': 'urcorn',
        '\u231E': 'dlcorn',
        '\u231F': 'drcorn',
        '\u2322': 'frown',
        '\u2323': 'smile',
        '\u232D': 'cylcty',
        '\u232E': 'profalar',
        '\u2336': 'topbot',
        '\u233D': 'ovbar',
        '\u233F': 'solbar',
        '\u237C': 'angzarr',
        '\u23B0': 'lmoust',
        '\u23B1': 'rmoust',
        '\u23B4': 'tbrk',
        '\u23B5': 'bbrk',
        '\u23B6': 'bbrktbrk',
        '\u23DC': 'OverParenthesis',
        '\u23DD': 'UnderParenthesis',
        '\u23DE': 'OverBrace',
        '\u23DF': 'UnderBrace',
        '\u23E2': 'trpezium',
        '\u23E7': 'elinters',
        '\u2423': 'blank',
        '\u2500': 'boxh',
        '\u2502': 'boxv',
        '\u250C': 'boxdr',
        '\u2510': 'boxdl',
        '\u2514': 'boxur',
        '\u2518': 'boxul',
        '\u251C': 'boxvr',
        '\u2524': 'boxvl',
        '\u252C': 'boxhd',
        '\u2534': 'boxhu',
        '\u253C': 'boxvh',
        '\u2550': 'boxH',
        '\u2551': 'boxV',
        '\u2552': 'boxdR',
        '\u2553': 'boxDr',
        '\u2554': 'boxDR',
        '\u2555': 'boxdL',
        '\u2556': 'boxDl',
        '\u2557': 'boxDL',
        '\u2558': 'boxuR',
        '\u2559': 'boxUr',
        '\u255A': 'boxUR',
        '\u255B': 'boxuL',
        '\u255C': 'boxUl',
        '\u255D': 'boxUL',
        '\u255E': 'boxvR',
        '\u255F': 'boxVr',
        '\u2560': 'boxVR',
        '\u2561': 'boxvL',
        '\u2562': 'boxVl',
        '\u2563': 'boxVL',
        '\u2564': 'boxHd',
        '\u2565': 'boxhD',
        '\u2566': 'boxHD',
        '\u2567': 'boxHu',
        '\u2568': 'boxhU',
        '\u2569': 'boxHU',
        '\u256A': 'boxvH',
        '\u256B': 'boxVh',
        '\u256C': 'boxVH',
        '\u2580': 'uhblk',
        '\u2584': 'lhblk',
        '\u2588': 'block',
        '\u2591': 'blk14',
        '\u2592': 'blk12',
        '\u2593': 'blk34',
        '\u25A1': 'squ',
        '\u25AA': 'squf',
        '\u25AB': 'EmptyVerySmallSquare',
        '\u25AD': 'rect',
        '\u25AE': 'marker',
        '\u25B1': 'fltns',
        '\u25B3': 'xutri',
        '\u25B4': 'utrif',
        '\u25B5': 'utri',
        '\u25B8': 'rtrif',
        '\u25B9': 'rtri',
        '\u25BD': 'xdtri',
        '\u25BE': 'dtrif',
        '\u25BF': 'dtri',
        '\u25C2': 'ltrif',
        '\u25C3': 'ltri',
        '\u25CA': 'loz',
        '\u25CB': 'cir',
        '\u25EC': 'tridot',
        '\u25EF': 'xcirc',
        '\u25F8': 'ultri',
        '\u25F9': 'urtri',
        '\u25FA': 'lltri',
        '\u25FB': 'EmptySmallSquare',
        '\u25FC': 'FilledSmallSquare',
        '\u2605': 'starf',
        '\u2606': 'star',
        '\u260E': 'phone',
        '\u2640': 'female',
        '\u2642': 'male',
        '\u2660': 'spades',
        '\u2663': 'clubs',
        '\u2665': 'hearts',
        '\u2666': 'diams',
        '\u266A': 'sung',
        '\u2713': 'check',
        '\u2717': 'cross',
        '\u2720': 'malt',
        '\u2736': 'sext',
        '\u2758': 'VerticalSeparator',
        '\u27C8': 'bsolhsub',
        '\u27C9': 'suphsol',
        '\u27F5': 'xlarr',
        '\u27F6': 'xrarr',
        '\u27F7': 'xharr',
        '\u27F8': 'xlArr',
        '\u27F9': 'xrArr',
        '\u27FA': 'xhArr',
        '\u27FC': 'xmap',
        '\u27FF': 'dzigrarr',
        '\u2902': 'nvlArr',
        '\u2903': 'nvrArr',
        '\u2904': 'nvHarr',
        '\u2905': 'Map',
        '\u290C': 'lbarr',
        '\u290D': 'rbarr',
        '\u290E': 'lBarr',
        '\u290F': 'rBarr',
        '\u2910': 'RBarr',
        '\u2911': 'DDotrahd',
        '\u2912': 'UpArrowBar',
        '\u2913': 'DownArrowBar',
        '\u2916': 'Rarrtl',
        '\u2919': 'latail',
        '\u291A': 'ratail',
        '\u291B': 'lAtail',
        '\u291C': 'rAtail',
        '\u291D': 'larrfs',
        '\u291E': 'rarrfs',
        '\u291F': 'larrbfs',
        '\u2920': 'rarrbfs',
        '\u2923': 'nwarhk',
        '\u2924': 'nearhk',
        '\u2925': 'searhk',
        '\u2926': 'swarhk',
        '\u2927': 'nwnear',
        '\u2928': 'toea',
        '\u2929': 'tosa',
        '\u292A': 'swnwar',
        '\u2933': 'rarrc',
        '\u2933\u0338': 'nrarrc',
        '\u2935': 'cudarrr',
        '\u2936': 'ldca',
        '\u2937': 'rdca',
        '\u2938': 'cudarrl',
        '\u2939': 'larrpl',
        '\u293C': 'curarrm',
        '\u293D': 'cularrp',
        '\u2945': 'rarrpl',
        '\u2948': 'harrcir',
        '\u2949': 'Uarrocir',
        '\u294A': 'lurdshar',
        '\u294B': 'ldrushar',
        '\u294E': 'LeftRightVector',
        '\u294F': 'RightUpDownVector',
        '\u2950': 'DownLeftRightVector',
        '\u2951': 'LeftUpDownVector',
        '\u2952': 'LeftVectorBar',
        '\u2953': 'RightVectorBar',
        '\u2954': 'RightUpVectorBar',
        '\u2955': 'RightDownVectorBar',
        '\u2956': 'DownLeftVectorBar',
        '\u2957': 'DownRightVectorBar',
        '\u2958': 'LeftUpVectorBar',
        '\u2959': 'LeftDownVectorBar',
        '\u295A': 'LeftTeeVector',
        '\u295B': 'RightTeeVector',
        '\u295C': 'RightUpTeeVector',
        '\u295D': 'RightDownTeeVector',
        '\u295E': 'DownLeftTeeVector',
        '\u295F': 'DownRightTeeVector',
        '\u2960': 'LeftUpTeeVector',
        '\u2961': 'LeftDownTeeVector',
        '\u2962': 'lHar',
        '\u2963': 'uHar',
        '\u2964': 'rHar',
        '\u2965': 'dHar',
        '\u2966': 'luruhar',
        '\u2967': 'ldrdhar',
        '\u2968': 'ruluhar',
        '\u2969': 'rdldhar',
        '\u296A': 'lharul',
        '\u296B': 'llhard',
        '\u296C': 'rharul',
        '\u296D': 'lrhard',
        '\u296E': 'udhar',
        '\u296F': 'duhar',
        '\u2970': 'RoundImplies',
        '\u2971': 'erarr',
        '\u2972': 'simrarr',
        '\u2973': 'larrsim',
        '\u2974': 'rarrsim',
        '\u2975': 'rarrap',
        '\u2976': 'ltlarr',
        '\u2978': 'gtrarr',
        '\u2979': 'subrarr',
        '\u297B': 'suplarr',
        '\u297C': 'lfisht',
        '\u297D': 'rfisht',
        '\u297E': 'ufisht',
        '\u297F': 'dfisht',
        '\u299A': 'vzigzag',
        '\u299C': 'vangrt',
        '\u299D': 'angrtvbd',
        '\u29A4': 'ange',
        '\u29A5': 'range',
        '\u29A6': 'dwangle',
        '\u29A7': 'uwangle',
        '\u29A8': 'angmsdaa',
        '\u29A9': 'angmsdab',
        '\u29AA': 'angmsdac',
        '\u29AB': 'angmsdad',
        '\u29AC': 'angmsdae',
        '\u29AD': 'angmsdaf',
        '\u29AE': 'angmsdag',
        '\u29AF': 'angmsdah',
        '\u29B0': 'bemptyv',
        '\u29B1': 'demptyv',
        '\u29B2': 'cemptyv',
        '\u29B3': 'raemptyv',
        '\u29B4': 'laemptyv',
        '\u29B5': 'ohbar',
        '\u29B6': 'omid',
        '\u29B7': 'opar',
        '\u29B9': 'operp',
        '\u29BB': 'olcross',
        '\u29BC': 'odsold',
        '\u29BE': 'olcir',
        '\u29BF': 'ofcir',
        '\u29C0': 'olt',
        '\u29C1': 'ogt',
        '\u29C2': 'cirscir',
        '\u29C3': 'cirE',
        '\u29C4': 'solb',
        '\u29C5': 'bsolb',
        '\u29C9': 'boxbox',
        '\u29CD': 'trisb',
        '\u29CE': 'rtriltri',
        '\u29CF': 'LeftTriangleBar',
        '\u29CF\u0338': 'NotLeftTriangleBar',
        '\u29D0': 'RightTriangleBar',
        '\u29D0\u0338': 'NotRightTriangleBar',
        '\u29DC': 'iinfin',
        '\u29DD': 'infintie',
        '\u29DE': 'nvinfin',
        '\u29E3': 'eparsl',
        '\u29E4': 'smeparsl',
        '\u29E5': 'eqvparsl',
        '\u29EB': 'lozf',
        '\u29F4': 'RuleDelayed',
        '\u29F6': 'dsol',
        '\u2A00': 'xodot',
        '\u2A01': 'xoplus',
        '\u2A02': 'xotime',
        '\u2A04': 'xuplus',
        '\u2A06': 'xsqcup',
        '\u2A0D': 'fpartint',
        '\u2A10': 'cirfnint',
        '\u2A11': 'awint',
        '\u2A12': 'rppolint',
        '\u2A13': 'scpolint',
        '\u2A14': 'npolint',
        '\u2A15': 'pointint',
        '\u2A16': 'quatint',
        '\u2A17': 'intlarhk',
        '\u2A22': 'pluscir',
        '\u2A23': 'plusacir',
        '\u2A24': 'simplus',
        '\u2A25': 'plusdu',
        '\u2A26': 'plussim',
        '\u2A27': 'plustwo',
        '\u2A29': 'mcomma',
        '\u2A2A': 'minusdu',
        '\u2A2D': 'loplus',
        '\u2A2E': 'roplus',
        '\u2A2F': 'Cross',
        '\u2A30': 'timesd',
        '\u2A31': 'timesbar',
        '\u2A33': 'smashp',
        '\u2A34': 'lotimes',
        '\u2A35': 'rotimes',
        '\u2A36': 'otimesas',
        '\u2A37': 'Otimes',
        '\u2A38': 'odiv',
        '\u2A39': 'triplus',
        '\u2A3A': 'triminus',
        '\u2A3B': 'tritime',
        '\u2A3C': 'iprod',
        '\u2A3F': 'amalg',
        '\u2A40': 'capdot',
        '\u2A42': 'ncup',
        '\u2A43': 'ncap',
        '\u2A44': 'capand',
        '\u2A45': 'cupor',
        '\u2A46': 'cupcap',
        '\u2A47': 'capcup',
        '\u2A48': 'cupbrcap',
        '\u2A49': 'capbrcup',
        '\u2A4A': 'cupcup',
        '\u2A4B': 'capcap',
        '\u2A4C': 'ccups',
        '\u2A4D': 'ccaps',
        '\u2A50': 'ccupssm',
        '\u2A53': 'And',
        '\u2A54': 'Or',
        '\u2A55': 'andand',
        '\u2A56': 'oror',
        '\u2A57': 'orslope',
        '\u2A58': 'andslope',
        '\u2A5A': 'andv',
        '\u2A5B': 'orv',
        '\u2A5C': 'andd',
        '\u2A5D': 'ord',
        '\u2A5F': 'wedbar',
        '\u2A66': 'sdote',
        '\u2A6A': 'simdot',
        '\u2A6D': 'congdot',
        '\u2A6D\u0338': 'ncongdot',
        '\u2A6E': 'easter',
        '\u2A6F': 'apacir',
        '\u2A70': 'apE',
        '\u2A70\u0338': 'napE',
        '\u2A71': 'eplus',
        '\u2A72': 'pluse',
        '\u2A73': 'Esim',
        '\u2A77': 'eDDot',
        '\u2A78': 'equivDD',
        '\u2A79': 'ltcir',
        '\u2A7A': 'gtcir',
        '\u2A7B': 'ltquest',
        '\u2A7C': 'gtquest',
        '\u2A7D': 'les',
        '\u2A7D\u0338': 'nles',
        '\u2A7E': 'ges',
        '\u2A7E\u0338': 'nges',
        '\u2A7F': 'lesdot',
        '\u2A80': 'gesdot',
        '\u2A81': 'lesdoto',
        '\u2A82': 'gesdoto',
        '\u2A83': 'lesdotor',
        '\u2A84': 'gesdotol',
        '\u2A85': 'lap',
        '\u2A86': 'gap',
        '\u2A87': 'lne',
        '\u2A88': 'gne',
        '\u2A89': 'lnap',
        '\u2A8A': 'gnap',
        '\u2A8B': 'lEg',
        '\u2A8C': 'gEl',
        '\u2A8D': 'lsime',
        '\u2A8E': 'gsime',
        '\u2A8F': 'lsimg',
        '\u2A90': 'gsiml',
        '\u2A91': 'lgE',
        '\u2A92': 'glE',
        '\u2A93': 'lesges',
        '\u2A94': 'gesles',
        '\u2A95': 'els',
        '\u2A96': 'egs',
        '\u2A97': 'elsdot',
        '\u2A98': 'egsdot',
        '\u2A99': 'el',
        '\u2A9A': 'eg',
        '\u2A9D': 'siml',
        '\u2A9E': 'simg',
        '\u2A9F': 'simlE',
        '\u2AA0': 'simgE',
        '\u2AA1': 'LessLess',
        '\u2AA1\u0338': 'NotNestedLessLess',
        '\u2AA2': 'GreaterGreater',
        '\u2AA2\u0338': 'NotNestedGreaterGreater',
        '\u2AA4': 'glj',
        '\u2AA5': 'gla',
        '\u2AA6': 'ltcc',
        '\u2AA7': 'gtcc',
        '\u2AA8': 'lescc',
        '\u2AA9': 'gescc',
        '\u2AAA': 'smt',
        '\u2AAB': 'lat',
        '\u2AAC': 'smte',
        '\u2AAC\uFE00': 'smtes',
        '\u2AAD': 'late',
        '\u2AAD\uFE00': 'lates',
        '\u2AAE': 'bumpE',
        '\u2AAF': 'pre',
        '\u2AAF\u0338': 'npre',
        '\u2AB0': 'sce',
        '\u2AB0\u0338': 'nsce',
        '\u2AB3': 'prE',
        '\u2AB4': 'scE',
        '\u2AB5': 'prnE',
        '\u2AB6': 'scnE',
        '\u2AB7': 'prap',
        '\u2AB8': 'scap',
        '\u2AB9': 'prnap',
        '\u2ABA': 'scnap',
        '\u2ABB': 'Pr',
        '\u2ABC': 'Sc',
        '\u2ABD': 'subdot',
        '\u2ABE': 'supdot',
        '\u2ABF': 'subplus',
        '\u2AC0': 'supplus',
        '\u2AC1': 'submult',
        '\u2AC2': 'supmult',
        '\u2AC3': 'subedot',
        '\u2AC4': 'supedot',
        '\u2AC5': 'subE',
        '\u2AC5\u0338': 'nsubE',
        '\u2AC6': 'supE',
        '\u2AC6\u0338': 'nsupE',
        '\u2AC7': 'subsim',
        '\u2AC8': 'supsim',
        '\u2ACB\uFE00': 'vsubnE',
        '\u2ACB': 'subnE',
        '\u2ACC\uFE00': 'vsupnE',
        '\u2ACC': 'supnE',
        '\u2ACF': 'csub',
        '\u2AD0': 'csup',
        '\u2AD1': 'csube',
        '\u2AD2': 'csupe',
        '\u2AD3': 'subsup',
        '\u2AD4': 'supsub',
        '\u2AD5': 'subsub',
        '\u2AD6': 'supsup',
        '\u2AD7': 'suphsub',
        '\u2AD8': 'supdsub',
        '\u2AD9': 'forkv',
        '\u2ADA': 'topfork',
        '\u2ADB': 'mlcp',
        '\u2AE4': 'Dashv',
        '\u2AE6': 'Vdashl',
        '\u2AE7': 'Barv',
        '\u2AE8': 'vBar',
        '\u2AE9': 'vBarv',
        '\u2AEB': 'Vbar',
        '\u2AEC': 'Not',
        '\u2AED': 'bNot',
        '\u2AEE': 'rnmid',
        '\u2AEF': 'cirmid',
        '\u2AF0': 'midcir',
        '\u2AF1': 'topcir',
        '\u2AF2': 'nhpar',
        '\u2AF3': 'parsim',
        '\u2AFD': 'parsl',
        '\u2AFD\u20E5': 'nparsl',
        '\u266D': 'flat',
        '\u266E': 'natur',
        '\u266F': 'sharp',
        '\xA4': 'curren',
        '\xA2': 'cent',
        '$': 'dollar',
        '\xA3': 'pound',
        '\xA5': 'yen',
        '\u20AC': 'euro',
        '\xB9': 'sup1',
        '\xBD': 'half',
        '\u2153': 'frac13',
        '\xBC': 'frac14',
        '\u2155': 'frac15',
        '\u2159': 'frac16',
        '\u215B': 'frac18',
        '\xB2': 'sup2',
        '\u2154': 'frac23',
        '\u2156': 'frac25',
        '\xB3': 'sup3',
        '\xBE': 'frac34',
        '\u2157': 'frac35',
        '\u215C': 'frac38',
        '\u2158': 'frac45',
        '\u215A': 'frac56',
        '\u215D': 'frac58',
        '\u215E': 'frac78',
        '\uD835\uDCB6': 'ascr',
        '\uD835\uDD52': 'aopf',
        '\uD835\uDD1E': 'afr',
        '\uD835\uDD38': 'Aopf',
        '\uD835\uDD04': 'Afr',
        '\uD835\uDC9C': 'Ascr',
        '\xAA': 'ordf',
        '\xE1': 'aacute',
        '\xC1': 'Aacute',
        '\xE0': 'agrave',
        '\xC0': 'Agrave',
        '\u0103': 'abreve',
        '\u0102': 'Abreve',
        '\xE2': 'acirc',
        '\xC2': 'Acirc',
        '\xE5': 'aring',
        '\xC5': 'angst',
        '\xE4': 'auml',
        '\xC4': 'Auml',
        '\xE3': 'atilde',
        '\xC3': 'Atilde',
        '\u0105': 'aogon',
        '\u0104': 'Aogon',
        '\u0101': 'amacr',
        '\u0100': 'Amacr',
        '\xE6': 'aelig',
        '\xC6': 'AElig',
        '\uD835\uDCB7': 'bscr',
        '\uD835\uDD53': 'bopf',
        '\uD835\uDD1F': 'bfr',
        '\uD835\uDD39': 'Bopf',
        '\u212C': 'Bscr',
        '\uD835\uDD05': 'Bfr',
        '\uD835\uDD20': 'cfr',
        '\uD835\uDCB8': 'cscr',
        '\uD835\uDD54': 'copf',
        '\u212D': 'Cfr',
        '\uD835\uDC9E': 'Cscr',
        '\u2102': 'Copf',
        '\u0107': 'cacute',
        '\u0106': 'Cacute',
        '\u0109': 'ccirc',
        '\u0108': 'Ccirc',
        '\u010D': 'ccaron',
        '\u010C': 'Ccaron',
        '\u010B': 'cdot',
        '\u010A': 'Cdot',
        '\xE7': 'ccedil',
        '\xC7': 'Ccedil',
        '\u2105': 'incare',
        '\uD835\uDD21': 'dfr',
        '\u2146': 'dd',
        '\uD835\uDD55': 'dopf',
        '\uD835\uDCB9': 'dscr',
        '\uD835\uDC9F': 'Dscr',
        '\uD835\uDD07': 'Dfr',
        '\u2145': 'DD',
        '\uD835\uDD3B': 'Dopf',
        '\u010F': 'dcaron',
        '\u010E': 'Dcaron',
        '\u0111': 'dstrok',
        '\u0110': 'Dstrok',
        '\xF0': 'eth',
        '\xD0': 'ETH',
        '\u2147': 'ee',
        '\u212F': 'escr',
        '\uD835\uDD22': 'efr',
        '\uD835\uDD56': 'eopf',
        '\u2130': 'Escr',
        '\uD835\uDD08': 'Efr',
        '\uD835\uDD3C': 'Eopf',
        '\xE9': 'eacute',
        '\xC9': 'Eacute',
        '\xE8': 'egrave',
        '\xC8': 'Egrave',
        '\xEA': 'ecirc',
        '\xCA': 'Ecirc',
        '\u011B': 'ecaron',
        '\u011A': 'Ecaron',
        '\xEB': 'euml',
        '\xCB': 'Euml',
        '\u0117': 'edot',
        '\u0116': 'Edot',
        '\u0119': 'eogon',
        '\u0118': 'Eogon',
        '\u0113': 'emacr',
        '\u0112': 'Emacr',
        '\uD835\uDD23': 'ffr',
        '\uD835\uDD57': 'fopf',
        '\uD835\uDCBB': 'fscr',
        '\uD835\uDD09': 'Ffr',
        '\uD835\uDD3D': 'Fopf',
        '\u2131': 'Fscr',
        '\uFB00': 'fflig',
        '\uFB03': 'ffilig',
        '\uFB04': 'ffllig',
        '\uFB01': 'filig',
        'fj': 'fjlig',
        '\uFB02': 'fllig',
        '\u0192': 'fnof',
        '\u210A': 'gscr',
        '\uD835\uDD58': 'gopf',
        '\uD835\uDD24': 'gfr',
        '\uD835\uDCA2': 'Gscr',
        '\uD835\uDD3E': 'Gopf',
        '\uD835\uDD0A': 'Gfr',
        '\u01F5': 'gacute',
        '\u011F': 'gbreve',
        '\u011E': 'Gbreve',
        '\u011D': 'gcirc',
        '\u011C': 'Gcirc',
        '\u0121': 'gdot',
        '\u0120': 'Gdot',
        '\u0122': 'Gcedil',
        '\uD835\uDD25': 'hfr',
        '\u210E': 'planckh',
        '\uD835\uDCBD': 'hscr',
        '\uD835\uDD59': 'hopf',
        '\u210B': 'Hscr',
        '\u210C': 'Hfr',
        '\u210D': 'Hopf',
        '\u0125': 'hcirc',
        '\u0124': 'Hcirc',
        '\u210F': 'hbar',
        '\u0127': 'hstrok',
        '\u0126': 'Hstrok',
        '\uD835\uDD5A': 'iopf',
        '\uD835\uDD26': 'ifr',
        '\uD835\uDCBE': 'iscr',
        '\u2148': 'ii',
        '\uD835\uDD40': 'Iopf',
        '\u2110': 'Iscr',
        '\u2111': 'Im',
        '\xED': 'iacute',
        '\xCD': 'Iacute',
        '\xEC': 'igrave',
        '\xCC': 'Igrave',
        '\xEE': 'icirc',
        '\xCE': 'Icirc',
        '\xEF': 'iuml',
        '\xCF': 'Iuml',
        '\u0129': 'itilde',
        '\u0128': 'Itilde',
        '\u0130': 'Idot',
        '\u012F': 'iogon',
        '\u012E': 'Iogon',
        '\u012B': 'imacr',
        '\u012A': 'Imacr',
        '\u0133': 'ijlig',
        '\u0132': 'IJlig',
        '\u0131': 'imath',
        '\uD835\uDCBF': 'jscr',
        '\uD835\uDD5B': 'jopf',
        '\uD835\uDD27': 'jfr',
        '\uD835\uDCA5': 'Jscr',
        '\uD835\uDD0D': 'Jfr',
        '\uD835\uDD41': 'Jopf',
        '\u0135': 'jcirc',
        '\u0134': 'Jcirc',
        '\u0237': 'jmath',
        '\uD835\uDD5C': 'kopf',
        '\uD835\uDCC0': 'kscr',
        '\uD835\uDD28': 'kfr',
        '\uD835\uDCA6': 'Kscr',
        '\uD835\uDD42': 'Kopf',
        '\uD835\uDD0E': 'Kfr',
        '\u0137': 'kcedil',
        '\u0136': 'Kcedil',
        '\uD835\uDD29': 'lfr',
        '\uD835\uDCC1': 'lscr',
        '\u2113': 'ell',
        '\uD835\uDD5D': 'lopf',
        '\u2112': 'Lscr',
        '\uD835\uDD0F': 'Lfr',
        '\uD835\uDD43': 'Lopf',
        '\u013A': 'lacute',
        '\u0139': 'Lacute',
        '\u013E': 'lcaron',
        '\u013D': 'Lcaron',
        '\u013C': 'lcedil',
        '\u013B': 'Lcedil',
        '\u0142': 'lstrok',
        '\u0141': 'Lstrok',
        '\u0140': 'lmidot',
        '\u013F': 'Lmidot',
        '\uD835\uDD2A': 'mfr',
        '\uD835\uDD5E': 'mopf',
        '\uD835\uDCC2': 'mscr',
        '\uD835\uDD10': 'Mfr',
        '\uD835\uDD44': 'Mopf',
        '\u2133': 'Mscr',
        '\uD835\uDD2B': 'nfr',
        '\uD835\uDD5F': 'nopf',
        '\uD835\uDCC3': 'nscr',
        '\u2115': 'Nopf',
        '\uD835\uDCA9': 'Nscr',
        '\uD835\uDD11': 'Nfr',
        '\u0144': 'nacute',
        '\u0143': 'Nacute',
        '\u0148': 'ncaron',
        '\u0147': 'Ncaron',
        '\xF1': 'ntilde',
        '\xD1': 'Ntilde',
        '\u0146': 'ncedil',
        '\u0145': 'Ncedil',
        '\u2116': 'numero',
        '\u014B': 'eng',
        '\u014A': 'ENG',
        '\uD835\uDD60': 'oopf',
        '\uD835\uDD2C': 'ofr',
        '\u2134': 'oscr',
        '\uD835\uDCAA': 'Oscr',
        '\uD835\uDD12': 'Ofr',
        '\uD835\uDD46': 'Oopf',
        '\xBA': 'ordm',
        '\xF3': 'oacute',
        '\xD3': 'Oacute',
        '\xF2': 'ograve',
        '\xD2': 'Ograve',
        '\xF4': 'ocirc',
        '\xD4': 'Ocirc',
        '\xF6': 'ouml',
        '\xD6': 'Ouml',
        '\u0151': 'odblac',
        '\u0150': 'Odblac',
        '\xF5': 'otilde',
        '\xD5': 'Otilde',
        '\xF8': 'oslash',
        '\xD8': 'Oslash',
        '\u014D': 'omacr',
        '\u014C': 'Omacr',
        '\u0153': 'oelig',
        '\u0152': 'OElig',
        '\uD835\uDD2D': 'pfr',
        '\uD835\uDCC5': 'pscr',
        '\uD835\uDD61': 'popf',
        '\u2119': 'Popf',
        '\uD835\uDD13': 'Pfr',
        '\uD835\uDCAB': 'Pscr',
        '\uD835\uDD62': 'qopf',
        '\uD835\uDD2E': 'qfr',
        '\uD835\uDCC6': 'qscr',
        '\uD835\uDCAC': 'Qscr',
        '\uD835\uDD14': 'Qfr',
        '\u211A': 'Qopf',
        '\u0138': 'kgreen',
        '\uD835\uDD2F': 'rfr',
        '\uD835\uDD63': 'ropf',
        '\uD835\uDCC7': 'rscr',
        '\u211B': 'Rscr',
        '\u211C': 'Re',
        '\u211D': 'Ropf',
        '\u0155': 'racute',
        '\u0154': 'Racute',
        '\u0159': 'rcaron',
        '\u0158': 'Rcaron',
        '\u0157': 'rcedil',
        '\u0156': 'Rcedil',
        '\uD835\uDD64': 'sopf',
        '\uD835\uDCC8': 'sscr',
        '\uD835\uDD30': 'sfr',
        '\uD835\uDD4A': 'Sopf',
        '\uD835\uDD16': 'Sfr',
        '\uD835\uDCAE': 'Sscr',
        '\u24C8': 'oS',
        '\u015B': 'sacute',
        '\u015A': 'Sacute',
        '\u015D': 'scirc',
        '\u015C': 'Scirc',
        '\u0161': 'scaron',
        '\u0160': 'Scaron',
        '\u015F': 'scedil',
        '\u015E': 'Scedil',
        '\xDF': 'szlig',
        '\uD835\uDD31': 'tfr',
        '\uD835\uDCC9': 'tscr',
        '\uD835\uDD65': 'topf',
        '\uD835\uDCAF': 'Tscr',
        '\uD835\uDD17': 'Tfr',
        '\uD835\uDD4B': 'Topf',
        '\u0165': 'tcaron',
        '\u0164': 'Tcaron',
        '\u0163': 'tcedil',
        '\u0162': 'Tcedil',
        '\u2122': 'trade',
        '\u0167': 'tstrok',
        '\u0166': 'Tstrok',
        '\uD835\uDCCA': 'uscr',
        '\uD835\uDD66': 'uopf',
        '\uD835\uDD32': 'ufr',
        '\uD835\uDD4C': 'Uopf',
        '\uD835\uDD18': 'Ufr',
        '\uD835\uDCB0': 'Uscr',
        '\xFA': 'uacute',
        '\xDA': 'Uacute',
        '\xF9': 'ugrave',
        '\xD9': 'Ugrave',
        '\u016D': 'ubreve',
        '\u016C': 'Ubreve',
        '\xFB': 'ucirc',
        '\xDB': 'Ucirc',
        '\u016F': 'uring',
        '\u016E': 'Uring',
        '\xFC': 'uuml',
        '\xDC': 'Uuml',
        '\u0171': 'udblac',
        '\u0170': 'Udblac',
        '\u0169': 'utilde',
        '\u0168': 'Utilde',
        '\u0173': 'uogon',
        '\u0172': 'Uogon',
        '\u016B': 'umacr',
        '\u016A': 'Umacr',
        '\uD835\uDD33': 'vfr',
        '\uD835\uDD67': 'vopf',
        '\uD835\uDCCB': 'vscr',
        '\uD835\uDD19': 'Vfr',
        '\uD835\uDD4D': 'Vopf',
        '\uD835\uDCB1': 'Vscr',
        '\uD835\uDD68': 'wopf',
        '\uD835\uDCCC': 'wscr',
        '\uD835\uDD34': 'wfr',
        '\uD835\uDCB2': 'Wscr',
        '\uD835\uDD4E': 'Wopf',
        '\uD835\uDD1A': 'Wfr',
        '\u0175': 'wcirc',
        '\u0174': 'Wcirc',
        '\uD835\uDD35': 'xfr',
        '\uD835\uDCCD': 'xscr',
        '\uD835\uDD69': 'xopf',
        '\uD835\uDD4F': 'Xopf',
        '\uD835\uDD1B': 'Xfr',
        '\uD835\uDCB3': 'Xscr',
        '\uD835\uDD36': 'yfr',
        '\uD835\uDCCE': 'yscr',
        '\uD835\uDD6A': 'yopf',
        '\uD835\uDCB4': 'Yscr',
        '\uD835\uDD1C': 'Yfr',
        '\uD835\uDD50': 'Yopf',
        '\xFD': 'yacute',
        '\xDD': 'Yacute',
        '\u0177': 'ycirc',
        '\u0176': 'Ycirc',
        '\xFF': 'yuml',
        '\u0178': 'Yuml',
        '\uD835\uDCCF': 'zscr',
        '\uD835\uDD37': 'zfr',
        '\uD835\uDD6B': 'zopf',
        '\u2128': 'Zfr',
        '\u2124': 'Zopf',
        '\uD835\uDCB5': 'Zscr',
        '\u017A': 'zacute',
        '\u0179': 'Zacute',
        '\u017E': 'zcaron',
        '\u017D': 'Zcaron',
        '\u017C': 'zdot',
        '\u017B': 'Zdot',
        '\u01B5': 'imped',
        '\xFE': 'thorn',
        '\xDE': 'THORN',
        '\u0149': 'napos',
        '\u03B1': 'alpha',
        '\u0391': 'Alpha',
        '\u03B2': 'beta',
        '\u0392': 'Beta',
        '\u03B3': 'gamma',
        '\u0393': 'Gamma',
        '\u03B4': 'delta',
        '\u0394': 'Delta',
        '\u03B5': 'epsi',
        '\u03F5': 'epsiv',
        '\u0395': 'Epsilon',
        '\u03DD': 'gammad',
        '\u03DC': 'Gammad',
        '\u03B6': 'zeta',
        '\u0396': 'Zeta',
        '\u03B7': 'eta',
        '\u0397': 'Eta',
        '\u03B8': 'theta',
        '\u03D1': 'thetav',
        '\u0398': 'Theta',
        '\u03B9': 'iota',
        '\u0399': 'Iota',
        '\u03BA': 'kappa',
        '\u03F0': 'kappav',
        '\u039A': 'Kappa',
        '\u03BB': 'lambda',
        '\u039B': 'Lambda',
        '\u03BC': 'mu',
        '\xB5': 'micro',
        '\u039C': 'Mu',
        '\u03BD': 'nu',
        '\u039D': 'Nu',
        '\u03BE': 'xi',
        '\u039E': 'Xi',
        '\u03BF': 'omicron',
        '\u039F': 'Omicron',
        '\u03C0': 'pi',
        '\u03D6': 'piv',
        '\u03A0': 'Pi',
        '\u03C1': 'rho',
        '\u03F1': 'rhov',
        '\u03A1': 'Rho',
        '\u03C3': 'sigma',
        '\u03A3': 'Sigma',
        '\u03C2': 'sigmaf',
        '\u03C4': 'tau',
        '\u03A4': 'Tau',
        '\u03C5': 'upsi',
        '\u03A5': 'Upsilon',
        '\u03D2': 'Upsi',
        '\u03C6': 'phi',
        '\u03D5': 'phiv',
        '\u03A6': 'Phi',
        '\u03C7': 'chi',
        '\u03A7': 'Chi',
        '\u03C8': 'psi',
        '\u03A8': 'Psi',
        '\u03C9': 'omega',
        '\u03A9': 'ohm',
        '\u0430': 'acy',
        '\u0410': 'Acy',
        '\u0431': 'bcy',
        '\u0411': 'Bcy',
        '\u0432': 'vcy',
        '\u0412': 'Vcy',
        '\u0433': 'gcy',
        '\u0413': 'Gcy',
        '\u0453': 'gjcy',
        '\u0403': 'GJcy',
        '\u0434': 'dcy',
        '\u0414': 'Dcy',
        '\u0452': 'djcy',
        '\u0402': 'DJcy',
        '\u0435': 'iecy',
        '\u0415': 'IEcy',
        '\u0451': 'iocy',
        '\u0401': 'IOcy',
        '\u0454': 'jukcy',
        '\u0404': 'Jukcy',
        '\u0436': 'zhcy',
        '\u0416': 'ZHcy',
        '\u0437': 'zcy',
        '\u0417': 'Zcy',
        '\u0455': 'dscy',
        '\u0405': 'DScy',
        '\u0438': 'icy',
        '\u0418': 'Icy',
        '\u0456': 'iukcy',
        '\u0406': 'Iukcy',
        '\u0457': 'yicy',
        '\u0407': 'YIcy',
        '\u0439': 'jcy',
        '\u0419': 'Jcy',
        '\u0458': 'jsercy',
        '\u0408': 'Jsercy',
        '\u043A': 'kcy',
        '\u041A': 'Kcy',
        '\u045C': 'kjcy',
        '\u040C': 'KJcy',
        '\u043B': 'lcy',
        '\u041B': 'Lcy',
        '\u0459': 'ljcy',
        '\u0409': 'LJcy',
        '\u043C': 'mcy',
        '\u041C': 'Mcy',
        '\u043D': 'ncy',
        '\u041D': 'Ncy',
        '\u045A': 'njcy',
        '\u040A': 'NJcy',
        '\u043E': 'ocy',
        '\u041E': 'Ocy',
        '\u043F': 'pcy',
        '\u041F': 'Pcy',
        '\u0440': 'rcy',
        '\u0420': 'Rcy',
        '\u0441': 'scy',
        '\u0421': 'Scy',
        '\u0442': 'tcy',
        '\u0422': 'Tcy',
        '\u045B': 'tshcy',
        '\u040B': 'TSHcy',
        '\u0443': 'ucy',
        '\u0423': 'Ucy',
        '\u045E': 'ubrcy',
        '\u040E': 'Ubrcy',
        '\u0444': 'fcy',
        '\u0424': 'Fcy',
        '\u0445': 'khcy',
        '\u0425': 'KHcy',
        '\u0446': 'tscy',
        '\u0426': 'TScy',
        '\u0447': 'chcy',
        '\u0427': 'CHcy',
        '\u045F': 'dzcy',
        '\u040F': 'DZcy',
        '\u0448': 'shcy',
        '\u0428': 'SHcy',
        '\u0449': 'shchcy',
        '\u0429': 'SHCHcy',
        '\u044A': 'hardcy',
        '\u042A': 'HARDcy',
        '\u044B': 'ycy',
        '\u042B': 'Ycy',
        '\u044C': 'softcy',
        '\u042C': 'SOFTcy',
        '\u044D': 'ecy',
        '\u042D': 'Ecy',
        '\u044E': 'yucy',
        '\u042E': 'YUcy',
        '\u044F': 'yacy',
        '\u042F': 'YAcy',
        '\u2135': 'aleph',
        '\u2136': 'beth',
        '\u2137': 'gimel',
        '\u2138': 'daleth'
      };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': '&quot;',
        '&': '&amp;',
        '\'': '&#x27;',
        '<': '&lt;',
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless its part of a tag or an
        // unquoted attribute value. Were only escaping it to support those
        // situations, and for XML support.
        '>': '&gt;',
        // In Internet Explorer  8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        '`': '&#x60;'
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = {
        'aacute': '\xE1',
        'Aacute': '\xC1',
        'abreve': '\u0103',
        'Abreve': '\u0102',
        'ac': '\u223E',
        'acd': '\u223F',
        'acE': '\u223E\u0333',
        'acirc': '\xE2',
        'Acirc': '\xC2',
        'acute': '\xB4',
        'acy': '\u0430',
        'Acy': '\u0410',
        'aelig': '\xE6',
        'AElig': '\xC6',
        'af': '\u2061',
        'afr': '\uD835\uDD1E',
        'Afr': '\uD835\uDD04',
        'agrave': '\xE0',
        'Agrave': '\xC0',
        'alefsym': '\u2135',
        'aleph': '\u2135',
        'alpha': '\u03B1',
        'Alpha': '\u0391',
        'amacr': '\u0101',
        'Amacr': '\u0100',
        'amalg': '\u2A3F',
        'amp': '&',
        'AMP': '&',
        'and': '\u2227',
        'And': '\u2A53',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'ange': '\u29A4',
        'angle': '\u2220',
        'angmsd': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angst': '\xC5',
        'angzarr': '\u237C',
        'aogon': '\u0105',
        'Aogon': '\u0104',
        'aopf': '\uD835\uDD52',
        'Aopf': '\uD835\uDD38',
        'ap': '\u2248',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'apE': '\u2A70',
        'apid': '\u224B',
        'apos': '\'',
        'ApplyFunction': '\u2061',
        'approx': '\u2248',
        'approxeq': '\u224A',
        'aring': '\xE5',
        'Aring': '\xC5',
        'ascr': '\uD835\uDCB6',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'ast': '*',
        'asymp': '\u2248',
        'asympeq': '\u224D',
        'atilde': '\xE3',
        'Atilde': '\xC3',
        'auml': '\xE4',
        'Auml': '\xC4',
        'awconint': '\u2233',
        'awint': '\u2A11',
        'backcong': '\u224C',
        'backepsilon': '\u03F6',
        'backprime': '\u2035',
        'backsim': '\u223D',
        'backsimeq': '\u22CD',
        'Backslash': '\u2216',
        'Barv': '\u2AE7',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'Barwed': '\u2306',
        'barwedge': '\u2305',
        'bbrk': '\u23B5',
        'bbrktbrk': '\u23B6',
        'bcong': '\u224C',
        'bcy': '\u0431',
        'Bcy': '\u0411',
        'bdquo': '\u201E',
        'becaus': '\u2235',
        'because': '\u2235',
        'Because': '\u2235',
        'bemptyv': '\u29B0',
        'bepsi': '\u03F6',
        'bernou': '\u212C',
        'Bernoullis': '\u212C',
        'beta': '\u03B2',
        'Beta': '\u0392',
        'beth': '\u2136',
        'between': '\u226C',
        'bfr': '\uD835\uDD1F',
        'Bfr': '\uD835\uDD05',
        'bigcap': '\u22C2',
        'bigcirc': '\u25EF',
        'bigcup': '\u22C3',
        'bigodot': '\u2A00',
        'bigoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'bigsqcup': '\u2A06',
        'bigstar': '\u2605',
        'bigtriangledown': '\u25BD',
        'bigtriangleup': '\u25B3',
        'biguplus': '\u2A04',
        'bigvee': '\u22C1',
        'bigwedge': '\u22C0',
        'bkarow': '\u290D',
        'blacklozenge': '\u29EB',
        'blacksquare': '\u25AA',
        'blacktriangle': '\u25B4',
        'blacktriangledown': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'blacktriangleright': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '=\u20E5',
        'bnequiv': '\u2261\u20E5',
        'bnot': '\u2310',
        'bNot': '\u2AED',
        'bopf': '\uD835\uDD53',
        'Bopf': '\uD835\uDD39',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'bowtie': '\u22C8',
        'boxbox': '\u29C9',
        'boxdl': '\u2510',
        'boxdL': '\u2555',
        'boxDl': '\u2556',
        'boxDL': '\u2557',
        'boxdr': '\u250C',
        'boxdR': '\u2552',
        'boxDr': '\u2553',
        'boxDR': '\u2554',
        'boxh': '\u2500',
        'boxH': '\u2550',
        'boxhd': '\u252C',
        'boxhD': '\u2565',
        'boxHd': '\u2564',
        'boxHD': '\u2566',
        'boxhu': '\u2534',
        'boxhU': '\u2568',
        'boxHu': '\u2567',
        'boxHU': '\u2569',
        'boxminus': '\u229F',
        'boxplus': '\u229E',
        'boxtimes': '\u22A0',
        'boxul': '\u2518',
        'boxuL': '\u255B',
        'boxUl': '\u255C',
        'boxUL': '\u255D',
        'boxur': '\u2514',
        'boxuR': '\u2558',
        'boxUr': '\u2559',
        'boxUR': '\u255A',
        'boxv': '\u2502',
        'boxV': '\u2551',
        'boxvh': '\u253C',
        'boxvH': '\u256A',
        'boxVh': '\u256B',
        'boxVH': '\u256C',
        'boxvl': '\u2524',
        'boxvL': '\u2561',
        'boxVl': '\u2562',
        'boxVL': '\u2563',
        'boxvr': '\u251C',
        'boxvR': '\u255E',
        'boxVr': '\u255F',
        'boxVR': '\u2560',
        'bprime': '\u2035',
        'breve': '\u02D8',
        'Breve': '\u02D8',
        'brvbar': '\xA6',
        'bscr': '\uD835\uDCB7',
        'Bscr': '\u212C',
        'bsemi': '\u204F',
        'bsim': '\u223D',
        'bsime': '\u22CD',
        'bsol': '\\',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bump': '\u224E',
        'bumpe': '\u224F',
        'bumpE': '\u2AAE',
        'bumpeq': '\u224F',
        'Bumpeq': '\u224E',
        'cacute': '\u0107',
        'Cacute': '\u0106',
        'cap': '\u2229',
        'Cap': '\u22D2',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'CapitalDifferentialD': '\u2145',
        'caps': '\u2229\uFE00',
        'caret': '\u2041',
        'caron': '\u02C7',
        'Cayleys': '\u212D',
        'ccaps': '\u2A4D',
        'ccaron': '\u010D',
        'Ccaron': '\u010C',
        'ccedil': '\xE7',
        'Ccedil': '\xC7',
        'ccirc': '\u0109',
        'Ccirc': '\u0108',
        'Cconint': '\u2230',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': '\u010B',
        'Cdot': '\u010A',
        'cedil': '\xB8',
        'Cedilla': '\xB8',
        'cemptyv': '\u29B2',
        'cent': '\xA2',
        'centerdot': '\xB7',
        'CenterDot': '\xB7',
        'cfr': '\uD835\uDD20',
        'Cfr': '\u212D',
        'chcy': '\u0447',
        'CHcy': '\u0427',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': '\u03C7',
        'Chi': '\u03A7',
        'cir': '\u25CB',
        'circ': '\u02C6',
        'circeq': '\u2257',
        'circlearrowleft': '\u21BA',
        'circlearrowright': '\u21BB',
        'circledast': '\u229B',
        'circledcirc': '\u229A',
        'circleddash': '\u229D',
        'CircleDot': '\u2299',
        'circledR': '\xAE',
        'circledS': '\u24C8',
        'CircleMinus': '\u2296',
        'CirclePlus': '\u2295',
        'CircleTimes': '\u2297',
        'cire': '\u2257',
        'cirE': '\u29C3',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'ClockwiseContourIntegral': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': ':',
        'Colon': '\u2237',
        'colone': '\u2254',
        'Colone': '\u2A74',
        'coloneq': '\u2254',
        'comma': ',',
        'commat': '@',
        'comp': '\u2201',
        'compfn': '\u2218',
        'complement': '\u2201',
        'complexes': '\u2102',
        'cong': '\u2245',
        'congdot': '\u2A6D',
        'Congruent': '\u2261',
        'conint': '\u222E',
        'Conint': '\u222F',
        'ContourIntegral': '\u222E',
        'copf': '\uD835\uDD54',
        'Copf': '\u2102',
        'coprod': '\u2210',
        'Coproduct': '\u2210',
        'copy': '\xA9',
        'COPY': '\xA9',
        'copysr': '\u2117',
        'CounterClockwiseContourIntegral': '\u2233',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'Cross': '\u2A2F',
        'cscr': '\uD835\uDCB8',
        'Cscr': '\uD835\uDC9E',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'cuesc': '\u22DF',
        'cularr': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'Cup': '\u22D3',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'CupCap': '\u224D',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A\uFE00',
        'curarr': '\u21B7',
        'curarrm': '\u293C',
        'curlyeqprec': '\u22DE',
        'curlyeqsucc': '\u22DF',
        'curlyvee': '\u22CE',
        'curlywedge': '\u22CF',
        'curren': '\xA4',
        'curvearrowleft': '\u21B6',
        'curvearrowright': '\u21B7',
        'cuvee': '\u22CE',
        'cuwed': '\u22CF',
        'cwconint': '\u2232',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dagger': '\u2020',
        'Dagger': '\u2021',
        'daleth': '\u2138',
        'darr': '\u2193',
        'dArr': '\u21D3',
        'Darr': '\u21A1',
        'dash': '\u2010',
        'dashv': '\u22A3',
        'Dashv': '\u2AE4',
        'dbkarow': '\u290F',
        'dblac': '\u02DD',
        'dcaron': '\u010F',
        'Dcaron': '\u010E',
        'dcy': '\u0434',
        'Dcy': '\u0414',
        'dd': '\u2146',
        'DD': '\u2145',
        'ddagger': '\u2021',
        'ddarr': '\u21CA',
        'DDotrahd': '\u2911',
        'ddotseq': '\u2A77',
        'deg': '\xB0',
        'Del': '\u2207',
        'delta': '\u03B4',
        'Delta': '\u0394',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'Dfr': '\uD835\uDD07',
        'dHar': '\u2965',
        'dharl': '\u21C3',
        'dharr': '\u21C2',
        'DiacriticalAcute': '\xB4',
        'DiacriticalDot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'DiacriticalGrave': '`',
        'DiacriticalTilde': '\u02DC',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'Diamond': '\u22C4',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'die': '\xA8',
        'DifferentialD': '\u2146',
        'digamma': '\u03DD',
        'disin': '\u22F2',
        'div': '\xF7',
        'divide': '\xF7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': '\u0452',
        'DJcy': '\u0402',
        'dlcorn': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '$',
        'dopf': '\uD835\uDD55',
        'Dopf': '\uD835\uDD3B',
        'dot': '\u02D9',
        'Dot': '\xA8',
        'DotDot': '\u20DC',
        'doteq': '\u2250',
        'doteqdot': '\u2251',
        'DotEqual': '\u2250',
        'dotminus': '\u2238',
        'dotplus': '\u2214',
        'dotsquare': '\u22A1',
        'doublebarwedge': '\u2306',
        'DoubleContourIntegral': '\u222F',
        'DoubleDot': '\xA8',
        'DoubleDownArrow': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'DoubleLeftTee': '\u2AE4',
        'DoubleLongLeftArrow': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'downarrow': '\u2193',
        'Downarrow': '\u21D3',
        'DownArrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'DownBreve': '\u0311',
        'downdownarrows': '\u21CA',
        'downharpoonleft': '\u21C3',
        'downharpoonright': '\u21C2',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'drbkarow': '\u2910',
        'drcorn': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'Dscr': '\uD835\uDC9F',
        'dscy': '\u0455',
        'DScy': '\u0405',
        'dsol': '\u29F6',
        'dstrok': '\u0111',
        'Dstrok': '\u0110',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'dtrif': '\u25BE',
        'duarr': '\u21F5',
        'duhar': '\u296F',
        'dwangle': '\u29A6',
        'dzcy': '\u045F',
        'DZcy': '\u040F',
        'dzigrarr': '\u27FF',
        'eacute': '\xE9',
        'Eacute': '\xC9',
        'easter': '\u2A6E',
        'ecaron': '\u011B',
        'Ecaron': '\u011A',
        'ecir': '\u2256',
        'ecirc': '\xEA',
        'Ecirc': '\xCA',
        'ecolon': '\u2255',
        'ecy': '\u044D',
        'Ecy': '\u042D',
        'eDDot': '\u2A77',
        'edot': '\u0117',
        'eDot': '\u2251',
        'Edot': '\u0116',
        'ee': '\u2147',
        'efDot': '\u2252',
        'efr': '\uD835\uDD22',
        'Efr': '\uD835\uDD08',
        'eg': '\u2A9A',
        'egrave': '\xE8',
        'Egrave': '\xC8',
        'egs': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'Element': '\u2208',
        'elinters': '\u23E7',
        'ell': '\u2113',
        'els': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': '\u0113',
        'Emacr': '\u0112',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'EmptySmallSquare': '\u25FB',
        'emptyv': '\u2205',
        'EmptyVerySmallSquare': '\u25AB',
        'emsp': '\u2003',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'eng': '\u014B',
        'ENG': '\u014A',
        'ensp': '\u2002',
        'eogon': '\u0119',
        'Eogon': '\u0118',
        'eopf': '\uD835\uDD56',
        'Eopf': '\uD835\uDD3C',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': '\u03B5',
        'epsilon': '\u03B5',
        'Epsilon': '\u0395',
        'epsiv': '\u03F5',
        'eqcirc': '\u2256',
        'eqcolon': '\u2255',
        'eqsim': '\u2242',
        'eqslantgtr': '\u2A96',
        'eqslantless': '\u2A95',
        'Equal': '\u2A75',
        'equals': '=',
        'EqualTilde': '\u2242',
        'equest': '\u225F',
        'Equilibrium': '\u21CC',
        'equiv': '\u2261',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erarr': '\u2971',
        'erDot': '\u2253',
        'escr': '\u212F',
        'Escr': '\u2130',
        'esdot': '\u2250',
        'esim': '\u2242',
        'Esim': '\u2A73',
        'eta': '\u03B7',
        'Eta': '\u0397',
        'eth': '\xF0',
        'ETH': '\xD0',
        'euml': '\xEB',
        'Euml': '\xCB',
        'euro': '\u20AC',
        'excl': '!',
        'exist': '\u2203',
        'Exists': '\u2203',
        'expectation': '\u2130',
        'exponentiale': '\u2147',
        'ExponentialE': '\u2147',
        'fallingdotseq': '\u2252',
        'fcy': '\u0444',
        'Fcy': '\u0424',
        'female': '\u2640',
        'ffilig': '\uFB03',
        'fflig': '\uFB00',
        'ffllig': '\uFB04',
        'ffr': '\uD835\uDD23',
        'Ffr': '\uD835\uDD09',
        'filig': '\uFB01',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'fjlig': 'fj',
        'flat': '\u266D',
        'fllig': '\uFB02',
        'fltns': '\u25B1',
        'fnof': '\u0192',
        'fopf': '\uD835\uDD57',
        'Fopf': '\uD835\uDD3D',
        'forall': '\u2200',
        'ForAll': '\u2200',
        'fork': '\u22D4',
        'forkv': '\u2AD9',
        'Fouriertrf': '\u2131',
        'fpartint': '\u2A0D',
        'frac12': '\xBD',
        'frac13': '\u2153',
        'frac14': '\xBC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\xBE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'Fscr': '\u2131',
        'gacute': '\u01F5',
        'gamma': '\u03B3',
        'Gamma': '\u0393',
        'gammad': '\u03DD',
        'Gammad': '\u03DC',
        'gap': '\u2A86',
        'gbreve': '\u011F',
        'Gbreve': '\u011E',
        'Gcedil': '\u0122',
        'gcirc': '\u011D',
        'Gcirc': '\u011C',
        'gcy': '\u0433',
        'Gcy': '\u0413',
        'gdot': '\u0121',
        'Gdot': '\u0120',
        'ge': '\u2265',
        'gE': '\u2267',
        'gel': '\u22DB',
        'gEl': '\u2A8C',
        'geq': '\u2265',
        'geqq': '\u2267',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB\uFE00',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'Gfr': '\uD835\uDD0A',
        'gg': '\u226B',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'gimel': '\u2137',
        'gjcy': '\u0453',
        'GJcy': '\u0403',
        'gl': '\u2277',
        'gla': '\u2AA5',
        'glE': '\u2A92',
        'glj': '\u2AA4',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gnE': '\u2269',
        'gneq': '\u2A88',
        'gneqq': '\u2269',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'Gopf': '\uD835\uDD3E',
        'grave': '`',
        'GreaterEqual': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gscr': '\u210A',
        'Gscr': '\uD835\uDCA2',
        'gsim': '\u2273',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gt': '>',
        'Gt': '\u226B',
        'GT': '>',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrapprox': '\u2A86',
        'gtrarr': '\u2978',
        'gtrdot': '\u22D7',
        'gtreqless': '\u22DB',
        'gtreqqless': '\u2A8C',
        'gtrless': '\u2277',
        'gtrsim': '\u2273',
        'gvertneqq': '\u2269\uFE00',
        'gvnE': '\u2269\uFE00',
        'Hacek': '\u02C7',
        'hairsp': '\u200A',
        'half': '\xBD',
        'hamilt': '\u210B',
        'hardcy': '\u044A',
        'HARDcy': '\u042A',
        'harr': '\u2194',
        'hArr': '\u21D4',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'Hat': '^',
        'hbar': '\u210F',
        'hcirc': '\u0125',
        'Hcirc': '\u0124',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'Hfr': '\u210C',
        'HilbertSpace': '\u210B',
        'hksearow': '\u2925',
        'hkswarow': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'hookrightarrow': '\u21AA',
        'hopf': '\uD835\uDD59',
        'Hopf': '\u210D',
        'horbar': '\u2015',
        'HorizontalLine': '\u2500',
        'hscr': '\uD835\uDCBD',
        'Hscr': '\u210B',
        'hslash': '\u210F',
        'hstrok': '\u0127',
        'Hstrok': '\u0126',
        'HumpDownHump': '\u224E',
        'HumpEqual': '\u224F',
        'hybull': '\u2043',
        'hyphen': '\u2010',
        'iacute': '\xED',
        'Iacute': '\xCD',
        'ic': '\u2063',
        'icirc': '\xEE',
        'Icirc': '\xCE',
        'icy': '\u0438',
        'Icy': '\u0418',
        'Idot': '\u0130',
        'iecy': '\u0435',
        'IEcy': '\u0415',
        'iexcl': '\xA1',
        'iff': '\u21D4',
        'ifr': '\uD835\uDD26',
        'Ifr': '\u2111',
        'igrave': '\xEC',
        'Igrave': '\xCC',
        'ii': '\u2148',
        'iiiint': '\u2A0C',
        'iiint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': '\u0133',
        'IJlig': '\u0132',
        'Im': '\u2111',
        'imacr': '\u012B',
        'Imacr': '\u012A',
        'image': '\u2111',
        'ImaginaryI': '\u2148',
        'imagline': '\u2110',
        'imagpart': '\u2111',
        'imath': '\u0131',
        'imof': '\u22B7',
        'imped': '\u01B5',
        'Implies': '\u21D2',
        'in': '\u2208',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'inodot': '\u0131',
        'int': '\u222B',
        'Int': '\u222C',
        'intcal': '\u22BA',
        'integers': '\u2124',
        'Integral': '\u222B',
        'intercal': '\u22BA',
        'Intersection': '\u22C2',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'InvisibleComma': '\u2063',
        'InvisibleTimes': '\u2062',
        'iocy': '\u0451',
        'IOcy': '\u0401',
        'iogon': '\u012F',
        'Iogon': '\u012E',
        'iopf': '\uD835\uDD5A',
        'Iopf': '\uD835\uDD40',
        'iota': '\u03B9',
        'Iota': '\u0399',
        'iprod': '\u2A3C',
        'iquest': '\xBF',
        'iscr': '\uD835\uDCBE',
        'Iscr': '\u2110',
        'isin': '\u2208',
        'isindot': '\u22F5',
        'isinE': '\u22F9',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'isinv': '\u2208',
        'it': '\u2062',
        'itilde': '\u0129',
        'Itilde': '\u0128',
        'iukcy': '\u0456',
        'Iukcy': '\u0406',
        'iuml': '\xEF',
        'Iuml': '\xCF',
        'jcirc': '\u0135',
        'Jcirc': '\u0134',
        'jcy': '\u0439',
        'Jcy': '\u0419',
        'jfr': '\uD835\uDD27',
        'Jfr': '\uD835\uDD0D',
        'jmath': '\u0237',
        'jopf': '\uD835\uDD5B',
        'Jopf': '\uD835\uDD41',
        'jscr': '\uD835\uDCBF',
        'Jscr': '\uD835\uDCA5',
        'jsercy': '\u0458',
        'Jsercy': '\u0408',
        'jukcy': '\u0454',
        'Jukcy': '\u0404',
        'kappa': '\u03BA',
        'Kappa': '\u039A',
        'kappav': '\u03F0',
        'kcedil': '\u0137',
        'Kcedil': '\u0136',
        'kcy': '\u043A',
        'Kcy': '\u041A',
        'kfr': '\uD835\uDD28',
        'Kfr': '\uD835\uDD0E',
        'kgreen': '\u0138',
        'khcy': '\u0445',
        'KHcy': '\u0425',
        'kjcy': '\u045C',
        'KJcy': '\u040C',
        'kopf': '\uD835\uDD5C',
        'Kopf': '\uD835\uDD42',
        'kscr': '\uD835\uDCC0',
        'Kscr': '\uD835\uDCA6',
        'lAarr': '\u21DA',
        'lacute': '\u013A',
        'Lacute': '\u0139',
        'laemptyv': '\u29B4',
        'lagran': '\u2112',
        'lambda': '\u03BB',
        'Lambda': '\u039B',
        'lang': '\u27E8',
        'Lang': '\u27EA',
        'langd': '\u2991',
        'langle': '\u27E8',
        'lap': '\u2A85',
        'Laplacetrf': '\u2112',
        'laquo': '\xAB',
        'larr': '\u2190',
        'lArr': '\u21D0',
        'Larr': '\u219E',
        'larrb': '\u21E4',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrhk': '\u21A9',
        'larrlp': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'lAtail': '\u291B',
        'late': '\u2AAD',
        'lates': '\u2AAD\uFE00',
        'lbarr': '\u290C',
        'lBarr': '\u290E',
        'lbbrk': '\u2772',
        'lbrace': '{',
        'lbrack': '[',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': '\u013E',
        'Lcaron': '\u013D',
        'lcedil': '\u013C',
        'Lcedil': '\u013B',
        'lceil': '\u2308',
        'lcub': '{',
        'lcy': '\u043B',
        'Lcy': '\u041B',
        'ldca': '\u2936',
        'ldquo': '\u201C',
        'ldquor': '\u201E',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'lE': '\u2266',
        'LeftAngleBracket': '\u27E8',
        'leftarrow': '\u2190',
        'Leftarrow': '\u21D0',
        'LeftArrow': '\u2190',
        'LeftArrowBar': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftarrowtail': '\u21A2',
        'LeftCeiling': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'leftharpoondown': '\u21BD',
        'leftharpoonup': '\u21BC',
        'leftleftarrows': '\u21C7',
        'leftrightarrow': '\u2194',
        'Leftrightarrow': '\u21D4',
        'LeftRightArrow': '\u2194',
        'leftrightarrows': '\u21C6',
        'leftrightharpoons': '\u21CB',
        'leftrightsquigarrow': '\u21AD',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'LeftTeeVector': '\u295A',
        'leftthreetimes': '\u22CB',
        'LeftTriangle': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'LeftVectorBar': '\u2952',
        'leg': '\u22DA',
        'lEg': '\u2A8B',
        'leq': '\u2264',
        'leqq': '\u2266',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA\uFE00',
        'lesges': '\u2A93',
        'lessapprox': '\u2A85',
        'lessdot': '\u22D6',
        'lesseqgtr': '\u22DA',
        'lesseqqgtr': '\u2A8B',
        'LessEqualGreater': '\u22DA',
        'LessFullEqual': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'LessLess': '\u2AA1',
        'lesssim': '\u2272',
        'LessSlantEqual': '\u2A7D',
        'LessTilde': '\u2272',
        'lfisht': '\u297C',
        'lfloor': '\u230A',
        'lfr': '\uD835\uDD29',
        'Lfr': '\uD835\uDD0F',
        'lg': '\u2276',
        'lgE': '\u2A91',
        'lHar': '\u2962',
        'lhard': '\u21BD',
        'lharu': '\u21BC',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': '\u0459',
        'LJcy': '\u0409',
        'll': '\u226A',
        'Ll': '\u22D8',
        'llarr': '\u21C7',
        'llcorner': '\u231E',
        'Lleftarrow': '\u21DA',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': '\u0140',
        'Lmidot': '\u013F',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lnE': '\u2268',
        'lneq': '\u2A87',
        'lneqq': '\u2268',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'lobrk': '\u27E6',
        'longleftarrow': '\u27F5',
        'Longleftarrow': '\u27F8',
        'LongLeftArrow': '\u27F5',
        'longleftrightarrow': '\u27F7',
        'Longleftrightarrow': '\u27FA',
        'LongLeftRightArrow': '\u27F7',
        'longmapsto': '\u27FC',
        'longrightarrow': '\u27F6',
        'Longrightarrow': '\u27F9',
        'LongRightArrow': '\u27F6',
        'looparrowleft': '\u21AB',
        'looparrowright': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'Lopf': '\uD835\uDD43',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'lowbar': '_',
        'LowerLeftArrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lozf': '\u29EB',
        'lpar': '(',
        'lparlt': '\u2993',
        'lrarr': '\u21C6',
        'lrcorner': '\u231F',
        'lrhar': '\u21CB',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'Lscr': '\u2112',
        'lsh': '\u21B0',
        'Lsh': '\u21B0',
        'lsim': '\u2272',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsqb': '[',
        'lsquo': '\u2018',
        'lsquor': '\u201A',
        'lstrok': '\u0142',
        'Lstrok': '\u0141',
        'lt': '<',
        'Lt': '\u226A',
        'LT': '<',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltdot': '\u22D6',
        'lthree': '\u22CB',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltri': '\u25C3',
        'ltrie': '\u22B4',
        'ltrif': '\u25C2',
        'ltrPar': '\u2996',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268\uFE00',
        'lvnE': '\u2268\uFE00',
        'macr': '\xAF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'map': '\u21A6',
        'Map': '\u2905',
        'mapsto': '\u21A6',
        'mapstodown': '\u21A7',
        'mapstoleft': '\u21A4',
        'mapstoup': '\u21A5',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': '\u043C',
        'Mcy': '\u041C',
        'mdash': '\u2014',
        'mDDot': '\u223A',
        'measuredangle': '\u2221',
        'MediumSpace': '\u205F',
        'Mellintrf': '\u2133',
        'mfr': '\uD835\uDD2A',
        'Mfr': '\uD835\uDD10',
        'mho': '\u2127',
        'micro': '\xB5',
        'mid': '\u2223',
        'midast': '*',
        'midcir': '\u2AF0',
        'middot': '\xB7',
        'minus': '\u2212',
        'minusb': '\u229F',
        'minusd': '\u2238',
        'minusdu': '\u2A2A',
        'MinusPlus': '\u2213',
        'mlcp': '\u2ADB',
        'mldr': '\u2026',
        'mnplus': '\u2213',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'Mopf': '\uD835\uDD44',
        'mp': '\u2213',
        'mscr': '\uD835\uDCC2',
        'Mscr': '\u2133',
        'mstpos': '\u223E',
        'mu': '\u03BC',
        'Mu': '\u039C',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nabla': '\u2207',
        'nacute': '\u0144',
        'Nacute': '\u0143',
        'nang': '\u2220\u20D2',
        'nap': '\u2249',
        'napE': '\u2A70\u0338',
        'napid': '\u224B\u0338',
        'napos': '\u0149',
        'napprox': '\u2249',
        'natur': '\u266E',
        'natural': '\u266E',
        'naturals': '\u2115',
        'nbsp': '\xA0',
        'nbump': '\u224E\u0338',
        'nbumpe': '\u224F\u0338',
        'ncap': '\u2A43',
        'ncaron': '\u0148',
        'Ncaron': '\u0147',
        'ncedil': '\u0146',
        'Ncedil': '\u0145',
        'ncong': '\u2247',
        'ncongdot': '\u2A6D\u0338',
        'ncup': '\u2A42',
        'ncy': '\u043D',
        'Ncy': '\u041D',
        'ndash': '\u2013',
        'ne': '\u2260',
        'nearhk': '\u2924',
        'nearr': '\u2197',
        'neArr': '\u21D7',
        'nearrow': '\u2197',
        'nedot': '\u2250\u0338',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'nequiv': '\u2262',
        'nesear': '\u2928',
        'nesim': '\u2242\u0338',
        'NestedGreaterGreater': '\u226B',
        'NestedLessLess': '\u226A',
        'NewLine': '\n',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'nfr': '\uD835\uDD2B',
        'Nfr': '\uD835\uDD11',
        'nge': '\u2271',
        'ngE': '\u2267\u0338',
        'ngeq': '\u2271',
        'ngeqq': '\u2267\u0338',
        'ngeqslant': '\u2A7E\u0338',
        'nges': '\u2A7E\u0338',
        'nGg': '\u22D9\u0338',
        'ngsim': '\u2275',
        'ngt': '\u226F',
        'nGt': '\u226B\u20D2',
        'ngtr': '\u226F',
        'nGtv': '\u226B\u0338',
        'nharr': '\u21AE',
        'nhArr': '\u21CE',
        'nhpar': '\u2AF2',
        'ni': '\u220B',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'niv': '\u220B',
        'njcy': '\u045A',
        'NJcy': '\u040A',
        'nlarr': '\u219A',
        'nlArr': '\u21CD',
        'nldr': '\u2025',
        'nle': '\u2270',
        'nlE': '\u2266\u0338',
        'nleftarrow': '\u219A',
        'nLeftarrow': '\u21CD',
        'nleftrightarrow': '\u21AE',
        'nLeftrightarrow': '\u21CE',
        'nleq': '\u2270',
        'nleqq': '\u2266\u0338',
        'nleqslant': '\u2A7D\u0338',
        'nles': '\u2A7D\u0338',
        'nless': '\u226E',
        'nLl': '\u22D8\u0338',
        'nlsim': '\u2274',
        'nlt': '\u226E',
        'nLt': '\u226A\u20D2',
        'nltri': '\u22EA',
        'nltrie': '\u22EC',
        'nLtv': '\u226A\u0338',
        'nmid': '\u2224',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\xA0',
        'nopf': '\uD835\uDD5F',
        'Nopf': '\u2115',
        'not': '\xAC',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'NotElement': '\u2209',
        'NotEqual': '\u2260',
        'NotEqualTilde': '\u2242\u0338',
        'NotExists': '\u2204',
        'NotGreater': '\u226F',
        'NotGreaterEqual': '\u2271',
        'NotGreaterFullEqual': '\u2267\u0338',
        'NotGreaterGreater': '\u226B\u0338',
        'NotGreaterLess': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E\u0338',
        'NotGreaterTilde': '\u2275',
        'NotHumpDownHump': '\u224E\u0338',
        'NotHumpEqual': '\u224F\u0338',
        'notin': '\u2209',
        'notindot': '\u22F5\u0338',
        'notinE': '\u22F9\u0338',
        'notinva': '\u2209',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'NotLeftTriangle': '\u22EA',
        'NotLeftTriangleBar': '\u29CF\u0338',
        'NotLeftTriangleEqual': '\u22EC',
        'NotLess': '\u226E',
        'NotLessEqual': '\u2270',
        'NotLessGreater': '\u2278',
        'NotLessLess': '\u226A\u0338',
        'NotLessSlantEqual': '\u2A7D\u0338',
        'NotLessTilde': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2\u0338',
        'NotNestedLessLess': '\u2AA1\u0338',
        'notni': '\u220C',
        'notniva': '\u220C',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'NotPrecedes': '\u2280',
        'NotPrecedesEqual': '\u2AAF\u0338',
        'NotPrecedesSlantEqual': '\u22E0',
        'NotReverseElement': '\u220C',
        'NotRightTriangle': '\u22EB',
        'NotRightTriangleBar': '\u29D0\u0338',
        'NotRightTriangleEqual': '\u22ED',
        'NotSquareSubset': '\u228F\u0338',
        'NotSquareSubsetEqual': '\u22E2',
        'NotSquareSuperset': '\u2290\u0338',
        'NotSquareSupersetEqual': '\u22E3',
        'NotSubset': '\u2282\u20D2',
        'NotSubsetEqual': '\u2288',
        'NotSucceeds': '\u2281',
        'NotSucceedsEqual': '\u2AB0\u0338',
        'NotSucceedsSlantEqual': '\u22E1',
        'NotSucceedsTilde': '\u227F\u0338',
        'NotSuperset': '\u2283\u20D2',
        'NotSupersetEqual': '\u2289',
        'NotTilde': '\u2241',
        'NotTildeEqual': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'NotTildeTilde': '\u2249',
        'NotVerticalBar': '\u2224',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nparsl': '\u2AFD\u20E5',
        'npart': '\u2202\u0338',
        'npolint': '\u2A14',
        'npr': '\u2280',
        'nprcue': '\u22E0',
        'npre': '\u2AAF\u0338',
        'nprec': '\u2280',
        'npreceq': '\u2AAF\u0338',
        'nrarr': '\u219B',
        'nrArr': '\u21CF',
        'nrarrc': '\u2933\u0338',
        'nrarrw': '\u219D\u0338',
        'nrightarrow': '\u219B',
        'nRightarrow': '\u21CF',
        'nrtri': '\u22EB',
        'nrtrie': '\u22ED',
        'nsc': '\u2281',
        'nsccue': '\u22E1',
        'nsce': '\u2AB0\u0338',
        'nscr': '\uD835\uDCC3',
        'Nscr': '\uD835\uDCA9',
        'nshortmid': '\u2224',
        'nshortparallel': '\u2226',
        'nsim': '\u2241',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'nsmid': '\u2224',
        'nspar': '\u2226',
        'nsqsube': '\u22E2',
        'nsqsupe': '\u22E3',
        'nsub': '\u2284',
        'nsube': '\u2288',
        'nsubE': '\u2AC5\u0338',
        'nsubset': '\u2282\u20D2',
        'nsubseteq': '\u2288',
        'nsubseteqq': '\u2AC5\u0338',
        'nsucc': '\u2281',
        'nsucceq': '\u2AB0\u0338',
        'nsup': '\u2285',
        'nsupe': '\u2289',
        'nsupE': '\u2AC6\u0338',
        'nsupset': '\u2283\u20D2',
        'nsupseteq': '\u2289',
        'nsupseteqq': '\u2AC6\u0338',
        'ntgl': '\u2279',
        'ntilde': '\xF1',
        'Ntilde': '\xD1',
        'ntlg': '\u2278',
        'ntriangleleft': '\u22EA',
        'ntrianglelefteq': '\u22EC',
        'ntriangleright': '\u22EB',
        'ntrianglerighteq': '\u22ED',
        'nu': '\u03BD',
        'Nu': '\u039D',
        'num': '#',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvap': '\u224D\u20D2',
        'nvdash': '\u22AC',
        'nvDash': '\u22AD',
        'nVdash': '\u22AE',
        'nVDash': '\u22AF',
        'nvge': '\u2265\u20D2',
        'nvgt': '>\u20D2',
        'nvHarr': '\u2904',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264\u20D2',
        'nvlt': '<\u20D2',
        'nvltrie': '\u22B4\u20D2',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5\u20D2',
        'nvsim': '\u223C\u20D2',
        'nwarhk': '\u2923',
        'nwarr': '\u2196',
        'nwArr': '\u21D6',
        'nwarrow': '\u2196',
        'nwnear': '\u2927',
        'oacute': '\xF3',
        'Oacute': '\xD3',
        'oast': '\u229B',
        'ocir': '\u229A',
        'ocirc': '\xF4',
        'Ocirc': '\xD4',
        'ocy': '\u043E',
        'Ocy': '\u041E',
        'odash': '\u229D',
        'odblac': '\u0151',
        'Odblac': '\u0150',
        'odiv': '\u2A38',
        'odot': '\u2299',
        'odsold': '\u29BC',
        'oelig': '\u0153',
        'OElig': '\u0152',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'Ofr': '\uD835\uDD12',
        'ogon': '\u02DB',
        'ograve': '\xF2',
        'Ograve': '\xD2',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'ohm': '\u03A9',
        'oint': '\u222E',
        'olarr': '\u21BA',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'oline': '\u203E',
        'olt': '\u29C0',
        'omacr': '\u014D',
        'Omacr': '\u014C',
        'omega': '\u03C9',
        'Omega': '\u03A9',
        'omicron': '\u03BF',
        'Omicron': '\u039F',
        'omid': '\u29B6',
        'ominus': '\u2296',
        'oopf': '\uD835\uDD60',
        'Oopf': '\uD835\uDD46',
        'opar': '\u29B7',
        'OpenCurlyDoubleQuote': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'operp': '\u29B9',
        'oplus': '\u2295',
        'or': '\u2228',
        'Or': '\u2A54',
        'orarr': '\u21BB',
        'ord': '\u2A5D',
        'order': '\u2134',
        'orderof': '\u2134',
        'ordf': '\xAA',
        'ordm': '\xBA',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oS': '\u24C8',
        'oscr': '\u2134',
        'Oscr': '\uD835\uDCAA',
        'oslash': '\xF8',
        'Oslash': '\xD8',
        'osol': '\u2298',
        'otilde': '\xF5',
        'Otilde': '\xD5',
        'otimes': '\u2297',
        'Otimes': '\u2A37',
        'otimesas': '\u2A36',
        'ouml': '\xF6',
        'Ouml': '\xD6',
        'ovbar': '\u233D',
        'OverBar': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'OverParenthesis': '\u23DC',
        'par': '\u2225',
        'para': '\xB6',
        'parallel': '\u2225',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'part': '\u2202',
        'PartialD': '\u2202',
        'pcy': '\u043F',
        'Pcy': '\u041F',
        'percnt': '%',
        'period': '.',
        'permil': '\u2030',
        'perp': '\u22A5',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'Pfr': '\uD835\uDD13',
        'phi': '\u03C6',
        'Phi': '\u03A6',
        'phiv': '\u03D5',
        'phmmat': '\u2133',
        'phone': '\u260E',
        'pi': '\u03C0',
        'Pi': '\u03A0',
        'pitchfork': '\u22D4',
        'piv': '\u03D6',
        'planck': '\u210F',
        'planckh': '\u210E',
        'plankv': '\u210F',
        'plus': '+',
        'plusacir': '\u2A23',
        'plusb': '\u229E',
        'pluscir': '\u2A22',
        'plusdo': '\u2214',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'PlusMinus': '\xB1',
        'plusmn': '\xB1',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pm': '\xB1',
        'Poincareplane': '\u210C',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'Popf': '\u2119',
        'pound': '\xA3',
        'pr': '\u227A',
        'Pr': '\u2ABB',
        'prap': '\u2AB7',
        'prcue': '\u227C',
        'pre': '\u2AAF',
        'prE': '\u2AB3',
        'prec': '\u227A',
        'precapprox': '\u2AB7',
        'preccurlyeq': '\u227C',
        'Precedes': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'PrecedesTilde': '\u227E',
        'preceq': '\u2AAF',
        'precnapprox': '\u2AB9',
        'precneqq': '\u2AB5',
        'precnsim': '\u22E8',
        'precsim': '\u227E',
        'prime': '\u2032',
        'Prime': '\u2033',
        'primes': '\u2119',
        'prnap': '\u2AB9',
        'prnE': '\u2AB5',
        'prnsim': '\u22E8',
        'prod': '\u220F',
        'Product': '\u220F',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prop': '\u221D',
        'Proportion': '\u2237',
        'Proportional': '\u221D',
        'propto': '\u221D',
        'prsim': '\u227E',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'Pscr': '\uD835\uDCAB',
        'psi': '\u03C8',
        'Psi': '\u03A8',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'Qfr': '\uD835\uDD14',
        'qint': '\u2A0C',
        'qopf': '\uD835\uDD62',
        'Qopf': '\u211A',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'Qscr': '\uD835\uDCAC',
        'quaternions': '\u210D',
        'quatint': '\u2A16',
        'quest': '?',
        'questeq': '\u225F',
        'quot': '"',
        'QUOT': '"',
        'rAarr': '\u21DB',
        'race': '\u223D\u0331',
        'racute': '\u0155',
        'Racute': '\u0154',
        'radic': '\u221A',
        'raemptyv': '\u29B3',
        'rang': '\u27E9',
        'Rang': '\u27EB',
        'rangd': '\u2992',
        'range': '\u29A5',
        'rangle': '\u27E9',
        'raquo': '\xBB',
        'rarr': '\u2192',
        'rArr': '\u21D2',
        'Rarr': '\u21A0',
        'rarrap': '\u2975',
        'rarrb': '\u21E5',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrhk': '\u21AA',
        'rarrlp': '\u21AC',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'Rarrtl': '\u2916',
        'rarrw': '\u219D',
        'ratail': '\u291A',
        'rAtail': '\u291C',
        'ratio': '\u2236',
        'rationals': '\u211A',
        'rbarr': '\u290D',
        'rBarr': '\u290F',
        'RBarr': '\u2910',
        'rbbrk': '\u2773',
        'rbrace': '}',
        'rbrack': ']',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': '\u0159',
        'Rcaron': '\u0158',
        'rcedil': '\u0157',
        'Rcedil': '\u0156',
        'rceil': '\u2309',
        'rcub': '}',
        'rcy': '\u0440',
        'Rcy': '\u0420',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'rdsh': '\u21B3',
        'Re': '\u211C',
        'real': '\u211C',
        'realine': '\u211B',
        'realpart': '\u211C',
        'reals': '\u211D',
        'rect': '\u25AD',
        'reg': '\xAE',
        'REG': '\xAE',
        'ReverseElement': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'rfisht': '\u297D',
        'rfloor': '\u230B',
        'rfr': '\uD835\uDD2F',
        'Rfr': '\u211C',
        'rHar': '\u2964',
        'rhard': '\u21C1',
        'rharu': '\u21C0',
        'rharul': '\u296C',
        'rho': '\u03C1',
        'Rho': '\u03A1',
        'rhov': '\u03F1',
        'RightAngleBracket': '\u27E9',
        'rightarrow': '\u2192',
        'Rightarrow': '\u21D2',
        'RightArrow': '\u2192',
        'RightArrowBar': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightarrowtail': '\u21A3',
        'RightCeiling': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rightharpoondown': '\u21C1',
        'rightharpoonup': '\u21C0',
        'rightleftarrows': '\u21C4',
        'rightleftharpoons': '\u21CC',
        'rightrightarrows': '\u21C9',
        'rightsquigarrow': '\u219D',
        'RightTee': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'RightTeeVector': '\u295B',
        'rightthreetimes': '\u22CC',
        'RightTriangle': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'RightVectorBar': '\u2953',
        'ring': '\u02DA',
        'risingdotseq': '\u2253',
        'rlarr': '\u21C4',
        'rlhar': '\u21CC',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'robrk': '\u27E7',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'Ropf': '\u211D',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'RoundImplies': '\u2970',
        'rpar': ')',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rrarr': '\u21C9',
        'Rrightarrow': '\u21DB',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'Rscr': '\u211B',
        'rsh': '\u21B1',
        'Rsh': '\u21B1',
        'rsqb': ']',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'rthree': '\u22CC',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'rtrie': '\u22B5',
        'rtrif': '\u25B8',
        'rtriltri': '\u29CE',
        'RuleDelayed': '\u29F4',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': '\u015B',
        'Sacute': '\u015A',
        'sbquo': '\u201A',
        'sc': '\u227B',
        'Sc': '\u2ABC',
        'scap': '\u2AB8',
        'scaron': '\u0161',
        'Scaron': '\u0160',
        'sccue': '\u227D',
        'sce': '\u2AB0',
        'scE': '\u2AB4',
        'scedil': '\u015F',
        'Scedil': '\u015E',
        'scirc': '\u015D',
        'Scirc': '\u015C',
        'scnap': '\u2ABA',
        'scnE': '\u2AB6',
        'scnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scsim': '\u227F',
        'scy': '\u0441',
        'Scy': '\u0421',
        'sdot': '\u22C5',
        'sdotb': '\u22A1',
        'sdote': '\u2A66',
        'searhk': '\u2925',
        'searr': '\u2198',
        'seArr': '\u21D8',
        'searrow': '\u2198',
        'sect': '\xA7',
        'semi': ';',
        'seswar': '\u2929',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'Sfr': '\uD835\uDD16',
        'sfrown': '\u2322',
        'sharp': '\u266F',
        'shchcy': '\u0449',
        'SHCHcy': '\u0429',
        'shcy': '\u0448',
        'SHcy': '\u0428',
        'ShortDownArrow': '\u2193',
        'ShortLeftArrow': '\u2190',
        'shortmid': '\u2223',
        'shortparallel': '\u2225',
        'ShortRightArrow': '\u2192',
        'ShortUpArrow': '\u2191',
        'shy': '\xAD',
        'sigma': '\u03C3',
        'Sigma': '\u03A3',
        'sigmaf': '\u03C2',
        'sigmav': '\u03C2',
        'sim': '\u223C',
        'simdot': '\u2A6A',
        'sime': '\u2243',
        'simeq': '\u2243',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'slarr': '\u2190',
        'SmallCircle': '\u2218',
        'smallsetminus': '\u2216',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smid': '\u2223',
        'smile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC\uFE00',
        'softcy': '\u044C',
        'SOFTcy': '\u042C',
        'sol': '/',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'Sopf': '\uD835\uDD4A',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'spar': '\u2225',
        'sqcap': '\u2293',
        'sqcaps': '\u2293\uFE00',
        'sqcup': '\u2294',
        'sqcups': '\u2294\uFE00',
        'Sqrt': '\u221A',
        'sqsub': '\u228F',
        'sqsube': '\u2291',
        'sqsubset': '\u228F',
        'sqsubseteq': '\u2291',
        'sqsup': '\u2290',
        'sqsupe': '\u2292',
        'sqsupset': '\u2290',
        'sqsupseteq': '\u2292',
        'squ': '\u25A1',
        'square': '\u25A1',
        'Square': '\u25A1',
        'SquareIntersection': '\u2293',
        'SquareSubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'SquareSuperset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'SquareUnion': '\u2294',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'srarr': '\u2192',
        'sscr': '\uD835\uDCC8',
        'Sscr': '\uD835\uDCAE',
        'ssetmn': '\u2216',
        'ssmile': '\u2323',
        'sstarf': '\u22C6',
        'star': '\u2606',
        'Star': '\u22C6',
        'starf': '\u2605',
        'straightepsilon': '\u03F5',
        'straightphi': '\u03D5',
        'strns': '\xAF',
        'sub': '\u2282',
        'Sub': '\u22D0',
        'subdot': '\u2ABD',
        'sube': '\u2286',
        'subE': '\u2AC5',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subne': '\u228A',
        'subnE': '\u2ACB',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subset': '\u2282',
        'Subset': '\u22D0',
        'subseteq': '\u2286',
        'subseteqq': '\u2AC5',
        'SubsetEqual': '\u2286',
        'subsetneq': '\u228A',
        'subsetneqq': '\u2ACB',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'succ': '\u227B',
        'succapprox': '\u2AB8',
        'succcurlyeq': '\u227D',
        'Succeeds': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'SucceedsTilde': '\u227F',
        'succeq': '\u2AB0',
        'succnapprox': '\u2ABA',
        'succneqq': '\u2AB6',
        'succnsim': '\u22E9',
        'succsim': '\u227F',
        'SuchThat': '\u220B',
        'sum': '\u2211',
        'Sum': '\u2211',
        'sung': '\u266A',
        'sup': '\u2283',
        'Sup': '\u22D1',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supe': '\u2287',
        'supE': '\u2AC6',
        'supedot': '\u2AC4',
        'Superset': '\u2283',
        'SupersetEqual': '\u2287',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supne': '\u228B',
        'supnE': '\u2ACC',
        'supplus': '\u2AC0',
        'supset': '\u2283',
        'Supset': '\u22D1',
        'supseteq': '\u2287',
        'supseteqq': '\u2AC6',
        'supsetneq': '\u228B',
        'supsetneqq': '\u2ACC',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swarhk': '\u2926',
        'swarr': '\u2199',
        'swArr': '\u21D9',
        'swarrow': '\u2199',
        'swnwar': '\u292A',
        'szlig': '\xDF',
        'Tab': '\t',
        'target': '\u2316',
        'tau': '\u03C4',
        'Tau': '\u03A4',
        'tbrk': '\u23B4',
        'tcaron': '\u0165',
        'Tcaron': '\u0164',
        'tcedil': '\u0163',
        'Tcedil': '\u0162',
        'tcy': '\u0442',
        'Tcy': '\u0422',
        'tdot': '\u20DB',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'Tfr': '\uD835\uDD17',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Therefore': '\u2234',
        'theta': '\u03B8',
        'Theta': '\u0398',
        'thetasym': '\u03D1',
        'thetav': '\u03D1',
        'thickapprox': '\u2248',
        'thicksim': '\u223C',
        'ThickSpace': '\u205F\u200A',
        'thinsp': '\u2009',
        'ThinSpace': '\u2009',
        'thkap': '\u2248',
        'thksim': '\u223C',
        'thorn': '\xFE',
        'THORN': '\xDE',
        'tilde': '\u02DC',
        'Tilde': '\u223C',
        'TildeEqual': '\u2243',
        'TildeFullEqual': '\u2245',
        'TildeTilde': '\u2248',
        'times': '\xD7',
        'timesb': '\u22A0',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'tint': '\u222D',
        'toea': '\u2928',
        'top': '\u22A4',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'Topf': '\uD835\uDD4B',
        'topfork': '\u2ADA',
        'tosa': '\u2929',
        'tprime': '\u2034',
        'trade': '\u2122',
        'TRADE': '\u2122',
        'triangle': '\u25B5',
        'triangledown': '\u25BF',
        'triangleleft': '\u25C3',
        'trianglelefteq': '\u22B4',
        'triangleq': '\u225C',
        'triangleright': '\u25B9',
        'trianglerighteq': '\u22B5',
        'tridot': '\u25EC',
        'trie': '\u225C',
        'triminus': '\u2A3A',
        'TripleDot': '\u20DB',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'Tscr': '\uD835\uDCAF',
        'tscy': '\u0446',
        'TScy': '\u0426',
        'tshcy': '\u045B',
        'TSHcy': '\u040B',
        'tstrok': '\u0167',
        'Tstrok': '\u0166',
        'twixt': '\u226C',
        'twoheadleftarrow': '\u219E',
        'twoheadrightarrow': '\u21A0',
        'uacute': '\xFA',
        'Uacute': '\xDA',
        'uarr': '\u2191',
        'uArr': '\u21D1',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'ubrcy': '\u045E',
        'Ubrcy': '\u040E',
        'ubreve': '\u016D',
        'Ubreve': '\u016C',
        'ucirc': '\xFB',
        'Ucirc': '\xDB',
        'ucy': '\u0443',
        'Ucy': '\u0423',
        'udarr': '\u21C5',
        'udblac': '\u0171',
        'Udblac': '\u0170',
        'udhar': '\u296E',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'Ufr': '\uD835\uDD18',
        'ugrave': '\xF9',
        'Ugrave': '\xD9',
        'uHar': '\u2963',
        'uharl': '\u21BF',
        'uharr': '\u21BE',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': '\u016B',
        'Umacr': '\u016A',
        'uml': '\xA8',
        'UnderBar': '_',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'UnionPlus': '\u228E',
        'uogon': '\u0173',
        'Uogon': '\u0172',
        'uopf': '\uD835\uDD66',
        'Uopf': '\uD835\uDD4C',
        'uparrow': '\u2191',
        'Uparrow': '\u21D1',
        'UpArrow': '\u2191',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'updownarrow': '\u2195',
        'Updownarrow': '\u21D5',
        'UpDownArrow': '\u2195',
        'UpEquilibrium': '\u296E',
        'upharpoonleft': '\u21BF',
        'upharpoonright': '\u21BE',
        'uplus': '\u228E',
        'UpperLeftArrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'upsi': '\u03C5',
        'Upsi': '\u03D2',
        'upsih': '\u03D2',
        'upsilon': '\u03C5',
        'Upsilon': '\u03A5',
        'UpTee': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'upuparrows': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': '\u016F',
        'Uring': '\u016E',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'Uscr': '\uD835\uDCB0',
        'utdot': '\u22F0',
        'utilde': '\u0169',
        'Utilde': '\u0168',
        'utri': '\u25B5',
        'utrif': '\u25B4',
        'uuarr': '\u21C8',
        'uuml': '\xFC',
        'Uuml': '\xDC',
        'uwangle': '\u29A7',
        'vangrt': '\u299C',
        'varepsilon': '\u03F5',
        'varkappa': '\u03F0',
        'varnothing': '\u2205',
        'varphi': '\u03D5',
        'varpi': '\u03D6',
        'varpropto': '\u221D',
        'varr': '\u2195',
        'vArr': '\u21D5',
        'varrho': '\u03F1',
        'varsigma': '\u03C2',
        'varsubsetneq': '\u228A\uFE00',
        'varsubsetneqq': '\u2ACB\uFE00',
        'varsupsetneq': '\u228B\uFE00',
        'varsupsetneqq': '\u2ACC\uFE00',
        'vartheta': '\u03D1',
        'vartriangleleft': '\u22B2',
        'vartriangleright': '\u22B3',
        'vBar': '\u2AE8',
        'Vbar': '\u2AEB',
        'vBarv': '\u2AE9',
        'vcy': '\u0432',
        'Vcy': '\u0412',
        'vdash': '\u22A2',
        'vDash': '\u22A8',
        'Vdash': '\u22A9',
        'VDash': '\u22AB',
        'Vdashl': '\u2AE6',
        'vee': '\u2228',
        'Vee': '\u22C1',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'verbar': '|',
        'Verbar': '\u2016',
        'vert': '|',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'VerticalLine': '|',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'VeryThinSpace': '\u200A',
        'vfr': '\uD835\uDD33',
        'Vfr': '\uD835\uDD19',
        'vltri': '\u22B2',
        'vnsub': '\u2282\u20D2',
        'vnsup': '\u2283\u20D2',
        'vopf': '\uD835\uDD67',
        'Vopf': '\uD835\uDD4D',
        'vprop': '\u221D',
        'vrtri': '\u22B3',
        'vscr': '\uD835\uDCCB',
        'Vscr': '\uD835\uDCB1',
        'vsubne': '\u228A\uFE00',
        'vsubnE': '\u2ACB\uFE00',
        'vsupne': '\u228B\uFE00',
        'vsupnE': '\u2ACC\uFE00',
        'Vvdash': '\u22AA',
        'vzigzag': '\u299A',
        'wcirc': '\u0175',
        'Wcirc': '\u0174',
        'wedbar': '\u2A5F',
        'wedge': '\u2227',
        'Wedge': '\u22C0',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wfr': '\uD835\uDD34',
        'Wfr': '\uD835\uDD1A',
        'wopf': '\uD835\uDD68',
        'Wopf': '\uD835\uDD4E',
        'wp': '\u2118',
        'wr': '\u2240',
        'wreath': '\u2240',
        'wscr': '\uD835\uDCCC',
        'Wscr': '\uD835\uDCB2',
        'xcap': '\u22C2',
        'xcirc': '\u25EF',
        'xcup': '\u22C3',
        'xdtri': '\u25BD',
        'xfr': '\uD835\uDD35',
        'Xfr': '\uD835\uDD1B',
        'xharr': '\u27F7',
        'xhArr': '\u27FA',
        'xi': '\u03BE',
        'Xi': '\u039E',
        'xlarr': '\u27F5',
        'xlArr': '\u27F8',
        'xmap': '\u27FC',
        'xnis': '\u22FB',
        'xodot': '\u2A00',
        'xopf': '\uD835\uDD69',
        'Xopf': '\uD835\uDD4F',
        'xoplus': '\u2A01',
        'xotime': '\u2A02',
        'xrarr': '\u27F6',
        'xrArr': '\u27F9',
        'xscr': '\uD835\uDCCD',
        'Xscr': '\uD835\uDCB3',
        'xsqcup': '\u2A06',
        'xuplus': '\u2A04',
        'xutri': '\u25B3',
        'xvee': '\u22C1',
        'xwedge': '\u22C0',
        'yacute': '\xFD',
        'Yacute': '\xDD',
        'yacy': '\u044F',
        'YAcy': '\u042F',
        'ycirc': '\u0177',
        'Ycirc': '\u0176',
        'ycy': '\u044B',
        'Ycy': '\u042B',
        'yen': '\xA5',
        'yfr': '\uD835\uDD36',
        'Yfr': '\uD835\uDD1C',
        'yicy': '\u0457',
        'YIcy': '\u0407',
        'yopf': '\uD835\uDD6A',
        'Yopf': '\uD835\uDD50',
        'yscr': '\uD835\uDCCE',
        'Yscr': '\uD835\uDCB4',
        'yucy': '\u044E',
        'YUcy': '\u042E',
        'yuml': '\xFF',
        'Yuml': '\u0178',
        'zacute': '\u017A',
        'Zacute': '\u0179',
        'zcaron': '\u017E',
        'Zcaron': '\u017D',
        'zcy': '\u0437',
        'Zcy': '\u0417',
        'zdot': '\u017C',
        'Zdot': '\u017B',
        'zeetrf': '\u2128',
        'ZeroWidthSpace': '\u200B',
        'zeta': '\u03B6',
        'Zeta': '\u0396',
        'zfr': '\uD835\uDD37',
        'Zfr': '\u2128',
        'zhcy': '\u0436',
        'ZHcy': '\u0416',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'Zopf': '\u2124',
        'zscr': '\uD835\uDCCF',
        'Zscr': '\uD835\uDCB5',
        'zwj': '\u200D',
        'zwnj': '\u200C'
      };
      var decodeMapLegacy = {
        'aacute': '\xE1',
        'Aacute': '\xC1',
        'acirc': '\xE2',
        'Acirc': '\xC2',
        'acute': '\xB4',
        'aelig': '\xE6',
        'AElig': '\xC6',
        'agrave': '\xE0',
        'Agrave': '\xC0',
        'amp': '&',
        'AMP': '&',
        'aring': '\xE5',
        'Aring': '\xC5',
        'atilde': '\xE3',
        'Atilde': '\xC3',
        'auml': '\xE4',
        'Auml': '\xC4',
        'brvbar': '\xA6',
        'ccedil': '\xE7',
        'Ccedil': '\xC7',
        'cedil': '\xB8',
        'cent': '\xA2',
        'copy': '\xA9',
        'COPY': '\xA9',
        'curren': '\xA4',
        'deg': '\xB0',
        'divide': '\xF7',
        'eacute': '\xE9',
        'Eacute': '\xC9',
        'ecirc': '\xEA',
        'Ecirc': '\xCA',
        'egrave': '\xE8',
        'Egrave': '\xC8',
        'eth': '\xF0',
        'ETH': '\xD0',
        'euml': '\xEB',
        'Euml': '\xCB',
        'frac12': '\xBD',
        'frac14': '\xBC',
        'frac34': '\xBE',
        'gt': '>',
        'GT': '>',
        'iacute': '\xED',
        'Iacute': '\xCD',
        'icirc': '\xEE',
        'Icirc': '\xCE',
        'iexcl': '\xA1',
        'igrave': '\xEC',
        'Igrave': '\xCC',
        'iquest': '\xBF',
        'iuml': '\xEF',
        'Iuml': '\xCF',
        'laquo': '\xAB',
        'lt': '<',
        'LT': '<',
        'macr': '\xAF',
        'micro': '\xB5',
        'middot': '\xB7',
        'nbsp': '\xA0',
        'not': '\xAC',
        'ntilde': '\xF1',
        'Ntilde': '\xD1',
        'oacute': '\xF3',
        'Oacute': '\xD3',
        'ocirc': '\xF4',
        'Ocirc': '\xD4',
        'ograve': '\xF2',
        'Ograve': '\xD2',
        'ordf': '\xAA',
        'ordm': '\xBA',
        'oslash': '\xF8',
        'Oslash': '\xD8',
        'otilde': '\xF5',
        'Otilde': '\xD5',
        'ouml': '\xF6',
        'Ouml': '\xD6',
        'para': '\xB6',
        'plusmn': '\xB1',
        'pound': '\xA3',
        'quot': '"',
        'QUOT': '"',
        'raquo': '\xBB',
        'reg': '\xAE',
        'REG': '\xAE',
        'sect': '\xA7',
        'shy': '\xAD',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'szlig': '\xDF',
        'thorn': '\xFE',
        'THORN': '\xDE',
        'times': '\xD7',
        'uacute': '\xFA',
        'Uacute': '\xDA',
        'ucirc': '\xFB',
        'Ucirc': '\xDB',
        'ugrave': '\xF9',
        'Ugrave': '\xD9',
        'uml': '\xA8',
        'uuml': '\xFC',
        'Uuml': '\xDC',
        'yacute': '\xFD',
        'Yacute': '\xDD',
        'yen': '\xA5',
        'yuml': '\xFF'
      };
      var decodeMapNumeric = {
        '0': '\uFFFD',
        '128': '\u20AC',
        '130': '\u201A',
        '131': '\u0192',
        '132': '\u201E',
        '133': '\u2026',
        '134': '\u2020',
        '135': '\u2021',
        '136': '\u02C6',
        '137': '\u2030',
        '138': '\u0160',
        '139': '\u2039',
        '140': '\u0152',
        '142': '\u017D',
        '145': '\u2018',
        '146': '\u2019',
        '147': '\u201C',
        '148': '\u201D',
        '149': '\u2022',
        '150': '\u2013',
        '151': '\u2014',
        '152': '\u02DC',
        '153': '\u2122',
        '154': '\u0161',
        '155': '\u203A',
        '156': '\u0153',
        '158': '\u017E',
        '159': '\u0178'
      };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      /*--------------------------------------------------------------------------*/

      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;

      var has = function (object, propertyName) {
        return hasOwnProperty.call(object, propertyName);
      };

      var contains = function (array, value) {
        var index = -1;
        var length = array.length;

        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }

        return false;
      };

      var merge = function (options, defaults) {
        if (!options) {
          return defaults;
        }

        var result = {};
        var key;

        for (key in defaults) {
          // A `hasOwnProperty` check is not needed here, since only recognized
          // option names are used anyway. Any others are ignored.
          result[key] = has(options, key) ? options[key] : defaults[key];
        }

        return result;
      }; // Modified version of `ucs2encode`; see https://mths.be/punycode.


      var codePointToSymbol = function (codePoint, strict) {
        var output = '';

        if (codePoint >= 0xD800 && codePoint <= 0xDFFF || codePoint > 0x10FFFF) {
          // See issue #4:
          // Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
          // greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
          // REPLACEMENT CHARACTER.
          if (strict) {
            parseError('character reference outside the permissible Unicode range');
          }

          return '\uFFFD';
        }

        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError('disallowed character reference');
          }

          return decodeMapNumeric[codePoint];
        }

        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError('disallowed character reference');
        }

        if (codePoint > 0xFFFF) {
          codePoint -= 0x10000;
          output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        output += stringFromCharCode(codePoint);
        return output;
      };

      var hexEscape = function (codePoint) {
        return '&#x' + codePoint.toString(16).toUpperCase() + ';';
      };

      var decEscape = function (codePoint) {
        return '&#' + codePoint + ';';
      };

      var parseError = function (message) {
        throw Error('Parse error: ' + message);
      };
      /*--------------------------------------------------------------------------*/


      var encode = function (string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;

        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError('forbidden code point');
        }

        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;

        var escapeBmpSymbol = function (symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };

        if (encodeEverything) {
          // Encode ASCII symbols.
          string = string.replace(regexAsciiWhitelist, function (symbol) {
            // Use named references if requested & possible.
            if (useNamedReferences && has(encodeMap, symbol)) {
              return '&' + encodeMap[symbol] + ';';
            }

            return escapeBmpSymbol(symbol);
          }); // Shorten a few escapes that represent two symbols, of which at least one
          // is within the ASCII range.

          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
          } // Encode non-ASCII symbols.


          if (useNamedReferences) {
            // Encode non-ASCII symbols that can be replaced with a named reference.
            string = string.replace(regexEncodeNonAscii, function (string) {
              // Note: there is no need to check `has(encodeMap, string)` here.
              return '&' + encodeMap[string] + ';';
            });
          } // Note: any remaining non-ASCII symbols are handled outside of the `if`.

        } else if (useNamedReferences) {
          // Apply named character references.
          // Encode `<>"'&` using named character references.
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function (string) {
              return '&' + encodeMap[string] + ';'; // no need to check `has()` here
            });
          } // Shorten escapes that represent two symbols, of which at least one is
          // `<>"'&`.


          string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;'); // Encode non-ASCII symbols that can be replaced with a named reference.

          string = string.replace(regexEncodeNonAscii, function (string) {
            // Note: there is no need to check `has(encodeMap, string)` here.
            return '&' + encodeMap[string] + ';';
          });
        } else if (!allowUnsafeSymbols) {
          // Encode `<>"'&` using hexadecimal escapes, now that theyre not handled
          // using named character references.
          string = string.replace(regexEscape, escapeBmpSymbol);
        }

        return string // Encode astral symbols.
        .replace(regexAstralSymbols, function ($0) {
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
          return escapeCodePoint(codePoint);
        }) // Encode any remaining BMP symbols that are not printable ASCII symbols
        // using a hexadecimal escape.
        .replace(regexBmpWhitelist, escapeBmpSymbol);
      }; // Expose default options (so they can be overridden globally).


      encode.options = {
        'allowUnsafeSymbols': false,
        'encodeEverything': false,
        'strict': false,
        'useNamedReferences': false,
        'decimal': false
      };

      var decode = function (html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;

        if (strict && regexInvalidEntity.test(html)) {
          parseError('malformed character reference');
        }

        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;

          if ($1) {
            reference = $1; // Note: there is no need to check `has(decodeMap, reference)`.

            return decodeMap[reference];
          }

          if ($2) {
            // Decode named character references without trailing `;`, e.g. `&amp`.
            // This is only a parse error if it gets converted to `&`, or if it is
            // followed by `=` in an attribute context.
            reference = $2;
            next = $3;

            if (next && options.isAttributeValue) {
              if (strict && next == '=') {
                parseError('`&` did not start a character reference');
              }

              return $0;
            } else {
              if (strict) {
                parseError('named character reference was not terminated by a semicolon');
              } // Note: there is no need to check `has(decodeMapLegacy, reference)`.


              return decodeMapLegacy[reference] + (next || '');
            }
          }

          if ($4) {
            // Decode decimal escapes, e.g. `&#119558;`.
            decDigits = $4;
            semicolon = $5;

            if (strict && !semicolon) {
              parseError('character reference was not terminated by a semicolon');
            }

            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }

          if ($6) {
            // Decode hexadecimal escapes, e.g. `&#x1D306;`.
            hexDigits = $6;
            semicolon = $7;

            if (strict && !semicolon) {
              parseError('character reference was not terminated by a semicolon');
            }

            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          } // If were still here, `if ($7)` is implied; its an ambiguous
          // ampersand for sure. https://mths.be/notes/ambiguous-ampersands


          if (strict) {
            parseError('named character reference was not terminated by a semicolon');
          }

          return $0;
        });
      }; // Expose default options (so they can be overridden globally).


      decode.options = {
        'isAttributeValue': false,
        'strict': false
      };

      var escape = function (string) {
        return string.replace(regexEscape, function ($0) {
          // Note: there is no need to check `has(escapeMap, $0)` here.
          return escapeMap[$0];
        });
      };
      /*--------------------------------------------------------------------------*/


      var he = {
        'version': '1.2.0',
        'encode': encode,
        'decode': decode,
        'escape': escape,
        'unescape': decode
      }; // Some AMD build optimizers, like r.js, check for specific condition patterns
      // like the following:

      if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          // in Node.js, io.js, or RingoJS v0.8.0+
          freeModule.exports = he;
        } else {
          // in Narwhal or RingoJS v0.7.0-
          for (var key in he) {
            has(he, key) && (freeExports[key] = he[key]);
          }
        }
      } else {
        // in Rhino or a web browser
        root.he = he;
      }
    })(commonjsGlobal);
  });

  // rule: character-encode

  function processStr(str, offset, context, mode) {
    // traverse the value of this text node:
    for (var i = 0, len = str.length; i < len; i++) {
      if ((str[i].charCodeAt(0) > 127 || "<>\"&".includes(str[i])) && (str[i].charCodeAt(0) !== 160 || !Object.keys(context.processedRulesConfig).includes("bad-character-non-breaking-space") || !isAnEnabledValue(context.processedRulesConfig["bad-character-non-breaking-space"]))) {
        var encodedChr = he.encode(str[i], {
          useNamedReferences: mode === "named"
        });

        if (Object.keys(notEmailFriendly).includes(encodedChr.slice(1, encodedChr.length - 1))) {
          encodedChr = "&".concat(notEmailFriendly[encodedChr.slice(1, encodedChr.length - 1)], ";");
        }

        var charName = "";

        if (str[i].charCodeAt(0) === 160) {
          charName = " no-break space";
        } else if (str[i].charCodeAt(0) === 38) {
          charName = " ampersand";
        } else if (str[i].charCodeAt(0) === 60) {
          charName = " less than";
        } else if (str[i].charCodeAt(0) === 62) {
          charName = " greater than";
        } else if (str[i].charCodeAt(0) === 34) {
          charName = " double quotes";
        } else if (str[i].charCodeAt(0) === 163) {
          charName = " pound sign";
        }

        context.report({
          ruleId: "character-encode",
          message: "Unencoded".concat(charName, " character."),
          idxFrom: i + offset,
          idxTo: i + 1 + offset,
          fix: {
            ranges: [[i + offset, i + 1 + offset, encodedChr]]
          }
        });
      }
    }
  } // Catches characters outside ASCII and suggests encoding.
  // Applies only to "text" scope
  // This is rule to catch unencoded characters. If we relied on the tokenizer
  // output only, just the particular chunk of "text" type token, we would
  // lost the opportunity to catch whole class of errors; that would put more
  // strain and responsibility onto the tokenizer.
  //
  // For example, imagine the case of missing dash, a<!--b->c
  //
  // Tokenizer will "think" that "b->c" is text.
  //
  // Here, we come and process this token.
  //
  // If we didn't process from AST, we could not tell, is that legit unencoded
  // characters (piece of text) or is it broken closing comment tag. Without AST
  // we can't look what was before! Well, we can simply traverse backwards but
  // consider nested comments:
  //
  // a<!--<div><table><tr><td>z</td></tr></table></div>->c
  //
  // With its own errors inside that comment!
  //
  // We can't traverse left and from "->" and check, is the first encountered
  // opening bracket followed by exclamation mark and two dashes...
  //
  // Thus, we use AST instead of listening on "character" being emitted:
  //
  // function characterEncode(context, ...opts) {
  //   return {
  //     character: function({ type, chr, i }) {
  //     ...


  function characterEncode(context) {
    for (var _len = arguments.length, opts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      opts[_key - 1] = arguments[_key];
    }

    return {
      text: function text(token) {
        // settle the mode, is it "always" or a default, "never"
        var mode = "named"; // opts array comes already sliced, without 1st element, so opts value
        // is 0th (and onwards if more)

        if (Array.isArray(opts) && ["named", "numeric"].includes(opts[0])) {
          mode = opts[0];
        } // ACTION


        processStr(token.value, token.start, context, mode);
      }
    };
  }

  function characterUnspacedPunctuation(context) {
    for (var _len = arguments.length, originalOpts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      originalOpts[_key - 1] = arguments[_key];
    }

    var charCodeMapping = {
      "63": "questionMark",
      "33": "exclamationMark",
      "59": "semicolon",
      "187": "rightDoubleAngleQuotMark",
      "171": "leftDoubleAngleQuotMark"
    };
    return {
      text: function text(node) {
        var defaults = {
          questionMark: {
            whitespaceLeft: "never",
            whitespaceRight: "always"
          },
          exclamationMark: {
            whitespaceLeft: "never",
            whitespaceRight: "always"
          },
          semicolon: {
            whitespaceLeft: "never",
            whitespaceRight: "always"
          },
          rightDoubleAngleQuotMark: {
            whitespaceLeft: "never",
            whitespaceRight: "always"
          },
          leftDoubleAngleQuotMark: {
            whitespaceLeft: "never",
            whitespaceRight: "always"
          }
        };
        var opts = Object.assign({}, defaults); // default opts above are the default

        if (Array.isArray(originalOpts) && originalOpts.length && _typeof(originalOpts[0]) === "object" && originalOpts[0] !== null) {
          opts = Object.assign({}, defaults, originalOpts[0]);
        } // plan: iterate each character from this text chunk/node, query each
        // caught character's surroundings as per config


        for (var i = node.start; i < node.end; i++) {
          var charCode = context.str[i].charCodeAt(0);

          if (charCodeMapping[String(charCode)]) {
            var charName = charCodeMapping[String(charCode)]; // precautions first.
            // if it's an exclamation mark and two dashes follow, we bail right away

            if (charName === "exclamationMark" && context.str[right(context.str, i)] === "-" && context.str[right(context.str, right(context.str, i))] === "-") {
              return;
            }

            if (opts[charName].whitespaceLeft === "never" && i && !context.str[i - 1].trim().length) {
              context.report({
                ruleId: "character-unspaced-punctuation",
                idxFrom: left(context.str, i) + 1,
                idxTo: i,
                message: "Remove the whitespace.",
                fix: {
                  ranges: [[left(context.str, i) + 1, i]]
                }
              });
            }

            if (opts[charName].whitespaceRight === "never" && i < node.end - 1 && !context.str[i + 1].trim().length) {
              context.report({
                ruleId: "character-unspaced-punctuation",
                idxFrom: i + 1,
                idxTo: right(context.str, i),
                message: "Remove the whitespace.",
                fix: {
                  ranges: [[i + 1, right(context.str, i)]]
                }
              });
            }

            if (opts[charName].whitespaceLeft === "always" && i && context.str[i - 1].trim().length) {
              context.report({
                ruleId: "character-unspaced-punctuation",
                idxFrom: i,
                idxTo: i + 1,
                message: "Add a space.",
                fix: {
                  ranges: [[i, i, " "]]
                }
              });
            }

            if (opts[charName].whitespaceRight === "always" && i < node.end - 1 && context.str[i + 1].trim().length) {
              context.report({
                ruleId: "character-unspaced-punctuation",
                idxFrom: i,
                idxTo: i + 1,
                message: "Add a space.",
                fix: {
                  ranges: [[i + 1, i + 1, " "]]
                }
              });
            }
          }
        } // Add a space.

      }
    };
  }

  // -----------------------------------------------------------------------------
  // it tap the is-media-descriptor that we already use on tags
  // to validate media query selectors, for example (rogue letter "e"):
  // @media screeen {
  //   ...
  // }

  function mediaMalformed(context) {
    return {
      at: function at(node) {
        if (node.identifier === "media") {
          var errors = isMediaD(node.query, {
            offset: node.queryStartsAt
          });
          errors.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "media-malformed"
            }));
          });
        } // if (node.tagName === "bold") {
        //   console.log(`037 RAISE ERROR [${node.start}, ${node.end}]`);
        //   context.report({
        //     ruleId: "media-malformed",
        //     message: `Tag "bold" does not exist in HTML.`,
        //     idxFrom: node.start,
        //     idxTo: node.end, // second elem. from last range
        //     fix: {
        //       ranges: [[node.tagNameStartsAt, node.tagNameEndsAt, suggested]]
        //     }
        //   });
        // }

      }
    };
  }

  function validateCommentClosing(token) {
    var reference = {
      simple: "-->",
      only: "<![endif]-->",
      not: "<!--<![endif]-->"
    }; // if all is fine, end quick

    if (token.kind === "simple" && token.value === "-->" || token.kind === "only" && token.value === "<![endif]-->" || token.kind === "not" && token.value === "<!--<![endif]-->") {
      return [];
    }

    var errorArr = []; // assemble string without whitespace:

    var valueWithoutWhitespace = ""; // first, tackle any inner whitespace

    splitByWhitespace(token.value, function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          charFrom = _ref2[0],
          charTo = _ref2[1];

      valueWithoutWhitespace = "".concat(valueWithoutWhitespace).concat(token.value.slice(charFrom, charTo));
    }, function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          whitespaceFrom = _ref4[0],
          whitespaceTo = _ref4[1];

      errorArr.push({
        ruleId: "comment-only-closing-malformed",
        idxFrom: token.start,
        idxTo: token.end,
        message: "Remove whitespace.",
        fix: {
          ranges: [[whitespaceFrom + token.start, whitespaceTo + token.start]]
        }
      });
    }); // if all it took was to remove some whitespace to get a correct value,
    // that's the end - return the "errorArr" with only whitespace ranges:

    if (token.kind === "simple" && valueWithoutWhitespace === "-->" || token.kind === "only" && valueWithoutWhitespace === "<![endif]-->" || token.kind === "not" && valueWithoutWhitespace === "<!--<![endif]-->") {
      return errorArr;
    } // if processing continues, it means something more is wrong


    errorArr.push({
      idxFrom: token.start,
      idxTo: token.end,
      message: "Malformed closing comment tag.",
      fix: {
        ranges: [[token.start, token.end, reference[token.kind]]]
      }
    });
    return errorArr;
  }

  // rule: comment-closing-malformed

  function commentClosingMalformed(context) {
    return {
      comment: function comment(node) {
        if (node.closing) {
          // run the tag's value past the validator function
          var errorArr = validateCommentClosing(node) || []; // Out of all raised errors, only one can have "ranges.fix" -
          // all other fixes, if any present, will be removed.
          // This is to simplify the rule fix clashing.

          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              keepSeparateWhenFixing: true,
              ruleId: "comment-closing-malformed"
            }));
          });
        }
      }
    };
  }

  /**
   * string-find-malformed
   * Search for a malformed string. Think of Levenshtein distance but in search.
   * Version: 1.1.2
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-find-malformed
   */

  function isObj$1(something) {
    return something && typeof something === "object" && !Array.isArray(something);
  }

  function isStr$1(something) {
    return typeof something === "string";
  }

  function strFindMalformed(str, refStr, cb, originalOpts) {
    if (!isStr$1(str)) {
      throw new TypeError(`string-find-malformed: [THROW_ID_01] the first input argument, string where to look for, must be a string! Currently it's equal to: ${str} (type: ${typeof str})`);
    } else if (!str.length) {
      return;
    }

    if (!isStr$1(refStr)) {
      throw new TypeError(`string-find-malformed: [THROW_ID_02] the second input argument, string we should find, must be a string! Currently it's equal to: ${refStr} (type: ${typeof refStr})`);
    } else if (!refStr.length) {
      return;
    }

    if (typeof cb !== "function") {
      throw new TypeError(`string-find-malformed: [THROW_ID_03] the third input argument, a callback function, must be a function! Currently it's equal to: ${cb} (type: ${typeof cb})`);
    }

    if (originalOpts && !isObj$1(originalOpts)) {
      throw new TypeError(`string-find-malformed: [THROW_ID_04] the fourth input argument, an Optional Options Object, must be a plain object! Currently it's equal to: ${originalOpts} (type: ${typeof originalOpts})`);
    }

    const defaults = {
      stringOffset: 0,
      maxDistance: 1,
      ignoreWhitespace: true
    };
    const opts = Object.assign({}, defaults, originalOpts);

    if (typeof opts.stringOffset === "string" && /^\d*$/.test(opts.stringOffset)) {
      opts.stringOffset = Number(opts.stringOffset);
    } else if (!Number.isInteger(opts.stringOffset) || opts.stringOffset < 0) {
      throw new TypeError(`${opts.source} [THROW_ID_05] opts.stringOffset must be a natural number or zero! Currently it's: ${opts.fromIndex}`);
    }

    const len = str.length;
    const len2 = Math.min(refStr.length, opts.maxDistance + 1);
    let pendingMatchesArr = [];
    const patience = opts.maxDistance;
    let wasThisLetterMatched;

    for (let i = 0; i < len; i++) {
      if (opts.ignoreWhitespace && !str[i].trim().length) {
        continue;
      }

      for (let z = 0, len3 = pendingMatchesArr.length; z < len3; z++) {
        wasThisLetterMatched = false;

        if (Array.isArray(pendingMatchesArr[z].pendingToCheck) && pendingMatchesArr[z].pendingToCheck.length && str[i] === pendingMatchesArr[z].pendingToCheck[0]) {
          wasThisLetterMatched = true;
          pendingMatchesArr[z].pendingToCheck.shift();
        } else if (Array.isArray(pendingMatchesArr[z].pendingToCheck) && pendingMatchesArr[z].pendingToCheck.length && str[i] === pendingMatchesArr[z].pendingToCheck[1]) {
          wasThisLetterMatched = true;
          pendingMatchesArr[z].pendingToCheck.shift();
          pendingMatchesArr[z].pendingToCheck.shift();
          pendingMatchesArr[z].patienceLeft = pendingMatchesArr[z].patienceLeft - 1;
        } else {
          pendingMatchesArr[z].patienceLeft = pendingMatchesArr[z].patienceLeft - 1;

          if (str[right(str, i)] !== pendingMatchesArr[z].pendingToCheck[0]) {
            pendingMatchesArr[z].pendingToCheck.shift();

            if (str[i] === pendingMatchesArr[z].pendingToCheck[0]) {
              pendingMatchesArr[z].pendingToCheck.shift();
            }
          }
        }
      }

      pendingMatchesArr = pendingMatchesArr.filter(obj => obj.patienceLeft >= 0);
      const tempArr = pendingMatchesArr.filter(obj => obj.pendingToCheck.length === 0).map(obj => obj.startsAt);

      if (Array.isArray(tempArr) && tempArr.length) {
        const idxFrom = Math.min(...tempArr);
        const idxTo = i + (wasThisLetterMatched ? 1 : 0);

        if (str.slice(idxFrom, idxTo) !== refStr) {
          cb({
            idxFrom: idxFrom + opts.stringOffset,
            idxTo: idxTo + opts.stringOffset
          });
        }

        pendingMatchesArr = pendingMatchesArr.filter(obj => obj.pendingToCheck.length);
      }

      for (let y = 0; y < len2; y++) {
        if (str[i] === refStr[y]) {
          const whatToPush = {
            startsAt: i,
            patienceLeft: patience - y,
            pendingToCheck: Array.from(refStr.slice(y + 1))
          };
          pendingMatchesArr.push(whatToPush);
          break;
        }
      }
    }
  }

  /**
   * arrayiffy-if-string
   * Put non-empty strings into arrays, turn empty-ones into empty arrays. Bypass everything else.
   * Version: 3.11.28
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/arrayiffy-if-string
   */
  function arrayiffyString(something) {
    if (typeof something === "string") {
      if (something.length > 0) {
        return [something];
      }

      return [];
    }

    return something;
  }

  /**
   * string-match-left-right
   * Do substrings match what's on the left or right of a given index?
   * Version: 4.0.2
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-match-left-right
   */

  function isObj$2(something) {
    return something && typeof something === "object" && !Array.isArray(something);
  }

  function isStr$2(something) {
    return typeof something === "string";
  }

  function march(str, fromIndexInclusive, whatToMatchVal, opts, special, getNextIdx) {
    const whatToMatchValVal = typeof whatToMatchVal === "function" ? whatToMatchVal() : whatToMatchVal;

    if (fromIndexInclusive < 0 && special && whatToMatchValVal === "EOL") {
      return whatToMatchValVal;
    }

    if (fromIndexInclusive >= str.length && !special) {
      return false;
    }

    let charsToCheckCount = special ? 1 : whatToMatchVal.length;
    let lastWasMismatched = false;
    let atLeastSomethingWasMatched = false;
    let patience = opts.maxMismatches;
    let i = fromIndexInclusive;
    let somethingFound = false;
    let firstCharacterMatched = false;
    let lastCharacterMatched = false;

    while (str[i]) {
      const nextIdx = getNextIdx(i);

      if (opts.trimBeforeMatching && str[i].trim() === "") {
        if (!str[nextIdx] && special && whatToMatchVal === "EOL") {
          return true;
        }

        i = getNextIdx(i);
        continue;
      }

      if (!opts.i && opts.trimCharsBeforeMatching.includes(str[i]) || opts.i && opts.trimCharsBeforeMatching.map(val => val.toLowerCase()).includes(str[i].toLowerCase())) {
        if (special && whatToMatchVal === "EOL" && !str[nextIdx]) {
          return true;
        }

        i = getNextIdx(i);
        continue;
      }

      const charToCompareAgainst = nextIdx > i ? whatToMatchVal[whatToMatchVal.length - charsToCheckCount] : whatToMatchVal[charsToCheckCount - 1];

      if (!opts.i && str[i] === charToCompareAgainst || opts.i && str[i].toLowerCase() === charToCompareAgainst.toLowerCase()) {
        if (!somethingFound) {
          somethingFound = true;
        }

        if (!atLeastSomethingWasMatched) {
          atLeastSomethingWasMatched = true;
        }

        if (charsToCheckCount === whatToMatchVal.length) {
          firstCharacterMatched = true;
        } else if (charsToCheckCount === 1) {
          lastCharacterMatched = true;
        }

        charsToCheckCount -= 1;

        if (charsToCheckCount < 1) {
          return i;
        }
      } else {
        if (opts.maxMismatches && patience && i) {
          patience--;

          for (let y = 0; y <= patience; y++) {
            const nextCharToCompareAgainst = nextIdx > i ? whatToMatchVal[whatToMatchVal.length - charsToCheckCount + 1 + y] : whatToMatchVal[charsToCheckCount - 2 - y];
            const nextCharInSource = str[getNextIdx(i)];

            if (nextCharToCompareAgainst && (!opts.i && str[i] === nextCharToCompareAgainst || opts.i && str[i].toLowerCase() === nextCharToCompareAgainst.toLowerCase()) && (!opts.firstMustMatch || charsToCheckCount !== whatToMatchVal.length)) {
              charsToCheckCount -= 2;
              somethingFound = true;
              break;
            } else if (nextCharInSource && nextCharToCompareAgainst && (!opts.i && nextCharInSource === nextCharToCompareAgainst || opts.i && nextCharInSource.toLowerCase() === nextCharToCompareAgainst.toLowerCase()) && (!opts.firstMustMatch || charsToCheckCount !== whatToMatchVal.length)) {
              charsToCheckCount -= 1;
              somethingFound = true;
              break;
            } else if (nextCharToCompareAgainst === undefined && patience >= 0 && somethingFound && (!opts.firstMustMatch || firstCharacterMatched) && (!opts.lastMustMatch || lastCharacterMatched)) {
              return i;
            }
          }

          if (!somethingFound) {
            lastWasMismatched = i;
          }
        } else if (i === 0 && charsToCheckCount === 1 && !opts.lastMustMatch && atLeastSomethingWasMatched) {
          return 0;
        } else {
          return false;
        }
      }

      if (lastWasMismatched !== false && lastWasMismatched !== i) {
        lastWasMismatched = false;
      }

      if (charsToCheckCount < 1) {
        return i;
      }

      i = getNextIdx(i);
    }

    if (charsToCheckCount > 0) {
      if (special && whatToMatchValVal === "EOL") {
        return true;
      } else if (opts.maxMismatches >= charsToCheckCount && atLeastSomethingWasMatched) {
        return lastWasMismatched || 0;
      }

      return false;
    }
  }

  function main(mode, str, position, originalWhatToMatch, originalOpts) {
    const defaults = {
      i: false,
      trimBeforeMatching: false,
      trimCharsBeforeMatching: [],
      maxMismatches: 0,
      firstMustMatch: false,
      lastMustMatch: false
    };

    if (isObj$2(originalOpts) && Object.prototype.hasOwnProperty.call(originalOpts, "trimBeforeMatching") && typeof originalOpts.trimBeforeMatching !== "boolean") {
      throw new Error(`string-match-left-right/${mode}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(originalOpts.trimBeforeMatching) ? ` Did you mean to use opts.trimCharsBeforeMatching?` : ""}`);
    }

    const opts = Object.assign({}, defaults, originalOpts);
    opts.trimCharsBeforeMatching = arrayiffyString(opts.trimCharsBeforeMatching);
    opts.trimCharsBeforeMatching = opts.trimCharsBeforeMatching.map(el => isStr$2(el) ? el : String(el));

    if (!isStr$2(str)) {
      return false;
    } else if (!str.length) {
      return false;
    }

    if (!Number.isInteger(position) || position < 0) {
      throw new Error(`string-match-left-right/${mode}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof position}, equal to:\n${JSON.stringify(position, null, 4)}`);
    }

    let whatToMatch;
    let special;

    if (isStr$2(originalWhatToMatch)) {
      whatToMatch = [originalWhatToMatch];
    } else if (Array.isArray(originalWhatToMatch)) {
      whatToMatch = originalWhatToMatch;
    } else if (!originalWhatToMatch) {
      whatToMatch = originalWhatToMatch;
    } else if (typeof originalWhatToMatch === "function") {
      whatToMatch = [];
      whatToMatch.push(originalWhatToMatch);
    } else {
      throw new Error(`string-match-left-right/${mode}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof originalWhatToMatch}, equal to:\n${JSON.stringify(originalWhatToMatch, null, 4)}`);
    }

    if (originalOpts && !isObj$2(originalOpts)) {
      throw new Error(`string-match-left-right/${mode}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof originalOpts}", and equal to:\n${JSON.stringify(originalOpts, null, 4)}`);
    }

    let culpritsIndex;
    let culpritsVal;

    if (opts.trimCharsBeforeMatching.some((el, i) => {
      if (el.length > 1) {
        culpritsIndex = i;
        culpritsVal = el;
        return true;
      }

      return false;
    })) {
      throw new Error(`string-match-left-right/${mode}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${culpritsIndex} is longer than 1 character, ${culpritsVal.length} (equals to ${culpritsVal}). Please split it into separate characters and put into array as separate elements.`);
    }

    if (!whatToMatch || !Array.isArray(whatToMatch) || Array.isArray(whatToMatch) && !whatToMatch.length || Array.isArray(whatToMatch) && whatToMatch.length === 1 && isStr$2(whatToMatch[0]) && !whatToMatch[0].trim().length) {
      if (typeof opts.cb === "function") {
        let firstCharOutsideIndex;
        let startingPosition = position;

        if (mode === "matchLeftIncl" || mode === "matchRight") {
          startingPosition += 1;
        }

        if (mode[5] === "L") {
          for (let y = startingPosition; y--;) {
            const currentChar = str[y];

            if ((!opts.trimBeforeMatching || opts.trimBeforeMatching && currentChar !== undefined && currentChar.trim().length) && (!opts.trimCharsBeforeMatching.length || currentChar !== undefined && !opts.trimCharsBeforeMatching.includes(currentChar))) {
              firstCharOutsideIndex = y;
              break;
            }
          }
        } else if (mode.startsWith("matchRight")) {
          for (let y = startingPosition; y < str.length; y++) {
            const currentChar = str[y];

            if ((!opts.trimBeforeMatching || opts.trimBeforeMatching && currentChar.trim().length) && (!opts.trimCharsBeforeMatching.length || !opts.trimCharsBeforeMatching.includes(currentChar))) {
              firstCharOutsideIndex = y;
              break;
            }
          }
        }

        if (firstCharOutsideIndex === undefined) {
          return false;
        }

        const wholeCharacterOutside = str[firstCharOutsideIndex];
        const indexOfTheCharacterAfter = firstCharOutsideIndex + 1;
        let theRemainderOfTheString = "";

        if (indexOfTheCharacterAfter && indexOfTheCharacterAfter > 0) {
          theRemainderOfTheString = str.slice(0, indexOfTheCharacterAfter);
        }

        if (mode[5] === "L") {
          return opts.cb(wholeCharacterOutside, theRemainderOfTheString, firstCharOutsideIndex);
        }

        if (firstCharOutsideIndex && firstCharOutsideIndex > 0) {
          theRemainderOfTheString = str.slice(firstCharOutsideIndex);
        }

        return opts.cb(wholeCharacterOutside, theRemainderOfTheString, firstCharOutsideIndex);
      }

      let extraNote = "";

      if (!originalOpts) {
        extraNote = " More so, the whole options object, the fourth input argument, is missing!";
      }

      throw new Error(`string-match-left-right/${mode}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${extraNote}`);
    }

    for (let i = 0, len = whatToMatch.length; i < len; i++) {
      special = typeof whatToMatch[i] === "function";
      const whatToMatchVal = whatToMatch[i];
      let fullCharacterInFront;
      let indexOfTheCharacterInFront;
      let restOfStringInFront = "";
      let startingPosition = position;

      if (mode === "matchRight") {
        startingPosition++;
      } else if (mode === "matchLeft") {
        startingPosition--;
      }

      const found = march(str, startingPosition, whatToMatchVal, opts, special, i => mode[5] === "L" ? i - 1 : i + 1);

      if (found && special && typeof whatToMatchVal === "function" && whatToMatchVal() === "EOL") {
        return whatToMatchVal() && (opts.cb ? opts.cb(fullCharacterInFront, restOfStringInFront, indexOfTheCharacterInFront) : true) ? whatToMatchVal() : false;
      }

      if (Number.isInteger(found)) {
        indexOfTheCharacterInFront = mode.startsWith("matchLeft") ? found - 1 : found + 1;

        if (mode[5] === "L") {
          restOfStringInFront = str.slice(0, found);
        } else {
          restOfStringInFront = str.slice(indexOfTheCharacterInFront);
        }
      }

      if (indexOfTheCharacterInFront < 0) {
        indexOfTheCharacterInFront = undefined;
      }

      if (str[indexOfTheCharacterInFront]) {
        fullCharacterInFront = str[indexOfTheCharacterInFront];
      }

      if (Number.isInteger(found) && (opts.cb ? opts.cb(fullCharacterInFront, restOfStringInFront, indexOfTheCharacterInFront) : true)) {
        return whatToMatchVal;
      }
    }

    return false;
  }

  function matchLeftIncl(str, position, whatToMatch, opts) {
    return main("matchLeftIncl", str, position, whatToMatch, opts);
  }

  function matchLeft(str, position, whatToMatch, opts) {
    return main("matchLeft", str, position, whatToMatch, opts);
  }

  function matchRightIncl(str, position, whatToMatch, opts) {
    return main("matchRightIncl", str, position, whatToMatch, opts);
  }

  function matchRight(str, position, whatToMatch, opts) {
    return main("matchRight", str, position, whatToMatch, opts);
  }

  function validateCommentOpening(token) {
    var reference = {
      simple: /<!--/g,
      only: /<!--\[[^\]]+\]>/g,
      not: /<!--\[[^\]]+\]><!-->/g
    }; // if all is fine, end quick

    if (token.kind === "simple" && reference.simple.test(token.value) || token.kind === "only" && reference.only.test(token.value) || token.kind === "not" && reference.not.test(token.value)) {
      return [];
    }

    var errorArr = []; // assemble string without whitespace:

    var valueWithoutWhitespace = "";

    if (token.kind === "simple") {
      // first, tackle any inner whitespace
      splitByWhitespace(token.value, function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            charFrom = _ref2[0],
            charTo = _ref2[1];

        valueWithoutWhitespace = "".concat(valueWithoutWhitespace).concat(token.value.slice(charFrom, charTo));
      }, function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            whitespaceFrom = _ref4[0],
            whitespaceTo = _ref4[1];

        errorArr.push({
          idxFrom: token.start,
          idxTo: token.end,
          message: "Remove whitespace.",
          fix: {
            ranges: [[whitespaceFrom + token.start, whitespaceTo + token.start]]
          }
        });
      });
    } // if all it took was to remove some whitespace to get a correct value,
    // that's the end - return the "errorArr" with only whitespace ranges:


    if (token.kind === "simple" && reference.simple.test(valueWithoutWhitespace) || token.kind === "only" && reference.only.test(valueWithoutWhitespace) || token.kind === "not" && reference.not.test(valueWithoutWhitespace)) {
      return errorArr;
    } // if processing continues, it means something more is wrong


    var wrongBracketType; // check the opening tag's beginning:

    if (["only", "not"].includes(token.kind)) {
      // if beginning is malformed:
      strFindMalformed(token.value, "<!--[", function (_ref5) {
        var idxFrom = _ref5.idxFrom,
            idxTo = _ref5.idxTo;
        var finalIdxTo = idxTo; // take precaution, "not" type openings have very similar
        // ending, <!--> which will get caught as well here!

        if (idxFrom === token.start) {
          if ( // imagine, we searched for "<!--[" in "<!--{if !mso}><!-->" -
          // the idxTo is currently at "{" - search stopped at "{" and caught
          // only "<!--", the frontal part.
          // We check, maybe there's wrong type opening bracket, followed by "if"
          "{(".includes(token.value[idxTo]) && // and "if" follows
          matchRight(token.value, idxTo, "if", {
            trimBeforeMatching: true
          })) {
            wrongBracketType = true;
            finalIdxTo++;
          }

          errorArr.push({
            idxFrom: token.start,
            idxTo: token.end,
            message: "Malformed opening comment tag.",
            fix: {
              ranges: [[idxFrom + token.start, finalIdxTo + token.start, "<!--["]]
            }
          });
        }
      });
    } // check the ending part:


    if (token.kind === "not") {
      // if ending of the opening is malformed:
      strFindMalformed(token.value, "]><!-->", function (_ref6) {
        var idxFrom = _ref6.idxFrom,
            idxTo = _ref6.idxTo;
        var finalIdxFrom = idxFrom;

        if ("})".includes(token.value[idxFrom - 1]) && // also require that token would start with:
        // "<!--{if" or "<!--(if"
        wrongBracketType) {
          finalIdxFrom--;
        }

        errorArr.push({
          idxFrom: token.start,
          idxTo: token.end,
          message: "Malformed opening comment tag.",
          fix: {
            ranges: [[finalIdxFrom + token.start, idxTo + token.start, "]><!-->"]]
          }
        });
      });
    } else if (token.kind === "only") {
      // plan: take the value, chomp all ">" and "]" characters
      // from the end of it, then if anything's suspicious,
      // replace all that with tight "]>".
      for (var i = token.value.length; i--;) {
        if (token.value[i].trim().length && !">]".includes(token.value[i])) {
          // if heads already report wrong bracket type, extend by one character
          // and remove that bracket too
          var rangeStart = i + 1;

          if ("})".includes(token.value[i]) && wrongBracketType) {
            rangeStart--;
          }

          if (token.value.slice(i + 1) !== "]>") {
            errorArr.push({
              idxFrom: token.start,
              idxTo: token.end,
              message: "Malformed opening comment tag.",
              fix: {
                ranges: [[rangeStart + token.start, token.end, "]>"]]
              }
            });
          }

          break;
        }
      }
    }

    return errorArr;
  }

  // rule: comment-opening-malformed

  function commentOpeningMalformed(context) {
    return {
      text: function text(node) {
        strFindMalformed(node.value, "<!--", function (errorObj) {
          context.report(Object.assign({}, errorObj, {
            message: "Malformed opening comment tag.",
            ruleId: "comment-opening-malformed",
            fix: {
              ranges: [[errorObj.idxFrom, errorObj.idxTo, "<!--"]]
            }
          }));
        }, {
          stringOffset: node.start
        });
      },
      comment: function comment(node) {
        if (!node.closing) {
          // run the tag's value past the validator function
          var errorArr = validateCommentOpening(node) || [];
          errorArr.forEach(function (errorObj) {
            context.report(Object.assign({}, errorObj, {
              ruleId: "comment-opening-malformed"
            }));
          });
        }
      }
    };
  }

  /**
   * ast-monkey-traverse
   * Utility library to traverse parsed HTML (AST's) or anything nested (plain objects within arrays within plain objects)
   * Version: 1.12.7
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/ast-monkey-traverse
   */

  function trimFirstDot(str) {
    if (typeof str === "string" && str.length && str[0] === ".") {
      return str.slice(1);
    }

    return str;
  }

  function isObj$3(something) {
    return something && typeof something === "object" && !Array.isArray(something);
  }

  function astMonkeyTraverse(tree1, cb1) {
    const stop = {
      now: false
    };

    function traverseInner(treeOriginal, callback, innerObj, stop) {
      const tree = lodash_clonedeep(treeOriginal);
      let i;
      let len;
      let res;
      innerObj = Object.assign({
        depth: -1,
        path: ""
      }, innerObj);
      innerObj.depth += 1;

      if (Array.isArray(tree)) {
        for (i = 0, len = tree.length; i < len; i++) {
          if (stop.now) {
            break;
          }

          const path = `${innerObj.path}.${i}`;

          if (tree[i] !== undefined) {
            innerObj.parent = lodash_clonedeep(tree);
            innerObj.parentType = "array";
            res = traverseInner(callback(tree[i], undefined, Object.assign({}, innerObj, {
              path: trimFirstDot(path)
            }), stop), callback, Object.assign({}, innerObj, {
              path: trimFirstDot(path)
            }), stop);

            if (Number.isNaN(res) && i < tree.length) {
              tree.splice(i, 1);
              i -= 1;
            } else {
              tree[i] = res;
            }
          } else {
            tree.splice(i, 1);
          }
        }
      } else if (isObj$3(tree)) {
        for (const key in tree) {
          if (stop.now && key != null) {
            break;
          }

          const path = `${innerObj.path}.${key}`;

          if (innerObj.depth === 0 && key != null) {
            innerObj.topmostKey = key;
          }

          innerObj.parent = lodash_clonedeep(tree);
          innerObj.parentType = "object";
          res = traverseInner(callback(key, tree[key], Object.assign({}, innerObj, {
            path: trimFirstDot(path)
          }), stop), callback, Object.assign({}, innerObj, {
            path: trimFirstDot(path)
          }), stop);

          if (Number.isNaN(res)) {
            delete tree[key];
          } else {
            tree[key] = res;
          }
        }
      }

      return tree;
    }

    return traverseInner(tree1, cb1, {}, stop);
  }

  /**
   * ast-monkey-util
   * Utility library of AST helper functions
   * Version: 1.1.2
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/ast-monkey-util
   */
  function pathNext(str) {
    if (typeof str !== "string" || !str.length) {
      return str;
    }

    if (str.includes(".") && /^\d*$/.test(str.slice(str.lastIndexOf(".") + 1))) {
      return `${str.slice(0, str.lastIndexOf(".") + 1)}${+str.slice(str.lastIndexOf(".") + 1) + 1}`;
    } else if (/^\d*$/.test(str)) {
      return `${+str + 1}`;
    }

    return str;
  }

  function pathPrev(str) {
    if (typeof str !== "string" || !str.length) {
      return null;
    }

    const extractedValue = str.slice(str.lastIndexOf(".") + 1);

    if (extractedValue === "0") {
      return null;
    } else if (str.includes(".") && /^\d*$/.test(extractedValue)) {
      return `${str.slice(0, str.lastIndexOf(".") + 1)}${+str.slice(str.lastIndexOf(".") + 1) - 1}`;
    } else if (/^\d*$/.test(str)) {
      return `${+str - 1}`;
    }

    return null;
  }

  function pathUp(str) {
    if (typeof str === "string") {
      if (!str.includes(".") || !str.slice(str.indexOf(".") + 1).includes(".")) {
        return "0";
      }

      let dotsCount = 0;

      for (let i = str.length; i--;) {
        if (str[i] === ".") {
          dotsCount++;
        }

        if (dotsCount === 2) {
          return str.slice(0, i);
        }
      }
    }

    return str;
  }

  var objectPath = createCommonjsModule(function (module) {
    (function (root, factory) {
      /*istanbul ignore next:cant test*/

      {
        module.exports = factory();
      }
    })(commonjsGlobal, function () {

      var toStr = Object.prototype.toString;

      function hasOwnProperty(obj, prop) {
        if (obj == null) {
          return false;
        } //to handle objects with null prototypes (too edge case?)


        return Object.prototype.hasOwnProperty.call(obj, prop);
      }

      function isEmpty(value) {
        if (!value) {
          return true;
        }

        if (isArray(value) && value.length === 0) {
          return true;
        } else if (typeof value !== 'string') {
          for (var i in value) {
            if (hasOwnProperty(value, i)) {
              return false;
            }
          }

          return true;
        }

        return false;
      }

      function toString(type) {
        return toStr.call(type);
      }

      function isObject(obj) {
        return typeof obj === 'object' && toString(obj) === "[object Object]";
      }

      var isArray = Array.isArray || function (obj) {
        /*istanbul ignore next:cant test*/
        return toStr.call(obj) === '[object Array]';
      };

      function isBoolean(obj) {
        return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';
      }

      function getKey(key) {
        var intKey = parseInt(key);

        if (intKey.toString() === key) {
          return intKey;
        }

        return key;
      }

      function factory(options) {
        options = options || {};

        var objectPath = function (obj) {
          return Object.keys(objectPath).reduce(function (proxy, prop) {
            if (prop === 'create') {
              return proxy;
            }
            /*istanbul ignore else*/


            if (typeof objectPath[prop] === 'function') {
              proxy[prop] = objectPath[prop].bind(objectPath, obj);
            }

            return proxy;
          }, {});
        };

        function hasShallowProperty(obj, prop) {
          return options.includeInheritedProps || typeof prop === 'number' && Array.isArray(obj) || hasOwnProperty(obj, prop);
        }

        function getShallowProperty(obj, prop) {
          if (hasShallowProperty(obj, prop)) {
            return obj[prop];
          }
        }

        function set(obj, path, value, doNotReplace) {
          if (typeof path === 'number') {
            path = [path];
          }

          if (!path || path.length === 0) {
            return obj;
          }

          if (typeof path === 'string') {
            return set(obj, path.split('.').map(getKey), value, doNotReplace);
          }

          var currentPath = path[0];
          var currentValue = getShallowProperty(obj, currentPath);

          if (path.length === 1) {
            if (currentValue === void 0 || !doNotReplace) {
              obj[currentPath] = value;
            }

            return currentValue;
          }

          if (currentValue === void 0) {
            //check if we assume an array
            if (typeof path[1] === 'number') {
              obj[currentPath] = [];
            } else {
              obj[currentPath] = {};
            }
          }

          return set(obj[currentPath], path.slice(1), value, doNotReplace);
        }

        objectPath.has = function (obj, path) {
          if (typeof path === 'number') {
            path = [path];
          } else if (typeof path === 'string') {
            path = path.split('.');
          }

          if (!path || path.length === 0) {
            return !!obj;
          }

          for (var i = 0; i < path.length; i++) {
            var j = getKey(path[i]);

            if (typeof j === 'number' && isArray(obj) && j < obj.length || (options.includeInheritedProps ? j in Object(obj) : hasOwnProperty(obj, j))) {
              obj = obj[j];
            } else {
              return false;
            }
          }

          return true;
        };

        objectPath.ensureExists = function (obj, path, value) {
          return set(obj, path, value, true);
        };

        objectPath.set = function (obj, path, value, doNotReplace) {
          return set(obj, path, value, doNotReplace);
        };

        objectPath.insert = function (obj, path, value, at) {
          var arr = objectPath.get(obj, path);
          at = ~~at;

          if (!isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
          }

          arr.splice(at, 0, value);
        };

        objectPath.empty = function (obj, path) {
          if (isEmpty(path)) {
            return void 0;
          }

          if (obj == null) {
            return void 0;
          }

          var value, i;

          if (!(value = objectPath.get(obj, path))) {
            return void 0;
          }

          if (typeof value === 'string') {
            return objectPath.set(obj, path, '');
          } else if (isBoolean(value)) {
            return objectPath.set(obj, path, false);
          } else if (typeof value === 'number') {
            return objectPath.set(obj, path, 0);
          } else if (isArray(value)) {
            value.length = 0;
          } else if (isObject(value)) {
            for (i in value) {
              if (hasShallowProperty(value, i)) {
                delete value[i];
              }
            }
          } else {
            return objectPath.set(obj, path, null);
          }
        };

        objectPath.push = function (obj, path
        /*, values */
        ) {
          var arr = objectPath.get(obj, path);

          if (!isArray(arr)) {
            arr = [];
            objectPath.set(obj, path, arr);
          }

          arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
        };

        objectPath.coalesce = function (obj, paths, defaultValue) {
          var value;

          for (var i = 0, len = paths.length; i < len; i++) {
            if ((value = objectPath.get(obj, paths[i])) !== void 0) {
              return value;
            }
          }

          return defaultValue;
        };

        objectPath.get = function (obj, path, defaultValue) {
          if (typeof path === 'number') {
            path = [path];
          }

          if (!path || path.length === 0) {
            return obj;
          }

          if (obj == null) {
            return defaultValue;
          }

          if (typeof path === 'string') {
            return objectPath.get(obj, path.split('.'), defaultValue);
          }

          var currentPath = getKey(path[0]);
          var nextObj = getShallowProperty(obj, currentPath);

          if (nextObj === void 0) {
            return defaultValue;
          }

          if (path.length === 1) {
            return nextObj;
          }

          return objectPath.get(obj[currentPath], path.slice(1), defaultValue);
        };

        objectPath.del = function del(obj, path) {
          if (typeof path === 'number') {
            path = [path];
          }

          if (obj == null) {
            return obj;
          }

          if (isEmpty(path)) {
            return obj;
          }

          if (typeof path === 'string') {
            return objectPath.del(obj, path.split('.'));
          }

          var currentPath = getKey(path[0]);

          if (!hasShallowProperty(obj, currentPath)) {
            return obj;
          }

          if (path.length === 1) {
            if (isArray(obj)) {
              obj.splice(currentPath, 1);
            } else {
              delete obj[currentPath];
            }
          } else {
            return objectPath.del(obj[currentPath], path.slice(1));
          }

          return obj;
        };

        return objectPath;
      }

      var mod = factory();
      mod.create = factory;
      mod.withInheritedProps = factory({
        includeInheritedProps: true
      });
      return mod;
    });
  });

  // rule: comment-mismatching-pair

  function commentMismatchingPair(context) {
    return {
      ast: function ast(node) {
        // console.log(
        //   `021 commentMismatchingPair(): FIY, ${`\u001b[${32}m${`INCOMING`}\u001b[${39}m`} ${`\u001b[${33}m${`whole AST`}\u001b[${39}m`} = ${JSON.stringify(
        //     node,
        //     null,
        //     4
        //   )}`
        // );
        // we have raw AST, we need to traverse it and find mismatching-kind pairs
        // of type="comment" tokens, only-not or not-only
        astMonkeyTraverse(node, // (key, val, innerObj, stop) => {
        function (key, val, innerObj) {
          var current = val !== undefined ? val : key;

          if (isObj(current)) {
            // monkey will traverse every key, every string within.
            // We need to pick the objects of a type we need: "comment"
            // console.log(
            //   `210  ${`\u001b[${35}m${`linter/tagCb():`}\u001b[${39}m`} PING ${`\u001b[${33}m${`current`}\u001b[${39}m`} = ${JSON.stringify(
            //     current,
            //     null,
            //     4
            //   )}`
            // );
            if (current.type === "comment" && current.closing) {
              var previousToken = objectPath.get(node, pathPrev(innerObj.path));

              if (isObj(previousToken) && previousToken.type === "comment" && !previousToken.closing) {
                if (previousToken.kind === "not" && current.kind === "only") {
                  // turn tail into "not"-kind, add front part (<!--)
                  // Out of all raised errors, only one can have "ranges.fix" -
                  // all other fixes, if any present, will be removed.
                  // This is to simplify the rule fix clashing.
                  context.report({
                    ruleId: "comment-mismatching-pair",
                    keepSeparateWhenFixing: true,
                    message: "Add \"<!--\".",
                    idxFrom: current.start,
                    idxTo: current.end,
                    fix: {
                      ranges: [[current.start, current.start, "<!--"]]
                    }
                  });
                } else if (previousToken.kind === "only" && current.kind === "not") {
                  // turn tail into "only"-kind, remove front part (<!--)
                  // Out of all raised errors, only one can have "ranges.fix" -
                  // all other fixes, if any present, will be removed.
                  // This is to simplify the rule fix clashing.
                  context.report({
                    ruleId: "comment-mismatching-pair",
                    keepSeparateWhenFixing: true,
                    message: "Remove \"<!--\".",
                    idxFrom: current.start,
                    idxTo: current.end,
                    fix: {
                      ranges: [[current.start, current.end, "<![endif]-->"]]
                    }
                  });
                }
              }
            }
          }

          return current;
        });
      }
    };
  }

  // rule: comment-conditional-nested
  // function commentConditionalNested(context, ...opts) {

  function commentConditionalNested(context) {
    return {
      ast: function ast(node) {
        var pathsWithOpeningComments = [];
        astMonkeyTraverse(node, // (key, val, innerObj, stop) => {
        function (key, val, innerObj) {
          var current = val !== undefined ? val : key;

          if (isObj(current)) {
            // monkey will traverse every key, every string within.
            // We need to pick the objects of a type we need: "comment"
            if (current.type === "comment") {
              // first, check, does any opening comment path strings match
              // the start of the current path - because if it is, it's nested
              // and should be reported
              if (pathsWithOpeningComments.some(function (pathStr) {
                return innerObj.path.startsWith(pathStr);
              })) {
                context.report({
                  ruleId: "comment-conditional-nested",
                  message: "Don't nest comments.",
                  idxFrom: current.start,
                  idxTo: current.end,
                  fix: null
                });
              }

              if (!current.closing) {
                pathsWithOpeningComments.push(innerObj.path);
              }
            }
          }

          return current;
        });
      }
    };
  }

  // here we fetch the rules from all the places,
  var builtInRules = {};
  defineLazyProp(builtInRules, "bad-character-null", function () {
    return badCharacterNull;
  });
  defineLazyProp(builtInRules, "bad-character-start-of-heading", function () {
    return badCharacterStartOfHeading;
  });
  defineLazyProp(builtInRules, "bad-character-start-of-text", function () {
    return badCharacterStartOfText;
  });
  defineLazyProp(builtInRules, "bad-character-end-of-text", function () {
    return badCharacterEndOfText;
  });
  defineLazyProp(builtInRules, "bad-character-end-of-transmission", function () {
    return badCharacterEndOfTransmission;
  });
  defineLazyProp(builtInRules, "bad-character-enquiry", function () {
    return badCharacterEnquiry;
  });
  defineLazyProp(builtInRules, "bad-character-acknowledge", function () {
    return badCharacterAcknowledge;
  });
  defineLazyProp(builtInRules, "bad-character-bell", function () {
    return badCharacterBell;
  });
  defineLazyProp(builtInRules, "bad-character-backspace", function () {
    return badCharacterBackspace;
  });
  defineLazyProp(builtInRules, "bad-character-tabulation", function () {
    return badCharacterTabulation;
  });
  defineLazyProp(builtInRules, "bad-character-line-tabulation", function () {
    return badCharacterLineTabulation;
  });
  defineLazyProp(builtInRules, "bad-character-form-feed", function () {
    return badCharacterFormFeed;
  });
  defineLazyProp(builtInRules, "bad-character-shift-out", function () {
    return badCharacterShiftOut;
  });
  defineLazyProp(builtInRules, "bad-character-shift-in", function () {
    return badCharacterShiftIn;
  });
  defineLazyProp(builtInRules, "bad-character-data-link-escape", function () {
    return badCharacterDataLinkEscape;
  });
  defineLazyProp(builtInRules, "bad-character-device-control-one", function () {
    return badCharacterDeviceControlOne;
  });
  defineLazyProp(builtInRules, "bad-character-device-control-two", function () {
    return badCharacterDeviceControlTwo;
  });
  defineLazyProp(builtInRules, "bad-character-device-control-three", function () {
    return badCharacterDeviceControlThree;
  });
  defineLazyProp(builtInRules, "bad-character-device-control-four", function () {
    return badCharacterDeviceControlFour;
  });
  defineLazyProp(builtInRules, "bad-character-negative-acknowledge", function () {
    return badCharacterNegativeAcknowledge;
  });
  defineLazyProp(builtInRules, "bad-character-synchronous-idle", function () {
    return badCharacterSynchronousIdle;
  });
  defineLazyProp(builtInRules, "bad-character-end-of-transmission-block", function () {
    return badCharacterEndOfTransmissionBlock;
  });
  defineLazyProp(builtInRules, "bad-character-cancel", function () {
    return badCharacterCancel;
  });
  defineLazyProp(builtInRules, "bad-character-end-of-medium", function () {
    return badCharacterEndOfMedium;
  });
  defineLazyProp(builtInRules, "bad-character-substitute", function () {
    return badCharacterSubstitute;
  });
  defineLazyProp(builtInRules, "bad-character-escape", function () {
    return badCharacterEscape;
  });
  defineLazyProp(builtInRules, "bad-character-information-separator-four", function () {
    return badCharacterInformationSeparatorFour;
  });
  defineLazyProp(builtInRules, "bad-character-information-separator-three", function () {
    return badCharacterInformationSeparatorThree;
  });
  defineLazyProp(builtInRules, "bad-character-information-separator-two", function () {
    return badCharacterInformationSeparatorTwo;
  });
  defineLazyProp(builtInRules, "bad-character-information-separator-one", function () {
    return badCharacterInformationSeparatorTwo$1;
  });
  defineLazyProp(builtInRules, "bad-character-delete", function () {
    return badCharacterDelete;
  });
  defineLazyProp(builtInRules, "bad-character-control-0080", function () {
    return badCharacterControl0080;
  });
  defineLazyProp(builtInRules, "bad-character-control-0081", function () {
    return badCharacterControl0081;
  });
  defineLazyProp(builtInRules, "bad-character-break-permitted-here", function () {
    return badCharacterBreakPermittedHere;
  });
  defineLazyProp(builtInRules, "bad-character-no-break-here", function () {
    return badCharacterNoBreakHere;
  });
  defineLazyProp(builtInRules, "bad-character-control-0084", function () {
    return badCharacterControl0084;
  });
  defineLazyProp(builtInRules, "bad-character-next-line", function () {
    return badCharacterNextLine;
  });
  defineLazyProp(builtInRules, "bad-character-start-of-selected-area", function () {
    return badCharacterStartOfSelectedArea;
  });
  defineLazyProp(builtInRules, "bad-character-end-of-selected-area", function () {
    return badCharacterEndOfSelectedArea;
  });
  defineLazyProp(builtInRules, "bad-character-character-tabulation-set", function () {
    return badCharacterCharacterTabulationSet;
  });
  defineLazyProp(builtInRules, "bad-character-character-tabulation-with-justification", function () {
    return badCharacterCharacterTabulationWithJustification;
  });
  defineLazyProp(builtInRules, "bad-character-line-tabulation-set", function () {
    return badCharacterLineTabulationSet;
  });
  defineLazyProp(builtInRules, "bad-character-partial-line-forward", function () {
    return badCharacterPartialLineForward;
  });
  defineLazyProp(builtInRules, "bad-character-partial-line-backward", function () {
    return badCharacterPartialLineBackward;
  });
  defineLazyProp(builtInRules, "bad-character-reverse-line-feed", function () {
    return badCharacterReverseLineFeed;
  });
  defineLazyProp(builtInRules, "bad-character-single-shift-two", function () {
    return badCharacterSingleShiftTwo;
  });
  defineLazyProp(builtInRules, "bad-character-single-shift-three", function () {
    return badCharacterSingleShiftTwo$1;
  });
  defineLazyProp(builtInRules, "bad-character-device-control-string", function () {
    return badCharacterDeviceControlString;
  });
  defineLazyProp(builtInRules, "bad-character-private-use-1", function () {
    return badCharacterPrivateUseOne;
  });
  defineLazyProp(builtInRules, "bad-character-private-use-2", function () {
    return badCharacterPrivateUseTwo;
  });
  defineLazyProp(builtInRules, "bad-character-set-transmit-state", function () {
    return badCharacterSetTransmitState;
  });
  defineLazyProp(builtInRules, "bad-character-cancel-character", function () {
    return badCharacterCancelCharacter;
  });
  defineLazyProp(builtInRules, "bad-character-message-waiting", function () {
    return badCharacterMessageWaiting;
  });
  defineLazyProp(builtInRules, "bad-character-start-of-protected-area", function () {
    return badCharacterStartOfProtectedArea;
  });
  defineLazyProp(builtInRules, "bad-character-end-of-protected-area", function () {
    return badCharacterEndOfProtectedArea;
  });
  defineLazyProp(builtInRules, "bad-character-start-of-string", function () {
    return badCharacterStartOfString;
  });
  defineLazyProp(builtInRules, "bad-character-control-0099", function () {
    return badCharacterControl0099;
  });
  defineLazyProp(builtInRules, "bad-character-single-character-introducer", function () {
    return badCharacterSingleCharacterIntroducer;
  });
  defineLazyProp(builtInRules, "bad-character-control-sequence-introducer", function () {
    return badCharacterControlSequenceIntroducer;
  });
  defineLazyProp(builtInRules, "bad-character-string-terminator", function () {
    return badCharacterStringTerminator;
  });
  defineLazyProp(builtInRules, "bad-character-operating-system-command", function () {
    return badCharacterOperatingSystemCommand;
  });
  defineLazyProp(builtInRules, "bad-character-private-message", function () {
    return badCharacterPrivateMessage;
  });
  defineLazyProp(builtInRules, "bad-character-application-program-command", function () {
    return badCharacterApplicationProgramCommand;
  });
  defineLazyProp(builtInRules, "bad-character-soft-hyphen", function () {
    return badCharacterSoftHyphen;
  }); // space characters:
  defineLazyProp(builtInRules, "bad-character-non-breaking-space", function () {
    return badCharacterNonBreakingSpace;
  });
  defineLazyProp(builtInRules, "bad-character-ogham-space-mark", function () {
    return badCharacterOghamSpaceMark;
  });
  defineLazyProp(builtInRules, "bad-character-en-quad", function () {
    return badCharacterEnQuad;
  });
  defineLazyProp(builtInRules, "bad-character-em-quad", function () {
    return badCharacterEmQuad;
  });
  defineLazyProp(builtInRules, "bad-character-en-space", function () {
    return badCharacterEnSpace;
  });
  defineLazyProp(builtInRules, "bad-character-em-space", function () {
    return badCharacterEmSpace;
  });
  defineLazyProp(builtInRules, "bad-character-three-per-em-space", function () {
    return badCharacterThreePerEmSpace;
  });
  defineLazyProp(builtInRules, "bad-character-four-per-em-space", function () {
    return badCharacterFourPerEmSpace;
  });
  defineLazyProp(builtInRules, "bad-character-six-per-em-space", function () {
    return badCharacterSixPerEmSpace;
  });
  defineLazyProp(builtInRules, "bad-character-figure-space", function () {
    return badCharacterFigureSpace;
  });
  defineLazyProp(builtInRules, "bad-character-punctuation-space", function () {
    return badCharacterPunctuationSpace;
  });
  defineLazyProp(builtInRules, "bad-character-thin-space", function () {
    return badCharacterThinSpace;
  });
  defineLazyProp(builtInRules, "bad-character-hair-space", function () {
    return badCharacterHairSpace;
  });
  defineLazyProp(builtInRules, "bad-character-zero-width-space", function () {
    return badCharacterZeroWidthSpace;
  });
  defineLazyProp(builtInRules, "bad-character-zero-width-non-joiner", function () {
    return badCharacterZeroWidthNonJoiner;
  });
  defineLazyProp(builtInRules, "bad-character-zero-width-joiner", function () {
    return badCharacterZeroWidthJoiner;
  });
  defineLazyProp(builtInRules, "bad-character-left-to-right-mark", function () {
    return badCharacterLeftToRightMark;
  });
  defineLazyProp(builtInRules, "bad-character-right-to-left-mark", function () {
    return badCharacterRightToLeftMark;
  });
  defineLazyProp(builtInRules, "bad-character-left-to-right-embedding", function () {
    return badCharacterLeftToRightEmbedding;
  });
  defineLazyProp(builtInRules, "bad-character-right-to-left-embedding", function () {
    return badCharacterRightToLeftEmbedding;
  });
  defineLazyProp(builtInRules, "bad-character-pop-directional-formatting", function () {
    return badCharacterPopDirectionalFormatting;
  });
  defineLazyProp(builtInRules, "bad-character-left-to-right-override", function () {
    return badCharacterLeftToRightOverride;
  });
  defineLazyProp(builtInRules, "bad-character-right-to-left-override", function () {
    return badCharacterRightToLeftOverride;
  }); //
  defineLazyProp(builtInRules, "bad-character-word-joiner", function () {
    return badCharacterWordJoiner;
  });
  defineLazyProp(builtInRules, "bad-character-function-application", function () {
    return badCharacterFunctionApplication;
  });
  defineLazyProp(builtInRules, "bad-character-invisible-times", function () {
    return badCharacterInvisibleTimes;
  });
  defineLazyProp(builtInRules, "bad-character-invisible-separator", function () {
    return badCharacterInvisibleSeparator;
  });
  defineLazyProp(builtInRules, "bad-character-invisible-plus", function () {
    return badCharacterInvisiblePlus;
  });
  defineLazyProp(builtInRules, "bad-character-left-to-right-isolate", function () {
    return badCharacterLeftToRightIsolate;
  });
  defineLazyProp(builtInRules, "bad-character-right-to-left-isolate", function () {
    return badCharacterRightToLeftIsolate;
  });
  defineLazyProp(builtInRules, "bad-character-first-strong-isolate", function () {
    return badCharacterFirstStrongIsolate;
  });
  defineLazyProp(builtInRules, "bad-character-pop-directional-isolate", function () {
    return badCharacterPopDirectionalIsolate;
  });
  defineLazyProp(builtInRules, "bad-character-inhibit-symmetric-swapping", function () {
    return badCharacterInhibitSymmetricSwapping;
  });
  defineLazyProp(builtInRules, "bad-character-activate-symmetric-swapping", function () {
    return badCharacterActivateSymmetricSwapping;
  });
  defineLazyProp(builtInRules, "bad-character-inhibit-arabic-form-shaping", function () {
    return badCharacterInhibitArabicFormShaping;
  });
  defineLazyProp(builtInRules, "bad-character-activate-arabic-form-shaping", function () {
    return badCharacterActivateArabicFormShaping;
  });
  defineLazyProp(builtInRules, "bad-character-national-digit-shapes", function () {
    return badCharacterNationalDigitShapes;
  });
  defineLazyProp(builtInRules, "bad-character-nominal-digit-shapes", function () {
    return badCharacterNominalDigitShapes;
  });
  defineLazyProp(builtInRules, "bad-character-zero-width-no-break-space", function () {
    return badCharacterZeroWidthNoBreakSpace;
  });
  defineLazyProp(builtInRules, "bad-character-interlinear-annotation-anchor", function () {
    return badCharacterInterlinearAnnotationAnchor;
  });
  defineLazyProp(builtInRules, "bad-character-interlinear-annotation-separator", function () {
    return badCharacterInterlinearAnnotationSeparator;
  });
  defineLazyProp(builtInRules, "bad-character-interlinear-annotation-terminator", function () {
    return badCharacterInterlinearAnnotationTerminator;
  });
  defineLazyProp(builtInRules, "bad-character-line-separator", function () {
    return badCharacterLineSeparator;
  });
  defineLazyProp(builtInRules, "bad-character-paragraph-separator", function () {
    return badCharacterParagraphSeparator;
  }); //
  defineLazyProp(builtInRules, "bad-character-narrow-no-break-space", function () {
    return badCharacterNarrowNoBreakSpace;
  });
  defineLazyProp(builtInRules, "bad-character-medium-mathematical-space", function () {
    return badCharacterMediumMathematicalSpace;
  });
  defineLazyProp(builtInRules, "bad-character-ideographic-space", function () {
    return badCharacterIdeographicSpace;
  });
  defineLazyProp(builtInRules, "bad-character-replacement-character", function () {
    return badCharacterReplacementCharacter;
  }); // TAG-LEVEL rules
  defineLazyProp(builtInRules, "tag-space-after-opening-bracket", function () {
    return tagSpaceAfterOpeningBracket;
  });
  defineLazyProp(builtInRules, "tag-space-before-closing-bracket", function () {
    return tagSpaceBeforeClosingBracket;
  });
  defineLazyProp(builtInRules, "tag-space-before-closing-slash", function () {
    return tagSpaceBeforeClosingSlash;
  });
  defineLazyProp(builtInRules, "tag-space-between-slash-and-bracket", function () {
    return tagSpaceBetweenSlashAndBracket;
  });
  defineLazyProp(builtInRules, "tag-closing-backslash", function () {
    return tagClosingBackslash;
  });
  defineLazyProp(builtInRules, "tag-void-slash", function () {
    return tagVoidSlash;
  });
  defineLazyProp(builtInRules, "tag-name-case", function () {
    return tagNameCase;
  });
  defineLazyProp(builtInRules, "tag-is-present", function () {
    return tagIsPresent;
  });
  defineLazyProp(builtInRules, "tag-bold", function () {
    return tagBold;
  });
  defineLazyProp(builtInRules, "tag-bad-self-closing", function () {
    return tagBadSelfClosing;
  }); // ATTRIBUTE rules
  defineLazyProp(builtInRules, "attribute-duplicate", function () {
    return attributeDuplicate;
  });
  defineLazyProp(builtInRules, "attribute-malformed", function () {
    return attributeMalformed;
  }); // ATTRIBUTE-VALIDATE- rules
  defineLazyProp(builtInRules, "attribute-validate-abbr", function () {
    return attributeValidateAbbr;
  });
  defineLazyProp(builtInRules, "attribute-validate-accept-charset", function () {
    return attributeValidateAcceptCharset;
  });
  defineLazyProp(builtInRules, "attribute-validate-accept", function () {
    return attributeValidateAccept;
  });
  defineLazyProp(builtInRules, "attribute-validate-accesskey", function () {
    return attributeValidateAccesskey;
  });
  defineLazyProp(builtInRules, "attribute-validate-action", function () {
    return attributeValidateAction;
  });
  defineLazyProp(builtInRules, "attribute-validate-align", function () {
    return attributeValidateAlign;
  });
  defineLazyProp(builtInRules, "attribute-validate-alink", function () {
    return attributeValidateAlink;
  });
  defineLazyProp(builtInRules, "attribute-validate-alt", function () {
    return attributeValidateAlt;
  });
  defineLazyProp(builtInRules, "attribute-validate-archive", function () {
    return attributeValidateArchive;
  });
  defineLazyProp(builtInRules, "attribute-validate-axis", function () {
    return attributeValidateAxis;
  });
  defineLazyProp(builtInRules, "attribute-validate-background", function () {
    return attributeValidateBackground;
  });
  defineLazyProp(builtInRules, "attribute-validate-bgcolor", function () {
    return attributeValidateBgcolor;
  });
  defineLazyProp(builtInRules, "attribute-validate-border", function () {
    return attributeValidateBorder;
  });
  defineLazyProp(builtInRules, "attribute-validate-cellpadding", function () {
    return attributeValidateCellpadding;
  });
  defineLazyProp(builtInRules, "attribute-validate-cellspacing", function () {
    return attributeValidateCellspacing;
  });
  defineLazyProp(builtInRules, "attribute-validate-char", function () {
    return attributeValidateChar;
  });
  defineLazyProp(builtInRules, "attribute-validate-charoff", function () {
    return attributeValidateCharoff;
  });
  defineLazyProp(builtInRules, "attribute-validate-charset", function () {
    return attributeValidateCharset;
  });
  defineLazyProp(builtInRules, "attribute-validate-checked", function () {
    return attributeValidateChecked;
  });
  defineLazyProp(builtInRules, "attribute-validate-cite", function () {
    return attributeValidateCite;
  });
  defineLazyProp(builtInRules, "attribute-validate-class", function () {
    return attributeValidateClass;
  });
  defineLazyProp(builtInRules, "attribute-validate-classid", function () {
    return attributeValidateClassid;
  });
  defineLazyProp(builtInRules, "attribute-validate-clear", function () {
    return attributeValidateClassid$1;
  });
  defineLazyProp(builtInRules, "attribute-validate-code", function () {
    return attributeValidateCode;
  });
  defineLazyProp(builtInRules, "attribute-validate-codebase", function () {
    return attributeValidateCodebase;
  });
  defineLazyProp(builtInRules, "attribute-validate-codetype", function () {
    return attributeValidateCodetype;
  });
  defineLazyProp(builtInRules, "attribute-validate-color", function () {
    return attributeValidateColor;
  });
  defineLazyProp(builtInRules, "attribute-validate-cols", function () {
    return attributeValidateCols;
  });
  defineLazyProp(builtInRules, "attribute-validate-colspan", function () {
    return attributeValidateColspan;
  });
  defineLazyProp(builtInRules, "attribute-validate-compact", function () {
    return attributeValidateCompact;
  });
  defineLazyProp(builtInRules, "attribute-validate-content", function () {
    return attributeValidateContent;
  });
  defineLazyProp(builtInRules, "attribute-validate-coords", function () {
    return attributeValidateCoords;
  });
  defineLazyProp(builtInRules, "attribute-validate-data", function () {
    return attributeValidateData;
  });
  defineLazyProp(builtInRules, "attribute-validate-datetime", function () {
    return attributeValidateDatetime;
  });
  defineLazyProp(builtInRules, "attribute-validate-declare", function () {
    return attributeValidateDeclare;
  });
  defineLazyProp(builtInRules, "attribute-validate-defer", function () {
    return attributeValidateDefer;
  });
  defineLazyProp(builtInRules, "attribute-validate-dir", function () {
    return attributeValidateDir;
  });
  defineLazyProp(builtInRules, "attribute-validate-disabled", function () {
    return attributeValidateDisabled;
  });
  defineLazyProp(builtInRules, "attribute-validate-enctype", function () {
    return attributeValidateEnctype;
  });
  defineLazyProp(builtInRules, "attribute-validate-face", function () {
    return attributeValidateFace;
  });
  defineLazyProp(builtInRules, "attribute-validate-for", function () {
    return attributeValidateFor;
  });
  defineLazyProp(builtInRules, "attribute-validate-frame", function () {
    return attributeValidateFrame;
  });
  defineLazyProp(builtInRules, "attribute-validate-frameborder", function () {
    return attributeValidateFrameborder;
  });
  defineLazyProp(builtInRules, "attribute-validate-headers", function () {
    return attributeValidateHeaders;
  });
  defineLazyProp(builtInRules, "attribute-validate-height", function () {
    return attributeValidateHeight;
  });
  defineLazyProp(builtInRules, "attribute-validate-href", function () {
    return attributeValidateHref;
  });
  defineLazyProp(builtInRules, "attribute-validate-hreflang", function () {
    return attributeValidateHreflang;
  });
  defineLazyProp(builtInRules, "attribute-validate-hspace", function () {
    return attributeValidateHspace;
  });
  defineLazyProp(builtInRules, "attribute-validate-http-equiv", function () {
    return attributeValidateHttpequiv;
  });
  defineLazyProp(builtInRules, "attribute-validate-id", function () {
    return attributeValidateId;
  });
  defineLazyProp(builtInRules, "attribute-validate-ismap", function () {
    return attributeValidateIsmap;
  });
  defineLazyProp(builtInRules, "attribute-validate-label", function () {
    return attributeValidateLabel;
  });
  defineLazyProp(builtInRules, "attribute-validate-lang", function () {
    return attributeValidateLang;
  });
  defineLazyProp(builtInRules, "attribute-validate-language", function () {
    return attributeValidateLanguage;
  });
  defineLazyProp(builtInRules, "attribute-validate-link", function () {
    return attributeValidateLink;
  });
  defineLazyProp(builtInRules, "attribute-validate-longdesc", function () {
    return attributeValidateLongdesc;
  });
  defineLazyProp(builtInRules, "attribute-validate-marginheight", function () {
    return attributeValidateMarginheight;
  });
  defineLazyProp(builtInRules, "attribute-validate-marginwidth", function () {
    return attributeValidateMarginwidth;
  });
  defineLazyProp(builtInRules, "attribute-validate-maxlength", function () {
    return attributeValidateMaxlength;
  });
  defineLazyProp(builtInRules, "attribute-validate-media", function () {
    return attributeValidateMedia;
  });
  defineLazyProp(builtInRules, "attribute-validate-method", function () {
    return attributeValidateMethod;
  });
  defineLazyProp(builtInRules, "attribute-validate-multiple", function () {
    return attributeValidateMultiple;
  });
  defineLazyProp(builtInRules, "attribute-validate-name", function () {
    return attributeValidateName;
  });
  defineLazyProp(builtInRules, "attribute-validate-nohref", function () {
    return attributeValidateNohref;
  });
  defineLazyProp(builtInRules, "attribute-validate-noresize", function () {
    return attributeValidateNoresize;
  });
  defineLazyProp(builtInRules, "attribute-validate-noshade", function () {
    return attributeValidateNoshade;
  });
  defineLazyProp(builtInRules, "attribute-validate-nowrap", function () {
    return attributeValidateNowrap;
  });
  defineLazyProp(builtInRules, "attribute-validate-object", function () {
    return attributeValidateObject;
  });
  defineLazyProp(builtInRules, "attribute-validate-onblur", function () {
    return attributeValidateOnblur;
  });
  defineLazyProp(builtInRules, "attribute-validate-onchange", function () {
    return attributeValidateOnchange;
  });
  defineLazyProp(builtInRules, "attribute-validate-onclick", function () {
    return attributeValidateOnclick;
  });
  defineLazyProp(builtInRules, "attribute-validate-ondblclick", function () {
    return attributeValidateOndblclick;
  });
  defineLazyProp(builtInRules, "attribute-validate-onfocus", function () {
    return attributeValidateOnfocus;
  });
  defineLazyProp(builtInRules, "attribute-validate-onkeydown", function () {
    return attributeValidateOnkeydown;
  });
  defineLazyProp(builtInRules, "attribute-validate-onkeypress", function () {
    return attributeValidateOnkeypress;
  });
  defineLazyProp(builtInRules, "attribute-validate-onkeyup", function () {
    return attributeValidateOnkeyup;
  });
  defineLazyProp(builtInRules, "attribute-validate-onload", function () {
    return attributeValidateOnload;
  });
  defineLazyProp(builtInRules, "attribute-validate-onmousedown", function () {
    return attributeValidateOnmousedown;
  });
  defineLazyProp(builtInRules, "attribute-validate-onmousemove", function () {
    return attributeValidateOnmousemove;
  });
  defineLazyProp(builtInRules, "attribute-validate-onmouseout", function () {
    return attributeValidateOnmouseout;
  });
  defineLazyProp(builtInRules, "attribute-validate-onmouseover", function () {
    return attributeValidateOnmouseover;
  });
  defineLazyProp(builtInRules, "attribute-validate-onmouseup", function () {
    return attributeValidateOnmouseup;
  });
  defineLazyProp(builtInRules, "attribute-validate-onreset", function () {
    return attributeValidateOnreset;
  });
  defineLazyProp(builtInRules, "attribute-validate-onsubmit", function () {
    return attributeValidateOnsubmit;
  });
  defineLazyProp(builtInRules, "attribute-validate-onselect", function () {
    return attributeValidateOnselect;
  });
  defineLazyProp(builtInRules, "attribute-validate-onunload", function () {
    return attributeValidateOnunload;
  });
  defineLazyProp(builtInRules, "attribute-validate-profile", function () {
    return attributeValidateProfile;
  });
  defineLazyProp(builtInRules, "attribute-validate-prompt", function () {
    return attributeValidatePrompt;
  });
  defineLazyProp(builtInRules, "attribute-validate-readonly", function () {
    return attributeValidateReadonly;
  });
  defineLazyProp(builtInRules, "attribute-validate-rel", function () {
    return attributeValidateRel;
  });
  defineLazyProp(builtInRules, "attribute-validate-rev", function () {
    return attributeValidateRev;
  });
  defineLazyProp(builtInRules, "attribute-validate-rows", function () {
    return attributeValidateRows;
  });
  defineLazyProp(builtInRules, "attribute-validate-rowspan", function () {
    return attributeValidateRowspan;
  });
  defineLazyProp(builtInRules, "attribute-validate-rules", function () {
    return attributeValidateRules;
  });
  defineLazyProp(builtInRules, "attribute-validate-scheme", function () {
    return attributeValidateScheme;
  });
  defineLazyProp(builtInRules, "attribute-validate-scope", function () {
    return attributeValidateScope;
  });
  defineLazyProp(builtInRules, "attribute-validate-scrolling", function () {
    return attributeValidateScrolling;
  });
  defineLazyProp(builtInRules, "attribute-validate-selected", function () {
    return attributeValidateSelected;
  });
  defineLazyProp(builtInRules, "attribute-validate-shape", function () {
    return attributeValidateShape;
  });
  defineLazyProp(builtInRules, "attribute-validate-size", function () {
    return attributeValidateSize;
  });
  defineLazyProp(builtInRules, "attribute-validate-span", function () {
    return attributeValidateSpan;
  });
  defineLazyProp(builtInRules, "attribute-validate-src", function () {
    return attributeValidateSrc;
  });
  defineLazyProp(builtInRules, "attribute-validate-standby", function () {
    return attributeValidateStandby;
  });
  defineLazyProp(builtInRules, "attribute-validate-start", function () {
    return attributeValidateStart;
  });
  defineLazyProp(builtInRules, "attribute-validate-style", function () {
    return attributeValidateStyle;
  });
  defineLazyProp(builtInRules, "attribute-validate-summary", function () {
    return attributeValidateSummary;
  });
  defineLazyProp(builtInRules, "attribute-validate-tabindex", function () {
    return attributeValidateTabindex;
  });
  defineLazyProp(builtInRules, "attribute-validate-target", function () {
    return attributeValidateTarget;
  });
  defineLazyProp(builtInRules, "attribute-validate-text", function () {
    return attributeValidateText;
  });
  defineLazyProp(builtInRules, "attribute-validate-title", function () {
    return attributeValidateTitle;
  });
  defineLazyProp(builtInRules, "attribute-validate-type", function () {
    return attributeValidateType;
  });
  defineLazyProp(builtInRules, "attribute-validate-usemap", function () {
    return attributeValidateUsemap;
  });
  defineLazyProp(builtInRules, "attribute-validate-valign", function () {
    return attributeValidateValign;
  });
  defineLazyProp(builtInRules, "attribute-validate-value", function () {
    return attributeValidateValue;
  });
  defineLazyProp(builtInRules, "attribute-validate-valuetype", function () {
    return attributeValidateValuetype;
  });
  defineLazyProp(builtInRules, "attribute-validate-version", function () {
    return attributeValidateVersion;
  });
  defineLazyProp(builtInRules, "attribute-validate-vlink", function () {
    return attributeValidateVlink;
  });
  defineLazyProp(builtInRules, "attribute-validate-vspace", function () {
    return attributeValidateVspace;
  });
  defineLazyProp(builtInRules, "attribute-validate-width", function () {
    return attributeValidateWidth;
  }); // BAD-HTML-ENTITY rules
  defineLazyProp(builtInRules, "bad-named-html-entity-not-email-friendly", function () {
    return htmlEntitiesNotEmailFriendly;
  }); // CHARACTER rules
  defineLazyProp(builtInRules, "character-encode", function () {
    return characterEncode;
  });
  defineLazyProp(builtInRules, "character-unspaced-punctuation", function () {
    return characterUnspacedPunctuation;
  }); // MEDIA (QUERY) rules
  defineLazyProp(builtInRules, "media-malformed", function () {
    return mediaMalformed;
  }); // COMMENT TAG rules
  defineLazyProp(builtInRules, "comment-closing-malformed", function () {
    return commentClosingMalformed;
  });
  defineLazyProp(builtInRules, "comment-opening-malformed", function () {
    return commentOpeningMalformed;
  });
  defineLazyProp(builtInRules, "comment-mismatching-pair", function () {
    return commentMismatchingPair;
  });
  defineLazyProp(builtInRules, "comment-conditional-nested", function () {
    return commentConditionalNested;
  }); // EXPORTS
  // -----------------------------------------------------------------------------

  function get(something) {
    return builtInRules[something];
  } // it expands the grouped rules, such as "bad-character", then
  // removes the grouped rule so that only real, single rules
  // are passed to Linter


  function normaliseRequestedRules(opts) {
    // console.log(
    //   `870 normaliseRequestedRules() RECEIVED: ${`\u001b[${33}m${`opts`}\u001b[${39}m`} = ${JSON.stringify(
    //     opts,
    //     null,
    //     4
    //   )}`
    // );
    var res = {}; // first, if there are known group rules such as "bad-character", set
    // them as a foundation:

    if (Object.keys(opts).includes("all") && isAnEnabledValue(opts.all)) {
      Object.keys(builtInRules).forEach(function (ruleName) {
        res[ruleName] = opts.all;
      });
    } else {
      var temp;

      if (Object.keys(opts).some(function (ruleName) {
        if (["bad-character", "bad-character*", "bad-character-*"].includes(ruleName)) {
          temp = ruleName;
          return true;
        }
      })) {
        allBadCharacterRules.forEach(function (ruleName) {
          res[ruleName] = opts[temp];
        });
      }

      if (Object.keys(opts).some(function (ruleName) {
        if (["tag", "tag*", "tag-*"].includes(ruleName)) {
          temp = ruleName;
          return true;
        }
      })) {
        allTagRules.forEach(function (ruleName) {
          res[ruleName] = opts[temp];
        });
      }

      if (Object.keys(opts).some(function (ruleName) {
        if (["attribute", "attribute*", "attribute-*"].includes(ruleName)) {
          temp = ruleName;
          return true;
        }
      })) {
        allAttribRules.forEach(function (ruleName) {
          res[ruleName] = opts[temp];
        });
      }

      if (Object.keys(opts).includes("bad-html-entity")) {
        allBadNamedHTMLEntityRules.forEach(function (ruleName) {
          // whole group of rules, not necessarily starting with "bad-html-entity"
          // will be added. Currently it's the list:
          //  * bad-named-html-entity-malformed-nbsp
          //  * bad-named-html-entity-malformed-*
          //  * bad-named-html-entity-unrecognised
          //  * bad-named-html-entity-multiple-encoding
          //  * bad-malformed-numeric-character-entity
          //  * encoded-html-entity-nbsp
          //  * encoded-numeric-html-entity-reference
          res[ruleName] = opts["bad-html-entity"];
        });
      } // then, a-la Object.assign the rest


      Object.keys(opts).forEach(function (ruleName) {
        if (!["all", "tag", "tag*", "tag-*", "attribute", "attribute*", "attribute-*", "bad-character", "bad-character", "bad-character*", "bad-character-*", "bad-html-entity"].includes(ruleName)) {
          // now, it depends is an exact rule name is being queried or is it wildcard
          if (Object.keys(builtInRules).includes(ruleName)) {
            res[ruleName] = lodash_clonedeep(opts[ruleName]);
          } else if (ruleName.includes("*")) {
            Object.keys(builtInRules).forEach(function (builtInRule) {
              if (matcher.isMatch(builtInRule, ruleName)) {
                res[builtInRule] = lodash_clonedeep(opts[ruleName]);
              }
            });
          } // TODO - else clause error messaging - rule is configured but not available

        }
      });
    }

    return res;
  }

  var toString = {}.toString;

  var isarray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  var isobject = function isObject(val) {
    return val != null && typeof val === 'object' && isarray(val) === false;
  };

  var lineColumn = LineColumnFinder;
  /**
   * Finder for index and line-column from given string.
   *
   * You can call this without `new` operator as it returns an instance anyway.
   *
   * @class
   * @param {string} str - A string to be parsed.
   * @param {Object|number} [options] - Options.
   *     This can be an index in the string for shorthand of `lineColumn(str, index)`.
   * @param {number} [options.origin=1] - The origin value of line and column.
   */

  function LineColumnFinder(str, options) {
    if (!(this instanceof LineColumnFinder)) {
      if (typeof options === "number") {
        return new LineColumnFinder(str).fromIndex(options);
      }

      return new LineColumnFinder(str, options);
    }

    this.str = str || "";
    this.lineToIndex = buildLineToIndex(this.str);
    options = options || {};
    this.origin = typeof options.origin === "undefined" ? 1 : options.origin;
  }
  /**
   * Find line and column from index in the string.
   *
   * @param  {number} index - Index in the string. (0-origin)
   * @return {Object|null}
   *     Found line number and column number in object `{ line: X, col: Y }`.
   *     If the given index is out of range, it returns `null`.
   */


  LineColumnFinder.prototype.fromIndex = function (index) {
    if (index < 0 || index >= this.str.length || isNaN(index)) {
      return null;
    }

    var line = findLowerIndexInRangeArray(index, this.lineToIndex);
    return {
      line: line + this.origin,
      col: index - this.lineToIndex[line] + this.origin
    };
  };
  /**
   * Find index from line and column in the string.
   *
   * @param  {number|Object|Array} line - Line number in the string.
   *     This can be an Object of `{ line: X, col: Y }`, or
   *     an Array of `[line, col]`.
   * @param  {number} [column] - Column number in the string.
   *     This must be omitted or undefined when Object or Array is given
   *     to the first argument.
   * @return {number}
   *     Found index in the string. (always 0-origin)
   *     If the given line or column is out of range, it returns `-1`.
   */


  LineColumnFinder.prototype.toIndex = function (line, column) {
    if (typeof column === "undefined") {
      if (isarray(line) && line.length >= 2) {
        return this.toIndex(line[0], line[1]);
      }

      if (isobject(line) && "line" in line && ("col" in line || "column" in line)) {
        return this.toIndex(line.line, "col" in line ? line.col : line.column);
      }

      return -1;
    }

    if (isNaN(line) || isNaN(column)) {
      return -1;
    }

    line -= this.origin;
    column -= this.origin;

    if (line >= 0 && column >= 0 && line < this.lineToIndex.length) {
      var lineIndex = this.lineToIndex[line];
      var nextIndex = line === this.lineToIndex.length - 1 ? this.str.length : this.lineToIndex[line + 1];

      if (column < nextIndex - lineIndex) {
        return lineIndex + column;
      }
    }

    return -1;
  };
  /**
   * Build an array of indexes of each line from a string.
   *
   * @private
   * @param   str {string}  An input string.
   * @return  {number[]}    Built array of indexes. The key is line number.
   */


  function buildLineToIndex(str) {
    var lines = str.split("\n"),
        lineToIndex = new Array(lines.length),
        index = 0;

    for (var i = 0, l = lines.length; i < l; i++) {
      lineToIndex[i] = index;
      index += lines[i].length +
      /* "\n".length */
      1;
    }

    return lineToIndex;
  }
  /**
   * Find a lower-bound index of a value in a sorted array of ranges.
   *
   * Assume `arr = [0, 5, 10, 15, 20]` and
   * this returns `1` for `value = 7` (5 <= value < 10),
   * and returns `3` for `value = 18` (15 <= value < 20).
   *
   * @private
   * @param  arr   {number[]} An array of values representing ranges.
   * @param  value {number}   A value to be searched.
   * @return {number} Found index. If not found `-1`.
   */


  function findLowerIndexInRangeArray(value, arr) {
    if (value >= arr[arr.length - 1]) {
      return arr.length - 1;
    }

    var min = 0,
        max = arr.length - 2,
        mid;

    while (min < max) {
      mid = min + (max - min >> 1);

      if (value < arr[mid]) {
        max = mid - 1;
      } else if (value >= arr[mid + 1]) {
        min = mid + 1;
      } else {
        // value >= arr[mid] && value < arr[mid + 1]
        min = mid;
        break;
      }
    }

    return min;
  }

  /**
   * is-html-tag-opening
   * Is given opening bracket a beginning of a tag?
   * Version: 1.7.2
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/is-html-tag-opening
   */
  const BACKSLASH$4 = "\u005C";
  const knownHtmlTags = ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "doctype", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h1 - h6", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "math", "menu", "menuitem", "meta", "meter", "nav", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xml"];

  function isStr$3(something) {
    return typeof something === "string";
  }

  function isNotLetter(char) {
    return char === undefined || char.toUpperCase() === char.toLowerCase() && !`0123456789`.includes(char) && char !== "=";
  }

  function isOpening(str, idx = 0, originalOpts) {
    const defaults = {
      allowCustomTagNames: false,
      skipOpeningBracket: false
    };
    const opts = Object.assign({}, defaults, originalOpts);
    const whitespaceChunk = `[\\\\ \\t\\r\\n/]*`;
    const generalChar = `._a-z0-9\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\uFFFF`;
    const r1 = new RegExp(`^${opts.skipOpeningBracket ? "" : "<"}${whitespaceChunk}\\w+${whitespaceChunk}>`, "g");
    const r5 = new RegExp(`^${opts.skipOpeningBracket ? "" : "<"}${whitespaceChunk}[${generalChar}]+[-${generalChar}]*${whitespaceChunk}>`, "g");
    const r2 = new RegExp(`^${opts.skipOpeningBracket ? "" : "<"}\\s*\\w+\\s+\\w+(?:-\\w+)?\\s*=\\s*['"\\w]`, "g");
    const r6 = new RegExp(`^${opts.skipOpeningBracket ? "" : "<"}\\s*\\w+\\s+[${generalChar}]+[-${generalChar}]*(?:-\\w+)?\\s*=\\s*['"\\w]`);
    const r3 = new RegExp(`^${opts.skipOpeningBracket ? "" : "<"}\\s*\\/?\\s*\\w+\\s*\\/?\\s*>`, "g");
    const r7 = new RegExp(`^${opts.skipOpeningBracket ? "" : "<"}\\s*\\/?\\s*[${generalChar}]+[-${generalChar}]*\\s*\\/?\\s*>`, "g");
    const r4 = new RegExp(`^${opts.skipOpeningBracket ? "" : "<"}${whitespaceChunk}\\w+(?:\\s*\\w+)*\\s*\\w+=['"]`, "g");
    const r8 = new RegExp(`^${opts.skipOpeningBracket ? "" : "<"}${whitespaceChunk}[${generalChar}]+[-${generalChar}]*(?:\\s*\\w+)*\\s*\\w+=['"]`, "g");
    const whatToTest = idx ? str.slice(idx) : str;
    let passed = false;
    const matchingOptions = {
      cb: isNotLetter,
      i: true,
      trimCharsBeforeMatching: ["/", BACKSLASH$4, "!", " ", "\t", "\n", "\r"]
    };

    if (opts.allowCustomTagNames) {
      if (r5.test(whatToTest)) {
        passed = true;
      } else if (r6.test(whatToTest)) {
        passed = true;
      } else if (r7.test(whatToTest)) {
        passed = true;
      } else if (r8.test(whatToTest)) {
        passed = true;
      }
    } else if (matchRightIncl(str, idx, knownHtmlTags, {
      cb: isNotLetter,
      i: true,
      trimCharsBeforeMatching: ["<", "/", BACKSLASH$4, "!", " ", "\t", "\n", "\r"]
    })) {
      if (r1.test(whatToTest)) {
        passed = true;
      } else if (r2.test(whatToTest)) {
        passed = true;
      } else if (r3.test(whatToTest)) {
        passed = true;
      } else if (r4.test(whatToTest)) {
        passed = true;
      }
    }

    if (!passed && !opts.skipOpeningBracket && str[idx] === "<" && str[idx + 1].trim().length && matchRight(str, idx, knownHtmlTags, matchingOptions)) {
      passed = true;
    }

    const res = isStr$3(str) && idx < str.length && passed;
    return res;
  }

  /**
   * codsen-tokenizer
   * HTML Lexer aimed at erroneous code
   * Version: 2.11.0
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/codsen-tokenizer
   */
  const allHTMLTagsKnownToHumanity = ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"];
  const espChars = `{}%-$_()*|`;
  const espLumpBlacklist = [")|(", "|(", ")(", "()", "{}", "%)", "*)", "**"];

  function isStr$4(something) {
    return typeof something === "string";
  }

  function isLatinLetter(char) {
    return isStr$4(char) && char.length === 1 && (char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91 || char.charCodeAt(0) > 96 && char.charCodeAt(0) < 123);
  }

  function charSuitableForTagName(char) {
    return /[.\-_a-z0-9\u00B7\u00C0-\uFFFD]/i.test(char);
  }

  function charSuitableForHTMLAttrName(char) {
    return isLatinLetter(char) || char.charCodeAt(0) >= 48 && char.charCodeAt(0) <= 57 || [":", "-"].includes(char);
  }

  function flipEspTag(str) {
    let res = "";

    for (let i = 0, len = str.length; i < len; i++) {
      if (str[i] === "[") {
        res = `]${res}`;
      } else if (str[i] === "{") {
        res = `}${res}`;
      } else if (str[i] === "(") {
        res = `)${res}`;
      } else {
        res = `${str[i]}${res}`;
      }
    }

    return res;
  }

  function isTagNameRecognised(tagName) {
    return allHTMLTagsKnownToHumanity.includes(tagName.toLowerCase()) || ["doctype", "cdata", "xml"].includes(tagName.toLowerCase());
  }

  function xBeforeYOnTheRight(str, startingIdx, x, y) {
    for (let i = startingIdx, len = str.length; i < len; i++) {
      if (str.startsWith(x, i)) {
        return true;
      } else if (str.startsWith(y, i)) {
        return false;
      }
    }

    return false;
  }

  function ensureXIsNotPresentBeforeOneOfY(str, startingIdx, x, y = []) {
    for (let i = startingIdx, len = str.length; i < len; i++) {
      if (y.some(oneOfStr => str.startsWith(oneOfStr, i))) {
        return true;
      } else if (str[i] === x) {
        return false;
      }
    }

    return true;
  }

  function startsEsp(str, i, token, layers, styleStarts) {
    return espChars.includes(str[i]) && str[i + 1] && espChars.includes(str[i + 1]) && token.type !== "rule" && token.type !== "at" && !(str[i] === "-" && "-{(".includes(str[i + 1])) && !("})".includes(str[i]) && "-".includes(str[i + 1])) && !("0123456789".includes(str[left(str, i)]) && (!str[i + 2] || [`"`, `'`, ";"].includes(str[i + 2]) || !str[i + 2].trim().length)) && !(styleStarts && ("{}".includes(str[i]) || "{}".includes(str[right(str, i)])));
  }

  const BACKSLASH$5 = "\u005C";

  function startsTag(str, i, token, layers) {
    return str[i] && str[i].trim().length && (!layers.length || token.type === "text") && !["doctype", "xml"].includes(token.kind) && (str[i] === "<" && (isOpening(str, i, {
      allowCustomTagNames: true
    }) || str[right(str, i)] === ">" || matchRight(str, i, ["doctype", "xml", "cdata"], {
      i: true,
      trimBeforeMatching: true,
      trimCharsBeforeMatching: ["?", "!", "[", " ", "-"]
    })) || isLatinLetter(str[i]) && (!str[i - 1] || !isLatinLetter(str[i - 1]) && !["<", "/", "!", BACKSLASH$5].includes(str[left(str, i)])) && isOpening(str, i, {
      allowCustomTagNames: false,
      skipOpeningBracket: true
    })) && (token.type !== "esp" || token.tail.includes(str[i]));
  }

  function startsComment(str, i, token) {
    return (str[i] === "<" && (matchRight(str, i, ["!--"], {
      maxMismatches: 1,
      firstMustMatch: true,
      trimBeforeMatching: true
    }) || matchRight(str, i, ["![endif]"], {
      i: true,
      maxMismatches: 2,
      trimBeforeMatching: true
    })) && !matchRight(str, i, ["![cdata", "<"], {
      i: true,
      maxMismatches: 1,
      trimBeforeMatching: true
    }) && (token.type !== "comment" || token.kind !== "not") || str[i] === "-" && matchRight(str, i, ["->"], {
      trimBeforeMatching: true
    }) && (token.type !== "comment" || !token.closing && token.kind !== "not") && !matchLeft(str, i, "<", {
      trimBeforeMatching: true,
      trimCharsBeforeMatching: ["-", "!"]
    })) && (token.type !== "esp" || token.tail.includes(str[i]));
  }

  function attributeEnds(str, i, attrib) {
    return attrib.attribOpeningQuoteAt === null || str[attrib.attribOpeningQuoteAt] === str[i] || `'"`.includes(str[attrib.attribOpeningQuoteAt]) && (!xBeforeYOnTheRight(str, i, str[attrib.attribOpeningQuoteAt], "=") || str.includes(">", i) && Array.from(str.slice(i + 1, str.indexOf(">"))).reduce((acc, curr) => {
      return acc + (`'"`.includes(curr) ? 1 : 0);
    }, 0) % 2 == 0 && attrib.attribOpeningQuoteAt + 1 < i && str.slice(attrib.attribOpeningQuoteAt + 1, i).trim().length && (ensureXIsNotPresentBeforeOneOfY(str, i, str[attrib.attribOpeningQuoteAt], [">", `="`, `='`]) || ensureXIsNotPresentBeforeOneOfY(str, i, "=", [">"])));
  }

  function isObj$4(something) {
    return something && typeof something === "object" && !Array.isArray(something);
  }

  const voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"];
  const charsThatEndCSSChunks = ["{", "}", ","];

  function tokenizer(str, originalOpts) {
    const start = Date.now();

    if (!isStr$4(str)) {
      if (str === undefined) {
        throw new Error("codsen-tokenizer: [THROW_ID_01] the first input argument is completely missing! It should be given as string.");
      } else {
        throw new Error(`codsen-tokenizer: [THROW_ID_02] the first input argument must be string! It was given as "${typeof str}", equal to:\n${JSON.stringify(str, null, 4)}`);
      }
    }

    if (originalOpts && !isObj$4(originalOpts)) {
      throw new Error(`codsen-tokenizer: [THROW_ID_03] the second input argument, an options object, should be a plain object but it was given as type ${typeof originalOpts}, equal to ${JSON.stringify(originalOpts, null, 4)}`);
    }

    if (isObj$4(originalOpts) && originalOpts.tagCb && typeof originalOpts.tagCb !== "function") {
      throw new Error(`codsen-tokenizer: [THROW_ID_04] the opts.tagCb, callback function, should be a function but it was given as type ${typeof originalOpts.tagCb}, equal to ${JSON.stringify(originalOpts.tagCb, null, 4)}`);
    }

    if (isObj$4(originalOpts) && originalOpts.charCb && typeof originalOpts.charCb !== "function") {
      throw new Error(`codsen-tokenizer: [THROW_ID_05] the opts.charCb, callback function, should be a function but it was given as type ${typeof originalOpts.charCb}, equal to ${JSON.stringify(originalOpts.charCb, null, 4)}`);
    }

    if (isObj$4(originalOpts) && originalOpts.reportProgressFunc && typeof originalOpts.reportProgressFunc !== "function") {
      throw new Error(`codsen-tokenizer: [THROW_ID_06] the opts.reportProgressFunc, callback function, should be a function but it was given as type ${typeof originalOpts.reportProgressFunc}, equal to ${JSON.stringify(originalOpts.reportProgressFunc, null, 4)}`);
    }

    const defaults = {
      tagCb: null,
      tagCbLookahead: 0,
      charCb: null,
      charCbLookahead: 0,
      reportProgressFunc: null,
      reportProgressFuncFrom: 0,
      reportProgressFuncTo: 100
    };
    const opts = Object.assign({}, defaults, originalOpts);
    let currentPercentageDone;
    let lastPercentage = 0;
    const len = str.length;
    const midLen = Math.floor(len / 2);
    let doNothing;
    let styleStarts = false;
    const tagStash = [];
    const charStash = [];
    let token = {};
    const tokenDefault = {
      type: null,
      start: null,
      end: null
    };

    function tokenReset() {
      token = lodash_clonedeep(tokenDefault);
      attribReset();
      return token;
    }

    let attrib = {};
    const attribDefault = {
      attribName: null,
      attribNameRecognised: null,
      attribNameStartsAt: null,
      attribNameEndsAt: null,
      attribOpeningQuoteAt: null,
      attribClosingQuoteAt: null,
      attribValue: null,
      attribValueStartsAt: null,
      attribValueEndsAt: null,
      attribStart: null,
      attribEnd: null
    };

    function attribReset() {
      attrib = lodash_clonedeep(attribDefault);
    }

    tokenReset();
    attribReset();
    let selectorChunkStartedAt;
    let parentTokenToWrapAround;
    let layers = [];

    function matchLayerLast(str, i, matchFirstInstead) {
      if (!layers.length) {
        return false;
      }

      const whichLayerToMatch = matchFirstInstead ? layers[0] : layers[layers.length - 1];

      if (whichLayerToMatch.type === "simple") {
        return !whichLayerToMatch.value || str[i] === flipEspTag(whichLayerToMatch.value);
      } else if (whichLayerToMatch.type === "esp") {
        if (!espChars.includes(str[i])) {
          return false;
        }

        let wholeEspTagLump = "";
        const len = str.length;

        for (let y = i; y < len; y++) {
          if (espChars.includes(str[y])) {
            wholeEspTagLump = wholeEspTagLump + str[y];
          } else {
            break;
          }
        }

        if (wholeEspTagLump && whichLayerToMatch.openingLump && wholeEspTagLump.length > whichLayerToMatch.guessedClosingLump.length) {
          if (wholeEspTagLump.endsWith(whichLayerToMatch.openingLump)) {
            return wholeEspTagLump.length - whichLayerToMatch.openingLump.length;
          }

          let uniqueCharsListFromGuessedClosingLumpArr = new Set(whichLayerToMatch.guessedClosingLump);
          let found = 0;

          for (let y = 0, len2 = wholeEspTagLump.length; y < len2; y++) {
            if (!uniqueCharsListFromGuessedClosingLumpArr.has(wholeEspTagLump[y]) && found > 1) {
              return y;
            }

            if (uniqueCharsListFromGuessedClosingLumpArr.has(wholeEspTagLump[y])) {
              found++;
              uniqueCharsListFromGuessedClosingLumpArr = new Set([...uniqueCharsListFromGuessedClosingLumpArr].filter(el => el !== wholeEspTagLump[y]));
            }
          }
        } else if (whichLayerToMatch.guessedClosingLump.split("").every(char => wholeEspTagLump.includes(char))) {
          return wholeEspTagLump.length;
        }
      }
    }

    function matchLayerFirst(str, i) {
      return matchLayerLast(str, i, true);
    }

    function reportFirstFromStash(stash, cb, lookaheadLength) {
      const currentElem = stash.shift();
      const next = [];

      for (let i = 0; i < lookaheadLength; i++) {
        if (stash[i]) {
          next.push(lodash_clonedeep(stash[i]));
        } else {
          break;
        }
      }

      cb(currentElem, next);
    }

    function pingCharCb(incomingToken) {
      if (opts.charCb) {
        charStash.push(incomingToken);

        if (charStash.length > opts.charCbLookahead) {
          reportFirstFromStash(charStash, opts.charCb, opts.charCbLookahead);
        }
      }
    }

    function pingTagCb(incomingToken) {
      if (opts.tagCb) {
        tagStash.push(incomingToken);

        if (tagStash.length > opts.tagCbLookahead) {
          reportFirstFromStash(tagStash, opts.tagCb, opts.tagCbLookahead);
        }
      }
    }

    function dumpCurrentToken(token, i) {
      if (!["text", "esp"].includes(token.type) && token.start !== null && token.start < i && (str[i - 1] && !str[i - 1].trim().length || str[i] === "<")) {
        token.end = left(str, i) + 1;
        token.value = str.slice(token.start, token.end);

        if (token.type === "tag" && !"/>".includes(str[token.end - 1])) {
          let cutOffIndex = token.tagNameEndsAt || i;

          if (Array.isArray(token.attribs) && token.attribs.length) {
            for (let i = 0, len = token.attribs.length; i < len; i++) {
              if (token.attribs[i].attribNameRecognised) {
                cutOffIndex = token.attribs[i].attribEnd;

                if (str[cutOffIndex] && str[cutOffIndex + 1] && !str[cutOffIndex].trim().length && str[cutOffIndex + 1].trim().length) {
                  cutOffIndex++;
                }
              } else {
                if (i === 0) {
                  token.attribs = [];
                } else {
                  token.attribs = token.attribs.splice(0, i);
                }

                break;
              }
            }
          }

          token.end = cutOffIndex;
          token.value = str.slice(token.start, token.end);

          if (!token.tagNameEndsAt) {
            token.tagNameEndsAt = cutOffIndex;
          }

          if (Number.isInteger(token.tagNameStartsAt) && Number.isInteger(token.tagNameEndsAt) && !token.tagName) {
            token.tagName = str.slice(token.tagNameStartsAt, cutOffIndex);
            token.recognised = isTagNameRecognised(token.tagName);
          }

          pingTagCb(token);
          token = tokenReset();
          initToken("text", cutOffIndex);
        } else {
          pingTagCb(token);
          token = tokenReset();

          if (str[i - 1] && !str[i - 1].trim().length) {
            initToken("text", left(str, i) + 1);
          }
        }
      }

      if (token.start !== null) {
        if (token.end === null && token.start !== i) {
          token.end = i;
          token.value = str.slice(token.start, token.end);
        }

        if (token.start !== null && token.end !== null) {
          pingTagCb(token);
        }

        token = tokenReset();
      }
    }

    function atRuleWaitingForClosingCurlie() {
      return layers.length && layers[layers.length - 1].type === "at" && isObj$4(layers[layers.length - 1].token) && Number.isInteger(layers[layers.length - 1].token.openingCurlyAt) && !Number.isInteger(layers[layers.length - 1].token.closingCurlyAt);
    }

    function initToken(type, start) {
      attribReset();

      if (type === "tag") {
        token.type = type;
        token.start = start;
        token.end = null;
        token.value = null;
        token.tagNameStartsAt = null;
        token.tagNameEndsAt = null;
        token.tagName = null;
        token.recognised = null;
        token.closing = false;
        token.void = false;
        token.pureHTML = true;
        token.kind = null;
        token.attribs = [];
      } else if (type === "comment") {
        token.type = type;
        token.start = start;
        token.end = null;
        token.value = null;
        token.kind = "simple";
        token.closing = false;
      } else if (type === "rule") {
        token.type = type;
        token.start = start;
        token.end = null;
        token.value = null;
        token.openingCurlyAt = null;
        token.closingCurlyAt = null;
        token.selectorsStart = null;
        token.selectorsEnd = null;
        token.selectors = [];
      } else if (type === "at") {
        token.type = type;
        token.start = start;
        token.end = null;
        token.value = null;
        token.identifier = null;
        token.identifierStartsAt = null;
        token.identifierEndsAt = null;
        token.query = null;
        token.queryStartsAt = null;
        token.queryEndsAt = null;
        token.openingCurlyAt = null;
        token.closingCurlyAt = null;
      } else if (type === "text") {
        token.type = type;
        token.start = start;
        token.end = null;
        token.value = null;
      } else if (type === "esp") {
        token.type = type;
        token.start = start;
        token.end = null;
        token.value = null;
        token.head = null;
        token.tail = null;
        token.kind = null;
      }
    }

    for (let i = 0; i <= len; i++) {
      if (!doNothing && str[i] && opts.reportProgressFunc) {
        if (len > 1000 && len < 2000) {
          if (i === midLen) {
            opts.reportProgressFunc(Math.floor((opts.reportProgressFuncTo - opts.reportProgressFuncFrom) / 2));
          }
        } else if (len >= 2000) {
          currentPercentageDone = opts.reportProgressFuncFrom + Math.floor(i / len * (opts.reportProgressFuncTo - opts.reportProgressFuncFrom));

          if (currentPercentageDone !== lastPercentage) {
            lastPercentage = currentPercentageDone;
            opts.reportProgressFunc(currentPercentageDone);
          }
        }
      }

      if (styleStarts && token.type && !["rule", "at", "text"].includes(token.type)) {
        styleStarts = false;
      }

      if (Number.isInteger(doNothing) && i >= doNothing) {
        doNothing = false;
      }

      if (!doNothing && atRuleWaitingForClosingCurlie()) {
        if (str[i] === "}") {
          if (token.type === null || token.type === "text" || token.type === "rule" && token.openingCurlyAt === null) {
            if (token.type === "rule") {
              token.end = left(str, i) + 1;
              token.value = str.slice(token.start, token.end);
              pingTagCb(token);
              token = tokenReset();

              if (left(str, i) < i - 1) {
                initToken("text", left(str, i) + 1);
              }
            }

            dumpCurrentToken(token, i);
            const poppedToken = layers.pop();
            token = poppedToken.token;
            token.closingCurlyAt = i;
            token.end = i + 1;
            token.value = str.slice(token.start, token.end);
            pingTagCb(token);
            token = tokenReset();
            doNothing = i + 1;
          }
        } else if (token.type === "text" && str[i] && str[i].trim().length) {
          token.end = i;
          token.value = str.slice(token.start, token.end);
          pingTagCb(token);
          token = tokenReset();
        }
      }

      if (token.end && token.end === i) {
        if (token.tagName === "style" && !token.closing) {
          styleStarts = true;
        }

        dumpCurrentToken(token, i);
        layers = [];
      }

      if (!doNothing) {
        if (["tag", "esp", "rule", "at"].includes(token.type) && token.kind !== "cdata") {
          if ([`"`, `'`, `(`, `)`].includes(str[i]) && !([`"`, `'`].includes(str[left(str, i)]) && str[left(str, i)] === str[right(str, i)])) {
            if (matchLayerLast(str, i)) {
              layers.pop();
            } else {
              layers.push({
                type: "simple",
                value: str[i],
                position: i
              });
            }
          }
        } else if (token.type === "comment" && ["only", "not"].includes(token.kind)) {
          if ([`[`, `]`].includes(str[i])) {
            if (matchLayerLast(str, i)) {
              layers.pop();
            } else {
              layers.push({
                type: "simple",
                value: str[i],
                position: i
              });
            }
          }
        }
      }

      if (!doNothing && token.type === "at" && Number.isInteger(token.start) && i >= token.start && !Number.isInteger(token.identifierStartsAt) && str[i] && str[i].trim().length && str[i] !== "@") {
        token.identifierStartsAt = i;
      }

      if (!doNothing && token.type === "at" && Number.isInteger(token.queryStartsAt) && !Number.isInteger(token.queryEndsAt) && "{};".includes(str[i])) {
        if (str[i - 1] && str[i - 1].trim().length) {
          token.queryEndsAt = i;
        } else {
          token.queryEndsAt = left(str, i) + 1;
        }

        token.query = str.slice(token.queryStartsAt, token.queryEndsAt);
      }

      if (!doNothing && token.type === "at" && str[i] === "{" && token.identifier && !Number.isInteger(token.openingCurlyAt)) {
        token.openingCurlyAt = i;
        layers.push({
          type: "at",
          token
        });
        const charIdxOnTheRight = right(str, i);

        if (str[charIdxOnTheRight] === "}") {
          token.closingCurlyAt = charIdxOnTheRight;
          pingTagCb(token);
          doNothing = charIdxOnTheRight;
        } else {
          tokenReset();

          if (charIdxOnTheRight > i + 1) {
            initToken("text", i + 1);
            token.end = charIdxOnTheRight;
            token.value = str.slice(token.start, token.end);
            pingTagCb(token);
          }

          tokenReset();
          initToken("rule", charIdxOnTheRight);
          doNothing = charIdxOnTheRight;
        }
      }

      if (!doNothing && token.type === "at" && token.identifier && str[i] && str[i].trim().length && !Number.isInteger(token.queryStartsAt)) {
        token.queryStartsAt = i;
      }

      if (!doNothing && token.type === "at" && Number.isInteger(token.identifierStartsAt) && i >= token.start && str[i] && (!str[i].trim().length || "()".includes(str[i])) && !Number.isInteger(token.identifierEndsAt)) {
        token.identifierEndsAt = i;
        token.identifier = str.slice(token.identifierStartsAt, i);
      }

      if (token.type === "rule" && Number.isInteger(selectorChunkStartedAt) && (charsThatEndCSSChunks.includes(str[i]) || str[i] && !str[i].trim().length && charsThatEndCSSChunks.includes(str[right(str, i)]))) {
        token.selectors.push({
          value: str.slice(selectorChunkStartedAt, i),
          selectorStarts: selectorChunkStartedAt,
          selectorEnds: i
        });
        selectorChunkStartedAt = undefined;
        token.selectorsEnd = i;
      }

      if (!doNothing) {
        if (startsTag(str, i, token, layers)) {
          if (token.type && token.start !== null) {
            dumpCurrentToken(token, i);
            tokenReset();
          }

          initToken("tag", i);

          if (styleStarts) {
            styleStarts = false;
          }

          if (matchRight(str, i, "doctype", {
            i: true,
            trimCharsBeforeMatching: ["?", "!", "[", " ", "-"]
          })) {
            token.kind = "doctype";
          } else if (matchRight(str, i, "cdata", {
            i: true,
            trimCharsBeforeMatching: ["?", "!", "[", " ", "-"]
          })) {
            token.kind = "cdata";
          } else if (matchRight(str, i, "xml", {
            i: true,
            trimCharsBeforeMatching: ["?", "!", "[", " ", "-"]
          })) {
            token.kind = "xml";
          }
        } else if (startsComment(str, i, token)) {
          if (Number.isInteger(token.start)) {
            dumpCurrentToken(token, i);
          }

          tokenReset();
          initToken("comment", i);

          if (str[i] === "-") {
            token.closing = true;
          } else if (matchRightIncl(str, i, ["<![endif]-->"], {
            i: true,
            trimBeforeMatching: true,
            maxMismatches: 2
          })) {
            token.closing = true;
            token.kind = "only";
          }

          if (styleStarts) {
            styleStarts = false;
          }
        } else if (startsEsp(str, i, token, layers, styleStarts)) {
          let wholeEspTagLump = "";

          for (let y = i; y < len; y++) {
            if (espChars.includes(str[y])) {
              wholeEspTagLump = wholeEspTagLump + str[y];
            } else {
              break;
            }
          }

          if (!espLumpBlacklist.includes(wholeEspTagLump) && (!Array.isArray(layers) || !layers.length || layers[layers.length - 1].type !== "simple" || layers[layers.length - 1].value !== str[i + wholeEspTagLump.length])) {
            let lengthOfClosingEspChunk;

            if (layers.length && matchLayerLast(str, i)) {
              lengthOfClosingEspChunk = matchLayerLast(str, i);

              if (token.type === "esp") {
                if (!Number.isInteger(token.end)) {
                  token.end = i + lengthOfClosingEspChunk;
                  token.value = str.slice(token.start, token.end);
                }

                if (parentTokenToWrapAround) {
                  if (!Array.isArray(parentTokenToWrapAround.attribs)) {
                    parentTokenToWrapAround.attribs = [];
                  }

                  parentTokenToWrapAround.attribs.push(lodash_clonedeep(token));
                  token = lodash_clonedeep(parentTokenToWrapAround);
                  parentTokenToWrapAround = undefined;
                  layers.pop();
                  continue;
                } else {
                  dumpCurrentToken(token, i);
                }

                tokenReset();
              }

              layers.pop();
            } else if (layers.length && matchLayerFirst(str, i)) {
              lengthOfClosingEspChunk = matchLayerFirst(str, i);

              if (token.type === "esp") {
                if (!Number.isInteger(token.end)) {
                  token.end = i + lengthOfClosingEspChunk;
                  token.value = str.slice(token.start, token.end);
                }

                dumpCurrentToken(token, i);
                tokenReset();
              }

              layers = [];
            } else {
              layers.push({
                type: "esp",
                openingLump: wholeEspTagLump,
                guessedClosingLump: flipEspTag(wholeEspTagLump),
                position: i
              });

              if (token.start !== null) {
                if (token.type === "tag") {
                  if (!token.tagName || !token.tagNameEndsAt) {
                    token.tagNameEndsAt = i;
                    token.tagName = str.slice(token.tagNameStartsAt, i);
                    token.recognised = isTagNameRecognised(token.tagName);
                  }

                  parentTokenToWrapAround = lodash_clonedeep(token);
                } else {
                  dumpCurrentToken(token, i);
                }
              }

              initToken("esp", i);
              token.tail = flipEspTag(wholeEspTagLump);
              token.head = wholeEspTagLump;
            }

            doNothing = i + (lengthOfClosingEspChunk ? lengthOfClosingEspChunk : wholeEspTagLump.length);
          }
        } else if (token.start === null || token.end === i) {
          if (styleStarts) {
            if (str[i] && !str[i].trim().length) {
              tokenReset();
              initToken("text", i);
              token.end = right(str, i) || str.length;
              token.value = str.slice(token.start, token.end);
              pingTagCb(token);
              doNothing = token.end;
              tokenReset();

              if (right(str, i) && !["{", "}", "<"].includes(str[right(str, i)])) {
                const idxOnTheRight = right(str, i);
                initToken(str[idxOnTheRight] === "@" ? "at" : "rule", idxOnTheRight);

                if (str[i + 1] && !str[i + 1].trim().length) {
                  doNothing = right(str, i);
                }
              }
            } else if (str[i]) {
              tokenReset();

              if ("}".includes(str[i])) {
                initToken("text", i);
                doNothing = i + 1;
              } else {
                initToken(str[i] === "@" ? "at" : "rule", i);
              }
            }
          } else if (str[i]) {
            if (i) {
              token = tokenReset();
            }

            initToken("text", i);
          }
        } else if (token.type === "text" && styleStarts && str[i] && str[i].trim().length && !"{},".includes(str[i])) {
          dumpCurrentToken(token, i);
          tokenReset();
          initToken("rule", i);
        }
      }

      if (!doNothing && token.type === "rule" && str[i] && str[i].trim().length && !"{}".includes(str[i]) && !Number.isInteger(selectorChunkStartedAt) && !Number.isInteger(token.openingCurlyAt)) {
        if (!",".includes(str[i])) {
          selectorChunkStartedAt = i;

          if (token.selectorsStart === null) {
            token.selectorsStart = i;
          }
        } else {
          token.selectorsEnd = i + 1;
        }
      }

      if (token.type === "comment" && ["only", "not"].includes(token.kind)) {
        if (str[i] === "[") ;
      }

      if (!doNothing) {
        if (token.type === "tag" && !layers.length && str[i] === ">") {
          token.end = i + 1;
          token.value = str.slice(token.start, token.end);
        } else if (token.type === "comment" && !layers.length && token.kind === "simple" && (str[token.start] === "<" && str[i] === "-" && (matchLeft(str, i, "!-", {
          trimBeforeMatching: true
        }) || matchLeftIncl(str, i, "!-", {
          trimBeforeMatching: true
        }) && str[i + 1] !== "-") || str[token.start] === "-" && str[i] === ">" && matchLeft(str, i, "--", {
          trimBeforeMatching: true,
          maxMismatches: 1
        }))) {
          if (str[i] === "-" && (matchRight(str, i, ["[if", "(if", "{if"], {
            i: true,
            trimBeforeMatching: true
          }) || matchRight(str, i, ["if"], {
            i: true,
            trimBeforeMatching: true
          }) && (xBeforeYOnTheRight(str, i, "]", ">") || str.includes("mso", i) && !str.slice(i, str.indexOf("mso")).includes("<") && !str.slice(i, str.indexOf("mso")).includes(">")))) {
            token.kind = "only";
          } else if (str[token.start] !== "-" && matchRightIncl(str, i, ["-<![endif"], {
            i: true,
            trimBeforeMatching: true,
            maxMismatches: 2
          })) {
            token.kind = "not";
            token.closing = true;
          } else if (token.kind === "simple" && !token.closing && str[right(str, i)] === ">") {
            token.end = right(str, i) + 1;
            token.kind = "simplet";
            token.closing = null;
          } else {
            token.end = i + 1;

            if (str[left(str, i)] === "!" && str[right(str, i)] === "-") {
              token.end = right(str, i) + 1;
            }

            token.value = str.slice(token.start, token.end);
          }
        } else if (token.type === "comment" && str[i] === ">" && (!layers.length || str[right(str, i)] === "<")) {
          if (Array.isArray(layers) && layers.length && layers[layers.length - 1].value === "[") {
            layers.pop();
          }

          if (!["simplet", "not"].includes(token.kind) && matchRight(str, i, ["<!-->", "<!---->"], {
            trimBeforeMatching: true,
            maxMismatches: 1,
            lastMustMatch: true
          })) {
            token.kind = "not";
          } else {
            token.end = i + 1;
            token.value = str.slice(token.start, token.end);
          }
        } else if (token.type === "esp" && token.end === null && isStr$4(token.tail) && token.tail.includes(str[i])) {
          let wholeEspTagClosing = "";

          for (let y = i; y < len; y++) {
            if (espChars.includes(str[y])) {
              wholeEspTagClosing = wholeEspTagClosing + str[y];
            } else {
              break;
            }
          }

          if (wholeEspTagClosing.length > token.head.length) {
            const headsFirstChar = token.head[0];

            if (wholeEspTagClosing.endsWith(token.head)) {
              token.end = i + wholeEspTagClosing.length - token.head.length;
              token.value = str.slice(token.start, token.end);
              doNothing = token.end;
            } else if (wholeEspTagClosing.startsWith(token.tail)) {
              token.end = i + token.tail.length;
              token.value = str.slice(token.start, token.end);
              doNothing = token.end;
            } else if (!token.tail.includes(headsFirstChar) && wholeEspTagClosing.includes(headsFirstChar) || wholeEspTagClosing.endsWith(token.head) || wholeEspTagClosing.startsWith(token.tail)) {
              const firstPartOfWholeEspTagClosing = wholeEspTagClosing.slice(0, wholeEspTagClosing.indexOf(headsFirstChar));
              const secondPartOfWholeEspTagClosing = wholeEspTagClosing.slice(wholeEspTagClosing.indexOf(headsFirstChar));

              if (firstPartOfWholeEspTagClosing.length && secondPartOfWholeEspTagClosing.length && token.tail.split("").every(char => firstPartOfWholeEspTagClosing.includes(char))) {
                token.end = i + firstPartOfWholeEspTagClosing.length;
                token.value = str.slice(token.start, token.end);
                doNothing = token.end;
              }
            } else {
              token.end = i + wholeEspTagClosing.length;
              token.value = str.slice(token.start, token.end);
              doNothing = token.end;
            }
          } else {
            token.end = i + wholeEspTagClosing.length;
            token.value = str.slice(token.start, token.end);
            doNothing = token.end;
          }
        }
      }

      if (!doNothing && token.type === "tag" && Number.isInteger(token.tagNameStartsAt) && !Number.isInteger(token.tagNameEndsAt)) {
        if (!str[i] || !charSuitableForTagName(str[i])) {
          token.tagNameEndsAt = i;
          token.tagName = str.slice(token.tagNameStartsAt, i).toLowerCase();

          if (token.tagName === "xml" && token.closing && !token.kind) {
            token.kind = "xml";
          }

          if (voidTags.includes(token.tagName)) {
            token.void = true;
          }

          token.recognised = isTagNameRecognised(token.tagName);
        }
      }

      if (!doNothing && token.type === "tag" && !Number.isInteger(token.tagNameStartsAt) && Number.isInteger(token.start) && (token.start < i || str[token.start] !== "<")) {
        if (str[i] === "/") {
          token.closing = true;
        } else if (isLatinLetter(str[i])) {
          token.tagNameStartsAt = i;

          if (!token.closing) {
            token.closing = false;
          }
        }
      }

      if (!doNothing && token.type === "tag" && token.kind !== "cdata" && Number.isInteger(attrib.attribNameStartsAt) && i > attrib.attribNameStartsAt && attrib.attribNameEndsAt === null && !charSuitableForHTMLAttrName(str[i])) {
        attrib.attribNameEndsAt = i;
        attrib.attribName = str.slice(attrib.attribNameStartsAt, i);
        attrib.attribNameRecognised = allHtmlAttribs.includes(attrib.attribName);
        if (str[i] && !str[i].trim().length && str[right(str, i)] === "=") ;else if (str[i] && !str[i].trim().length || str[i] === ">" || str[i] === "/" && str[right(str, i)] === ">") {
          if (`'"`.includes(str[right(str, i)])) ;else {
            attrib.attribEnd = i;
            token.attribs.push(lodash_clonedeep(attrib));
            attribReset();
          }
        }
      }

      if (!doNothing && str[i] && token.type === "tag" && token.kind !== "cdata" && Number.isInteger(token.tagNameEndsAt) && i > token.tagNameEndsAt && attrib.attribStart === null && charSuitableForHTMLAttrName(str[i])) {
        attrib.attribStart = i;
        attrib.attribNameStartsAt = i;
      }

      if (!doNothing && token.type === "rule") {
        if (str[i] === "{" && !Number.isInteger(token.openingCurlyAt)) {
          token.openingCurlyAt = i;
        } else if (str[i] === "}" && Number.isInteger(token.openingCurlyAt) && !Number.isInteger(token.closingCurlyAt)) {
          token.closingCurlyAt = i;
          token.end = i + 1;
          token.value = str.slice(token.start, token.end);
          pingTagCb(token);
          tokenReset();
        }
      }

      if (!doNothing && token.type === "tag" && Number.isInteger(attrib.attribValueStartsAt) && i >= attrib.attribValueStartsAt && attrib.attribValueEndsAt === null) {
        if (`'"`.includes(str[i])) {
          if (str[left(str, i)] === str[i] && !`/>${espChars}`.includes(str[right(str, i)]) && !xBeforeYOnTheRight(str, i, "=", `"`) && !xBeforeYOnTheRight(str, i, "=", `'`) && (xBeforeYOnTheRight(str, i, `"`, `>`) || xBeforeYOnTheRight(str, i, `'`, `>`)) && (!str.slice(i + 1).includes("<") || !str.slice(0, str.indexOf("<")).includes("="))) {
            attrib.attribOpeningQuoteAt = i;
            attrib.attribValueStartsAt = i + 1;
            layers.push({
              type: "simple",
              value: str[i],
              position: i
            });
          } else if (!layers.some(layerObj => layerObj.type === "esp") && attributeEnds(str, i, attrib)) {
            attrib.attribClosingQuoteAt = i;
            attrib.attribValueEndsAt = i;

            if (Number.isInteger(attrib.attribValueStartsAt)) {
              attrib.attribValue = str.slice(attrib.attribValueStartsAt, i);
            }

            attrib.attribEnd = i + 1;

            if (str[attrib.attribOpeningQuoteAt] !== str[i]) {
              layers.pop();
              layers.pop();
            }

            token.attribs.push(lodash_clonedeep(attrib));
            attribReset();
          }
        } else if (attrib.attribOpeningQuoteAt === null && (str[i] && !str[i].trim().length || ["/", ">"].includes(str[i]) || espChars.includes(str[i]) && espChars.includes(str[i + 1]))) {
          attrib.attribValueEndsAt = i;
          attrib.attribValue = str.slice(attrib.attribValueStartsAt, i);
          attrib.attribEnd = i;
          token.attribs.push(lodash_clonedeep(attrib));
          attribReset();
          layers.pop();

          if (str[i] === ">") {
            token.end = i + 1;
            token.value = str.slice(token.start, token.end);
          }
        } else if (str[i] === "=" && (`'"`.includes(str[right(str, i)]) || str[i - 1] && isLatinLetter(str[i - 1]))) {
          let whitespaceFound;
          let attribClosingQuoteAt;

          for (let y = left(str, i); y >= attrib.attribValueStartsAt; y--) {
            if (!whitespaceFound && str[y] && !str[y].trim().length) {
              whitespaceFound = true;

              if (attribClosingQuoteAt) {
                const extractedChunksVal = str.slice(y, attribClosingQuoteAt);
              }
            }

            if (whitespaceFound && str[y] && str[y].trim().length) {
              whitespaceFound = false;

              if (!attribClosingQuoteAt) {
                attribClosingQuoteAt = y + 1;
              }
            }
          }

          if (attribClosingQuoteAt) {
            attrib.attribValueEndsAt = attribClosingQuoteAt;

            if (Number.isInteger(attrib.attribValueStartsAt)) {
              attrib.attribValue = str.slice(attrib.attribValueStartsAt, attribClosingQuoteAt);
            }

            attrib.attribEnd = attribClosingQuoteAt;

            if (str[attrib.attribOpeningQuoteAt] !== str[i]) {
              layers.pop();
            }

            token.attribs.push(lodash_clonedeep(attrib));
            attribReset();
            i = attribClosingQuoteAt - 1;
            continue;
          } else if (attrib.attribOpeningQuoteAt && (`'"`.includes(str[right(str, i)]) || allHtmlAttribs.includes(str.slice(attrib.attribOpeningQuoteAt + 1, i).trim()))) {
            i = attrib.attribOpeningQuoteAt;
            attrib.attribEnd = attrib.attribOpeningQuoteAt + 1;
            attrib.attribValueStartsAt = null;
            layers.pop();
            token.attribs.push(lodash_clonedeep(attrib));
            attribReset();
            continue;
          }
        }
      }

      if (!doNothing && token.type === "tag" && !Number.isInteger(attrib.attribValueStartsAt) && Number.isInteger(attrib.attribNameEndsAt) && attrib.attribNameEndsAt <= i && str[i] && str[i].trim().length) {
        if (str[i] === "=" && !`'"=`.includes(str[right(str, i)]) && !espChars.includes(str[right(str, i)])) {
          const firstCharOnTheRight = right(str, i);
          const firstQuoteOnTheRightIdx = [str.indexOf(`'`, firstCharOnTheRight), str.indexOf(`"`, firstCharOnTheRight)].filter(val => val > 0).length ? Math.min(...[str.indexOf(`'`, firstCharOnTheRight), str.indexOf(`"`, firstCharOnTheRight)].filter(val => val > 0)) : undefined;

          if (firstCharOnTheRight && str.slice(firstCharOnTheRight).includes("=") && allHtmlAttribs.includes(str.slice(firstCharOnTheRight, firstCharOnTheRight + str.slice(firstCharOnTheRight).indexOf("=")).trim().toLowerCase())) {
            attrib.attribEnd = i + 1;
            token.attribs.push(lodash_clonedeep(attrib));
            attribReset();
          } else if (!firstQuoteOnTheRightIdx || str.slice(firstCharOnTheRight, firstQuoteOnTheRightIdx).includes("=") || !str.includes(str[firstQuoteOnTheRightIdx], firstQuoteOnTheRightIdx + 1) || Array.from(str.slice(firstQuoteOnTheRightIdx + 1, str.indexOf(str[firstQuoteOnTheRightIdx], firstQuoteOnTheRightIdx + 1))).some(char => `<>=`.includes(char))) {
            attrib.attribValueStartsAt = firstCharOnTheRight;
            layers.push({
              type: "simple",
              value: null,
              position: attrib.attribValueStartsAt
            });
          }
        } else if (`'"`.includes(str[i])) {
          const nextCharIdx = right(str, i);

          if (nextCharIdx && `'"`.includes(str[nextCharIdx]) && str[i] !== str[nextCharIdx] && str.length > nextCharIdx + 2 && str.slice(nextCharIdx + 1).includes(str[nextCharIdx]) && (!str.indexOf(str[nextCharIdx], nextCharIdx + 1) || !right(str, str.indexOf(str[nextCharIdx], nextCharIdx + 1)) || str[i] !== str[right(str, str.indexOf(str[nextCharIdx], nextCharIdx + 1))]) && !Array.from(str.slice(nextCharIdx + 1, str.indexOf(str[nextCharIdx]))).some(char => `<>=${str[i]}`.includes(char))) {
            layers.pop();
          } else {
            attrib.attribOpeningQuoteAt = i;

            if (str[i + 1]) {
              attrib.attribValueStartsAt = i + 1;
            }
          }
        }
      }

      if (str[i] === ">" && token.type === "tag" && attrib.attribStart !== null && attrib.attribEnd === null) {
        let thisIsRealEnding = false;

        if (str[i + 1]) {
          for (let y = i + 1; y < len; y++) {
            if (attrib.attribOpeningQuoteAt !== null && str[y] === str[attrib.attribOpeningQuoteAt]) {
              if (y !== i + 1 && str[y - 1] !== "=") {
                thisIsRealEnding = true;
              }

              break;
            } else if (str[y] === ">") {
              break;
            } else if (str[y] === "<") {
              thisIsRealEnding = true;
              layers.pop();
              break;
            } else if (!str[y + 1]) {
              thisIsRealEnding = true;
              break;
            }
          }
        } else {
          thisIsRealEnding = true;
        }

        if (thisIsRealEnding) {
          token.end = i + 1;
          token.value = str.slice(token.start, token.end);

          if (Number.isInteger(attrib.attribValueStartsAt) && i && attrib.attribValueStartsAt < i && str.slice(attrib.attribValueStartsAt, i).trim().length) {
            attrib.attribValueEndsAt = i;
            attrib.attribValue = str.slice(attrib.attribValueStartsAt, i);
          } else {
            attrib.attribValueStartsAt = null;
          }

          attrib.attribEnd = i;
          token.attribs.push(lodash_clonedeep(attrib));
          attribReset();
        }
      }

      if (str[i] && opts.charCb) {
        pingCharCb({
          type: token.type,
          chr: str[i],
          i
        });
      }

      if (!str[i] && token.start !== null) {
        token.end = i;
        token.value = str.slice(token.start, token.end);
        pingTagCb(token);
      }
    }

    if (charStash.length) {
      for (let i = 0, len = charStash.length; i < len; i++) {
        reportFirstFromStash(charStash, opts.charCb, opts.charCbLookahead);
      }
    }

    if (tagStash.length) {
      for (let i = 0, len = tagStash.length; i < len; i++) {
        reportFirstFromStash(tagStash, opts.tagCb, opts.tagCbLookahead);
      }
    }

    return {
      timeTakenInMilliseconds: Date.now() - start
    };
  }

  /**
   * codsen-parser
   * Parser aiming at broken code, especially HTML & CSS
   * Version: 0.5.0
   * Author: Roy Revelt, Codsen Ltd
   * License: MIT
   * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/codsen-parser
   */

  function isObj$5(something) {
    return something && typeof something === "object" && !Array.isArray(something);
  }

  function layerPending(layers, tokenObj) {
    return tokenObj.closing && layers.length && (layers[layers.length - 1].type === tokenObj.type && Object.prototype.hasOwnProperty.call(layers[layers.length - 1], "tagName") && Object.prototype.hasOwnProperty.call(tokenObj, "tagName") && layers[layers.length - 1].tagName === tokenObj.tagName && layers[layers.length - 1].closing === false || tokenObj.type === "comment" && layers.some(layerObjToken => Object.prototype.hasOwnProperty.call(layerObjToken, "closing") && !layerObjToken.closing));
  }

  function cparser(str, originalOpts) {
    if (typeof str !== "string") {
      if (str === undefined) {
        throw new Error("codsen-tokenizer: [THROW_ID_01] the first input argument is completely missing! It should be given as string.");
      } else {
        throw new Error(`codsen-tokenizer: [THROW_ID_02] the first input argument must be string! It was given as "${typeof str}", equal to:\n${JSON.stringify(str, null, 4)}`);
      }
    }

    if (originalOpts && !isObj$5(originalOpts)) {
      throw new Error(`codsen-tokenizer: [THROW_ID_03] the second input argument, an options object, should be a plain object but it was given as type ${typeof originalOpts}, equal to ${JSON.stringify(originalOpts, null, 4)}`);
    }

    if (isObj$5(originalOpts) && originalOpts.tagCb && typeof originalOpts.tagCb !== "function") {
      throw new Error(`codsen-tokenizer: [THROW_ID_04] the opts.tagCb, callback function, should be a function but it was given as type ${typeof originalOpts.tagCb}, equal to ${JSON.stringify(originalOpts.tagCb, null, 4)}`);
    }

    if (isObj$5(originalOpts) && originalOpts.charCb && typeof originalOpts.charCb !== "function") {
      throw new Error(`codsen-tokenizer: [THROW_ID_05] the opts.charCb, callback function, should be a function but it was given as type ${typeof originalOpts.charCb}, equal to ${JSON.stringify(originalOpts.charCb, null, 4)}`);
    }

    if (isObj$5(originalOpts) && originalOpts.reportProgressFunc && typeof originalOpts.reportProgressFunc !== "function") {
      throw new Error(`codsen-tokenizer: [THROW_ID_06] the opts.reportProgressFunc, callback function, should be a function but it was given as type ${typeof originalOpts.reportProgressFunc}, equal to ${JSON.stringify(originalOpts.reportProgressFunc, null, 4)}`);
    }

    if (isObj$5(originalOpts) && originalOpts.errCb && typeof originalOpts.errCb !== "function") {
      throw new Error(`codsen-tokenizer: [THROW_ID_07] the opts.errCb, callback function, should be a function but it was given as type ${typeof originalOpts.errCb}, equal to ${JSON.stringify(originalOpts.errCb, null, 4)}`);
    }

    const defaults = {
      reportProgressFunc: null,
      reportProgressFuncFrom: 0,
      reportProgressFuncTo: 100,
      tagCb: null,
      charCb: null,
      errCb: null
    };
    const opts = Object.assign({}, defaults, originalOpts);
    const layers = [];
    const res = [];
    let path;
    let nestNext = false;
    let lastProcessedToken = {};
    const tokensWithChildren = ["tag", "comment"];
    const tagNamesThatDontHaveClosings = ["doctype"];
    tokenizer(str, {
      reportProgressFunc: opts.reportProgressFunc,
      reportProgressFuncFrom: opts.reportProgressFuncFrom,
      reportProgressFuncTo: opts.reportProgressFuncTo,
      tagCbLookahead: 2,
      tagCb: (tokenObj, next) => {
        if (typeof opts.tagCb === "function") {
          opts.tagCb(tokenObj);
        }

        let prevToken = objectPath.get(res, path);

        if (!isObj$5(prevToken)) {
          prevToken = null;
        }

        if (nestNext && !tokenObj.closing && (!prevToken || !(prevToken.tagName === tokenObj.tagName && !prevToken.closing && tokenObj.closing)) && !layerPending(layers, tokenObj)) {
          nestNext = false;
          path = `${path}.children.0`;
        } else if (tokenObj.closing && typeof path === "string" && path.includes(".") && (!tokenObj.tagName || lastProcessedToken.tagName !== tokenObj.tagName || lastProcessedToken.closing)) {
          path = pathNext(pathUp(path));

          if (layerPending(layers, tokenObj)) {
            while (layers.length && layers[layers.length - 1].type !== tokenObj.type && layers[layers.length - 1].kind !== tokenObj.kind) {
              layers.pop();
            }

            layers.pop();
            nestNext = false;
          } else {
            if (layers.length > 1 && tokenObj.tagName && tokenObj.tagName === layers[layers.length - 2].tagName) {
              path = pathNext(pathUp(path));

              if (opts.errCb) {
                const lastLayersToken = layers[layers.length - 1];
                opts.errCb({
                  ruleId: `${lastLayersToken.type}${lastLayersToken.type === "comment" ? `-${lastLayersToken.kind}` : ""}-missing-closing`,
                  idxFrom: lastLayersToken.start,
                  idxTo: lastLayersToken.end,
                  tokenObj: lastLayersToken
                });
              }

              layers.pop();
              layers.pop();
            } else if (layers.length > 2 && layers[layers.length - 3].type === tokenObj.type && layers[layers.length - 3].type === tokenObj.type && layers[layers.length - 3].tagName === tokenObj.tagName) {
              path = pathNext(pathUp(path));

              if (opts.errCb) {
                const lastLayersToken = layers[layers.length - 1];
                opts.errCb({
                  ruleId: `tag-rogue`,
                  idxFrom: lastLayersToken.start,
                  idxTo: lastLayersToken.end,
                  tokenObj: lastLayersToken
                });
              }

              layers.pop();
              layers.pop();
              layers.pop();
            } else if (layers.length > 1 && layers[layers.length - 2].type === tokenObj.type && layers[layers.length - 2].type === tokenObj.type && layers[layers.length - 2].tagName === tokenObj.tagName) {
              if (opts.errCb) {
                const lastLayersToken = layers[layers.length - 1];
                opts.errCb({
                  ruleId: `tag-rogue`,
                  idxFrom: lastLayersToken.start,
                  idxTo: lastLayersToken.end,
                  tokenObj: lastLayersToken
                });
              }

              layers.pop();
              layers.pop();
            }
          }
        } else if (!path) {
          path = "0";
        } else {
          path = pathNext(path);

          if (layerPending(layers, tokenObj)) {
            layers.pop();
          }
        }

        if (tokensWithChildren.includes(tokenObj.type) && !tokenObj.void && Object.prototype.hasOwnProperty.call(tokenObj, "closing") && !tokenObj.closing) {
          nestNext = true;

          if (!tagNamesThatDontHaveClosings.includes(tokenObj.kind)) {
            layers.push(Object.assign({}, tokenObj));
          }
        }

        const previousPath = pathPrev(path);
        const parentPath = pathUp(path);
        let parentTagsToken;

        if (parentPath && path.includes(".")) {
          parentTagsToken = objectPath.get(res, parentPath);
        }

        let previousTagsToken;

        if (previousPath) {
          previousTagsToken = objectPath.get(res, previousPath);
        }

        const suspiciousCommentTagEndingRegExp = /(-+|-+[^>])>/;
        let parentsLastChildTokenValue;
        let parentsLastChildTokenPath;

        if (isObj$5(previousTagsToken) && Array.isArray(previousTagsToken.children) && previousTagsToken.children.length && previousTagsToken.children[previousTagsToken.children.length - 1]) {
          parentsLastChildTokenValue = previousTagsToken.children[previousTagsToken.children.length - 1];
          parentsLastChildTokenPath = `${previousPath}.children.${objectPath.get(res, previousPath).children.length - 1}`;
        }

        let tokenTakenCareOf = false;

        if (tokenObj.type === "text" && isObj$5(parentTagsToken) && parentTagsToken.type === "comment" && parentTagsToken.kind === "simple" && !parentTagsToken.closing && suspiciousCommentTagEndingRegExp.test(tokenObj.value)) {
          const suspiciousEndingStartsAt = suspiciousCommentTagEndingRegExp.exec(tokenObj.value).index;
          const suspiciousEndingEndsAt = suspiciousEndingStartsAt + tokenObj.value.slice(suspiciousEndingStartsAt).indexOf(">") + 1;

          if (suspiciousEndingStartsAt > 0) {
            objectPath.set(res, path, Object.assign({}, tokenObj, {
              end: tokenObj.start + suspiciousEndingStartsAt,
              value: tokenObj.value.slice(0, suspiciousEndingStartsAt)
            }));

            if (tokensWithChildren.includes(tokenObj.type)) {
              tokenObj.children = [];
            }
          }

          path = pathNext(pathUp(path));
          objectPath.set(res, path, {
            type: "comment",
            kind: "simple",
            closing: true,
            start: tokenObj.start + suspiciousEndingStartsAt,
            end: tokenObj.start + suspiciousEndingEndsAt,
            value: tokenObj.value.slice(suspiciousEndingStartsAt, suspiciousEndingEndsAt),
            children: []
          });

          if (suspiciousEndingEndsAt < tokenObj.value.length) {
            path = pathNext(path);
            objectPath.set(res, path, {
              type: "text",
              start: tokenObj.start + suspiciousEndingEndsAt,
              end: tokenObj.end,
              value: tokenObj.value.slice(suspiciousEndingEndsAt)
            });
          }

          tokenTakenCareOf = true;
        } else if (tokenObj.type === "comment" && tokenObj.kind === "only" && isObj$5(previousTagsToken)) {
          if (previousTagsToken.type === "text" && previousTagsToken.value.trim().length && "<!-".includes(previousTagsToken.value[left(previousTagsToken.value, previousTagsToken.value.length)])) {
            const capturedMalformedTagRanges = [];
            strFindMalformed(previousTagsToken.value, "<!--", obj => {
              capturedMalformedTagRanges.push(obj);
            }, {
              maxDistance: 2
            });

            if (capturedMalformedTagRanges.length && !right(previousTagsToken.value, capturedMalformedTagRanges[capturedMalformedTagRanges.length - 1].idxTo - 1)) {
              const malformedRange = capturedMalformedTagRanges.pop();

              if (!left(previousTagsToken.value, malformedRange.idxFrom) && previousPath && isObj$5(previousTagsToken)) {
                if (tokensWithChildren.includes(tokenObj.type)) {
                  tokenObj.children = [];
                }

                path = previousPath;
                objectPath.set(res, path, Object.assign({}, tokenObj, {
                  start: malformedRange.idxFrom + previousTagsToken.start,
                  kind: "not",
                  value: `${previousTagsToken.value}${tokenObj.value}`
                }));
                tokenTakenCareOf = true;
              } else if (previousPath && isObj$5(previousTagsToken)) {
                objectPath.set(res, previousPath, Object.assign({}, previousTagsToken, {
                  end: malformedRange.idxFrom + previousTagsToken.start,
                  value: previousTagsToken.value.slice(0, malformedRange.idxFrom)
                }));

                if (tokensWithChildren.includes(tokenObj.type)) {
                  tokenObj.children = [];
                }

                objectPath.set(res, path, Object.assign({}, tokenObj, {
                  start: malformedRange.idxFrom + previousTagsToken.start,
                  kind: "not",
                  value: `${previousTagsToken.value.slice(malformedRange.idxFrom)}${tokenObj.value}`
                }));
                tokenTakenCareOf = true;
              }
            }
          } else if (isObj$5(parentsLastChildTokenValue) && parentsLastChildTokenValue.type === "text" && parentsLastChildTokenValue.value.trim().length && "<!-".includes(parentsLastChildTokenValue.value[left(parentsLastChildTokenValue.value, parentsLastChildTokenValue.value.length)])) {
            const capturedMalformedTagRanges = [];
            strFindMalformed(parentsLastChildTokenValue.value, "<!--", obj => {
              capturedMalformedTagRanges.push(obj);
            }, {
              maxDistance: 2
            });

            if (capturedMalformedTagRanges.length && !right(parentsLastChildTokenValue.value, capturedMalformedTagRanges[capturedMalformedTagRanges.length - 1].idxTo - 1)) {
              const malformedRange = capturedMalformedTagRanges.pop();

              if (!left(parentsLastChildTokenValue.value, malformedRange.idxFrom) && previousPath && isObj$5(parentsLastChildTokenValue)) {
                if (tokensWithChildren.includes(tokenObj.type)) {
                  tokenObj.children = [];
                }

                objectPath.set(res, path, Object.assign({}, tokenObj, {
                  start: malformedRange.idxFrom + parentsLastChildTokenValue.start,
                  kind: "not",
                  value: `${parentsLastChildTokenValue.value}${tokenObj.value}`
                }));
                objectPath.del(res, `${previousPath}.children.${objectPath.get(res, previousPath).children.length - 1}`);
                tokenTakenCareOf = true;
              } else if (previousPath && isObj$5(parentsLastChildTokenValue) && parentsLastChildTokenPath) {
                objectPath.set(res, parentsLastChildTokenPath, Object.assign({}, parentsLastChildTokenValue, {
                  end: malformedRange.idxFrom + parentsLastChildTokenValue.start,
                  value: parentsLastChildTokenValue.value.slice(0, malformedRange.idxFrom)
                }));

                if (tokensWithChildren.includes(tokenObj.type)) {
                  tokenObj.children = [];
                }

                objectPath.set(res, path, Object.assign({}, tokenObj, {
                  start: malformedRange.idxFrom + parentsLastChildTokenValue.start,
                  kind: "not",
                  value: `${parentsLastChildTokenValue.value.slice(malformedRange.idxFrom)}${tokenObj.value}`
                }));
                tokenTakenCareOf = true;
              }
            }
          }
        }

        if (!tokenTakenCareOf) {
          if (tokensWithChildren.includes(tokenObj.type)) {
            tokenObj.children = [];
          }

          objectPath.set(res, path, tokenObj);
        }

        if (tokensWithChildren.includes(tokenObj.type) && tokenObj.closing && (!previousPath || !isObj$5(previousTagsToken) || previousTagsToken.closing || previousTagsToken.type !== tokenObj.type || previousTagsToken.tagName !== tokenObj.tagName)) {
          if (tokenObj.void) {
            if (opts.errCb) {
              opts.errCb({
                ruleId: `tag-void-frontal-slash`,
                idxFrom: tokenObj.start,
                idxTo: tokenObj.end,
                fix: {
                  ranges: [[tokenObj.start + 1, tokenObj.tagNameStartsAt]]
                },
                tokenObj
              });
            }
          } else {
            if (opts.errCb) {
              opts.errCb({
                ruleId: `${tokenObj.type}${tokenObj.type === "comment" ? `-${tokenObj.kind}` : ""}-missing-opening`,
                idxFrom: tokenObj.start,
                idxTo: tokenObj.end,
                tokenObj
              });
            }
          }
        }

        lastProcessedToken = { ...tokenObj
        };
      },
      charCb: opts.charCb
    });

    if (layers.length) {
      layers.forEach(tokenObj => {
        if (opts.errCb) {
          opts.errCb({
            ruleId: `${tokenObj.type}${tokenObj.type === "comment" ? `-${tokenObj.kind}` : ""}-missing-closing`,
            idxFrom: tokenObj.start,
            idxTo: tokenObj.end,
            tokenObj
          });
        }
      });
    }

    return res;
  }

  var domain; // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).

  function EventHandlers() {}

  EventHandlers.prototype = Object.create(null);

  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  // require('events') === require('events').EventEmitter

  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.usingDomains = false;
  EventEmitter.prototype.domain = undefined;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.

  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function () {
    this.domain = null;

    if (EventEmitter.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain.active ) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  }; // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.


  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  }; // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.


  function emitNone(handler, isFn, self) {
    if (isFn) handler.call(self);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self);
    }
  }

  function emitOne(handler, isFn, self, arg1) {
    if (isFn) handler.call(self, arg1);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
    }
  }

  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn) handler.call(self, arg1, arg2);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
    }
  }

  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn) handler.call(self, arg1, arg2, arg3);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn) handler.apply(self, args);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
    }
  }

  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events, domain;
    var doError = type === 'error';
    events = this._events;
    if (events) doError = doError && events.error == null;else if (!doError) return false;
    domain = this.domain; // If there is no 'error' event listener then throw.

    if (doError) {
      er = arguments[1];

      if (domain) {
        if (!er) er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }

      return false;
    }

    handler = events[type];
    if (!handler) return false;
    var isFn = typeof handler === 'function';
    len = arguments.length;

    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;

      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;

      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;

      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower

      default:
        args = new Array(len - 1);

        for (i = 1; i < len; i++) args[i - 1] = arguments[i];

        emitMany(handler, isFn, this, args);
    }
    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    events = target._events;

    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object

        events = target._events;
      }

      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      } // Check for listener leak


      if (!existing.warned) {
        m = $getMaxListeners(target);

        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }

  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }

  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };

  function _onceWrap(target, type, listener) {
    var fired = false;

    function g() {
      target.removeListener(type, g);

      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }

    g.listener = listener;
    return g;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  }; // emits a 'removeListener' event iff the listener was removed


  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    events = this._events;
    if (!events) return this;
    list = events[type];
    if (!list) return this;

    if (list === listener || list.listener && list.listener === listener) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();else {
        delete events[type];
        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
      }
    } else if (typeof list !== 'function') {
      position = -1;

      for (i = list.length; i-- > 0;) {
        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }

      if (position < 0) return this;

      if (list.length === 1) {
        list[0] = undefined;

        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events[type];
        }
      } else {
        spliceOne(list, position);
      }

      if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events;
    events = this._events;
    if (!events) return this; // not listening for removeListener, no need to emit

    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
      }

      return this;
    } // emit removeListener for all listeners on all events


    if (arguments.length === 0) {
      var keys = Object.keys(events);

      for (var i = 0, key; i < keys.length; ++i) {
        key = keys[i];
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }

      this.removeAllListeners('removeListener');
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }

    listeners = events[type];

    if (typeof listeners === 'function') {
      this.removeListener(type, listeners);
    } else if (listeners) {
      // LIFO order
      do {
        this.removeListener(type, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }

    return this;
  };

  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;
    if (!events) ret = [];else {
      evlistener = events[type];
      if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
    }
    return ret;
  };

  EventEmitter.listenerCount = function (emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount;

  function listenerCount(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  }; // About 1.5x faster than the two-arg version of Array#splice().


  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];

    list.pop();
  }

  function arrayClone(arr, i) {
    var copy = new Array(i);

    while (i--) copy[i] = arr[i];

    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);

    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }

    return ret;
  }

  EventEmitter.defaultMaxListeners = 0;

  var Linter = /*#__PURE__*/function (_EventEmitter) {
    _inherits(Linter, _EventEmitter);

    var _super = _createSuper(Linter);

    function Linter() {
      _classCallCheck(this, Linter);

      return _super.apply(this, arguments);
    }

    _createClass(Linter, [{
      key: "verify",
      value: function verify(str, config) {
        var _this = this;

        this.messages = [];
        this.str = str;
        this.config = lodash_clonedeep(config);
        this.hasBeenCalledWithKeepSeparateWhenFixing = false; // VALIDATION FIRST

        if (config) {
          if (_typeof(config) !== "object") {
            throw new Error("emlint/verify(): [THROW_ID_01] second input argument, config is not a plain object but ".concat(_typeof(config), ". It's equal to:\n").concat(JSON.stringify(config, null, 4)));
          } else if (!Object.keys(config).length) {
            // empty config => early return
            return [];
          } else if (!config.rules || _typeof(config.rules) !== "object") {
            throw new Error("emlint/verify(): [THROW_ID_02] config contains no rules! It was given as:\n".concat(JSON.stringify(config, null, 4)));
          }
        } else {
          // falsey config => early return
          return [];
        } // filter out all applicable values and make them listen for events that
        // tokenizer emits


        var processedRulesConfig = normaliseRequestedRules(config.rules);
        this.processedRulesConfig = processedRulesConfig;
        Object.keys(processedRulesConfig) // filter out the rules coming from external packages - they'll be
        // processed separately, in the callbacks coming out og external packages,
        // see the section "rules coming from standalone packages".
        .filter(function (ruleName) {
          return get(ruleName);
        }) // filter out enabled rules:
        .filter(function (ruleName) {
          // same config like in ESLint - 0 is off, 1 is warning, 2 is error
          if (typeof processedRulesConfig[ruleName] === "number") {
            return processedRulesConfig[ruleName] > 0;
          } else if (Array.isArray(processedRulesConfig[ruleName])) {
            return processedRulesConfig[ruleName][0] > 0;
          }
        }).forEach(function (rule) {
          // console.log(
          //   `086 ${`\u001b[${32}m${`linter.js`}\u001b[${39}m`}: filtering rule ${rule}`
          // );
          // extract all the options, second array element onwards - the length is indeterminable
          var rulesFunction;

          if (Array.isArray(processedRulesConfig[rule]) && processedRulesConfig[rule].length > 1) {
            // pass not only "this", the context, but also all the opts, as args
            rulesFunction = get(rule).apply(void 0, [_this].concat(_toConsumableArray(processedRulesConfig[rule].slice(1))));
          } else {
            // just pass "this", the context
            rulesFunction = get(rule)(_this);
          }

          Object.keys(rulesFunction).forEach(function (consumedNode) {
            _this.on(consumedNode, function () {
              var _rulesFunction;

              // console.log(
              //   `106 ${`\u001b[${32}m${`linter.js`}\u001b[${39}m`}: ${`\u001b[${33}m${`consumedNode`}\u001b[${39}m`} = ${JSON.stringify(
              //     consumedNode,
              //     null,
              //     4
              //   )}`
              // );
              (_rulesFunction = rulesFunction)[consumedNode].apply(_rulesFunction, arguments);
            });
          });
        }); // emlint runs on codsen-parser which in turn runs on codsen-tokenizer.
        // Tokenizer recognises string as various token types and "pings" the
        // callback function given to the tokenizer with those lumps, plain objects.
        // Now, Parser consumes those tokens and assembles a tree, an AST.
        // EMLint is plugin-based. Plugins work on code source - consuming either
        // raw tokens, each token of particular kind, listening to event emitted
        // called after that token type, or plugins consume whole AST, listening
        // to "ast"-type event.
        // Now, the less work done the faster program runs.
        // The quickest way for emlint to obtain tokens is from codsen-parser,
        // to tap them raw, bypassing the AST tree, as they come from tokenizer.
        // But the problem is, this approach does not work with broken code.
        // We can't consume tokenizer's nodes because parser can change the
        // nodes, correcting the errors - it's possible because parser "sees" the
        // whole picture.
        // Therefore, we don't consume tokens from the tokenizer, we consume AST
        // from parser, then we send the monkey (ast-monkey-traverse) to traverse
        // that AST and emit the token events.

        this.emit("ast", astMonkeyTraverse(cparser(str, {
          charCb: function charCb(obj) {
            // We call the character-level callback from raw characters, coming
            // if from parser which comes straight from tokenizer.
            // console.log(
            //   `147  ${`\u001b[${35}m${`linter/charCb():`}\u001b[${39}m`} incoming ${`\u001b[${33}m${`obj`}\u001b[${39}m`} = ${JSON.stringify(
            //     obj,
            //     null,
            //     4
            //   )}`
            // );
            _this.emit("character", obj);
          },
          errCb: function errCb(obj) {
            // check, is rule enabled at the first place:
            var currentRulesSeverity = isAnEnabledRule(config.rules, obj.ruleId);

            if (currentRulesSeverity) {
              var message = "Something is wrong.";

              if (isObj(obj) && Object.keys(astErrMessages).includes(obj.ruleId)) {
                message = astErrMessages[obj.ruleId];
              }

              _this.report(Object.assign({
                message: message,
                severity: currentRulesSeverity,
                fix: null
              }, obj));
            }
          }
        }), // (key, val, innerObj, stop) => {
        function (key, val) {
          var current = val !== undefined ? val : key;

          if (isObj(current)) {
            // monkey will traverse every key, every string within.
            // We need to pick the objects of a type we need: "tag", "comment" etc.
            // tag-level callback
            // console.log(
            //   `210  ${`\u001b[${35}m${`linter/tagCb():`}\u001b[${39}m`} PING ${`\u001b[${33}m${`current`}\u001b[${39}m`} = ${JSON.stringify(
            //     current,
            //     null,
            //     4
            //   )}`
            // );
            _this.emit(current.type, current); // plus, for type:html also ping each attribute


            if (current.type === "tag" && Array.isArray(current.attribs) && current.attribs.length) {
              current.attribs.forEach(function (attribObj) {
                _this.emit("attribute", Object.assign({}, attribObj, {
                  parent: Object.assign({}, current)
                }));
              });
            }
          }

          return current;
        })); //
        //
        //
        //
        //
        //
        //                rules coming from standalone packages
        //
        //
        //
        //
        //
        //
        // 1. if any of bad named HTML entity catcher rules is requested, run it

        if (Object.keys(config.rules).some(function (ruleName) {
          return (ruleName === "all" || // group blanket setting
          ruleName === "bad-html-entity" || // group blanket setting
          ruleName.startsWith("bad-html-entity") || ruleName.startsWith("bad-named-html-entity") || matcher.isMatch(["bad-malformed-numeric-character-entity"], ruleName)) && (isAnEnabledValue(config.rules[ruleName]) || isAnEnabledValue(processedRulesConfig[ruleName]));
        })) {
          stringFixBrokenNamedEntities(str, {
            cb: function cb(obj) {
              // evaluate, does the config have this emitted rule set and enabled
              var matchedRulesName; // A severity value can be under array's first element or as digit,
              // plus rule itself might be group rule ("bad-html-entity") or
              // mentioned directly.
              // The plan is to try to extract severity various ways, later if it's
              // set, then report the error.

              var severity; // rule is group, blanket rule

              if (Object.keys(config.rules).includes("bad-html-entity")) {
                if (obj.ruleName === "bad-named-html-entity-unrecognised") {
                  // unrecongnised named HTML entities might be false positives,
                  // mix of ampersand, letters and semicolon, without spaces,
                  // so default level is "warning", not "error":
                  severity = 1;
                } else if (Array.isArray(config.rules["bad-html-entity"])) {
                  severity = config.rules["bad-html-entity"][0];
                } else if (Number.isInteger(config.rules["bad-html-entity"])) {
                  severity = config.rules["bad-html-entity"];
                }
              } else if (Object.keys(config.rules).some(function (rulesName) {
                if (matcher.isMatch(obj.ruleName, rulesName)) {
                  matchedRulesName = rulesName;
                  return true;
                }
              })) {
                if (obj.ruleName === "bad-named-html-entity-unrecognised" && config.rules["bad-named-html-entity-unrecognised"] === undefined) {
                  // unless the rule was requested exactly, severity is 1.
                  // This applies to both group blanket rules "bad-html-entity" and
                  // any rules achieved by applying wildcards, for example,
                  // "bad-named-html-entity-*".
                  severity = 1;
                } else if (Array.isArray(config.rules[matchedRulesName])) {
                  severity = config.rules[matchedRulesName][0];
                } else if (Number.isInteger(config.rules[matchedRulesName])) {
                  severity = config.rules[matchedRulesName];
                }
              }

              if (Number.isInteger(severity)) {
                var message;

                if (obj.ruleName === "bad-named-html-entity-malformed-nbsp") {
                  message = "Malformed NBSP entity.";
                } else if (obj.ruleName === "bad-named-html-entity-unrecognised") {
                  message = "Unrecognised named entity.";
                } else if (obj.ruleName === "bad-named-html-entity-multiple-encoding") {
                  message = "HTML entity encoding over and over.";
                } else if (obj.ruleName === "bad-malformed-numeric-character-entity") {
                  message = "Malformed numeric entity.";
                } else {
                  message = "Malformed ".concat(obj.entityName ? obj.entityName : "named", " entity.");
                }

                var ranges = [[obj.rangeFrom, obj.rangeTo, obj.rangeValEncoded ? obj.rangeValEncoded : ""]];

                if (obj.ruleName === "bad-named-html-entity-unrecognised") {
                  ranges = [];
                }

                _this.report({
                  severity: severity,
                  ruleId: obj.ruleName,
                  message: message,
                  idxFrom: obj.rangeFrom,
                  idxTo: obj.rangeTo,
                  fix: {
                    ranges: ranges
                  }
                });
              }
            },
            entityCatcherCb: function entityCatcherCb(from, to) {
              _this.emit("entity", {
                idxFrom: from,
                idxTo: to
              });
            }
          });
        } // remove all listeners


        ["tag", "at", "rule", "text", "esp", "character", "ast"].forEach(function (eventName) {
          _this.removeAllListeners(eventName);
        });
        return this.messages;
      }
    }, {
      key: "report",
      value: function report(obj) {
        // fill in other data points:
        var _lineColumn = lineColumn(this.str, obj.idxFrom),
            line = _lineColumn.line,
            col = _lineColumn.col;

        var severity = obj.severity; // rules coming from 3rd party packages will give the severity value

        if (!Number.isInteger(obj.severity) && typeof this.processedRulesConfig[obj.ruleId] === "number") {
          severity = this.processedRulesConfig[obj.ruleId];
        } else if (!Number.isInteger(obj.severity) && Array.isArray(this.processedRulesConfig[obj.ruleId])) {
          severity = this.processedRulesConfig[obj.ruleId][0];
        }

        this.messages.push(Object.assign({
          fix: null,
          keepSeparateWhenFixing: false
        }, {
          line: line,
          column: col,
          severity: severity
        }, obj, this.hasBeenCalledWithKeepSeparateWhenFixing ? {
          fix: null
        } : {})); // After pushing, let's manage "keepSeparateWhenFixing" messages -
        // make a note of the first incoming message with "keepSeparateWhenFixing"
        // key, in order to remove "fix" values from all other incoming messages
        // with "keepSeparateWhenFixing" key. That's necessary to support certain
        // fixes composition.

        if (obj.keepSeparateWhenFixing && !this.hasBeenCalledWithKeepSeparateWhenFixing && obj.fix) {
          this.hasBeenCalledWithKeepSeparateWhenFixing = true;
        }
      }
    }]);

    return Linter;
  }(EventEmitter);

  var version = "2.16.0";

  exports.Linter = Linter;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
