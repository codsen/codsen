/**
 * ranges-merge
 * Merge and sort arrays which mean string slice ranges
 * Version: 4.3.0
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/ranges-merge
 */

!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(e=e||self).rangesMerge=r()}(this,(function(){"use strict";function e(r){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(r)}function r(e){return function(e){if(Array.isArray(e)){for(var r=0,n=new Array(e.length);r<e.length;r++)n[r]=e[r];return n}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function n(e,r){if(!Array.isArray(e))throw new TypeError(`ranges-sort: [THROW_ID_01] Input must be an array, consisting of range arrays! Currently its type is: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(0===e.length)return e;const n=Object.assign({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null},r);let t,o;if(n.strictlyTwoElementsInRangeArrays&&!e.every((e,r)=>2===e.length||(t=r,o=e.length,!1)))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${t}th range (${JSON.stringify(e[t],null,4)}) has not two but ${o} elements!`);if(!e.every((e,r)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(t=r,!1)))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${t}th range (${JSON.stringify(e[t],null,4)}) does not consist of only natural numbers!`);const s=e.length*e.length;let a=0;return Array.from(e).sort((e,r)=>(n.progressFn&&(a++,n.progressFn(Math.floor(100*a/s))),e[0]===r[0]?e[1]<r[1]?-1:e[1]>r[1]?1:0:e[0]<r[0]?-1:1))}return function(t,o){function s(e){return"string"==typeof e}function a(r){return r&&"object"===e(r)&&!Array.isArray(r)}if(!Array.isArray(t))return t;var i,g={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};if(o){if(!a(o))throw new Error("emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n".concat(JSON.stringify(o,null,4)," (type ").concat(e(o),")"));if((i=Object.assign({},g,o)).progressFn&&a(i.progressFn)&&!Object.keys(i.progressFn).length)i.progressFn=null;else if(i.progressFn&&"function"!=typeof i.progressFn)throw new Error('ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "'.concat(e(i.progressFn),'", equal to ').concat(JSON.stringify(i.progressFn,null,4)));if(i.mergeType&&1!==i.mergeType&&2!==i.mergeType)if(s(i.mergeType)&&"1"===i.mergeType.trim())i.mergeType=1;else{if(!s(i.mergeType)||"2"!==i.mergeType.trim())throw new Error('ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(e(i.mergeType),'", equal to ').concat(JSON.stringify(i.mergeType,null,4)));i.mergeType=2}if("boolean"!=typeof i.joinRangesThatTouchEdges)throw new Error('ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "'.concat(e(i.joinRangesThatTouchEdges),'", equal to ').concat(JSON.stringify(i.joinRangesThatTouchEdges,null,4)))}else i=Object.assign({},g);for(var u,l,y,f=t.map((function(e){return r(e)})).filter((function(e){return void 0!==e[2]||e[0]!==e[1]})),c=(u=i.progressFn?n(f,{progressFn:function(e){(y=Math.floor(e/5))!==l&&(l=y,i.progressFn(y))}}):n(f)).length-1,p=c;p>0;p--)i.progressFn&&(y=Math.floor(78*(1-p/c))+21)!==l&&y>l&&(l=y,i.progressFn(y)),(u[p][0]<=u[p-1][0]||!i.joinRangesThatTouchEdges&&u[p][0]<u[p-1][1]||i.joinRangesThatTouchEdges&&u[p][0]<=u[p-1][1])&&(u[p-1][0]=Math.min(u[p][0],u[p-1][0]),u[p-1][1]=Math.max(u[p][1],u[p-1][1]),void 0!==u[p][2]&&(u[p-1][0]>=u[p][0]||u[p-1][1]<=u[p][1])&&null!==u[p-1][2]&&(null===u[p][2]&&null!==u[p-1][2]?u[p-1][2]=null:void 0!==u[p-1][2]?2===i.mergeType&&u[p-1][0]===u[p][0]?u[p-1][2]=u[p][2]:u[p-1][2]+=u[p][2]:u[p-1][2]=u[p][2]),u.splice(p,1),p=u.length);return u}}));
