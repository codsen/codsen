{"_quickTake.js":{"title":"Quick Take","content":"import { strict as assert } from \"assert\";\nimport {\n  nativeToUnicode,\n  unicodeToNative,\n} from \"../dist/string-convert-indexes.esm.js\";\n\n// CONVERTING NATIVE JS INDEXES TO UNICODE-CHAR-COUNT-BASED\n// ðŒ† - \\uD834\\uDF06\n\n// at index 1, we have low surrogate, that's still grapheme index zero\nassert.equal(nativeToUnicode(\"\\uD834\\uDF06aa\", \"1\"), \"0\");\n// notice it's retained as string. The same type as input is retained!\n\n// at index 2, we have first letter a - that's second index, counting graphemes\nassert.equal(nativeToUnicode(\"\\uD834\\uDF06aa\", 3), 2);\n\n// convert many indexes at once - any nested data structure is fine:\nassert.deepEqual(nativeToUnicode(\"\\uD834\\uDF06aa\", [1, 0, 2, 3]), [0, 0, 1, 2]);\n\n// numbers from an AST-like complex structure are still picked out and converted:\nassert.deepEqual(nativeToUnicode(\"\\uD834\\uDF06aa\", [1, \"0\", [[[2]]], 3]), [\n  0, // notice matching type is retained\n  \"0\", // notice matching type is retained\n  [[[1]]],\n  2,\n]);\n\n// CONVERTING UNICODE-CHAR-COUNT-BASED TO NATIVE JS INDEXES\n// ðŒ† - \\uD834\\uDF06\n\nassert.deepEqual(unicodeToNative(\"\\uD834\\uDF06aa\", [0, 1, 2]), [0, 2, 3]);\n\nassert.deepEqual(unicodeToNative(\"\\uD834\\uDF06aa\", [1, 0, 2]), [2, 0, 3]);\n\nassert.throws(() => unicodeToNative(\"\\uD834\\uDF06aa\", [1, 0, 2, 3]));\n// throws an error!\n// that's because there's no character (counting Unicode characters) with index 3\n// we have only three Unicode characters, so indexes go only up until 2"}}