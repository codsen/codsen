/**
 * string-find-heads-tails
 * Finds where are arbitrary templating marker heads and tails located
 * Version: 4.0.3
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/string-find-heads-tails/
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).stringFindHeadsTails={})}(this,(function(e){"use strict";function t(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function r(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function n(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?r(Object(i),!0).forEach((function(r){t(e,r,i[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function i(e){return"string"==typeof e?e.length?[e]:[]:e}function a(e){return e&&"object"==typeof e&&!Array.isArray(e)}function o(e){return"string"==typeof e}var s={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1},h=function(e){return e+1};function f(e,t,r,i,a,o){void 0===a&&(a=!1),void 0===o&&(o=h);var f="function"==typeof r?r():r;if(+t<0&&a&&"EOL"===f)return f;var l=n(n({},s),i);if(t>=e.length&&!a)return!1;for(var u=a?1:r.length,c=!1,g=!1,d=l.maxMismatches,m=t,y=!1,p=!1,w=!1;e[m];){var b=o(m);if(l.trimBeforeMatching&&""===e[m].trim()){if(!e[b]&&a&&"EOL"===r)return!0;m=o(m)}else if(l&&!l.i&&l.trimCharsBeforeMatching&&l.trimCharsBeforeMatching.includes(e[m])||l&&l.i&&l.trimCharsBeforeMatching&&l.trimCharsBeforeMatching.map((function(e){return e.toLowerCase()})).includes(e[m].toLowerCase())){if(a&&"EOL"===r&&!e[b])return!0;m=o(m)}else{var O=b>m?r[r.length-u]:r[u-1];if(!l.i&&e[m]===O||l.i&&e[m].toLowerCase()===O.toLowerCase()){if(y||(y=!0),g||(g=!0),u===r.length?p=!0:1===u&&(w=!0),(u-=1)<1)return m}else{if(!(l.maxMismatches&&d&&m))return!(0!==m||1!==u||l.lastMustMatch||!g)&&0;d-=1;for(var I=0;I<=d;I++){var T=b>m?r[r.length-u+1+I]:r[u-2-I],v=e[o(m)];if(T&&(!l.i&&e[m]===T||l.i&&e[m].toLowerCase()===T.toLowerCase())&&(!l.firstMustMatch||u!==r.length)){u-=2,y=!0;break}if(v&&T&&(!l.i&&v===T||l.i&&v.toLowerCase()===T.toLowerCase())&&(!l.firstMustMatch||u!==r.length)){u-=1,y=!0;break}if(void 0===T&&d>=0&&y&&(!l.firstMustMatch||p)&&(!l.lastMustMatch||w))return m}y||(c=m)}if(!1!==c&&c!==m&&(c=!1),u<1)return m;m=o(m)}}return u>0?!(!a||"EOL"!==f)||!!(l&&l.maxMismatches>=u&&g)&&(c||0):void 0}function l(e,t,r,h){return function(e,t,r,h,l){if(a(l)&&Object.prototype.hasOwnProperty.call(l,"trimBeforeMatching")&&"boolean"!=typeof l.trimBeforeMatching)throw new Error("string-match-left-right/"+e+"(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!"+(Array.isArray(l.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""));var u,c,g=n(n({},s),l);if("string"==typeof g.trimCharsBeforeMatching&&(g.trimCharsBeforeMatching=i(g.trimCharsBeforeMatching)),g.trimCharsBeforeMatching=g.trimCharsBeforeMatching.map((function(e){return o(e)?e:String(e)})),!o(t))return!1;if(!t.length)return!1;if(!Number.isInteger(r)||r<0)throw new Error("string-match-left-right/"+e+"(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: "+typeof r+", equal to:\n"+JSON.stringify(r,null,4));if(o(h))u=[h];else if(Array.isArray(h))u=h;else if(h){if("function"!=typeof h)throw new Error("string-match-left-right/"+e+"(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's "+typeof h+", equal to:\n"+JSON.stringify(h,null,4));(u=[]).push(h)}else u=h;if(l&&!a(l))throw new Error("string-match-left-right/"+e+"(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \""+typeof l+'", and equal to:\n'+JSON.stringify(l,null,4));var d=0,m="";if(g&&g.trimCharsBeforeMatching&&g.trimCharsBeforeMatching.some((function(e,t){return e.length>1&&(d=t,m=e,!0)})))throw new Error("string-match-left-right/"+e+"(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index "+d+" is longer than 1 character, "+m.length+" (equals to "+m+"). Please split it into separate characters and put into array as separate elements.");if(!u||!Array.isArray(u)||Array.isArray(u)&&!u.length||Array.isArray(u)&&1===u.length&&o(u[0])&&!u[0].trim()){if("function"==typeof g.cb){var y,p=r;if("matchLeftIncl"!==e&&"matchRight"!==e||(p+=1),"L"===e[5])for(var w=p;w--;){var b=t[w];if((!g.trimBeforeMatching||g.trimBeforeMatching&&void 0!==b&&b.trim())&&(!g.trimCharsBeforeMatching||!g.trimCharsBeforeMatching.length||void 0!==b&&!g.trimCharsBeforeMatching.includes(b))){y=w;break}}else if(e.startsWith("matchRight"))for(var O=p;O<t.length;O++){var I=t[O];if((!g.trimBeforeMatching||g.trimBeforeMatching&&I.trim())&&(!g.trimCharsBeforeMatching||!g.trimCharsBeforeMatching.length||!g.trimCharsBeforeMatching.includes(I))){y=O;break}}if(void 0===y)return!1;var T=t[y],v=y+1,M="";return v&&v>0&&(M=t.slice(0,v)),"L"===e[5]||y&&y>0&&(M=t.slice(y)),g.cb(T,M,y)}var A="";throw l||(A=" More so, the whole options object, the fourth input argument, is missing!"),new Error("string-match-left-right/"+e+'(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!'+A)}for(var _=0,W=u.length;_<W;_++){var C=u[_],x=void 0,B=void 0,D="",E=r;"matchRight"===e?E+=1:"matchLeft"===e&&(E-=1);var H=f(t,E,C,g,c="function"==typeof u[_],(function(t){return"L"===e[5]?t-1:t+1}));if(H&&c&&"function"==typeof C&&"EOL"===C())return!(!C()||g.cb&&!g.cb(x,D,B))&&C();if(Number.isInteger(H)&&(B=e.startsWith("matchLeft")?H-1:H+1,D="L"===e[5]?t.slice(0,H):t.slice(B)),B<0&&(B=void 0),t[B]&&(x=t[B]),Number.isInteger(H)&&(!g.cb||g.cb(x,D,B)))return C}return!1}("matchRightIncl",e,t,r,h)}function u(e){return"string"==typeof e}var c={fromIndex:0,throwWhenSomethingWrongIsDetected:!0,allowWholeValueToBeOnlyHeadsOrTails:!0,source:"string-find-heads-tails",matchHeadsAndTailsStrictlyInPairsByTheirOrder:!1,relaxedAPI:!1};e.defaults=c,e.strFindHeadsTails=function(e,t,r,a){if(a&&(!(o=a)||"object"!=typeof o||Array.isArray(o)))throw new TypeError("string-find-heads-tails: [THROW_ID_01] the fourth input argument, an Optional Options Object, must be a plain object! Currently it's equal to: "+a+" (type: "+typeof a+")");var o,s,h,f=n(n({},c),a);if("string"==typeof f.fromIndex&&/^\d*$/.test(f.fromIndex))f.fromIndex=Number(f.fromIndex);else if(!Number.isInteger(f.fromIndex)||f.fromIndex<0)throw new TypeError(f.source+" [THROW_ID_18] the fourth input argument must be a natural number or zero! Currently it's: "+f.fromIndex);if(!u(e)||0===e.length){if(f.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_02] the first input argument, input string, must be a non-zero-length string! Currently it's: "+typeof e+", equal to: "+e)}if("string"!=typeof t&&!Array.isArray(t)){if(f.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_03] the second input argument, heads, must be either a string or an array of strings! Currently it's: "+typeof t+", equal to:\n"+JSON.stringify(t,null,4))}if("string"==typeof t){if(0===t.length){if(f.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_04] the second input argument, heads, must be a non-empty string! Currently it's empty.")}t=i(t)}else if(Array.isArray(t)){if(0===t.length){if(f.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_05] the second input argument, heads, must be a non-empty array and contain at least one string! Currently it's empty.")}if(t.every((function(e,t){return s=e,h=t,u(e)}))){if(!t.every((function(e,t){return h=t,u(e)&&e.length>0&&""!==e.trim()}))){if(!f.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_07] the second input argument, heads, should not contain empty strings! For example, there's one detected at index "+h+" of heads array:\n"+JSON.stringify(t,null,4)+".");if(0===(t=t.filter((function(e){return u(e)&&e.length>0}))).length)return[]}}else{if(!f.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_06] the second input argument, heads, contains non-string elements! For example, element at "+h+"th index is "+typeof s+", equal to:\n"+JSON.stringify(s,null,4)+". Whole heads array looks like:\n"+JSON.stringify(t,null,4));if(0===(t=t.filter((function(e){return u(e)&&e.length>0}))).length)return[]}}if(!u(r)&&!Array.isArray(r)){if(f.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_08] the third input argument, tails, must be either a string or an array of strings! Currently it's: "+typeof r+", equal to:\n"+JSON.stringify(r,null,4))}if(u(r)){if(0===r.length){if(f.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_09] the third input argument, tails, must be a non-empty string! Currently it's empty.")}r=i(r)}else if(Array.isArray(r)){if(0===r.length){if(f.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_10] the third input argument, tails, must be a non-empty array and contain at least one string! Currently it's empty.")}if(r.every((function(e,t){return s=e,h=t,u(e)}))){if(!r.every((function(e,t){return h=t,u(e)&&e.length>0&&""!==e.trim()}))){if(!f.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_12] the third input argument, tails, should not contain empty strings! For example, there's one detected at index "+h+". Whole tails array is equal to:\n"+JSON.stringify(r,null,4));if(0===(r=r.filter((function(e){return u(e)&&e.length>0}))).length)return[]}}else{if(!f.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_11] the third input argument, tails, contains non-string elements! For example, element at "+h+"th index is "+typeof s+", equal to:\n"+JSON.stringify(s,null,4)+". Whole tails array is equal to:\n"+JSON.stringify(r,null,4));if(0===(r=r.filter((function(e){return u(e)&&e.length>0}))).length)return[]}}var g=f.source===c.source;if(f.throwWhenSomethingWrongIsDetected&&!f.allowWholeValueToBeOnlyHeadsOrTails){if(i(t).includes(e))throw new Error(f.source+(g?": [THROW_ID_16]":"")+" the whole input string can't be equal to "+(u(t)?"":"one of ")+"heads ("+e+")!");if(i(r).includes(e))throw new Error(f.source+(g?": [THROW_ID_17]":"")+" the whole input string can't be equal to "+(u(r)?"":"one of ")+"tails ("+e+")!")}for(var d,m=t.concat(r).map((function(e){return e.charAt(0)})).reduce((function(e,t){return t.charCodeAt(0)>e[1]?[e[0],t.charCodeAt(0)]:t.charCodeAt(0)<e[0]?[t.charCodeAt(0),e[1]]:e}),[t[0].charCodeAt(0),t[0].charCodeAt(0)]),y=[],p=!1,w={},b="",O=f.fromIndex,I=e.length;O<I;O++){var T=e[O].charCodeAt(0);if(T<=m[1]&&T>=m[0]){var v=l(e,O,t);if(v&&f.matchHeadsAndTailsStrictlyInPairsByTheirOrder)for(var M=t.length;M--;)if(t[M]===v){d=M;break}if("string"==typeof v){if(!p){(w={}).headsStartAt=O,w.headsEndAt=O+v.length,p=!0,O+=v.length-1,b&&(b="");continue}if(f.throwWhenSomethingWrongIsDetected)throw new TypeError(f.source+(g?": [THROW_ID_19]":"")+' When processing "'+e+'", we found heads ('+e.slice(O,O+v.length)+') starting at character with index number "'+O+'" and there was another set of heads before it! Generally speaking, there should be "heads-tails-heads-tails", not "heads-heads-tails"!\nWe\'re talking about the area of the code:\n\n\n--------------------------------------starts\n'+e.slice(Math.max(O-200,0),O)+"\n      [33m-------\x3e[39m [31m"+e.slice(O,O+v.length)+"[39m [33m<-------[39m\n"+e.slice(O+v.length,Math.min(I,O+200))+"\n--------------------------------------ends\n\n\nTo turn off this error being thrown, set opts.throwWhenSomethingWrongIsDetected to Boolean false.")}var A=l(e,O,r);if(p&&A&&f.matchHeadsAndTailsStrictlyInPairsByTheirOrder&&void 0!==d&&void 0!==r[d]&&r[d]!==A){for(var _=void 0,W=r.length;W--;)if(r[W]===A){_=W;break}throw new TypeError(f.source+(g?": [THROW_ID_20]":"")+' When processing "'+e+'", we had "opts.matchHeadsAndTailsStrictlyInPairsByTheirOrder" on. We found heads ('+t[d]+") but the tails the followed it were not of the same index, "+d+" ("+r[d]+") but "+_+" ("+A+").")}if("string"==typeof A){if(p){w.tailsStartAt=O,w.tailsEndAt=O+A.length,y.push(w),w={},p=!1,O+=A.length-1;continue}f.throwWhenSomethingWrongIsDetected&&(b=f.source+(g?": [THROW_ID_21]":"")+' When processing "'+e+'", we found tails ('+e.slice(O,O+A.length)+') starting at character with index number "'+O+"\" but there were no heads preceding it. That's very naughty!")}}if(f.throwWhenSomethingWrongIsDetected&&O===I-1){if(0!==Object.keys(w).length)throw new TypeError(f.source+(g?": [THROW_ID_22]":"")+' When processing "'+e+"\", we reached the end of the string and yet didn't find any tails ("+JSON.stringify(r,null,4)+") to match the last detected heads ("+e.slice(w.headsStartAt,w.headsEndAt)+")!");if(b)throw new Error(b)}}return y},e.version="4.0.3",Object.defineProperty(e,"__esModule",{value:!0})}));
