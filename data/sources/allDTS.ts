export const allDTS = {"all-named-html-entities":"type JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ndeclare const version: string;\ndeclare const allNamedEntities: JsonObject;\ndeclare const brokenNamedEntities: JsonObject;\ndeclare const entStartsWith: JsonObject;\ndeclare const entEndsWith: JsonObject;\ndeclare const entStartsWithCaseInsensitive: JsonObject;\ndeclare const entEndsWithCaseInsensitive: JsonObject;\ndeclare const uncertain: JsonObject;\ndeclare const allNamedEntitiesSetOnly: Set<string>;\ndeclare const allNamedEntitiesSetOnlyCaseInsensitive: Set<string>;\ndeclare function decode(ent: string): string | null;\ndeclare const minLength = 2;\ndeclare const maxLength = 31;\n\nexport {\n  allNamedEntities,\n  allNamedEntitiesSetOnly,\n  allNamedEntitiesSetOnlyCaseInsensitive,\n  brokenNamedEntities,\n  decode,\n  entEndsWith,\n  entEndsWithCaseInsensitive,\n  entStartsWith,\n  entStartsWithCaseInsensitive,\n  maxLength,\n  minLength,\n  uncertain,\n  version,\n};","array-group-str-omit-num-char":"export { Range, Ranges } from \"ranges-apply\";\n\ndeclare const version: string;\ninterface MappingObj {\n  [key: string]: any;\n}\ninterface Opts {\n  wildcard: string;\n  dedupePlease: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Groups array of strings by omitting number characters\n */\ndeclare function groupStr(arr: string[], opts?: Partial<Opts>): MappingObj;\n\nexport { defaults, groupStr, version };\nexport type { MappingObj, Opts };","array-includes-with-glob":"declare const version: string;\ninterface Opts {\n  arrayVsArrayAllMustBeFound: \"any\" | \"all\";\n  caseSensitive: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Like _.includes but with wildcards\n */\ndeclare function includesWithGlob(\n  input: string | string[],\n  findThis: string | string[],\n  opts?: Partial<Opts>,\n): boolean;\n\nexport { defaults, includesWithGlob, version };\nexport type { Opts };","array-of-arrays-into-ast":"declare const version: string;\ninterface PlainObj {\n  [key: string]: any;\n}\ninterface Opts {\n  dedupe: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Turns an array of arrays of data into a nested tree of plain objects\n */\ndeclare function generateAst(inputArr: any[], opts?: Partial<Opts>): PlainObj;\n\nexport { defaults, generateAst, version };\nexport type { Opts, PlainObj };","array-pull-all-with-glob":"declare const version: string;\ninterface Opts {\n  caseSensitive: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Like _.pullAll but with globs (wildcards)\n */\ndeclare function pull(\n  strArr: string[],\n  toBeRemoved: string | string[],\n  opts?: Partial<Opts>,\n): string[];\n\nexport { defaults, pull, version };\nexport type { Opts };","arrayiffy-if-string":"type StringInABox<T> = T extends \"\"\n  ? []\n  : string extends T\n    ? [] | [string]\n    : T extends string\n      ? [T]\n      : T;\ndeclare function arrayiffy<T>(something: T): StringInABox<T>;\n\nexport { arrayiffy };","ast-compare":"declare const version: string;\ntype JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ninterface AnyObject {\n  [key: string]: any;\n}\ninterface Opts {\n  hungryForWhitespace: boolean;\n  matchStrictly: boolean;\n  verboseWhenMismatches: boolean;\n  useWildcards: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Compare anything: AST, objects, arrays, strings and nested thereof\n */\ndeclare function compare(\n  b: JsonValue,\n  s: JsonValue,\n  opts?: Partial<Opts>,\n): boolean | string;\n\nexport { compare, defaults, version };\nexport type { AnyObject, JsonArray, JsonObject, JsonValue, Opts };","ast-contains-only-empty-space":"declare const version: string;\n/**\n * Does AST contain only empty space?\n */\ndeclare function empty(input: unknown): boolean;\n\nexport { empty, version };","ast-deep-contains":"declare const version: string;\ninterface Opts {\n  skipContainers: boolean;\n  arrayStrictComparison: boolean;\n}\ndeclare const defaults: Opts;\ninterface Callback {\n  (leftSideVal: any, rightSideVal: any, path: string): void;\n}\ninterface ErrorCallback {\n  (errStr: string): void;\n}\n/**\n * Like t.same assert on array of objects, where element order doesn't matter.\n */\ndeclare function deepContains(\n  tree1: any,\n  tree2: any,\n  cb: Callback,\n  errCb: ErrorCallback,\n  opts?: Partial<Opts>,\n): void;\n\nexport { deepContains, defaults, version };\nexport type { Callback, ErrorCallback, Opts };","ast-delete-object":"declare const version: string;\ntype JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ninterface Opts {\n  matchKeysStrictly: boolean;\n  hungryForWhitespace: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Delete all plain objects in AST if they contain a certain key/value pair\n */\ndeclare function deleteObj<T extends JsonValue>(\n  input: T,\n  objToDelete: JsonObject,\n  opts?: Partial<Opts>,\n): T;\n\nexport { defaults, deleteObj, version };\nexport type { JsonArray, JsonObject, JsonValue, Opts };","ast-get-object":"declare const version: string;\ninterface UnknownValueObj {\n  [key: string]: any;\n}\ndeclare function getObj(\n  originalAst: any,\n  keyValPair: UnknownValueObj,\n  replacementContentsArr?: UnknownValueObj[],\n): any;\n\nexport { getObj, version };\nexport type { UnknownValueObj };","ast-get-values-by-key":"declare const version: string;\ninterface Findings {\n  val: any;\n  path: string;\n}\n/**\n * Extract values and paths from AST by keys OR set them by keys\n */\ndeclare function getByKey(\n  originalInput: any,\n  whatToFind: string | string[],\n  originalReplacement?: any,\n): any;\n\nexport { getByKey, version };\nexport type { Findings };","ast-is-empty":"declare const version: string;\n/**\n * Find out, is nested array/object/string/AST tree is empty\n */\ndeclare function isEmpty(input: unknown): boolean | null;\n\nexport { isEmpty, version };","ast-loose-compare":"declare const version: string;\ntype JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ninterface UnknownValueObj {\n  [key: string]: any;\n}\n/**\n * Compare anything: AST, objects, arrays and strings\n */\ndeclare function looseCompare(\n  bigObj: JsonValue,\n  smallObj: JsonValue,\n): boolean | undefined;\n\nexport { looseCompare, version };\nexport type { JsonArray, JsonObject, JsonValue, UnknownValueObj };","ast-monkey":"export { traverse } from \"ast-monkey-traverse\";\n\ndeclare const version: string;\ntype JsonValue =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | JsonObject\n  | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ninterface Finding {\n  index: number;\n  key: string;\n  val: any;\n  path: number[];\n}\ninterface FindOpts {\n  key: null | string;\n  val: any;\n  only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function find(input: JsonValue, opts: FindOpts): Finding[];\ninterface GetOpts {\n  index: number;\n  only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function get(input: JsonValue, opts: GetOpts): JsonValue;\ninterface SetOpts {\n  key: null | string;\n  val: any;\n  index: number;\n}\ndeclare function set(input: JsonValue, opts: SetOpts): JsonValue;\ninterface DropOpts {\n  index: number;\n}\ndeclare function drop(input: JsonValue, opts: DropOpts): JsonValue;\ninterface DelOpts {\n  key: null | string;\n  val: any;\n  only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function del(input: JsonValue, opts: DelOpts): JsonValue;\ndeclare function arrayFirstOnly(input: JsonValue): JsonValue;\n\nexport { arrayFirstOnly, del, drop, find, get, set, version };\nexport type {\n  DelOpts,\n  DropOpts,\n  FindOpts,\n  Finding,\n  GetOpts,\n  JsonArray,\n  JsonObject,\n  JsonValue,\n  SetOpts,\n};","ast-monkey-traverse":"declare const version: string;\ninterface Stop {\n  now: boolean;\n}\ninterface InnerObj {\n  depth: number;\n  path: string;\n  topmostKey: string;\n  parent: any;\n  parentType: string;\n  parentKey: string | null;\n}\ntype Callback = (key: string, val: any, innerObj: InnerObj, stop: Stop) => any;\n/**\n * Utility library to traverse AST\n */\ndeclare function traverse<T>(tree1: T, cb1: Callback): T;\n\nexport { traverse, version };\nexport type { Callback, InnerObj, Stop };","ast-monkey-traverse-with-lookahead":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ntype NextToken = [\n  key: \"string\",\n  value: any,\n  innerObj: {\n    depth: number;\n    path: string;\n    parent: any;\n    parentType: string;\n  },\n];\ninterface InnerObj {\n  depth: number;\n  path: string;\n  topmostKey?: string;\n  parent?: any;\n  parentType?: string;\n  next?: NextToken[];\n}\ntype Callback = (\n  key: string | Obj,\n  val: any,\n  innerObj: InnerObj,\n  stop: {\n    now: boolean;\n  },\n) => any;\ndeclare function traverse(tree1: any, cb1: Callback, lookahead?: number): void;\n\nexport { traverse, version };\nexport type { Callback, InnerObj, NextToken, Obj };","ast-monkey-util":"declare function pathNext(str: string): string;\n\ndeclare function pathPrev(str: string): null | string;\n\ndeclare function pathUp(str: string): string;\n\ndeclare function parentItem(str: string): null | string;\n\ndeclare const version: string;\n\nexport { parentItem as parent, pathNext, pathPrev, pathUp, version };","charcode-is-valid-xml-name-character":"declare function isProduction4(char: string): boolean;\ndeclare function isProduction4a(char: string): boolean;\n\nexport {\n  isProduction4,\n  isProduction4a,\n  isProduction4 as validFirstChar,\n  isProduction4a as validSecondCharOnwards,\n};","check-types-mini":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  ignoreKeys: string | string[];\n  ignorePaths: string | string[];\n  acceptArrays: boolean;\n  acceptArraysIgnore: string | string[];\n  enforceStrictKeyset: boolean;\n  schema: Obj;\n  msg: string;\n  optsVarName: string;\n}\ndeclare const defaults: Opts;\n/**\n * Validate options object\n */\ndeclare function checkTypesMini(\n  obj: Obj,\n  ref: Obj | null,\n  opts?: Partial<Opts>,\n): void;\n\nexport { checkTypesMini, defaults, version };","codsen-utils":"declare const version: string;\ndeclare const leftSingleQuote = \"\\u2018\";\ndeclare const rightSingleQuote = \"\\u2019\";\ndeclare const leftDoubleQuote = \"\\u201C\";\ndeclare const rightDoubleQuote = \"\\u201D\";\ndeclare const rawNDash = \"\\u2013\";\ndeclare const rawMDash = \"\\u2014\";\ndeclare const rawNbsp = \"\\u00A0\";\ndeclare const ellipsis = \"\\u2026\";\ndeclare const hairspace = \"\\u200A\";\ndeclare const thinSpace = \"\\u2009\";\ndeclare const singlePrime = \"\\u2032\";\ndeclare const doublePrime = \"\\u2033\";\ndeclare const backslash = \"\\\\\";\ndeclare const rawReplacementMark = \"\\uFFFD\";\ndeclare const backtick = \"`\";\ndeclare const multiplicationSign = \"\\u00D7\";\ndeclare const punctuationChars: string[];\ntype JSONValue = string | number | boolean | null | JSONObject | JSONArray;\ntype JsonObject = {\n  [Key in string]?: JSONValue;\n};\ntype JSONArray = JSONValue[];\ninterface JSONObject {\n  [key: string]: JSONValue;\n}\ntype Obj = JSONObject;\ntype EolChar = \"\\n\" | \"\\r\" | \"\\r\\n\";\ntype EolSetting = \"lf\" | \"crlf\" | \"cr\";\ndeclare function isNumberChar(value: unknown): boolean;\ndeclare function isCurrencyChar(value: unknown): boolean;\ndeclare function isCurrencySymbol(value: unknown): boolean;\ndeclare function isLetter(value: unknown): boolean;\ndeclare function isLatinLetter(value: unknown): boolean;\ndeclare function isQuote(value: unknown): boolean;\ndeclare function isLowercaseLetter(value: unknown): boolean;\ndeclare function isUppercaseLetter(value: unknown): boolean;\ndeclare function isWhitespaceChar(value: unknown): boolean;\ndeclare const removeTrailingSlash: <T>(value: T) => string | T;\n/**\n * Tells, is given input a plain object (an object literal,\n * a container object Object.create(null) or created by new Object())\n * @param value unknown\n * @returns boolean\n */\ndeclare function isPlainObject(value: unknown): value is JSONObject;\n/**\n * @param str input string\n * @param index starting index\n * @param count how many characters to replace\n * @param add what string to insert\n * @returns string\n * Adapted from https://stackoverflow.com/a/21350614\n */\ndeclare function stringSplice(\n  str?: string,\n  index?: number,\n  count?: number,\n  add?: string,\n): string;\ndeclare function isStr(something: unknown): something is string;\ndeclare function isNum(something: unknown): something is number;\ndeclare function isInt(something: unknown): something is number;\ndeclare function isBool(something: unknown): something is boolean;\ndeclare function isNull(something: unknown): something is null;\ndeclare function isRegExp(something: any): something is RegExp;\n/**\n * Gives array of indexes of all found substring occurrences\n * @param string source string\n * @param substring what to look for\n * @returns array of findings' position indexes\n * adapted from https://stackoverflow.com/a/10710406\n * console.log(findAllIdx(\"scissors\", \"s\"));\n * -> [0, 3, 4, 7]\n */\ndeclare function findAllIdx(value: unknown, substring: unknown): number[];\n/**\n * Unlike lodash equivalent, it does not mutate the input array\n * @param input\n * @param remove\n * @returns\n */\ndeclare function pullAll<T, U>(input?: T[], remove?: U[]): T[];\ndeclare function existy(x: unknown): boolean;\n/**\n * Returns a shallow copy of input array, with only unique elements\n * @param input array\n * @returns de-duped array\n */\ndeclare function uniq<T>(input: T[]): T[];\ndeclare function detectEol(str: string | unknown): EolChar | undefined;\ndeclare function resolveEolSetting(\n  str: string | unknown,\n  eolSetting: EolSetting | unknown,\n  defaultEolChar?: EolChar,\n): EolChar;\ndeclare function hasOwnProp(obj: unknown, prop: string): boolean;\n/**\n * Related to @typescript-eslint/require-array-sort-compare lint error\n */\ndeclare function compareFn(a: string, b: string): number;\ndeclare const voidTags: string[];\ndeclare const inlineTags: Set<string>;\n/**\n * Like Array.prototype.includes() but it takes a mix of strings and/or\n * regex'es, and matches that against a string. It's also a friendly API,\n * it will not throw if the inputs are wrong.\n * @param arr - array of zero or more strings or regex'es\n * @param whatToMatch - string to match\n * @returns boolean\n */\ndeclare function includes(\n  arr: (string | RegExp)[],\n  whatToMatch: string,\n): boolean;\n/** Alternative to lodash.intersection */\ndeclare function intersection<T, U>(a?: T[], b?: U[]): T[];\n/** Alternative to lodash.omit */\ndeclare function omit(obj: JSONObject, keysToRemove?: string[]): JSONObject;\n\nexport {\n  backslash,\n  backtick,\n  compareFn,\n  detectEol,\n  doublePrime,\n  ellipsis,\n  existy,\n  findAllIdx,\n  hairspace,\n  hasOwnProp,\n  includes,\n  inlineTags,\n  intersection,\n  isBool,\n  isCurrencyChar,\n  isCurrencySymbol,\n  isInt,\n  isLatinLetter,\n  isLetter,\n  isLowercaseLetter,\n  isNull,\n  isNum,\n  isNumberChar,\n  isPlainObject,\n  isQuote,\n  isRegExp,\n  isStr,\n  isUppercaseLetter,\n  isWhitespaceChar,\n  leftDoubleQuote,\n  leftSingleQuote,\n  multiplicationSign,\n  omit,\n  pullAll,\n  punctuationChars,\n  rawMDash,\n  rawNDash,\n  rawNbsp,\n  rawReplacementMark,\n  removeTrailingSlash,\n  resolveEolSetting,\n  rightDoubleQuote,\n  rightSingleQuote,\n  singlePrime,\n  stringSplice,\n  thinSpace,\n  uniq,\n  version,\n  voidTags,\n};\nexport type {\n  EolChar,\n  EolSetting,\n  JSONArray,\n  JSONObject,\n  JSONValue,\n  JsonObject,\n  Obj,\n};","color-shorthand-hex-to-six-digit":"declare const version: string;\n/**\n * Convert shorthand hex color codes into full\n */\ndeclare function conv(input: any): any;\n\nexport { conv, version };","csv-sort":"declare function isNumeric(str: any): boolean;\ndeclare function findType(something: string): string;\n\ndeclare const version: string;\ninterface Res {\n  res: string[][];\n  msgContent: null | string;\n  msgType: null | string;\n}\n/**\n * Sorts double-entry bookkeeping CSV coming from internet banking\n */\ndeclare function sort(input: string): Res;\n\nexport { findType, isNumeric, sort, version };\nexport type { Res };","csv-split-easy":"declare const version: string;\ninterface Opts {\n  removeThousandSeparatorsFromNumbers: boolean;\n  padSingleDecimalPlaceNumbers: boolean;\n  forceUKStyle: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function splitEasy(str: string, opts?: Partial<Opts>): string[][];\n\nexport { defaults, splitEasy, version };\nexport type { Opts };","detect-is-it-html-or-xhtml":"declare const version: string;\ntype Output = \"html\" | \"xhtml\" | null;\ndeclare function detectIsItHTMLOrXhtml(input: string): Output;\n\nexport { detectIsItHTMLOrXhtml, version };\nexport type { Output };","detect-templating-language":"declare const version: string;\ntype Output = \"Nunjucks\" | \"Jinja\" | \"JSP\" | null;\ndeclare function detectLang(str: string): {\n  name: Output;\n};\n\nexport { detectLang, version };\nexport type { Output };","detergent":"import { EolSetting } from \"codsen-utils\";\n\ninterface Opts {\n  fixBrokenEntities: boolean;\n  removeWidows: boolean;\n  convertEntities: boolean;\n  convertDashes: boolean;\n  convertApostrophes: boolean;\n  replaceLineBreaks: boolean;\n  removeLineBreaks: boolean;\n  useXHTML: boolean;\n  dontEncodeNonLatin: boolean;\n  addMissingSpaces: boolean;\n  convertDotsToEllipsis: boolean;\n  stripHtml: boolean;\n  eol: EolSetting;\n  stripHtmlButIgnoreTags: string[];\n  stripHtmlAddNewLine: string[];\n  cb: null | ((str: string) => string);\n}\ndeclare const defaultOpts: Opts;\ninterface ApplicableOpts {\n  fixBrokenEntities: boolean;\n  removeWidows: boolean;\n  convertEntities: boolean;\n  convertDashes: boolean;\n  convertApostrophes: boolean;\n  replaceLineBreaks: boolean;\n  removeLineBreaks: boolean;\n  useXHTML: boolean;\n  dontEncodeNonLatin: boolean;\n  addMissingSpaces: boolean;\n  convertDotsToEllipsis: boolean;\n  stripHtml: boolean;\n  eol: boolean;\n}\ninterface Res {\n  res: string;\n  applicableOpts: ApplicableOpts;\n}\n\ndeclare const version: string;\n/**\n * Extracts, cleans and encodes text\n */\ndeclare function det(str: string, opts?: Partial<Opts>): Res;\n\nexport { det, defaultOpts as opts, version };\nexport type { Opts, Res };","edit-package-json":"declare const version: string;\ninterface Inputs {\n  str: string;\n  path: string;\n  valToInsert?: string | number;\n  mode: \"set\" | \"del\";\n}\ndeclare function set(\n  str: string,\n  path: string,\n  valToInsert: string | number,\n): string;\ndeclare function del(str: string, path: string): string;\n\nexport { del, set, version };\nexport type { Inputs };","email-all-chars-within-ascii":"declare const version: string;\ninterface Res {\n  type: \"character\" | \"line length\";\n  line: number;\n  column: number;\n  positionIdx: number;\n  value: number | string;\n  codePoint?: undefined | number;\n  UTF32Hex?: undefined | string;\n}\ninterface Opts {\n  lineLength: number;\n}\ndeclare const defaults: Opts;\ndeclare function within(str: string, opts?: Partial<Opts>): Res[];\n\nexport { defaults, version, within };\nexport type { Opts, Res };","email-comb":"import { Opts as Opts$1 } from \"html-crush\";\n\ndeclare const version: string;\ninterface HeadsAndTailsObj {\n  heads: string;\n  tails: string;\n}\ninterface Opts {\n  whitelist: string[];\n  backend: HeadsAndTailsObj[];\n  uglify: boolean;\n  removeHTMLComments: boolean;\n  removeCSSComments: boolean;\n  doNotRemoveHTMLCommentsWhoseOpeningTagContains: string[];\n  htmlCrushOpts: Partial<Opts$1>;\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n}\ntype StringifiedLegend = [string, string];\ninterface Res {\n  log: {\n    timeTakenInMilliseconds: number;\n    traversedTotalCharacters: number;\n    traversedTimesInputLength: number;\n    originalLength: number;\n    cleanedLength: number;\n    bytesSaved: number;\n    percentageReducedOfOriginal: number;\n    nonIndentationsWhitespaceLength: number;\n    nonIndentationsTakeUpPercentageOfOriginal: number;\n    commentsLength: number;\n    commentsTakeUpPercentageOfOriginal: number;\n    uglified: null | StringifiedLegend[];\n  };\n  result: string;\n  countAfterCleaning: number;\n  countBeforeCleaning: number;\n  allInHead: string[];\n  allInBody: string[];\n  deletedFromHead: string[];\n  deletedFromBody: string[];\n}\ndeclare const defaults: Opts;\n/**\n * Remove unused CSS from email templates\n */\ndeclare function comb(str: string, opts?: Partial<Opts>): Res;\n\nexport { comb, defaults, version };\nexport type { HeadsAndTailsObj, Opts, Res };","extract-search-index":"declare const version: string;\ndeclare function extract(str: string): string;\n\nexport { extract, version };","generate-atomic-css":"declare const headsAndTails: {\n  CONFIGHEAD: string;\n  CONFIGTAIL: string;\n  CONTENTHEAD: string;\n  CONTENTTAIL: string;\n};\ndeclare function extractFromToSource(\n  str: string,\n  fromDefault?: number,\n  toDefault?: number,\n): [from: number, to: number, source: string];\n\ndeclare const version: string;\ninterface Opts {\n  includeConfig: boolean;\n  includeHeadsAndTails: boolean;\n  pad: boolean;\n  configOverride: null | string;\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  log: {\n    count: number;\n  };\n  result: string;\n}\ndeclare function genAtomic(str: string, opts?: Partial<Opts>): Res;\n\nexport { defaults, extractFromToSource, genAtomic, headsAndTails, version };\nexport type { Opts, Res };","html-all-known-attributes":"declare const version: string;\ndeclare const allHtmlAttribs: Set<string>;\n\nexport { allHtmlAttribs, version };","html-crush":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n  lineLengthLimit: number;\n  removeIndentations: boolean;\n  removeLineBreaks: boolean;\n  removeHTMLComments: boolean | 0 | 1 | 2;\n  removeCSSComments: boolean;\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n  breakToTheLeftOf: string[];\n  mindTheInlineTags: string[];\n}\ndeclare const defaults: Opts;\ninterface Res {\n  log: {\n    timeTakenInMilliseconds: number;\n    originalLength: number;\n    cleanedLength: number;\n    bytesSaved: number;\n    percentageReducedOfOriginal: number;\n  };\n  applicableOpts: {\n    removeHTMLComments: boolean;\n    removeCSSComments: boolean;\n  };\n  ranges: Ranges;\n  result: string;\n}\n/**\n * Minifies HTML/CSS: valid or broken, pure or mixed with other languages\n */\ndeclare function crush(str: string, opts?: Partial<Opts>): Res;\n\nexport { crush, defaults, version };\nexport type { Opts, Res };","html-entities-not-email-friendly":"interface Obj {\n  [key: string]: any;\n}\ndeclare const notEmailFriendly: Obj;\ndeclare const notEmailFriendlySetOnly: Set<string>;\ndeclare const notEmailFriendlyLowercaseSetOnly: Set<string>;\ndeclare const notEmailFriendlyMinLength = 2;\ndeclare const notEmailFriendlyMaxLength = 31;\n\nexport {\n  notEmailFriendly,\n  notEmailFriendlyLowercaseSetOnly,\n  notEmailFriendlyMaxLength,\n  notEmailFriendlyMinLength,\n  notEmailFriendlySetOnly,\n};\nexport type { Obj };","html-img-alt":"declare const version: string;\ninterface Opts {\n  unfancyTheAltContents: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function alts(str: string, opts?: Partial<Opts>): string;\n\nexport { alts, defaults, version };\nexport type { Opts };","html-table-patcher":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  cssStylesContent: string;\n  alwaysCenter: boolean;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  result: string;\n}\n/**\n * Visual helper to place templating code around table tags into correct places\n */\ndeclare function patcher(str: string, opts?: Partial<Opts>): Res;\n\nexport { defaults, patcher, version };\nexport type { Obj, Opts, Res };","is-char-suitable-for-html-attr-name":"declare const version: string;\ndeclare function isAttrNameChar(char: any | string): boolean;\n\nexport { isAttrNameChar, version };","is-html-attribute-closing":"declare const version: string;\ndeclare function isAttrClosing(\n  str: string,\n  idxOfAttrOpening: number,\n  isThisClosingIdx: number,\n): boolean;\n\nexport { isAttrClosing, version };","is-html-tag-opening":"declare const defaultOpts: {\n  allowCustomTagNames: boolean;\n  skipOpeningBracket: boolean;\n};\n\ndeclare const version: string;\ninterface Opts {\n  allowCustomTagNames: boolean;\n  skipOpeningBracket: boolean;\n}\ndeclare function isOpening(\n  str: string,\n  idx?: number,\n  opts?: Partial<Opts>,\n): boolean;\n\nexport { defaultOpts as defaults, isOpening, version };\nexport type { Opts };","is-language-code":"declare const version: string;\ntype Res =\n  | {\n      res: true;\n      message: null;\n    }\n  | {\n      res: false;\n      message: string;\n    };\ndeclare function isLangCode(str: string): Res;\n\nexport { isLangCode, version };","is-media-descriptor":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ninterface Opts {\n  offset: number;\n}\ninterface ResObj {\n  idxFrom: number;\n  idxTo: number;\n  message: string;\n  fix: {\n    ranges: Ranges;\n  } | null;\n}\n\ndeclare const version: string;\ndeclare const defaults: {\n  offset: number;\n};\ndeclare function isMediaD(str: string, opts?: Partial<Opts>): ResObj[];\n\nexport { defaults, isMediaD, version };\nexport type { Opts, ResObj };","is-relative-uri":"declare const version: string;\ninterface Opts {\n  flagUpUrisWithSchemes: boolean;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  res: boolean;\n  message: string | null;\n}\ndeclare function isRel(str: string, opts?: Partial<Opts>): Res;\n\nexport { defaults, isRel, version };\nexport type { Opts, Res };","js-row-num":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\n\ninterface Opts {\n  padStart: number;\n  overrideRowNum: null | number;\n  triggerKeywords: string[];\n  extractedLogContentsWereGiven: boolean;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  log: {\n    timeTakenInMilliseconds: number;\n  };\n  result: string;\n  ranges: Ranges;\n}\ndeclare function fixRowNums(str: string, opts?: Partial<Opts>): Res;\n\nexport { defaults, fixRowNums, version };\nexport type { Opts, Ranges, Res };","json-comb-core":"import { Obj } from \"codsen-utils\";\n\ndeclare const version: string;\ndeclare function sortAllObjectsSync(input: any): any;\ndeclare function getKeyset(\n  arrOfPromises: Iterable<PromiseLike<Obj> | Obj>,\n  opts?: Partial<GetKeysetOpts>,\n): Promise<Obj>;\ninterface GetKeysetOpts {\n  placeholder: any;\n}\ndeclare function getKeysetSync(arr: Obj[], opts?: Partial<GetKeysetOpts>): Obj;\ninterface EnforceKeysetOpts {\n  doNotFillThesePathsIfTheyContainPlaceholders: string[];\n  placeholder: boolean;\n  useNullAsExplicitFalse: boolean;\n}\ndeclare function enforceKeyset(\n  obj: Obj,\n  schemaKeyset: Obj,\n  opts?: Partial<EnforceKeysetOpts>,\n): Promise<Obj>;\ndeclare function enforceKeysetSync(\n  obj: Obj,\n  schemaKeyset: Obj,\n  opts?: Partial<EnforceKeysetOpts>,\n): Obj;\ntype NoNewKeysSyncRes = string[];\ndeclare function noNewKeysSync(obj: Obj, schemaKeyset: Obj): NoNewKeysSyncRes;\ninterface FindUnusedSyncOpts {\n  placeholder: boolean;\n  comments: string;\n}\ndeclare function findUnusedSync(\n  arr: any[],\n  opts?: Partial<FindUnusedSyncOpts>,\n): string[];\n\nexport {\n  enforceKeyset,\n  enforceKeysetSync,\n  findUnusedSync,\n  getKeyset,\n  getKeysetSync,\n  noNewKeysSync,\n  sortAllObjectsSync,\n  version,\n};","json-variables":"import { Obj } from \"codsen-utils\";\n\ndeclare const version: string;\ninterface Opts {\n  heads: string;\n  tails: string;\n  headsNoWrap: string;\n  tailsNoWrap: string;\n  lookForDataContainers: boolean;\n  dataContainerIdentifierTails: string;\n  wrapHeadsWith: string | string[];\n  wrapTailsWith: string | string[];\n  dontWrapVars: string[];\n  preventDoubleWrapping: boolean;\n  wrapGlobalFlipSwitch: boolean;\n  noSingleMarkers: boolean;\n  resolveToBoolIfAnyValuesContainBool: boolean;\n  resolveToFalseIfAnyValuesContainBool: boolean;\n  throwWhenNonStringInsertedInString: boolean;\n  allowUnresolved: boolean | string;\n}\ndeclare const defaults: Opts;\n/**\n * Resolves custom-marked, cross-referenced paths in parsed JSON\n */\ndeclare function jVar(input: Obj, opts?: Partial<Opts>): Obj;\n\nexport { defaults, jVar, version };\nexport type { Opts };","lerna-clean-changelogs":"declare const version: string;\ninterface Opts {\n  extras: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function cleanChangelogs(\n  changelog: string,\n  opts?: Partial<Opts>,\n): {\n  version: string;\n  res: string;\n};\n\nexport { cleanChangelogs, defaults, version };\nexport type { Opts };","object-all-values-equal-to":"declare const version: string;\ninterface Opts {\n  arraysMustNotContainPlaceholders: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function allEq(input: any, value: any, opts?: Partial<Opts>): boolean;\n\nexport { allEq, defaults, version };\nexport type { Opts };","object-boolean-combinations":"import { Obj } from \"codsen-utils\";\n\ndeclare const version: string;\ninterface BoolObj {\n  [key: string]: boolean;\n}\ndeclare function combinations(input: Obj, Override?: undefined | Obj): Obj[];\n\nexport { combinations, version };\nexport type { BoolObj };","object-delete-key":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ntype Only = \"array\" | \"object\" | \"any\";\ninterface Opts {\n  key: null | string;\n  val: any;\n  cleanup: boolean;\n  only: Only;\n}\ndeclare const defaults: Opts;\ndeclare function deleteKey(input: Obj, opts?: Partial<Opts>): Obj;\n\nexport { defaults, deleteKey, version };\nexport type { Obj, Opts };","object-fill-missing-keys":"import { Obj } from \"codsen-utils\";\n\ndeclare const version: string;\ninterface Opts {\n  placeholder: boolean;\n  doNotFillThesePathsIfTheyContainPlaceholders: string[];\n  useNullAsExplicitFalse: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function fillMissing(\n  incomplete: Obj,\n  schema: Obj,\n  opts?: Partial<Opts>,\n): Obj;\n\nexport { defaults, fillMissing, version };\nexport type { Opts };","object-flatten-all-arrays":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  flattenArraysContainingStringsToBeEmpty: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function flattenAllArrays(input: Obj, opts?: Partial<Opts>): Obj;\n\nexport { defaults, flattenAllArrays, version };\nexport type { Obj, Opts };","object-flatten-referencing":"export { arrayiffy } from \"arrayiffy-if-string\";\nimport { JSONObject, JSONValue } from \"codsen-utils\";\n\ninterface Opts {\n  wrapHeadsWith: string;\n  wrapTailsWith: string;\n  dontWrapKeys: string[];\n  dontWrapPaths: string[];\n  xhtml: boolean;\n  preventDoubleWrapping: boolean;\n  preventWrappingIfContains: string[];\n  objectKeyAndValueJoinChar: string;\n  wrapGlobalFlipSwitch: boolean;\n  ignore: string[];\n  whatToDoWhenReferenceIsMissing: 0 | 1 | 2;\n  mergeArraysWithLineBreaks: boolean;\n  mergeWithoutTrailingBrIfLineContainsBr: boolean;\n  enforceStrictKeyset: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function flattenObject(obj: JSONObject, opts?: Partial<Opts>): any[];\ndeclare function flattenArr(\n  arr: any[],\n  opts?: Partial<Opts>,\n  wrap?: boolean,\n  joinArraysUsingBrs?: boolean,\n): string;\n\ndeclare const version: string;\ndeclare function flattenReferencing(\n  input: JSONValue,\n  reference: JSONValue,\n  opts?: Partial<Opts>,\n): any;\n\nexport { defaults, flattenArr, flattenObject, flattenReferencing, version };\nexport type { Opts };","object-merge-advanced":"declare const version: string;\ntype argType =\n  | \"date\"\n  | \"date\"\n  | \"object\"\n  | \"array\"\n  | \"string\"\n  | \"number\"\n  | \"function\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"symbol\"\n  | \"null\"\n  | \"undefined\";\ninterface InfoObj {\n  path: string | undefined;\n  key: string | null;\n  type: [argType, argType];\n}\ninterface Opts {\n  cb:\n    | null\n    | ((input1: any, input2: any, result: any, infoObj?: InfoObj) => any);\n  mergeObjectsOnlyWhenKeysetMatches: boolean;\n  ignoreKeys: string | string[];\n  hardMergeKeys: string | string[];\n  hardArrayConcatKeys: string[];\n  mergeArraysContainingStringsToBeEmpty: boolean;\n  oneToManyArrayObjectMerge: boolean;\n  hardMergeEverything: boolean;\n  hardArrayConcat: boolean;\n  ignoreEverything: boolean;\n  concatInsteadOfMerging: boolean;\n  dedupeStringsInArrayValues: boolean;\n  mergeBoolsUsingOrNotAnd: boolean;\n  useNullAsExplicitFalse: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Recursively, deeply merge of anything\n */\ndeclare function externalApi(\n  input1: unknown,\n  input2: unknown,\n  opts?: Partial<Opts>,\n): any;\n\nexport { defaults, externalApi as mergeAdvanced, version };\nexport type { InfoObj, Opts, argType };","object-no-new-keys":"import { JSONValue } from \"codsen-utils\";\n\ndeclare const version: string;\ninterface Opts {\n  mode: 1 | 2;\n}\ndeclare const defaults: Opts;\ndeclare function noNewKeys(\n  input: JSONValue,\n  reference: JSONValue,\n  opts?: Partial<Opts>,\n): string[];\n\nexport { defaults, noNewKeys, version };\nexport type { Opts };","object-set-all-values-to":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ndeclare function setAllValuesTo(input: Obj, value?: any): Obj;\n\nexport { setAllValuesTo, version };\nexport type { Obj };","ranges-apply":"import { Ranges } from \"ranges-merge\";\nexport { Range, Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ndeclare function rApply(\n  str: string,\n  originalRangesArr: Ranges,\n  progressFn?: (percentageDone: number) => void,\n): string;\n\nexport { rApply, version };","ranges-crop":"import { Ranges } from \"ranges-merge\";\nexport { Range, Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ndeclare function rCrop(arrOfRanges: Ranges, strLen: number): Ranges;\n\nexport { rCrop, version };","ranges-ent-decode":"import { Ranges } from \"ranges-merge\";\nexport { Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ninterface Opts {\n  isAttributeValue: boolean;\n  strict: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function rEntDecode(str: string, opts?: Partial<Opts>): Ranges;\n\nexport { defaults, rEntDecode, version };\nexport type { Opts };","ranges-invert":"import { Ranges } from \"ranges-merge\";\nexport { Range, Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ninterface Opts {\n  strictlyTwoElementsInRangeArrays: boolean;\n  skipChecks: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function rInvert(\n  arrOfRanges: Ranges,\n  strLen: number,\n  originalOptions?: Partial<Opts>,\n): Ranges;\n\nexport { defaults, rInvert, version };\nexport type { Opts };","ranges-is-index-within":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n  inclusiveRangeEnds: boolean;\n  returnMatchedRangeInsteadOfTrue: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function isIndexWithin(\n  index: number,\n  rangesArr: Ranges,\n  opts?: Partial<Opts>,\n): boolean | Range;\n\nexport { defaults, isIndexWithin, version };\nexport type { Opts, Range, Ranges };","ranges-iterate":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Obj {\n  i: number;\n  val: any;\n}\ntype Callback = (obj: Obj) => void;\ndeclare function rIterate(\n  str: string,\n  input: Ranges,\n  cb: Callback,\n  offset?: number,\n): void;\n\nexport { rIterate, version };\nexport type { Callback, Obj };","ranges-merge":"import { Ranges } from \"ranges-sort\";\nexport { Range, Ranges } from \"ranges-sort\";\n\ndeclare const version: string;\ninterface UnknownValueObj {\n  [key: string]: any;\n}\ntype ProgressFn = (percentageDone: number) => void;\ninterface Opts {\n  mergeType: 1 | 2 | \"1\" | \"2\";\n  progressFn: null | undefined | ProgressFn;\n  joinRangesThatTouchEdges: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function rMerge(\n  arrOfRanges: Ranges,\n  originalOpts?: Partial<Opts>,\n): Ranges;\n\nexport { defaults, rMerge, version };\nexport type { Opts, ProgressFn, UnknownValueObj };","ranges-process-outside":"import { Ranges } from \"ranges-crop\";\nexport { Ranges } from \"ranges-crop\";\n\ndeclare const version: string;\ntype OffsetValueCb = (amountToOffset: number) => void;\ntype Callback = (\n  fromIdx: number,\n  toIdx: number,\n  offsetValueCb: OffsetValueCb,\n) => void;\ndeclare function rProcessOutside(\n  originalStr: string,\n  originalRanges: Ranges,\n  cb: Callback,\n  skipChecks?: boolean,\n): void;\n\nexport { rProcessOutside, version };\nexport type { Callback, OffsetValueCb };","ranges-push":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\n\ndeclare const version: string;\ninterface Opts {\n  limitToBeAddedWhitespace: boolean;\n  limitLinebreaksCount: number;\n  mergeType: 1 | 2 | \"1\" | \"2\" | undefined;\n}\ndeclare const defaults: Opts;\ndeclare class Ranges {\n  constructor(originalOpts?: Partial<Opts>);\n  ranges: Range[];\n  opts: Opts;\n  add(\n    originalFrom: number,\n    originalTo?: number,\n    addVal?: undefined | null | string,\n  ): void;\n  add(originalFrom: Range[] | Range | null): void;\n  push(\n    originalFrom: number,\n    originalTo?: number,\n    addVal?: undefined | null | string,\n  ): void;\n  push(originalFrom: Range[] | Range | null): void;\n  current(): null | Range[];\n  wipe(): void;\n  replace(givenRanges: Range[]): void;\n  last(): Range | null;\n}\n\nexport { Ranges, defaults, version };\nexport type { Opts, Range };","ranges-regex":"import { Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ndeclare function rRegex(\n  regExp: RegExp,\n  str: string,\n  replacement?: string | null | undefined,\n): Ranges;\n\nexport { rRegex, version };","ranges-sort":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\ndeclare const version: string;\ntype ProgressFn = (percentageDone: number) => void;\ninterface Opts {\n  strictlyTwoElementsInRangeArrays: boolean;\n  progressFn: undefined | null | ProgressFn;\n}\ndeclare const defaults: Opts;\ndeclare function rSort(\n  arrOfRanges: Ranges,\n  originalOptions?: Partial<Opts>,\n): Ranges;\n\nexport { defaults, rSort, version };\nexport type { Opts, ProgressFn, Range, Ranges };","regex-empty-conditional-comments":"declare const version: string;\ndeclare function emptyCondCommentRegex(): RegExp;\n\nexport { emptyCondCommentRegex, version };","regex-is-jinja-nunjucks":"declare const version: string;\ndeclare function isJinjaNunjucksRegex(): RegExp;\n\nexport { isJinjaNunjucksRegex, version };","regex-is-jsp":"declare const version: string;\ndeclare function isJSP(): RegExp;\n\nexport { isJSP, version };","regex-jinja-specific":"declare const version: string;\ndeclare function isJinjaSpecific(): RegExp;\n\nexport { isJinjaSpecific, version };","rehype-responsive-tables":"import { Plugin } from \"unified\";\nimport { Root } from \"hast\";\n\ninterface Obj {\n  [key: string]: any;\n}\ndeclare const contains: (\n  tree: any,\n  something: string | string[],\n) => string | undefined;\ndeclare const getNthChildTag: (\n  tree: any,\n  tagName: string,\n  nth: number,\n) => Obj | null;\n\ninterface Opts {\n  /**\n   * Plugin will take each row, add a row above, with content from\n   * the first column (single TD with colspan=0)\n   */\n  tableClassName: string;\n  /**\n   * Plugin will take each row, add a row above, with content from\n   * the first column (single TD with colspan=0)\n   */\n  newTrClassName: string;\n  /**\n   * The first TD of each TR in the result table will have this class\n   */\n  hideTdClassName: string;\n  /**\n   * When cells are stacked, it's necessary to visually separate\n   * the blocks. This plugin will add a gap <tr> above\n   */\n  gapTrClassName: string;\n  /**\n   * When the first column is \"lifted\" up, its contents are wrapped\n   * with a span which will contain this CSS class\n   */\n  newTrSpanTopClassName: string;\n  /**\n   * All labels \"lifted\" with opts.up will be wrapped by a span\n   * with this class\n   */\n  newTrSpanOtherClassName: string;\n  /**\n   * Lift the following cells' contents up, under the first column\n   */\n  up: string[];\n}\ndeclare const defaults: Opts;\ndeclare const rehypeResponsiveTables: Plugin<[Partial<Opts>?], Root>;\n\nexport {\n  contains,\n  rehypeResponsiveTables as default,\n  defaults,\n  getNthChildTag,\n};\nexport type { Opts };","remark-conventional-commit-changelog-timeline":"import { Plugin } from \"unified\";\nimport { Root } from \"hast\";\n\ninterface DateParamsObj {\n  date: Date;\n  year: string;\n  month: string;\n  day: string;\n}\ninterface Opts {\n  dateDivLocale: string;\n  dateDivMarkup: (dateParamsObj: DateParamsObj) => string;\n}\ndeclare const defaults: Opts;\ntype UnifiedPlugin<T> = Plugin<[T], Root>;\ndeclare const changelogTimeline: UnifiedPlugin<[Partial<Opts>?]>;\n\nexport { changelogTimeline as default, defaults };\nexport type { DateParamsObj, Opts };","remark-typography":"import { Plugin } from \"unified\";\nimport { Root } from \"hast\";\n\ntype UnifiedPlugin<T> = Plugin<[T], Root>;\ndeclare const fixTypography: UnifiedPlugin<any[]>;\n\nexport { fixTypography as default };","str-indexes-of-plus":"declare const version: string;\ndeclare function strIndexesOfPlus(\n  str: string,\n  searchValue: string,\n  fromIndex?: string | number,\n): number[];\n\nexport { strIndexesOfPlus, version };","string-apostrophes":"import { Ranges } from \"ranges-apply\";\nexport { Range, Ranges } from \"ranges-apply\";\n\ndeclare const version: string;\ninterface Opts {\n  from: number;\n  to?: number;\n  value?: string;\n  convertEntities?: boolean;\n  convertApostrophes?: boolean;\n  offsetBy?: (amount: number) => void;\n}\ndeclare const defaults: {\n  convertEntities: boolean;\n  convertApostrophes: boolean;\n};\ndeclare function convertOne(str: string, opts: Opts): Ranges;\ninterface convertAllRes {\n  result: string;\n  ranges: Ranges;\n}\n/**\n * Typographically-correct the apostrophes and single/double quotes\n */\ndeclare function convertAll(str: string, opts?: Partial<Opts>): convertAllRes;\n\nexport { convertAll, convertOne, defaults, version };\nexport type { Opts };","string-character-is-astral-surrogate":"declare function isHighSurrogate(something: string | undefined): boolean;\ndeclare function isLowSurrogate(something: string | undefined): boolean;\n\nexport { isHighSurrogate, isLowSurrogate };","string-collapse-leading-whitespace":"declare const version: string;\ndeclare function collWhitespace(str: string, lineBreakLimit?: number): string;\n\nexport { collWhitespace, version };","string-collapse-white-space":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Extras {\n  whiteSpaceStartsAt: null | number;\n  whiteSpaceEndsAt: null | number;\n  str: string;\n}\ninterface CbObj extends Extras {\n  suggested: Range;\n}\ntype Callback = (cbObj: CbObj) => any;\ninterface Opts {\n  trimStart: boolean;\n  trimEnd: boolean;\n  trimLines: boolean;\n  trimnbsp: boolean;\n  removeEmptyLines: boolean;\n  limitConsecutiveEmptyLinesTo: number;\n  enforceSpacesOnly: boolean;\n  cb: Callback;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  result: string;\n  ranges: Ranges;\n}\ndeclare const cbSchema: string[];\ndeclare function collapse(str: string, opts?: Partial<Opts>): Res;\n\nexport { cbSchema, collapse, defaults, version };\nexport type { Callback, CbObj, Extras, Opts, Range, Ranges as RangesType, Res };","string-convert-indexes":"declare const version: string;\ndeclare function nativeToUnicode(str: string, indexes: any): number | string;\ndeclare function unicodeToNative(str: string, indexes: any): number | string;\n\nexport { nativeToUnicode, unicodeToNative, version };","string-dashes":"import { Ranges } from \"ranges-apply\";\nexport { Range, Ranges } from \"ranges-apply\";\n\ndeclare const version: string;\ninterface Opts {\n  from: number;\n  to?: number;\n  value?: string;\n  convertEntities?: boolean;\n  convertDashes?: boolean;\n  offsetBy?: (amount: number) => void;\n}\ndeclare const defaults: {\n  convertEntities: boolean;\n  convertDashes: boolean;\n};\ndeclare function convertOne(str: string, opts: Opts): Ranges;\ninterface convertAllRes {\n  result: string;\n  ranges: Ranges;\n}\n/**\n * Typographically-correct the hyphens and dashes\n */\ndeclare function convertAll(str: string, opts?: Partial<Opts>): convertAllRes;\n\nexport { convertAll, convertOne, defaults, version };\nexport type { Opts };","string-extract-class-names":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Result {\n  res: string[];\n  ranges: Ranges;\n}\n/**\n * Extracts CSS class/id names from a string\n */\ndeclare function extract(str: string): Result;\n\nexport { extract, version };\nexport type { Result };","string-extract-sass-vars":"declare const version: string;\ninterface UnknownValueObj {\n  [key: string]: any;\n}\ninterface Opts {\n  throwIfEmpty?: boolean;\n  cb?: null | ((varValue: string) => any);\n}\ndeclare const defaults: Opts;\ndeclare function extractVars(\n  str: string,\n  opts?: Partial<Opts>,\n): UnknownValueObj;\n\nexport { defaults, extractVars, version };\nexport type { Opts, UnknownValueObj };","string-find-heads-tails":"declare const version: string;\ninterface Opts {\n  fromIndex: number;\n  throwWhenSomethingWrongIsDetected: boolean;\n  allowWholeValueToBeOnlyHeadsOrTails: boolean;\n  source: string;\n  matchHeadsAndTailsStrictlyInPairsByTheirOrder: boolean;\n  relaxedAPI: boolean;\n}\ndeclare const defaults: {\n  fromIndex: number;\n  throwWhenSomethingWrongIsDetected: boolean;\n  allowWholeValueToBeOnlyHeadsOrTails: boolean;\n  source: string;\n  matchHeadsAndTailsStrictlyInPairsByTheirOrder: boolean;\n  relaxedAPI: boolean;\n};\ninterface ResObj {\n  headsStartAt: number;\n  headsEndAt: number;\n  tailsStartAt: number;\n  tailsEndAt: number;\n}\ndeclare function strFindHeadsTails(\n  str: string,\n  heads: string | string[],\n  tails: string | string[],\n  opts?: Partial<Opts>,\n): ResObj[];\n\nexport { defaults, strFindHeadsTails, version };\nexport type { Opts, ResObj };","string-find-malformed":"declare const version: string;\ninterface Opts {\n  stringOffset: number;\n  maxDistance: number;\n  ignoreWhitespace: boolean;\n}\ndeclare const defaults: Opts;\ninterface DataObj {\n  idxFrom: number;\n  idxTo: number;\n}\ndeclare function findMalformed(\n  str: string,\n  refStr: string,\n  cb: (obj: DataObj) => void,\n  opts?: Partial<Opts>,\n): void;\n\nexport { defaults, findMalformed, version };\nexport type { DataObj, Opts };","string-fix-broken-named-entities":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ndeclare const allRules: string[];\ninterface Obj {\n  [key: string]: any;\n}\ninterface cbObj {\n  rangeFrom: number;\n  rangeTo: number;\n  rangeValEncoded: string | null;\n  rangeValDecoded: string | null;\n  ruleName: string;\n  entityName: string | null;\n}\ninterface Opts {\n  decode: boolean;\n  cb: null | ((obj: cbObj) => void);\n  entityCatcherCb: null | ((from: number, to: number) => void);\n  textAmpersandCatcherCb: null | ((idx: number) => void);\n  progressFn: null | ((percDone: number) => void);\n}\ndeclare function fixEnt(str: string, opts?: Partial<Opts>): Ranges;\n\nexport { allRules, fixEnt, version };\nexport type { Obj, Opts, Ranges, cbObj };","string-left-right":"declare const version: string;\ninterface Opts {\n  i?: boolean;\n}\ndeclare function right(str: string, idx?: number | null): number | null;\ndeclare function rightStopAtNewLines(str: string, idx: number): number | null;\ndeclare function rightStopAtRawNbsp(str: string, idx: number): number | null;\ndeclare function left(str: string, idx?: number | null): number | null;\ndeclare function leftStopAtNewLines(str: string, idx: number): number | null;\ndeclare function leftStopAtRawNbsp(str: string, idx: number): number | null;\ninterface SeqOutput {\n  gaps: [number, number][];\n  leftmostChar: number;\n  rightmostChar: number;\n}\ndeclare function leftSeq(\n  str: string,\n  idx: number,\n  ...args: any[]\n): SeqOutput | null;\ndeclare function rightSeq(\n  str: string,\n  idx: number,\n  ...args: any[]\n): SeqOutput | null;\ndeclare function chompLeft(\n  str: string,\n  idx: number,\n  ...args: any[]\n): number | null;\ndeclare function chompRight(\n  str: string,\n  idx: number,\n  ...args: any[]\n): number | null;\n\nexport {\n  chompLeft,\n  chompRight,\n  left,\n  leftSeq,\n  leftStopAtNewLines,\n  leftStopAtRawNbsp,\n  right,\n  rightSeq,\n  rightStopAtNewLines,\n  rightStopAtRawNbsp,\n  version,\n};\nexport type { Opts };","string-match-left-right":"declare const version: string;\ninterface Opts {\n  cb:\n    | undefined\n    | null\n    | ((\n        wholeCharacterOutside?: string | undefined,\n        theRemainderOfTheString?: string,\n        firstCharOutsideIndex?: number,\n      ) => string | boolean);\n  i: boolean;\n  trimBeforeMatching: boolean;\n  trimCharsBeforeMatching: string | string[];\n  maxMismatches: number;\n  firstMustMatch: boolean;\n  lastMustMatch: boolean;\n  hungry: boolean;\n}\ndeclare const defaults: Opts;\ndeclare const defaultGetNextIdx: (index: number) => number;\ndeclare function matchLeftIncl(\n  str: string,\n  position: number,\n  whatToMatch: (() => string) | string | string[],\n  opts?: Partial<Opts>,\n): boolean | string;\ndeclare function matchLeft(\n  str: string,\n  position: number,\n  whatToMatch: (() => string) | string | string[],\n  opts?: Partial<Opts>,\n): boolean | string;\ndeclare function matchRightIncl(\n  str: string,\n  position: number,\n  whatToMatch: (() => string) | string | string[],\n  opts?: Partial<Opts>,\n): boolean | string;\ndeclare function matchRight(\n  str: string,\n  position: number,\n  whatToMatch: (() => string) | string | string[],\n  opts?: Partial<Opts>,\n): boolean | string;\n\nexport {\n  defaultGetNextIdx,\n  defaults,\n  matchLeft,\n  matchLeftIncl,\n  matchRight,\n  matchRightIncl,\n  version,\n};\nexport type { Opts };","string-process-comma-separated":"import { JSONValue } from \"codsen-utils\";\n\ndeclare const version: string;\ntype ErrCb = (\n  indexes: [from: number, to: number, whatToAdd?: JSONValue][],\n  explanation: string,\n  isFixable: boolean,\n) => void;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  from: number;\n  to: number;\n  offset: number;\n  leadingWhitespaceOK: boolean;\n  trailingWhitespaceOK: boolean;\n  oneSpaceAfterCommaOK: boolean;\n  innerWhitespaceAllowed: boolean;\n  separator: string;\n  cb: null | ((from: number, to: number) => void);\n  errCb: null | ErrCb;\n}\ndeclare function processCommaSep(str: string, opts?: Partial<Opts>): void;\n\nexport { processCommaSep, version };\nexport type { ErrCb, Obj, Opts };","string-range-expander":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\n\ndeclare const version: string;\ninterface Opts {\n  str: string;\n  from: number;\n  to: number;\n  ifLeftSideIncludesThisThenCropTightly: string;\n  ifLeftSideIncludesThisCropItToo: string;\n  ifRightSideIncludesThisThenCropTightly: string;\n  ifRightSideIncludesThisCropItToo: string;\n  extendToOneSide: false | \"left\" | \"right\";\n  wipeAllWhitespaceOnLeft: boolean;\n  wipeAllWhitespaceOnRight: boolean;\n  addSingleSpaceToPreventAccidentalConcatenation: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function expander(opts: Partial<Opts>): Range;\n\nexport { defaults, expander, version };\nexport type { Opts, Range };","string-remove-duplicate-heads-tails":"declare const version: string;\ninterface Opts {\n  heads: string[];\n  tails: string[];\n}\ninterface LenientOpts {\n  heads: string | string[];\n  tails: string | string[];\n}\ndeclare const defaults: Opts;\ndeclare function remDup(str: string, opts?: Partial<LenientOpts>): string;\n\nexport { defaults, remDup, version };\nexport type { LenientOpts, Opts };","string-remove-thousand-separators":"declare const version: string;\ninterface Opts {\n  removeThousandSeparatorsFromNumbers: boolean;\n  padSingleDecimalPlaceNumbers: boolean;\n  forceUKStyle: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function remSep(str: string, opts?: Partial<Opts>): string;\n\nexport { defaults, remSep, version };\nexport type { Opts };","string-remove-widows":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface HeadsAndTailsObj {\n  heads: string | string[];\n  tails: string | string[];\n}\ninterface Opts {\n  removeWidowPreventionMeasures: boolean;\n  convertEntities: boolean;\n  targetLanguage: \"html\" | \"css\" | \"js\";\n  UKPostcodes: boolean;\n  hyphens: boolean;\n  minWordCount: number;\n  minCharCount: number;\n  ignore: HeadsAndTailsObj[] | string | string[];\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n  tagRanges: Range[] | null;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  res: string;\n  ranges: Ranges;\n  log: {\n    timeTakenInMilliseconds: number;\n  };\n  whatWasDone: {\n    removeWidows: boolean;\n    convertEntities: boolean;\n  };\n}\ndeclare function removeWidows(str: string, opts?: Partial<Opts>): Res;\n\nexport { defaults, removeWidows, version };\nexport type { HeadsAndTailsObj, Obj, Opts, Res };","string-split-by-whitespace":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\n\ndeclare const version: string;\ninterface Opts {\n  ignoreRanges: Range[];\n}\ndeclare const defaults: Opts;\ndeclare function splitByW(str: string, opts?: Partial<Opts>): string[];\n\nexport { defaults, splitByW, version };\nexport type { Opts, Range };","string-strip-html":"import { Ranges as Ranges$1 } from \"ranges-push\";\n\ntype Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Attribute {\n  nameStarts: number;\n  nameEnds: number;\n  equalsAt?: number;\n  name: string;\n  valueStarts?: number;\n  valueEnds?: number;\n  value?: string;\n}\ninterface Tag {\n  attributes: Attribute[];\n  lastClosingBracketAt: number;\n  lastOpeningBracketAt: number;\n  slashPresent: number;\n  leftOuterWhitespace: number;\n  onlyPlausible: boolean;\n  nameStarts: number;\n  nameContainsLetters: boolean;\n  nameEnds: number;\n  name: string;\n}\ninterface CbObj {\n  tag: Tag;\n  deleteFrom: null | number;\n  deleteTo: null | number;\n  insert: null | undefined | string;\n  rangesArr: Ranges$1;\n  proposedReturn: Range | null;\n}\ninterface Opts {\n  ignoreTags: string[];\n  ignoreTagsWithTheirContents: string[];\n  onlyStripTags: string[];\n  stripTogetherWithTheirContents: string[];\n  skipHtmlDecoding: boolean;\n  trimOnlySpaces: boolean;\n  stripRecognisedHTMLOnly: boolean;\n  dumpLinkHrefsNearby: {\n    enabled?: boolean;\n    putOnNewLine?: boolean;\n    wrapHeads?: string;\n    wrapTails?: string;\n  };\n  ignoreIndentations: boolean;\n  cb: null | ((cbObj: CbObj) => void);\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  log: {\n    timeTakenInMilliseconds: number;\n  };\n  result: string;\n  ranges: Ranges;\n  allTagLocations: [number, number][];\n  filteredTagLocations: [number, number][];\n}\n/**\n * Strips HTML tags from strings. No parser, accepts mixed sources.\n */\ndeclare function stripHtml(str: string, opts?: Partial<Opts>): Res;\n\nexport { defaults, stripHtml, version };\nexport type { Attribute, CbObj, Opts, Res, Tag };","string-trim-spaces-only":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n  classicTrim: boolean;\n  cr: boolean;\n  lf: boolean;\n  tab: boolean;\n  space: boolean;\n  nbsp: boolean;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  res: string;\n  ranges: Ranges;\n}\ndeclare function trimSpaces(str: string, opts?: Partial<Opts>): Res;\n\nexport { defaults, trimSpaces, version };\nexport type { Opts, Res };","string-uglify":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ndeclare function uglifyArr(arr: string[]): string[];\ndeclare function uglifyById(refArr: string[], idNum: number): string;\n\nexport { uglifyArr, uglifyById, version };\nexport type { Obj };","string-unfancy":"declare const version: string;\ndeclare function unfancy(str: string): string;\n\nexport { unfancy, version };","test-mixer":"declare const version: string;\ntype PlainObject = {\n  [name: string]: any;\n};\ntype PlainObjectOfBool = {\n  [name: string]: boolean;\n};\ndeclare function mixer(\n  ref?: PlainObject,\n  defaultsObj?: PlainObject,\n): PlainObjectOfBool[];\n\nexport { mixer, version };\nexport type { PlainObject, PlainObjectOfBool };","tsd-extract":"declare const roysSort: (a: string, b: string) => number;\n\ndeclare const version: string;\ninterface Opts {\n  extractAll: boolean;\n  semi: boolean;\n  mustInclude: string;\n  stripAs: boolean;\n  contentSort?: (el1: string, el2: string) => number;\n}\ninterface Chunk {\n  startsAt: null | number;\n  endsAt: null | number;\n  identifiers: string[];\n}\ninterface Statement {\n  identifiers: string[];\n  identifiersStartAt: number | null;\n  identifiersEndAt: number | null;\n  content: string | null;\n  contentStartsAt: number | null;\n  contentEndsAt: number | null;\n  value: string | null;\n  valueStartsAt: number | null;\n  valueEndsAt: number | null;\n}\ndeclare const defaults: Opts;\ntype ReturnType = Statement & {\n  all: string[];\n  error: string | null;\n};\ndeclare function join(...args: string[]): string;\n/**\n *\n * @param str type definitions file, as a string\n * @param def name of an interface, function or something else to extract\n * @param opts optional options object\n */\ndeclare function extract(\n  str: string,\n  def: string,\n  opts?: Partial<Opts>,\n): ReturnType;\n\nexport { defaults, extract, join, roysSort, version };\nexport type { Chunk, Opts, ReturnType, Statement };","util-array-object-or-both":"declare const version: string;\ninterface Opts {\n  msg: string;\n  optsVarName: string;\n}\ndeclare const defaults: Opts;\ndeclare function arrObjOrBoth(\n  str: string,\n  opts?: Partial<Opts>,\n): \"array\" | \"object\" | \"any\";\n\nexport { arrObjOrBoth, defaults, version };\nexport type { Opts };","util-nonempty":"declare const version: string;\ndeclare function nonEmpty(input: unknown): boolean;\n\nexport { nonEmpty, version };"};
