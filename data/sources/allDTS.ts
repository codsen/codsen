export const allDTS = {"all-named-html-entities":"type JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ndeclare const version: string;\ndeclare const allNamedEntities: JsonObject;\ndeclare const brokenNamedEntities: JsonObject;\ndeclare const entStartsWith: JsonObject;\ndeclare const entEndsWith: JsonObject;\ndeclare const entStartsWithCaseInsensitive: JsonObject;\ndeclare const entEndsWithCaseInsensitive: JsonObject;\ndeclare const uncertain: JsonObject;\ndeclare const allNamedEntitiesSetOnly: Set<string>;\ndeclare const allNamedEntitiesSetOnlyCaseInsensitive: Set<string>;\ndeclare function decode(ent: string): string | null;\ndeclare const minLength = 2;\ndeclare const maxLength = 31;\n\nexport {\n  allNamedEntities,\n  allNamedEntitiesSetOnly,\n  allNamedEntitiesSetOnlyCaseInsensitive,\n  brokenNamedEntities,\n  decode,\n  entEndsWith,\n  entEndsWithCaseInsensitive,\n  entStartsWith,\n  entStartsWithCaseInsensitive,\n  maxLength,\n  minLength,\n  uncertain,\n  version,\n};","array-group-str-omit-num-char":"export { Range, Ranges } from \"ranges-apply\";\n\ndeclare const version: string;\ninterface MappingObj {\n  [key: string]: any;\n}\ninterface Opts {\n  wildcard: string;\n  dedupePlease: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Groups array of strings by omitting number characters\n */\ndeclare function groupStr(arr: string[], opts?: Partial<Opts>): MappingObj;\n\nexport { MappingObj, Opts, defaults, groupStr, version };","array-includes-with-glob":"declare const version: string;\ninterface Opts {\n  arrayVsArrayAllMustBeFound: \"any\" | \"all\";\n  caseSensitive: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Like _.includes but with wildcards\n */\ndeclare function includesWithGlob(\n  input: string | string[],\n  findThis: string | string[],\n  opts?: Partial<Opts>\n): boolean;\n\nexport { Opts, defaults, includesWithGlob, version };","array-of-arrays-into-ast":"declare const version: string;\ninterface PlainObj {\n  [key: string]: any;\n}\ninterface Opts {\n  dedupe: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Turns an array of arrays of data into a nested tree of plain objects\n */\ndeclare function generateAst(inputArr: any[], opts?: Partial<Opts>): PlainObj;\n\nexport { Opts, PlainObj, defaults, generateAst, version };","array-of-arrays-sort-by-col":"declare const version: string;\n/**\n * Sort array of arrays by column, rippling the sorting outwards from that column\n */\ndeclare function sortByCol(arr: any[], axis?: number | string): any[];\n\nexport { sortByCol, version };","array-pull-all-with-glob":"declare const version: string;\ninterface Opts {\n  caseSensitive: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Like _.pullAll but with globs (wildcards)\n */\ndeclare function pull(\n  strArr: string[],\n  toBeRemoved: string | string[],\n  opts?: Partial<Opts>\n): string[];\n\nexport { Opts, defaults, pull, version };","arrayiffy-if-string":"type StringInABox<T> = T extends \"\"\n  ? []\n  : string extends T\n  ? [] | [string]\n  : T extends string\n  ? [T]\n  : T;\ndeclare function arrayiffy<T>(something: T): StringInABox<T>;\n\nexport { arrayiffy };","ast-compare":"declare const version: string;\ntype JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ninterface AnyObject {\n  [key: string]: any;\n}\ninterface Opts {\n  hungryForWhitespace: boolean;\n  matchStrictly: boolean;\n  verboseWhenMismatches: boolean;\n  useWildcards: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Compare anything: AST, objects, arrays, strings and nested thereof\n */\ndeclare function compare(\n  b: JsonValue,\n  s: JsonValue,\n  opts?: Partial<Opts>\n): boolean | string;\n\nexport {\n  AnyObject,\n  JsonArray,\n  JsonObject,\n  JsonValue,\n  Opts,\n  compare,\n  defaults,\n  version,\n};","ast-contains-only-empty-space":"declare const version: string;\n/**\n * Does AST contain only empty space?\n */\ndeclare function empty(input: unknown): boolean;\n\nexport { empty, version };","ast-deep-contains":"declare const version: string;\ninterface Opts {\n  skipContainers: boolean;\n  arrayStrictComparison: boolean;\n}\ndeclare const defaults: Opts;\ninterface Callback {\n  (leftSideVal: any, rightSideVal: any, path: string): void;\n}\ninterface ErrorCallback {\n  (errStr: string): void;\n}\n/**\n * Like t.same assert on array of objects, where element order doesn't matter.\n */\ndeclare function deepContains(\n  tree1: any,\n  tree2: any,\n  cb: Callback,\n  errCb: ErrorCallback,\n  opts?: Partial<Opts>\n): void;\n\nexport { Callback, ErrorCallback, Opts, deepContains, defaults, version };","ast-delete-object":"declare const version: string;\ntype JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ninterface Opts {\n  matchKeysStrictly: boolean;\n  hungryForWhitespace: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Delete all plain objects in AST if they contain a certain key/value pair\n */\ndeclare function deleteObj<T extends JsonValue>(\n  input: T,\n  objToDelete: JsonObject,\n  opts?: Partial<Opts>\n): T;\n\nexport { JsonArray, JsonObject, JsonValue, Opts, defaults, deleteObj, version };","ast-get-object":"declare const version: string;\ninterface UnknownValueObj {\n  [key: string]: any;\n}\ndeclare function getObj(\n  originalAst: any,\n  keyValPair: UnknownValueObj,\n  replacementContentsArr?: UnknownValueObj[]\n): any;\n\nexport { UnknownValueObj, getObj, version };","ast-get-values-by-key":"declare const version: string;\ninterface Findings {\n  val: any;\n  path: string;\n}\n/**\n * Extract values and paths from AST by keys OR set them by keys\n */\ndeclare function getByKey(\n  originalInput: any,\n  whatToFind: string | string[],\n  originalReplacement?: any\n): any;\n\nexport { Findings, getByKey, version };","ast-is-empty":"declare const version: string;\n/**\n * Find out, is nested array/object/string/AST tree is empty\n */\ndeclare function isEmpty(input: any): boolean | null;\n\nexport { isEmpty, version };","ast-loose-compare":"declare const version: string;\ntype JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ninterface UnknownValueObj {\n  [key: string]: any;\n}\n/**\n * Compare anything: AST, objects, arrays and strings\n */\ndeclare function looseCompare(\n  bigObj: JsonValue,\n  smallObj: JsonValue\n): boolean | undefined;\n\nexport {\n  JsonArray,\n  JsonObject,\n  JsonValue,\n  UnknownValueObj,\n  looseCompare,\n  version,\n};","ast-monkey":"export { traverse } from \"ast-monkey-traverse\";\n\ndeclare const version: string;\ntype JsonValue =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | JsonObject\n  | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ninterface Finding {\n  index: number;\n  key: string;\n  val: any;\n  path: number[];\n}\ninterface FindOpts {\n  key: null | string;\n  val: any;\n  only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function find(input: JsonValue, opts: FindOpts): Finding[];\ninterface GetOpts {\n  index: number;\n  only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function get(input: JsonValue, opts: GetOpts): JsonValue;\ninterface SetOpts {\n  key: null | string;\n  val: any;\n  index: number;\n}\ndeclare function set(input: JsonValue, opts: SetOpts): JsonValue;\ninterface DropOpts {\n  index: number;\n}\ndeclare function drop(input: JsonValue, opts: DropOpts): JsonValue;\ninterface DelOpts {\n  key: null | string;\n  val: any;\n  only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function del(input: JsonValue, opts: DelOpts): JsonValue;\ndeclare function arrayFirstOnly(input: JsonValue): JsonValue;\n\nexport {\n  DelOpts,\n  DropOpts,\n  FindOpts,\n  Finding,\n  GetOpts,\n  JsonArray,\n  JsonObject,\n  JsonValue,\n  SetOpts,\n  arrayFirstOnly,\n  del,\n  drop,\n  find,\n  get,\n  set,\n  version,\n};","ast-monkey-traverse":"declare const version: string;\ninterface Stop {\n  now: boolean;\n}\ninterface InnerObj {\n  depth: number;\n  path: string;\n  topmostKey: string;\n  parent: any;\n  parentType: string;\n  parentKey: string | null;\n}\ntype Callback = (key: string, val: any, innerObj: InnerObj, stop: Stop) => any;\n/**\n * Utility library to traverse AST\n */\ndeclare function traverse<T>(tree1: T, cb1: Callback): T;\n\nexport { Callback, InnerObj, Stop, traverse, version };","ast-monkey-traverse-with-lookahead":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ntype NextToken = [\n  key: \"string\",\n  value: any,\n  innerObj: {\n    depth: number;\n    path: string;\n    parent: any;\n    parentType: string;\n  }\n];\ninterface InnerObj {\n  depth: number;\n  path: string;\n  topmostKey?: string;\n  parent?: any;\n  parentType?: string;\n  next?: NextToken[];\n}\ntype Callback = (\n  key: string | Obj,\n  val: any,\n  innerObj: InnerObj,\n  stop: {\n    now: boolean;\n  }\n) => any;\ndeclare function traverse(tree1: any, cb1: Callback, lookahead?: number): void;\n\nexport { Callback, InnerObj, NextToken, Obj, traverse, version };","ast-monkey-util":"declare function pathNext(str: string): string;\n\ndeclare function pathPrev(str: string): null | string;\n\ndeclare function pathUp(str: string): string;\n\ndeclare function parent(str: string): null | string;\n\ndeclare const version: string;\n\nexport { parent, pathNext, pathPrev, pathUp, version };","bitbucket-slug":"declare const version: string;\n/**\n * Generate BitBucket readme header anchor slug URLs\n */\ndeclare function bSlug(str: string): string;\n\nexport { bSlug, version };","charcode-is-valid-xml-name-character":"declare function isProduction4(char: string): boolean;\ndeclare function isProduction4a(char: string): boolean;\n\nexport {\n  isProduction4,\n  isProduction4a,\n  isProduction4 as validFirstChar,\n  isProduction4a as validSecondCharOnwards,\n};","check-types-mini":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  ignoreKeys: string | string[];\n  ignorePaths: string | string[];\n  acceptArrays: boolean;\n  acceptArraysIgnore: string | string[];\n  enforceStrictKeyset: boolean;\n  schema: Obj;\n  msg: string;\n  optsVarName: string;\n}\ndeclare const defaults: Opts;\n/**\n * Validate options object\n */\ndeclare function checkTypesMini(\n  obj: Obj,\n  ref: Obj | null,\n  opts?: Partial<Opts>\n): void;\n\nexport { checkTypesMini, defaults, version };","codsen-parser":"import {\n  TagToken,\n  CommentToken,\n  TextToken,\n  RuleToken,\n  AtToken,\n  EspToken,\n  CharCb,\n} from \"codsen-tokenizer\";\n\ntype Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ntype Severity = 0 | 1 | 2;\ninterface ErrorObj {\n  ruleId?: string;\n  message: string;\n  idxFrom: number;\n  idxTo: number;\n  fix: null | {\n    ranges: Ranges;\n  };\n  severity?: Severity;\n  keepSeparateWhenFixing?: boolean;\n}\ninterface IdxRangeObj {\n  idxFrom: number;\n  idxTo: number;\n}\ninterface TagTokenWithChildren extends TagToken {\n  children: TokenWithChildren[];\n}\ninterface CommentTokenWithChildren extends CommentToken {\n  children: TokenWithChildren[];\n}\ntype TokenWithChildren =\n  | TextToken\n  | TagTokenWithChildren\n  | RuleToken\n  | AtToken\n  | CommentTokenWithChildren\n  | EspToken;\ninterface SupplementedErrorObj extends ErrorObj {\n  tokenObj: TokenWithChildren;\n}\ntype ErrCb = (obj: Partial<SupplementedErrorObj>) => void;\ninterface Opts {\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n  tagCb: null | ((obj: TokenWithChildren) => void);\n  charCb: null | CharCb;\n  errCb: null | ErrCb;\n}\ndeclare const defaults: Opts;\n/**\n * Parser aiming at broken or mixed code, especially HTML & CSS\n */\ndeclare function cparser(str: string, opts?: Partial<Opts>): any[];\n\nexport {\n  CommentTokenWithChildren,\n  ErrCb,\n  ErrorObj,\n  IdxRangeObj,\n  Opts,\n  Severity,\n  SupplementedErrorObj,\n  TagTokenWithChildren,\n  TokenWithChildren,\n  cparser,\n  defaults,\n  version,\n};","codsen-tokenizer":"interface Selector {\n  value: string;\n  selectorStarts: number;\n  selectorEnds: number;\n}\ntype TokenType = \"text\" | \"tag\" | \"rule\" | \"at\" | \"comment\" | \"esp\";\ntype TokenKind = \"simplet\" | \"not\" | \"doctype\" | \"cdata\" | \"xml\" | \"inline\";\ntype CommentKind = \"simple\" | \"only\" | \"not\" | \"block\" | \"line\" | \"simplet\";\ninterface TextToken {\n  type: \"text\";\n  start: number;\n  end: number;\n  value: string;\n}\ninterface CommentToken {\n  type: \"comment\";\n  start: number;\n  end: number;\n  value: string;\n  closing: null | boolean;\n  kind: CommentKind;\n  language: \"html\" | \"css\";\n}\ninterface EspToken {\n  type: \"esp\";\n  start: number;\n  end: number;\n  value: string;\n  head: null | string;\n  headStartsAt: null | number;\n  headEndsAt: null | number;\n  tail: null | string;\n  tailStartsAt: null | number;\n  tailEndsAt: null | number;\n}\ntype PropertyValueWithinArray = TextToken | EspToken;\ninterface Property {\n  property: null | string;\n  propertyStarts: null | number;\n  propertyEnds: null | number;\n  colon: null | number;\n  value: string | PropertyValueWithinArray[];\n  valueStarts: null | number;\n  valueEnds: null | number;\n  importantStarts: null | number;\n  importantEnds: null | number;\n  important: null | string;\n  semi: null | number;\n  start: number;\n  end: number;\n}\ninterface Attrib {\n  attribName: string;\n  attribNameRecognised: boolean;\n  attribNameStartsAt: number;\n  attribNameEndsAt: number;\n  attribOpeningQuoteAt: null | number;\n  attribClosingQuoteAt: null | number;\n  attribValueRaw: string;\n  attribValue: (TextToken | Property | CommentToken | EspToken)[];\n  attribValueStartsAt: null | number;\n  attribValueEndsAt: null | number;\n  attribStarts: number;\n  attribEnds: number;\n  attribLeft: number;\n}\ninterface RuleToken {\n  type: \"rule\";\n  start: number;\n  end: number;\n  value: string;\n  left: null | number;\n  nested: null | boolean;\n  openingCurlyAt: null | number;\n  closingCurlyAt: null | number;\n  selectorsStart: null | number;\n  selectorsEnd: null | number;\n  selectors: Selector[];\n  properties: (Property | TextToken)[];\n}\ninterface TagToken {\n  type: \"tag\";\n  start: number;\n  end: number;\n  value: string;\n  tagNameStartsAt: number;\n  tagNameEndsAt: number;\n  tagName: string;\n  recognised: null | boolean;\n  closing: null | boolean;\n  void: null | boolean;\n  pureHTML: null | boolean;\n  kind: null | TokenKind;\n  attribs: Attrib[];\n}\ninterface AtToken {\n  type: \"at\";\n  start: number;\n  end: number;\n  value: string;\n  left: null | number;\n  nested: null | false;\n  identifier: null | string;\n  identifierStartsAt: null | number;\n  identifierEndsAt: null | number;\n  query: string;\n  queryStartsAt: number;\n  queryEndsAt: number;\n  openingCurlyAt: null | number;\n  closingCurlyAt: null | number;\n  rules: (RuleToken | TextToken)[];\n}\ntype Token =\n  | TextToken\n  | TagToken\n  | RuleToken\n  | AtToken\n  | CommentToken\n  | EspToken;\ninterface LayerKindAt {\n  type: \"at\";\n  token: AtToken;\n}\ninterface LayerSimple {\n  type: \"simple\" | \"block\";\n  value: string;\n  position: number;\n}\ninterface LayerEsp {\n  type: \"esp\";\n  openingLump: string;\n  guessedClosingLump: string;\n  position: number;\n}\ntype Layer = LayerKindAt | LayerSimple | LayerEsp;\ninterface CharacterToken {\n  chr: string;\n  i: number;\n  type: TokenType;\n}\ntype TokenCb = (token: Token, next: Token[]) => void;\ntype CharCb = (token: CharacterToken, next: CharacterToken[]) => void;\ninterface Opts {\n  tagCb: null | TokenCb;\n  tagCbLookahead: number;\n  charCb: null | CharCb;\n  charCbLookahead: number;\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n}\n\ndeclare function matchLayerLast(\n  wholeEspTagLump: string,\n  layers: Layer[],\n  matchFirstInstead?: boolean\n): undefined | number;\n\ndeclare const version: string;\ndeclare const defaults: Opts;\ninterface Res {\n  timeTakenInMilliseconds: number;\n}\n/**\n * HTML and CSS lexer aimed at code with fatal errors, accepts mixed coding languages\n */\ndeclare function tokenizer(str: string, opts?: Partial<Opts>): Res;\ndeclare const util: {\n  matchLayerLast: typeof matchLayerLast;\n};\n\nexport {\n  AtToken,\n  CharCb,\n  CommentToken,\n  EspToken,\n  Opts,\n  Res,\n  RuleToken,\n  TagToken,\n  TextToken,\n  defaults,\n  tokenizer,\n  util,\n  version,\n};","codsen-utils":"declare const version: string;\ndeclare const leftSingleQuote = \"\\u2018\";\ndeclare const rightSingleQuote = \"\\u2019\";\ndeclare const leftDoubleQuote = \"\\u201C\";\ndeclare const rightDoubleQuote = \"\\u201D\";\ndeclare const rawNDash = \"\\u2013\";\ndeclare const rawMDash = \"\\u2014\";\ndeclare const rawNbsp = \"\\u00A0\";\ndeclare const ellipsis = \"\\u2026\";\ndeclare const hairspace = \"\\u200A\";\ndeclare const thinSpace = \"\\u2009\";\ndeclare const singlePrime = \"\\u2032\";\ndeclare const doublePrime = \"\\u2033\";\ndeclare const backslash = \"\\\\\";\ndeclare const rawReplacementMark = \"\\uFFFD\";\ndeclare const backtick = \"`\";\ndeclare const multiplicationSign = \"\\u00D7\";\ndeclare const punctuationChars: string[];\ndeclare function isNumberChar(value: unknown): boolean;\ndeclare function isCurrencyChar(value: unknown): boolean;\ndeclare function isCurrencySymbol(value: unknown): boolean;\ndeclare function isLetter(value: unknown): boolean;\ndeclare function isLatinLetter(value: unknown): boolean;\ndeclare function isQuote(value: unknown): boolean;\ndeclare function isLowercaseLetter(value: unknown): boolean;\ndeclare function isUppercaseLetter(value: unknown): boolean;\ndeclare function isWhitespaceChar(value: unknown): boolean;\ndeclare const removeTrailingSlash: <T>(value: T) => string | T;\n/**\n * Tells, is given input a plain object (an object literal,\n * a container object Object.create(null) or created by new Object())\n * @param value unknown\n * @returns boolean\n */\ndeclare function isPlainObject(value: unknown): boolean;\n/**\n * @param str input string\n * @param index starting index\n * @param count how many characters to replace\n * @param add what string to insert\n * @returns string\n * Adapted from https://stackoverflow.com/a/21350614\n */\ndeclare function stringSplice(\n  str?: string,\n  index?: number,\n  count?: number,\n  add?: string\n): string;\n/**\n * Gives array of indexes of all found substring occurrences\n * @param string source string\n * @param substring what to look for\n * @returns array of findings' position indexes\n * adapted from https://stackoverflow.com/a/10710406\n * console.log(findAllIdx(\"scissors\", \"s\"));\n * -> [0, 3, 4, 7]\n */\ndeclare function findAllIdx(value: unknown, substring: unknown): number[];\ndeclare const voidTags: string[];\ndeclare const inlineTags: Set<string>;\n\nexport {\n  backslash,\n  backtick,\n  doublePrime,\n  ellipsis,\n  findAllIdx,\n  hairspace,\n  inlineTags,\n  isCurrencyChar,\n  isCurrencySymbol,\n  isLatinLetter,\n  isLetter,\n  isLowercaseLetter,\n  isNumberChar,\n  isPlainObject,\n  isQuote,\n  isUppercaseLetter,\n  isWhitespaceChar,\n  leftDoubleQuote,\n  leftSingleQuote,\n  multiplicationSign,\n  punctuationChars,\n  rawMDash,\n  rawNDash,\n  rawNbsp,\n  rawReplacementMark,\n  removeTrailingSlash,\n  rightDoubleQuote,\n  rightSingleQuote,\n  singlePrime,\n  stringSplice,\n  thinSpace,\n  version,\n  voidTags,\n};","color-shorthand-hex-to-six-digit":"declare const version: string;\n/**\n * Convert shorthand hex color codes into full\n */\ndeclare function conv(input: any): any;\n\nexport { conv, version };","csv-sort":"declare function isNumeric(str: any): boolean;\ndeclare function findType(something: string): string;\n\ndeclare const version: string;\ninterface Res {\n  res: string[][];\n  msgContent: null | string;\n  msgType: null | string;\n}\n/**\n * Sorts double-entry bookkeeping CSV coming from internet banking\n */\ndeclare function sort(input: string): Res;\n\nexport { Res, findType, isNumeric, sort, version };","csv-split-easy":"declare const version: string;\ninterface Opts {\n  removeThousandSeparatorsFromNumbers: boolean;\n  padSingleDecimalPlaceNumbers: boolean;\n  forceUKStyle: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function splitEasy(str: string, opts?: Partial<Opts>): string[][];\n\nexport { Opts, defaults, splitEasy, version };","detect-is-it-html-or-xhtml":"declare const version: string;\ntype Output = \"html\" | \"xhtml\" | null;\ndeclare function detectIsItHTMLOrXhtml(input: string): Output;\n\nexport { Output, detectIsItHTMLOrXhtml, version };","detect-templating-language":"declare const version: string;\ntype Output = \"Nunjucks\" | \"Jinja\" | \"JSP\" | null;\ndeclare function detectLang(str: string): {\n  name: Output;\n};\n\nexport { Output, detectLang, version };","detergent":"type EndOfLine = \"lf\" | \"crlf\" | \"cr\";\ninterface Opts {\n  fixBrokenEntities: boolean;\n  removeWidows: boolean;\n  convertEntities: boolean;\n  convertDashes: boolean;\n  convertApostrophes: boolean;\n  replaceLineBreaks: boolean;\n  removeLineBreaks: boolean;\n  useXHTML: boolean;\n  dontEncodeNonLatin: boolean;\n  addMissingSpaces: boolean;\n  convertDotsToEllipsis: boolean;\n  stripHtml: boolean;\n  eol: EndOfLine;\n  stripHtmlButIgnoreTags: string[];\n  stripHtmlAddNewLine: string[];\n  cb: null | ((str: string) => string);\n}\ndeclare const defaultOpts: Opts;\ninterface ApplicableOpts {\n  fixBrokenEntities: boolean;\n  removeWidows: boolean;\n  convertEntities: boolean;\n  convertDashes: boolean;\n  convertApostrophes: boolean;\n  replaceLineBreaks: boolean;\n  removeLineBreaks: boolean;\n  useXHTML: boolean;\n  dontEncodeNonLatin: boolean;\n  addMissingSpaces: boolean;\n  convertDotsToEllipsis: boolean;\n  stripHtml: boolean;\n  eol: boolean;\n}\ninterface Res {\n  res: string;\n  applicableOpts: ApplicableOpts;\n}\n\ndeclare const version: string;\n/**\n * Extracts, cleans and encodes text\n */\ndeclare function det(str: string, opts?: Partial<Opts>): Res;\n\nexport { Opts, Res, det, defaultOpts as opts, version };","easy-replace":"declare const version: string;\ninterface Opts {\n  leftOutsideNot: string | string[];\n  leftOutside: string | string[];\n  leftMaybe: string | string[];\n  searchFor: string | string[];\n  rightMaybe: string | string[];\n  rightOutside: string | string[];\n  rightOutsideNot: string | string[];\n  i: {\n    leftOutsideNot: boolean;\n    leftOutside: boolean;\n    leftMaybe: boolean;\n    searchFor: boolean;\n    rightMaybe: boolean;\n    rightOutside: boolean;\n    rightOutsideNot: boolean;\n  };\n}\ndeclare function er(source: string, opts: Opts, replacement: string): string;\n\nexport { Opts, er, version };","edit-package-json":"declare const version: string;\ninterface Inputs {\n  str: string;\n  path: string;\n  valToInsert?: string | number;\n  mode: \"set\" | \"del\";\n}\ndeclare function set(\n  str: string,\n  path: string,\n  valToInsert: string | number\n): string;\ndeclare function del(str: string, path: string): string;\n\nexport { Inputs, del, set, version };","email-all-chars-within-ascii":"declare const version: string;\ninterface Res {\n  type: \"character\" | \"line length\";\n  line: number;\n  column: number;\n  positionIdx: number;\n  value: number | string;\n  codePoint?: undefined | number;\n  UTF32Hex?: undefined | string;\n}\ninterface Opts {\n  lineLength: number;\n}\ndeclare const defaults: Opts;\ndeclare function within(str: string, opts?: Partial<Opts>): Res[];\n\nexport { Opts, Res, defaults, version, within };","email-comb":"import { Opts as Opts$1 } from \"html-crush\";\n\ninterface Obj {\n  [key: string]: any;\n}\n\ndeclare const version: string;\ninterface HeadsAndTailsObj {\n  heads: string;\n  tails: string;\n}\ninterface Opts {\n  whitelist: string[];\n  backend: HeadsAndTailsObj[];\n  uglify: boolean;\n  removeHTMLComments: boolean;\n  removeCSSComments: boolean;\n  doNotRemoveHTMLCommentsWhoseOpeningTagContains: string[];\n  htmlCrushOpts: Partial<Opts$1>;\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n}\ninterface Res {\n  log: {\n    timeTakenInMilliseconds: number;\n    traversedTotalCharacters: number;\n    traversedTimesInputLength: number;\n    originalLength: number;\n    cleanedLength: number;\n    bytesSaved: number;\n    percentageReducedOfOriginal: number;\n    nonIndentationsWhitespaceLength: number;\n    nonIndentationsTakeUpPercentageOfOriginal: number;\n    commentsLength: number;\n    commentsTakeUpPercentageOfOriginal: number;\n    uglified: null | Obj;\n  };\n  result: string;\n  countAfterCleaning: number;\n  countBeforeCleaning: number;\n  allInHead: string[];\n  allInBody: string[];\n  deletedFromHead: string[];\n  deletedFromBody: string[];\n}\ndeclare const defaults: Opts;\n/**\n * Remove unused CSS from email templates\n */\ndeclare function comb(str: string, opts?: Partial<Opts>): Res;\n\nexport { HeadsAndTailsObj, Opts, Res, comb, defaults, version };","emlint":"import { TypedEmitter } from \"tiny-typed-emitter\";\nimport {\n  TagToken,\n  CommentToken as CommentToken$1,\n  TextToken as TextToken$1,\n  RuleToken as RuleToken$1,\n  AtToken as AtToken$1,\n  EspToken as EspToken$1,\n} from \"codsen-tokenizer\";\n\ntype Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ninterface Selector {\n  value: string;\n  selectorStarts: number;\n  selectorEnds: number;\n}\ntype CommentKind = \"simple\" | \"only\" | \"not\" | \"block\" | \"line\" | \"simplet\";\ninterface TextToken {\n  type: \"text\";\n  start: number;\n  end: number;\n  value: string;\n}\ninterface CommentToken {\n  type: \"comment\";\n  start: number;\n  end: number;\n  value: string;\n  closing: null | boolean;\n  kind: CommentKind;\n  language: \"html\" | \"css\";\n}\ninterface EspToken {\n  type: \"esp\";\n  start: number;\n  end: number;\n  value: string;\n  head: null | string;\n  headStartsAt: null | number;\n  headEndsAt: null | number;\n  tail: null | string;\n  tailStartsAt: null | number;\n  tailEndsAt: null | number;\n}\ntype PropertyValueWithinArray = TextToken | EspToken;\ninterface Property {\n  property: null | string;\n  propertyStarts: null | number;\n  propertyEnds: null | number;\n  colon: null | number;\n  value: string | PropertyValueWithinArray[];\n  valueStarts: null | number;\n  valueEnds: null | number;\n  importantStarts: null | number;\n  importantEnds: null | number;\n  important: null | string;\n  semi: null | number;\n  start: number;\n  end: number;\n}\ninterface Attrib {\n  attribName: string;\n  attribNameRecognised: boolean;\n  attribNameStartsAt: number;\n  attribNameEndsAt: number;\n  attribOpeningQuoteAt: null | number;\n  attribClosingQuoteAt: null | number;\n  attribValueRaw: string;\n  attribValue: (TextToken | Property | CommentToken | EspToken)[];\n  attribValueStartsAt: null | number;\n  attribValueEndsAt: null | number;\n  attribStarts: number;\n  attribEnds: number;\n  attribLeft: number;\n}\ninterface RuleToken {\n  type: \"rule\";\n  start: number;\n  end: number;\n  value: string;\n  left: null | number;\n  nested: null | boolean;\n  openingCurlyAt: null | number;\n  closingCurlyAt: null | number;\n  selectorsStart: null | number;\n  selectorsEnd: null | number;\n  selectors: Selector[];\n  properties: (Property | TextToken)[];\n}\ninterface AtToken {\n  type: \"at\";\n  start: number;\n  end: number;\n  value: string;\n  left: null | number;\n  nested: null | false;\n  identifier: null | string;\n  identifierStartsAt: null | number;\n  identifierEndsAt: null | number;\n  query: string;\n  queryStartsAt: number;\n  queryEndsAt: number;\n  openingCurlyAt: null | number;\n  closingCurlyAt: null | number;\n  rules: (RuleToken | TextToken)[];\n}\n\ntype Severity$1 = 0 | 1 | 2;\ninterface ErrorObj {\n  ruleId?: string;\n  message: string;\n  idxFrom: number;\n  idxTo: number;\n  fix: null | {\n    ranges: Ranges;\n  };\n  severity?: Severity$1;\n  keepSeparateWhenFixing?: boolean;\n}\ninterface TagTokenWithChildren extends TagToken {\n  children: TokenWithChildren[];\n}\ninterface CommentTokenWithChildren extends CommentToken$1 {\n  children: TokenWithChildren[];\n}\ntype TokenWithChildren =\n  | TextToken$1\n  | TagTokenWithChildren\n  | RuleToken$1\n  | AtToken$1\n  | CommentTokenWithChildren\n  | EspToken$1;\n\ntype JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ntype Severity = 0 | 1 | 2;\ninterface RulesObj {\n  [rulesName: string]: Severity | [severity: Severity, ...opts: string[]];\n}\ninterface Config {\n  rules: RulesObj;\n}\ninterface AttribSupplementedWithParent extends Attrib {\n  parent: TagTokenWithChildren;\n}\ntype TagEvent = (node: TagTokenWithChildren) => void;\ntype AtEvent = (node: AtToken) => void;\ntype RuleEvent = (node: RuleToken) => void;\ntype TextEvent = (node: TextToken) => void;\ntype EspEvent = (node: EspToken) => void;\ntype CharacterEvent = ({ chr, i }: { chr: string; i: number }) => void;\ntype AttributeEvent = (node: AttribSupplementedWithParent) => void;\ntype AstEvent = (node: JsonObject[]) => void;\ntype CommentEvent = (node: CommentTokenWithChildren) => void;\ntype EntityEvent = (node: { idxFrom: number; idxTo: number }) => void;\ninterface RuleObjType {\n  tag?: TagEvent;\n  at?: AtEvent;\n  rule?: RuleEvent;\n  text?: TextEvent;\n  esp?: EspEvent;\n  character?: CharacterEvent;\n  attribute?: AttributeEvent;\n  ast?: AstEvent;\n  comment?: CommentEvent;\n  entity?: EntityEvent;\n}\ninterface MessageObj extends ErrorObj {\n  line: number;\n  column: number;\n  severity: Severity;\n  keepSeparateWhenFixing: boolean;\n}\n\ninterface ErrorObjWithRuleId extends ErrorObj {\n  ruleId: string;\n}\n/**\n * Pluggable email template code linter\n */\ndeclare class Linter extends TypedEmitter<RuleObjType> {\n  constructor();\n  messages: MessageObj[];\n  str: string;\n  strLineStartIndexes: number[];\n  config: Config;\n  hasBeenCalledWithKeepSeparateWhenFixing: boolean;\n  processedRulesConfig: RulesObj;\n  verify(str: string, config: Config): ErrorObj[];\n  report(obj: ErrorObjWithRuleId): void;\n}\n\ntype IdxRange = [charFrom: number, charTo: number];\ntype CbValues = (idxRange: IdxRange) => void;\ninterface Opts$1 {\n  offset: number;\n  from: number;\n  to: number;\n}\ndeclare function splitByWhitespace(\n  str: string,\n  cbValues: CbValues,\n  cbWhitespace?: CbValues,\n  originalOpts?: Partial<Opts$1>\n): void;\n\ndeclare const badChars: Map<number, string>;\n\ninterface Opts {\n  caseInsensitive: boolean;\n  canBeCommaSeparated: boolean;\n  quickPermittedValues: (string | RegExp)[];\n  permittedValues: string[];\n  noSpaceAfterComma: boolean;\n}\ndeclare function validateString(\n  str: string,\n  idxOffset: number,\n  originalOpts?: Partial<Opts>\n): ErrorObj[];\n\ndeclare const wholeExtensionRegex: RegExp;\ndeclare const isoDateRegex: RegExp;\ndeclare const fontSizeRegex: RegExp;\ndeclare const linkTypes: string[];\ndeclare const astErrMessages: {\n  \"tag-missing-opening\": string;\n  \"tag-missing-closing\": string;\n  \"tag-void-frontal-slash\": string;\n};\ndeclare function isAnEnabledValue(maybeARulesValue: unknown): Severity;\ndeclare function isAnEnabledRule(rules: RulesObj, ruleId: string): Severity;\n\ndeclare const util_wholeExtensionRegex: typeof wholeExtensionRegex;\ndeclare const util_splitByWhitespace: typeof splitByWhitespace;\ndeclare const util_isAnEnabledValue: typeof isAnEnabledValue;\ndeclare const util_isAnEnabledRule: typeof isAnEnabledRule;\ndeclare const util_astErrMessages: typeof astErrMessages;\ndeclare const util_validateString: typeof validateString;\ndeclare const util_fontSizeRegex: typeof fontSizeRegex;\ndeclare const util_isoDateRegex: typeof isoDateRegex;\ndeclare const util_linkTypes: typeof linkTypes;\ndeclare const util_badChars: typeof badChars;\ndeclare namespace util {\n  export {\n    util_wholeExtensionRegex as wholeExtensionRegex,\n    util_splitByWhitespace as splitByWhitespace,\n    util_isAnEnabledValue as isAnEnabledValue,\n    util_isAnEnabledRule as isAnEnabledRule,\n    util_astErrMessages as astErrMessages,\n    util_validateString as validateString,\n    util_fontSizeRegex as fontSizeRegex,\n    util_isoDateRegex as isoDateRegex,\n    util_linkTypes as linkTypes,\n    util_badChars as badChars,\n  };\n}\n\ndeclare const version: string;\n\nexport { Linter, util, version };","eslint-plugin-row-num-tbc":"interface Obj {\n  [key: string]: any;\n}\n\ndeclare const _default: {\n  configs: {\n    recommended: {\n      plugins: string[];\n      rules: {\n        \"no-console\": string;\n        \"row-num/correct-row-num\": string;\n      };\n    };\n  };\n  rules: {\n    \"correct-row-num\": {\n      create: (context: Obj) => Obj;\n      meta: {\n        type: string;\n        messages: {\n          correctRowNum: string;\n        };\n        fixable: string;\n      };\n    };\n  };\n};\n\nexport { _default as default };","eslint-plugin-test-num-tbc":"interface Obj {\n  [key: string]: any;\n}\n\ndeclare const _default: {\n  configs: {\n    recommended: {\n      plugins: string[];\n      rules: {\n        \"no-console\": string;\n        \"test-num/correct-test-num\": string;\n      };\n    };\n  };\n  rules: {\n    \"correct-test-num\": {\n      create: (context: Obj) => Obj;\n      meta: {\n        type: string;\n        messages: {\n          correctTestNum: string;\n        };\n        fixable: string;\n      };\n    };\n  };\n};\n\nexport { _default as default };","extract-search-index":"declare const version: string;\ndeclare function extract(str: string): string;\n\nexport { extract, version };","generate-atomic-css":"declare const headsAndTails: {\n  CONFIGHEAD: string;\n  CONFIGTAIL: string;\n  CONTENTHEAD: string;\n  CONTENTTAIL: string;\n};\ndeclare function extractFromToSource(\n  str: string,\n  fromDefault?: number,\n  toDefault?: number\n): [from: number, to: number, source: string];\n\ndeclare const version: string;\ninterface Opts {\n  includeConfig: boolean;\n  includeHeadsAndTails: boolean;\n  pad: boolean;\n  configOverride: null | string;\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  log: {\n    count: number;\n  };\n  result: string;\n}\ndeclare function genAtomic(str: string, opts?: Partial<Opts>): Res;\n\nexport {\n  Opts,\n  Res,\n  defaults,\n  extractFromToSource,\n  genAtomic,\n  headsAndTails,\n  version,\n};","helga":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  targetJSON: boolean;\n}\ndeclare const defaults: {\n  targetJSON: boolean;\n};\ndeclare function helga(\n  str: string,\n  originalOpts?: Partial<Opts>\n): {\n  minified: string;\n  beautified: string;\n};\n\nexport { Obj, Opts, defaults, helga, version };","html-all-known-attributes":"declare const version: string;\ndeclare const allHtmlAttribs: Set<string>;\n\nexport { allHtmlAttribs, version };","html-crush":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n  lineLengthLimit: number;\n  removeIndentations: boolean;\n  removeLineBreaks: boolean;\n  removeHTMLComments: boolean | 0 | 1 | 2;\n  removeCSSComments: boolean;\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n  breakToTheLeftOf: string[];\n  mindTheInlineTags: string[];\n}\ndeclare const defaults: Opts;\ninterface Res {\n  log: {\n    timeTakenInMilliseconds: number;\n    originalLength: number;\n    cleanedLength: number;\n    bytesSaved: number;\n    percentageReducedOfOriginal: number;\n  };\n  applicableOpts: {\n    removeHTMLComments: boolean;\n    removeCSSComments: boolean;\n  };\n  ranges: Ranges;\n  result: string;\n}\n/**\n * Minifies HTML/CSS: valid or broken, pure or mixed with other languages\n */\ndeclare function crush(str: string, opts?: Partial<Opts>): Res;\n\nexport { Opts, Res, crush, defaults, version };","html-entities-not-email-friendly":"interface Obj {\n  [key: string]: any;\n}\ndeclare const notEmailFriendly: Obj;\ndeclare const notEmailFriendlySetOnly: Set<string>;\ndeclare const notEmailFriendlyLowercaseSetOnly: Set<string>;\ndeclare const notEmailFriendlyMinLength = 2;\ndeclare const notEmailFriendlyMaxLength = 31;\n\nexport {\n  Obj,\n  notEmailFriendly,\n  notEmailFriendlyLowercaseSetOnly,\n  notEmailFriendlyMaxLength,\n  notEmailFriendlyMinLength,\n  notEmailFriendlySetOnly,\n};","html-img-alt":"declare const version: string;\ninterface Opts {\n  unfancyTheAltContents: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function alts(str: string, opts?: Partial<Opts>): string;\n\nexport { Opts, alts, defaults, version };","html-table-patcher":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  cssStylesContent: string;\n  alwaysCenter: boolean;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  result: string;\n}\n/**\n * Visual helper to place templating code around table tags into correct places\n */\ndeclare function patcher(str: string, opts?: Partial<Opts>): Res;\n\nexport { Obj, Opts, Res, defaults, patcher, version };","is-char-suitable-for-html-attr-name":"declare const version: string;\ndeclare function isAttrNameChar(char: any | string): boolean;\n\nexport { isAttrNameChar, version };","is-html-attribute-closing":"declare const version: string;\ndeclare function isAttrClosing(\n  str: string,\n  idxOfAttrOpening: number,\n  isThisClosingIdx: number\n): boolean;\n\nexport { isAttrClosing, version };","is-html-tag-opening":"declare const defaultOpts: {\n  allowCustomTagNames: boolean;\n  skipOpeningBracket: boolean;\n};\n\ndeclare const version: string;\ninterface Opts {\n  allowCustomTagNames: boolean;\n  skipOpeningBracket: boolean;\n}\ndeclare function isOpening(\n  str: string,\n  idx?: number,\n  opts?: Partial<Opts>\n): boolean;\n\nexport { Opts, defaultOpts as defaults, isOpening, version };","is-language-code":"declare const version: string;\ntype Res =\n  | {\n      res: true;\n      message: null;\n    }\n  | {\n      res: false;\n      message: string;\n    };\ndeclare function isLangCode(str: string): Res;\n\nexport { isLangCode, version };","is-media-descriptor":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ninterface Opts {\n  offset: number;\n}\ninterface ResObj {\n  idxFrom: number;\n  idxTo: number;\n  message: string;\n  fix: {\n    ranges: Ranges;\n  } | null;\n}\n\ndeclare const version: string;\ndeclare const defaults: {\n  offset: number;\n};\ndeclare function isMediaD(str: string, opts?: Partial<Opts>): ResObj[];\n\nexport { Opts, ResObj, defaults, isMediaD, version };","is-relative-uri":"declare const version: string;\ninterface Opts {\n  flagUpUrisWithSchemes: boolean;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  res: boolean;\n  message: string | null;\n}\ndeclare function isRel(str: string, opts?: Partial<Opts>): Res;\n\nexport { Opts, Res, defaults, isRel, version };","js-row-num":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\n\ninterface Opts {\n  padStart: number;\n  overrideRowNum: null | number;\n  triggerKeywords: string[];\n  extractedLogContentsWereGiven: boolean;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  log: {\n    timeTakenInMilliseconds: number;\n  };\n  result: string;\n  ranges: Ranges;\n}\ndeclare function fixRowNums(str: string, opts?: Partial<Opts>): Res;\n\nexport { Opts, Ranges, Res, defaults, fixRowNums, version };","json-comb-core":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ndeclare function sortAllObjectsSync(input: any): any;\ndeclare function getKeyset(\n  arrOfPromises: Iterable<PromiseLike<Obj> | Obj>,\n  opts?: Partial<GetKeysetOpts>\n): Promise<Obj>;\ninterface GetKeysetOpts {\n  placeholder: any;\n}\ndeclare function getKeysetSync(arr: Obj[], opts?: Partial<GetKeysetOpts>): Obj;\ninterface EnforceKeysetOpts {\n  doNotFillThesePathsIfTheyContainPlaceholders: string[];\n  placeholder: boolean;\n  useNullAsExplicitFalse: boolean;\n}\ndeclare function enforceKeyset(\n  obj: Obj,\n  schemaKeyset: Obj,\n  opts?: Partial<EnforceKeysetOpts>\n): Promise<Obj>;\ndeclare function enforceKeysetSync(\n  obj: Obj,\n  schemaKeyset: Obj,\n  opts?: Partial<EnforceKeysetOpts>\n): Obj;\ntype NoNewKeysSyncRes = string[];\ndeclare function noNewKeysSync(obj: Obj, schemaKeyset: Obj): NoNewKeysSyncRes;\ninterface FindUnusedSyncOpts {\n  placeholder: boolean;\n  comments: string;\n}\ndeclare function findUnusedSync(\n  arr: any[],\n  opts?: Partial<FindUnusedSyncOpts>\n): string[];\n\nexport {\n  enforceKeyset,\n  enforceKeysetSync,\n  findUnusedSync,\n  getKeyset,\n  getKeysetSync,\n  noNewKeysSync,\n  sortAllObjectsSync,\n  version,\n};","json-variables":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  heads: string;\n  tails: string;\n  headsNoWrap: string;\n  tailsNoWrap: string;\n  lookForDataContainers: boolean;\n  dataContainerIdentifierTails: string;\n  wrapHeadsWith: string | string[];\n  wrapTailsWith: string | string[];\n  dontWrapVars: string[];\n  preventDoubleWrapping: boolean;\n  wrapGlobalFlipSwitch: boolean;\n  noSingleMarkers: boolean;\n  resolveToBoolIfAnyValuesContainBool: boolean;\n  resolveToFalseIfAnyValuesContainBool: boolean;\n  throwWhenNonStringInsertedInString: boolean;\n  allowUnresolved: boolean | string;\n}\ndeclare const defaults: Opts;\n/**\n * Resolves custom-marked, cross-referenced paths in parsed JSON\n */\ndeclare function jVar(input: Obj, opts?: Partial<Opts>): Obj;\n\nexport { Obj, Opts, defaults, jVar, version };","lerna-clean-changelogs":"declare const version: string;\ninterface Opts {\n  extras: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function cleanChangelogs(\n  changelog: string,\n  opts?: Partial<Opts>\n): {\n  version: string;\n  res: string;\n};\n\nexport { Opts, cleanChangelogs, defaults, version };","line-column-mini":"declare const version: string;\ndeclare function getLineStartIndexes(str: string): number[];\ninterface Res {\n  line: number;\n  col: number;\n}\n/**\n * Convert string index to line-column position\n */\ndeclare function lineCol(\n  input: string | number[],\n  idx: number,\n  skipChecks?: boolean\n): Res | null;\n\nexport { Res, getLineStartIndexes, lineCol, version };","object-all-values-equal-to":"declare const version: string;\ninterface Opts {\n  arraysMustNotContainPlaceholders: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function allEq(input: any, value: any, opts?: Partial<Opts>): boolean;\n\nexport { Opts, allEq, defaults, version };","object-boolean-combinations":"declare const version: string;\ninterface BoolObj {\n  [key: string]: boolean;\n}\ninterface Obj {\n  [key: string]: any;\n}\ndeclare function combinations(\n  input: Obj,\n  Override?: undefined | Obj\n): BoolObj[];\n\nexport { BoolObj, Obj, combinations, version };","object-delete-key":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ntype Only = \"array\" | \"object\" | \"any\";\ninterface Opts {\n  key: null | string;\n  val: any;\n  cleanup: boolean;\n  only: Only;\n}\ndeclare const defaults: Opts;\ndeclare function deleteKey(input: Obj, opts?: Partial<Opts>): Obj;\n\nexport { Obj, Opts, defaults, deleteKey, version };","object-fill-missing-keys":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  placeholder: boolean;\n  doNotFillThesePathsIfTheyContainPlaceholders: string[];\n  useNullAsExplicitFalse: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function fillMissing(\n  incomplete: Obj,\n  schema: Obj,\n  opts?: Partial<Opts>\n): Obj;\n\nexport { Obj, Opts, defaults, fillMissing, version };","object-flatten-all-arrays":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  flattenArraysContainingStringsToBeEmpty: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function flattenAllArrays(input: Obj, opts?: Partial<Opts>): Obj;\n\nexport { Obj, Opts, defaults, flattenAllArrays, version };","object-flatten-referencing":"interface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  wrapHeadsWith: string;\n  wrapTailsWith: string;\n  dontWrapKeys: string[];\n  dontWrapPaths: string[];\n  xhtml: boolean;\n  preventDoubleWrapping: boolean;\n  preventWrappingIfContains: string[];\n  objectKeyAndValueJoinChar: string;\n  wrapGlobalFlipSwitch: boolean;\n  ignore: string[];\n  whatToDoWhenReferenceIsMissing: 0 | 1 | 2;\n  mergeArraysWithLineBreaks: boolean;\n  mergeWithoutTrailingBrIfLineContainsBr: boolean;\n  enforceStrictKeyset: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function flattenObject(obj: Obj, opts?: Partial<Opts>): any[];\ndeclare function flattenArr(\n  arr: any[],\n  opts?: Partial<Opts>,\n  wrap?: boolean,\n  joinArraysUsingBrs?: boolean\n): string;\ndeclare function arrayiffyString(something: string | any): any;\n\ndeclare const version: string;\ndeclare function flattenReferencing(\n  input: any,\n  reference: any,\n  opts?: Partial<Opts>\n): any;\n\nexport {\n  Opts,\n  arrayiffyString,\n  defaults,\n  flattenArr,\n  flattenObject,\n  flattenReferencing,\n  version,\n};","object-merge-advanced":"declare const version: string;\ntype argType =\n  | \"date\"\n  | \"date\"\n  | \"object\"\n  | \"array\"\n  | \"string\"\n  | \"number\"\n  | \"function\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"symbol\"\n  | \"null\"\n  | \"undefined\";\ninterface InfoObj {\n  path: string | undefined;\n  key: string | null;\n  type: [argType, argType];\n}\ninterface Opts {\n  cb:\n    | null\n    | ((input1: any, input2: any, result: any, infoObj?: InfoObj) => any);\n  mergeObjectsOnlyWhenKeysetMatches: boolean;\n  ignoreKeys: string | string[];\n  hardMergeKeys: string | string[];\n  hardArrayConcatKeys: string[];\n  mergeArraysContainingStringsToBeEmpty: boolean;\n  oneToManyArrayObjectMerge: boolean;\n  hardMergeEverything: boolean;\n  hardArrayConcat: boolean;\n  ignoreEverything: boolean;\n  concatInsteadOfMerging: boolean;\n  dedupeStringsInArrayValues: boolean;\n  mergeBoolsUsingOrNotAnd: boolean;\n  useNullAsExplicitFalse: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Recursively, deeply merge of anything\n */\ndeclare function externalApi(\n  input1: unknown,\n  input2: unknown,\n  opts?: Partial<Opts>\n): any;\n\nexport {\n  InfoObj,\n  Opts,\n  argType,\n  defaults,\n  externalApi as mergeAdvanced,\n  version,\n};","object-no-new-keys":"declare const version: string;\ntype JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ntype JsonObject = {\n  [Key in string]?: JsonValue;\n};\ntype JsonArray = JsonValue[];\ninterface Opts {\n  mode: 1 | 2;\n}\ndeclare const defaults: Opts;\ndeclare function noNewKeys(\n  input: JsonValue,\n  reference: JsonValue,\n  opts?: Partial<Opts>\n): string[];\n\nexport { JsonArray, JsonObject, JsonValue, Opts, defaults, noNewKeys, version };","object-set-all-values-to":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ndeclare function setAllValuesTo(input: Obj, value?: any): Obj;\n\nexport { Obj, setAllValuesTo, version };","ranges-apply":"import { Ranges } from \"ranges-merge\";\nexport { Range, Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ndeclare function rApply(\n  str: string,\n  originalRangesArr: Ranges,\n  progressFn?: (percentageDone: number) => void\n): string;\n\nexport { rApply, version };","ranges-crop":"import { Ranges } from \"ranges-merge\";\nexport { Range, Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ndeclare function rCrop(arrOfRanges: Ranges, strLen: number): Ranges;\n\nexport { rCrop, version };","ranges-ent-decode":"import { Ranges } from \"ranges-merge\";\nexport { Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ninterface Opts {\n  isAttributeValue: boolean;\n  strict: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function rEntDecode(str: string, opts?: Partial<Opts>): Ranges;\n\nexport { Opts, defaults, rEntDecode, version };","ranges-invert":"import { Ranges } from \"ranges-merge\";\nexport { Range, Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ninterface Opts {\n  strictlyTwoElementsInRangeArrays: boolean;\n  skipChecks: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function rInvert(\n  arrOfRanges: Ranges,\n  strLen: number,\n  originalOptions?: Partial<Opts>\n): Ranges;\n\nexport { Opts, defaults, rInvert, version };","ranges-is-index-within":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n  inclusiveRangeEnds: boolean;\n  returnMatchedRangeInsteadOfTrue: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function isIndexWithin(\n  index: number,\n  rangesArr: Ranges,\n  opts?: Partial<Opts>\n): boolean | Range;\n\nexport { Opts, Range, Ranges, defaults, isIndexWithin, version };","ranges-iterate":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Obj {\n  i: number;\n  val: any;\n}\ntype Callback = (obj: Obj) => void;\ndeclare function rIterate(\n  str: string,\n  input: Ranges,\n  cb: Callback,\n  offset?: number\n): void;\n\nexport { Callback, Obj, rIterate, version };","ranges-merge":"import { Ranges } from \"ranges-sort\";\nexport { Range, Ranges } from \"ranges-sort\";\n\ndeclare const version: string;\ninterface UnknownValueObj {\n  [key: string]: any;\n}\ntype ProgressFn = (percentageDone: number) => void;\ninterface Opts {\n  mergeType: 1 | 2 | \"1\" | \"2\";\n  progressFn: null | undefined | ProgressFn;\n  joinRangesThatTouchEdges: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function rMerge(\n  arrOfRanges: Ranges,\n  originalOpts?: Partial<Opts>\n): Ranges;\n\nexport { Opts, ProgressFn, UnknownValueObj, defaults, rMerge, version };","ranges-offset":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ndeclare function rOffset(arrOfRanges: Ranges, offset?: number): Ranges;\n\nexport { Ranges, rOffset, version };","ranges-process-outside":"import { Ranges } from \"ranges-crop\";\nexport { Ranges } from \"ranges-crop\";\n\ndeclare const version: string;\ntype OffsetValueCb = (amountToOffset: number) => void;\ntype Callback = (\n  fromIdx: number,\n  toIdx: number,\n  offsetValueCb: OffsetValueCb\n) => void;\ndeclare function rProcessOutside(\n  originalStr: string,\n  originalRanges: Ranges,\n  cb: Callback,\n  skipChecks?: boolean\n): void;\n\nexport { Callback, OffsetValueCb, rProcessOutside, version };","ranges-push":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\n\ndeclare const version: string;\ninterface Opts {\n  limitToBeAddedWhitespace: boolean;\n  limitLinebreaksCount: number;\n  mergeType: 1 | 2 | \"1\" | \"2\" | undefined;\n}\ndeclare const defaults: Opts;\ndeclare class Ranges {\n  constructor(originalOpts?: Partial<Opts>);\n  ranges: Range[];\n  opts: Opts;\n  add(\n    originalFrom: number,\n    originalTo?: number,\n    addVal?: undefined | null | string\n  ): void;\n  add(originalFrom: Range[] | Range | null): void;\n  push(\n    originalFrom: number,\n    originalTo?: number,\n    addVal?: undefined | null | string\n  ): void;\n  push(originalFrom: Range[] | Range | null): void;\n  current(): null | Range[];\n  wipe(): void;\n  replace(givenRanges: Range[]): void;\n  last(): Range | null;\n}\n\nexport { Opts, Range, Ranges, defaults, version };","ranges-regex":"import { Ranges } from \"ranges-merge\";\n\ndeclare const version: string;\ndeclare function rRegex(\n  regx: RegExp,\n  str: string,\n  replacement?: string | null | undefined\n): Ranges;\n\nexport { rRegex, version };","ranges-sort":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\ndeclare const version: string;\ntype ProgressFn = (percentageDone: number) => void;\ninterface Opts {\n  strictlyTwoElementsInRangeArrays: boolean;\n  progressFn: undefined | null | ProgressFn;\n}\ndeclare const defaults: Opts;\ndeclare function rSort(\n  arrOfRanges: Ranges,\n  originalOptions?: Partial<Opts>\n): Ranges;\n\nexport { Opts, ProgressFn, Range, Ranges, defaults, rSort, version };","regex-empty-conditional-comments":"declare const version: string;\ndeclare function emptyCondCommentRegex(): RegExp;\n\nexport { emptyCondCommentRegex, version };","regex-is-jinja-nunjucks":"declare const version: string;\ndeclare function isJinjaNunjucksRegex(): RegExp;\n\nexport { isJinjaNunjucksRegex, version };","regex-is-jsp":"declare const version: string;\ndeclare function isJSP(): RegExp;\n\nexport { isJSP, version };","regex-jinja-specific":"declare const version: string;\ndeclare function isJinjaSpecific(): RegExp;\n\nexport { isJinjaSpecific, version };","rehype-responsive-tables":"import { Plugin } from \"unified\";\nimport { Root } from \"hast\";\n\ninterface Obj {\n  [key: string]: any;\n}\ndeclare const contains: (\n  tree: any,\n  something: string | string[]\n) => string | undefined;\ndeclare const getNthChildTag: (\n  tree: any,\n  tagName: string,\n  nth: number\n) => Obj | null;\n\ninterface Opts {\n  /**\n   * Plugin will take each row, add a row above, with content from\n   * the first column (single TD with colspan=0)\n   */\n  tableClassName: string;\n  /**\n   * Plugin will take each row, add a row above, with content from\n   * the first column (single TD with colspan=0)\n   */\n  newTrClassName: string;\n  /**\n   * The first TD of each TR in the result table will have this class\n   */\n  hideTdClassName: string;\n  /**\n   * When cells are stacked, it's necessary to visually separate\n   * the blocks. This plugin will add a gap <tr> above\n   */\n  gapTrClassName: string;\n  /**\n   * When the first column is \"lifted\" up, its contents are wrapped\n   * with a span which will contain this CSS class\n   */\n  newTrSpanTopClassName: string;\n  /**\n   * All labels \"lifted\" with opts.up will be wrapped by a span\n   * with this class\n   */\n  newTrSpanOtherClassName: string;\n  /**\n   * Lift the following cells' contents up, under the first column\n   */\n  up: string[];\n}\ndeclare const defaults: Opts;\ndeclare const rehypeResponsiveTables: Plugin<[Partial<Opts>?], Root>;\n\nexport {\n  Opts,\n  contains,\n  rehypeResponsiveTables as default,\n  defaults,\n  getNthChildTag,\n};","remark-conventional-commit-changelog-timeline":"import { Plugin } from \"unified\";\nimport { Root } from \"hast\";\n\ninterface DateParamsObj {\n  date: Date;\n  year: string;\n  month: string;\n  day: string;\n}\ninterface Opts {\n  dateDivLocale: string;\n  dateDivMarkup: (dateParamsObj: DateParamsObj) => string;\n}\ndeclare const defaults: Opts;\ntype UnifiedPlugin<T> = Plugin<[T], Root>;\ndeclare const changelogTimeline: UnifiedPlugin<[Partial<Opts>?]>;\n\nexport { DateParamsObj, Opts, changelogTimeline as default, defaults };","remark-typography":"import { Plugin } from \"unified\";\nimport { Root } from \"hast\";\n\ntype UnifiedPlugin<T> = Plugin<[T], Root>;\ndeclare const fixTypography: UnifiedPlugin<any[]>;\n\nexport { fixTypography as default };","seo-editor":"declare const version: string;\ninterface Res {\n  todoLines: {\n    extracted: string;\n    counts: number[];\n    length: number;\n    lengthCompensation: number;\n  }[];\n  chunkWordCounts: number[];\n  chunkLengths: number[];\n  todoTotal: number;\n  completion: number[];\n  log: {\n    timeTakenInMilliseconds: number;\n    version: string;\n  };\n}\ndeclare function isLetter(str: unknown): boolean;\ndeclare function setLengthCompensation(\n  resultArr: Res[\"todoLines\"],\n  receivedMaxLen: number\n): {\n  extracted: string;\n  counts: number[];\n  length: number;\n  lengthCompensation: number;\n}[];\ndeclare function editor(todo?: string, copy?: string): Res;\n\nexport { Res, editor, isLetter, setLengthCompensation, version };","str-indexes-of-plus":"declare const version: string;\ndeclare function strIndexesOfPlus(\n  str: string,\n  searchValue: string,\n  fromIndex?: string | number\n): number[];\n\nexport { strIndexesOfPlus, version };","string-apostrophes":"import { Ranges } from \"ranges-apply\";\nexport { Range, Ranges } from \"ranges-apply\";\n\ndeclare const version: string;\ninterface Opts {\n  from: number;\n  to?: number;\n  value?: string;\n  convertEntities?: boolean;\n  convertApostrophes?: boolean;\n  offsetBy?: (amount: number) => void;\n}\ndeclare const defaults: {\n  convertEntities: boolean;\n  convertApostrophes: boolean;\n};\ndeclare function convertOne(str: string, opts: Opts): Ranges;\ninterface convertAllRes {\n  result: string;\n  ranges: Ranges;\n}\n/**\n * Typographically-correct the apostrophes and single/double quotes\n */\ndeclare function convertAll(str: string, opts?: Partial<Opts>): convertAllRes;\n\nexport { Opts, convertAll, convertOne, defaults, version };","string-bionic-split":"declare const version: string;\ninterface Opts {\n  throwIfEdgeWhitespace: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function split(str: string, opts?: Partial<Opts>): number;\n\nexport { Opts, defaults, split, version };","string-character-is-astral-surrogate":"declare function isHighSurrogate(something: string | undefined): boolean;\ndeclare function isLowSurrogate(something: string | undefined): boolean;\n\nexport { isHighSurrogate, isLowSurrogate };","string-collapse-leading-whitespace":"declare const version: string;\ndeclare function collWhitespace(str: string, lineBreakLimit?: number): string;\n\nexport { collWhitespace, version };","string-collapse-white-space":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Extras {\n  whiteSpaceStartsAt: null | number;\n  whiteSpaceEndsAt: null | number;\n  str: string;\n}\ninterface CbObj extends Extras {\n  suggested: Range;\n}\ntype Callback = (cbObj: CbObj) => any;\ninterface Opts {\n  trimStart: boolean;\n  trimEnd: boolean;\n  trimLines: boolean;\n  trimnbsp: boolean;\n  removeEmptyLines: boolean;\n  limitConsecutiveEmptyLinesTo: number;\n  enforceSpacesOnly: boolean;\n  cb: Callback;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  result: string;\n  ranges: Ranges;\n}\ndeclare const cbSchema: string[];\ndeclare function collapse(str: string, opts?: Partial<Opts>): Res;\n\nexport {\n  Callback,\n  CbObj,\n  Extras,\n  Opts,\n  Range,\n  Ranges as RangesType,\n  Res,\n  cbSchema,\n  collapse,\n  defaults,\n  version,\n};","string-convert-indexes":"declare const version: string;\ndeclare function nativeToUnicode(str: string, indexes: any): number | string;\ndeclare function unicodeToNative(str: string, indexes: any): number | string;\n\nexport { nativeToUnicode, unicodeToNative, version };","string-dashes":"import { Ranges } from \"ranges-apply\";\nexport { Range, Ranges } from \"ranges-apply\";\n\ndeclare const version: string;\ninterface Opts {\n  from: number;\n  to?: number;\n  value?: string;\n  convertEntities?: boolean;\n  convertDashes?: boolean;\n  offsetBy?: (amount: number) => void;\n}\ndeclare const defaults: {\n  convertEntities: boolean;\n  convertDashes: boolean;\n};\ndeclare function convertOne(str: string, opts: Opts): Ranges;\ninterface convertAllRes {\n  result: string;\n  ranges: Ranges;\n}\n/**\n * Typographically-correct the hyphens and dashes\n */\ndeclare function convertAll(str: string, opts?: Partial<Opts>): convertAllRes;\n\nexport { Opts, convertAll, convertOne, defaults, version };","string-extract-class-names":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Result {\n  res: string[];\n  ranges: Ranges;\n}\n/**\n * Extracts CSS class/id names from a string\n */\ndeclare function extract(str: string): Result;\n\nexport { Result, extract, version };","string-extract-sass-vars":"declare const version: string;\ninterface UnknownValueObj {\n  [key: string]: any;\n}\ninterface Opts {\n  throwIfEmpty?: boolean;\n  cb?: null | ((varValue: string) => any);\n}\ndeclare const defaults: Opts;\ndeclare function extractVars(\n  str: string,\n  opts?: Partial<Opts>\n): UnknownValueObj;\n\nexport { Opts, UnknownValueObj, defaults, extractVars, version };","string-find-heads-tails":"declare const version: string;\ninterface Opts {\n  fromIndex: number;\n  throwWhenSomethingWrongIsDetected: boolean;\n  allowWholeValueToBeOnlyHeadsOrTails: boolean;\n  source: string;\n  matchHeadsAndTailsStrictlyInPairsByTheirOrder: boolean;\n  relaxedAPI: boolean;\n}\ndeclare const defaults: {\n  fromIndex: number;\n  throwWhenSomethingWrongIsDetected: boolean;\n  allowWholeValueToBeOnlyHeadsOrTails: boolean;\n  source: string;\n  matchHeadsAndTailsStrictlyInPairsByTheirOrder: boolean;\n  relaxedAPI: boolean;\n};\ninterface ResObj {\n  headsStartAt: number;\n  headsEndAt: number;\n  tailsStartAt: number;\n  tailsEndAt: number;\n}\ndeclare function strFindHeadsTails(\n  str: string,\n  heads: string | string[],\n  tails: string | string[],\n  opts?: Partial<Opts>\n): ResObj[];\n\nexport { Opts, ResObj, defaults, strFindHeadsTails, version };","string-find-malformed":"declare const version: string;\ninterface Opts {\n  stringOffset: number;\n  maxDistance: number;\n  ignoreWhitespace: boolean;\n}\ndeclare const defaults: Opts;\ninterface DataObj {\n  idxFrom: number;\n  idxTo: number;\n}\ndeclare function findMalformed(\n  str: string,\n  refStr: string,\n  cb: (obj: DataObj) => void,\n  opts?: Partial<Opts>\n): void;\n\nexport { DataObj, Opts, defaults, findMalformed, version };","string-fix-broken-named-entities":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ndeclare const allRules: string[];\ninterface Obj {\n  [key: string]: any;\n}\ninterface cbObj {\n  rangeFrom: number;\n  rangeTo: number;\n  rangeValEncoded: string | null;\n  rangeValDecoded: string | null;\n  ruleName: string;\n  entityName: string | null;\n}\ninterface Opts {\n  decode: boolean;\n  cb: null | ((obj: cbObj) => void);\n  entityCatcherCb: null | ((from: number, to: number) => void);\n  textAmpersandCatcherCb: null | ((idx: number) => void);\n  progressFn: null | ((percDone: number) => void);\n}\ndeclare function fixEnt(str: string, opts?: Partial<Opts>): Ranges;\n\nexport { Obj, Opts, Ranges, allRules, cbObj, fixEnt, version };","string-left-right":"declare const version: string;\ninterface Opts {\n  i?: boolean;\n}\ndeclare function right(str: string, idx?: number | null): number | null;\ndeclare function rightStopAtNewLines(str: string, idx: number): number | null;\ndeclare function rightStopAtRawNbsp(str: string, idx: number): number | null;\ndeclare function left(str: string, idx?: number | null): number | null;\ndeclare function leftStopAtNewLines(str: string, idx: number): number | null;\ndeclare function leftStopAtRawNbsp(str: string, idx: number): number | null;\ninterface SeqOutput {\n  gaps: [number, number][];\n  leftmostChar: number;\n  rightmostChar: number;\n}\ndeclare function leftSeq(\n  str: string,\n  idx: number,\n  ...args: any[]\n): SeqOutput | null;\ndeclare function rightSeq(\n  str: string,\n  idx: number,\n  ...args: any[]\n): SeqOutput | null;\ndeclare function chompLeft(\n  str: string,\n  idx: number,\n  ...args: any[]\n): number | null;\ndeclare function chompRight(\n  str: string,\n  idx: number,\n  ...args: any[]\n): number | null;\n\nexport {\n  Opts,\n  chompLeft,\n  chompRight,\n  left,\n  leftSeq,\n  leftStopAtNewLines,\n  leftStopAtRawNbsp,\n  right,\n  rightSeq,\n  rightStopAtNewLines,\n  rightStopAtRawNbsp,\n  version,\n};","string-match-left-right":"declare const version: string;\ninterface Opts {\n  cb:\n    | undefined\n    | null\n    | ((\n        wholeCharacterOutside?: string | undefined,\n        theRemainderOfTheString?: string,\n        firstCharOutsideIndex?: number\n      ) => string | boolean);\n  i: boolean;\n  trimBeforeMatching: boolean;\n  trimCharsBeforeMatching: string | string[];\n  maxMismatches: number;\n  firstMustMatch: boolean;\n  lastMustMatch: boolean;\n  hungry: boolean;\n}\ndeclare const defaults: Opts;\ndeclare const defaultGetNextIdx: (index: number) => number;\ndeclare function matchLeftIncl(\n  str: string,\n  position: number,\n  whatToMatch: (() => string) | string | string[],\n  opts?: Partial<Opts>\n): boolean | string;\ndeclare function matchLeft(\n  str: string,\n  position: number,\n  whatToMatch: (() => string) | string | string[],\n  opts?: Partial<Opts>\n): boolean | string;\ndeclare function matchRightIncl(\n  str: string,\n  position: number,\n  whatToMatch: (() => string) | string | string[],\n  opts?: Partial<Opts>\n): boolean | string;\ndeclare function matchRight(\n  str: string,\n  position: number,\n  whatToMatch: (() => string) | string | string[],\n  opts?: Partial<Opts>\n): boolean | string;\n\nexport {\n  Opts,\n  defaultGetNextIdx,\n  defaults,\n  matchLeft,\n  matchLeftIncl,\n  matchRight,\n  matchRightIncl,\n  version,\n};","string-overlap-one-on-another":"declare const version: string;\ninterface Opts {\n  offset: number;\n  offsetFillerCharacter: string;\n}\ndeclare const defaults: Opts;\ndeclare function overlap(\n  str1: string,\n  str2: string,\n  opts?: Partial<Opts>\n): string;\n\nexport { Opts, defaults, overlap, version };","string-process-comma-separated":"declare const version: string;\ntype ErrCb = (\n  indexes: [from: number, to: number][],\n  explanation: string,\n  isFixable: boolean\n) => void;\ninterface Obj {\n  [key: string]: any;\n}\ninterface Opts {\n  from: number;\n  to: number;\n  offset: number;\n  leadingWhitespaceOK: boolean;\n  trailingWhitespaceOK: boolean;\n  oneSpaceAfterCommaOK: boolean;\n  innerWhitespaceAllowed: boolean;\n  separator: string;\n  cb: null | ((from: number, to: number) => void);\n  errCb: null | ErrCb;\n}\ndeclare function processCommaSep(str: string, opts?: Partial<Opts>): void;\n\nexport { ErrCb, Obj, Opts, processCommaSep, version };","string-range-expander":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\n\ndeclare const version: string;\ninterface Opts {\n  str: string;\n  from: number;\n  to: number;\n  ifLeftSideIncludesThisThenCropTightly: string;\n  ifLeftSideIncludesThisCropItToo: string;\n  ifRightSideIncludesThisThenCropTightly: string;\n  ifRightSideIncludesThisCropItToo: string;\n  extendToOneSide: false | \"left\" | \"right\";\n  wipeAllWhitespaceOnLeft: boolean;\n  wipeAllWhitespaceOnRight: boolean;\n  addSingleSpaceToPreventAccidentalConcatenation: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function expander(opts: Partial<Opts>): Range;\n\nexport { Opts, Range, defaults, expander, version };","string-remove-duplicate-heads-tails":"declare const version: string;\ninterface Opts {\n  heads: string[];\n  tails: string[];\n}\ninterface LenientOpts {\n  heads: string | string[];\n  tails: string | string[];\n}\ndeclare const defaults: Opts;\ndeclare function remDup(str: string, opts?: Partial<LenientOpts>): string;\n\nexport { LenientOpts, Opts, defaults, remDup, version };","string-remove-thousand-separators":"declare const version: string;\ninterface Opts {\n  removeThousandSeparatorsFromNumbers: boolean;\n  padSingleDecimalPlaceNumbers: boolean;\n  forceUKStyle: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function remSep(str: string, opts?: Partial<Opts>): string;\n\nexport { Opts, defaults, remSep, version };","string-remove-widows":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ninterface HeadsAndTailsObj {\n  heads: string | string[];\n  tails: string | string[];\n}\ninterface Opts {\n  removeWidowPreventionMeasures: boolean;\n  convertEntities: boolean;\n  targetLanguage: \"html\" | \"css\" | \"js\";\n  UKPostcodes: boolean;\n  hyphens: boolean;\n  minWordCount: number;\n  minCharCount: number;\n  ignore: HeadsAndTailsObj[] | string | string[];\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n  tagRanges: Range[] | null;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  res: string;\n  ranges: Ranges;\n  log: {\n    timeTakenInMilliseconds: number;\n  };\n  whatWasDone: {\n    removeWidows: boolean;\n    convertEntities: boolean;\n  };\n}\ndeclare function removeWidows(str: string, opts?: Partial<Opts>): Res;\n\nexport { HeadsAndTailsObj, Obj, Opts, Res, defaults, removeWidows, version };","string-split-by-whitespace":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\n\ndeclare const version: string;\ninterface Opts {\n  ignoreRanges: Range[];\n}\ndeclare const defaults: Opts;\ndeclare function splitByW(str: string, opts?: Partial<Opts>): string[];\n\nexport { Opts, Range, defaults, splitByW, version };","string-strip-html":"import { Ranges as Ranges$1 } from \"ranges-push\";\n\ntype Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Attribute {\n  nameStarts: number;\n  nameEnds: number;\n  equalsAt?: number;\n  name: string;\n  valueStarts?: number;\n  valueEnds?: number;\n  value?: string;\n}\ninterface Tag {\n  attributes: Attribute[];\n  lastClosingBracketAt: number;\n  lastOpeningBracketAt: number;\n  slashPresent: number;\n  leftOuterWhitespace: number;\n  onlyPlausible: boolean;\n  nameStarts: number;\n  nameContainsLetters: boolean;\n  nameEnds: number;\n  name: string;\n}\ninterface CbObj {\n  tag: Tag;\n  deleteFrom: null | number;\n  deleteTo: null | number;\n  insert: null | undefined | string;\n  rangesArr: Ranges$1;\n  proposedReturn: Range | null;\n}\ninterface Opts {\n  ignoreTags: string[];\n  ignoreTagsWithTheirContents: string[];\n  onlyStripTags: string[];\n  stripTogetherWithTheirContents: string[];\n  skipHtmlDecoding: boolean;\n  trimOnlySpaces: boolean;\n  stripRecognisedHTMLOnly: boolean;\n  dumpLinkHrefsNearby: {\n    enabled?: boolean;\n    putOnNewLine?: boolean;\n    wrapHeads?: string;\n    wrapTails?: string;\n  };\n  cb: null | ((cbObj: CbObj) => void);\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  log: {\n    timeTakenInMilliseconds: number;\n  };\n  result: string;\n  ranges: Ranges;\n  allTagLocations: [number, number][];\n  filteredTagLocations: [number, number][];\n}\n/**\n * Strips HTML tags from strings. No parser, accepts mixed sources.\n */\ndeclare function stripHtml(str: string, opts?: Partial<Opts>): Res;\n\nexport { Attribute, CbObj, Opts, Res, Tag, defaults, stripHtml, version };","string-trim-spaces-only":"type Range =\n  | [from: number, to: number]\n  | [from: number, to: number, whatToInsert: string | null | undefined];\ntype Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n  classicTrim: boolean;\n  cr: boolean;\n  lf: boolean;\n  tab: boolean;\n  space: boolean;\n  nbsp: boolean;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  res: string;\n  ranges: Ranges;\n}\ndeclare function trimSpaces(str: string, opts?: Partial<Opts>): Res;\n\nexport { Opts, Res, defaults, trimSpaces, version };","string-truncator":"declare const version: string;\ninterface Opts {\n  maxLen: number;\n  maxLines: number;\n  ellipsisLen?: number;\n  monospace: boolean;\n  noEmpty: boolean;\n  letterWidths: Record<string, number>;\n}\ndeclare const defaults: Opts;\ninterface Res {\n  result: string;\n  addEllipsis: boolean;\n}\ndeclare function truncate(str: string, opts?: Partial<Opts>): Res;\n\nexport { Opts, Res, defaults, truncate, version };","string-uglify":"declare const version: string;\ninterface Obj {\n  [key: string]: any;\n}\ndeclare function uglifyArr(arr: string[]): string[];\ndeclare function uglifyById(refArr: string[], idNum: number): string;\n\nexport { Obj, uglifyArr, uglifyById, version };","string-unfancy":"declare const version: string;\ndeclare function unfancy(str: string): string;\n\nexport { unfancy, version };","stristri":"interface ApplicableOpts {\n  html: boolean;\n  css: boolean;\n  text: boolean;\n  templatingTags: boolean;\n  js: boolean;\n}\ninterface Opts {\n  html: boolean;\n  css: boolean;\n  text: boolean;\n  templatingTags: boolean;\n  js: boolean;\n  reportProgressFunc: null | ((percDone: number) => void);\n  reportProgressFuncFrom: number;\n  reportProgressFuncTo: number;\n}\ninterface Res {\n  log: {\n    timeTakenInMilliseconds: number;\n  };\n  result: string;\n  applicableOpts: ApplicableOpts;\n  templatingLang: {\n    name: null | string;\n  };\n}\ndeclare const defaultOpts: Opts;\n\ndeclare const version: string;\n/**\n * Extracts or deletes HTML, CSS, text and/or templating tags from string\n */\ndeclare function stri(input: string, opts?: Partial<Opts>): Res;\n\nexport { ApplicableOpts, Opts, Res, defaultOpts as defaults, stri, version };","tap-parse-string-to-object":"declare const version: string;\ninterface Res {\n  ok: boolean;\n  assertsTotal: number;\n  assertsPassed: number;\n  assertsFailed: number;\n  suitesTotal: number;\n  suitesPassed: number;\n  suitesFailed: number;\n}\ninterface StreamInterface extends NodeJS.ReadWriteStream {\n  read(size?: number): any;\n}\ndeclare function parseTap(\n  something: string | StreamInterface\n): Res | Promise<Res>;\n\nexport { Res, StreamInterface, parseTap, version };","test-mixer":"declare const version: string;\ntype PlainObject = {\n  [name: string]: any;\n};\ntype PlainObjectOfBool = {\n  [name: string]: boolean;\n};\ndeclare function mixer(\n  ref?: PlainObject,\n  defaultsObj?: PlainObject\n): PlainObjectOfBool[];\n\nexport { PlainObject, PlainObjectOfBool, mixer, version };","tsd-extract":"declare const roysSort: (a: string, b: string) => number;\n\ndeclare const version: string;\ninterface Opts {\n  extractAll: boolean;\n  semi: boolean;\n  mustInclude: string;\n  stripAs: boolean;\n  contentSort?: (el1: string, el2: string) => number;\n}\ninterface Chunk {\n  startsAt: null | number;\n  endsAt: null | number;\n  identifiers: string[];\n}\ninterface Statement {\n  identifiers: string[];\n  identifiersStartAt: number | null;\n  identifiersEndAt: number | null;\n  content: string | null;\n  contentStartsAt: number | null;\n  contentEndsAt: number | null;\n  value: string | null;\n  valueStartsAt: number | null;\n  valueEndsAt: number | null;\n}\ndeclare const defaults: Opts;\ntype ReturnType = Statement & {\n  all: string[];\n  error: string | null;\n};\ndeclare function join(...args: string[]): string;\n/**\n *\n * @param str type definitions file, as a string\n * @param def name of an interface, function or something else to extract\n * @param opts optional options object\n */\ndeclare function extract(\n  str: string,\n  def: string,\n  opts?: Partial<Opts>\n): ReturnType;\n\nexport {\n  Chunk,\n  Opts,\n  ReturnType,\n  Statement,\n  defaults,\n  extract,\n  join,\n  roysSort,\n  version,\n};","util-array-object-or-both":"declare const version: string;\ninterface Opts {\n  msg: string;\n  optsVarName: string;\n}\ndeclare const defaults: Opts;\ndeclare function arrObjOrBoth(\n  str: string,\n  opts?: Partial<Opts>\n): \"array\" | \"object\" | \"any\";\n\nexport { Opts, arrObjOrBoth, defaults, version };","util-nonempty":"declare const version: string;\ndeclare function nonEmpty(input: unknown): boolean;\n\nexport { nonEmpty, version };"};
