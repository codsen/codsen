export const allDTS = {"all-named-html-entities":"declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ndeclare type JsonObject = {\n    [Key in string]?: JsonValue;\n};\ndeclare type JsonArray = JsonValue[];\ndeclare const version: string;\ndeclare const allNamedEntities: JsonObject;\ndeclare const brokenNamedEntities: JsonObject;\ndeclare const entStartsWith: JsonObject;\ndeclare const entEndsWith: JsonObject;\ndeclare const entStartsWithCaseInsensitive: JsonObject;\ndeclare const entEndsWithCaseInsensitive: JsonObject;\ndeclare const uncertain: JsonObject;\ndeclare const allNamedEntitiesSetOnly: Set<string>;\ndeclare const allNamedEntitiesSetOnlyCaseInsensitive: Set<string>;\ndeclare function decode(ent: string): string | null;\ndeclare const minLength = 2;\ndeclare const maxLength = 31;\n\nexport { allNamedEntities, allNamedEntitiesSetOnly, allNamedEntitiesSetOnlyCaseInsensitive, brokenNamedEntities, decode, entEndsWith, entEndsWithCaseInsensitive, entStartsWith, entStartsWithCaseInsensitive, maxLength, minLength, uncertain, version };","array-group-str-omit-num-char":"export { Range, Ranges } from 'ranges-apply';\n\ndeclare const version: string;\ninterface UnknownValueObj {\n    [key: string]: any;\n}\ninterface Opts {\n    wildcard: string;\n    dedupePlease: boolean;\n}\n/**\n * Groups array of strings by omitting number characters\n */\ndeclare function groupStr(originalArr: string[], originalOpts?: Partial<Opts>): UnknownValueObj;\n\nexport { groupStr, version };","array-includes-with-glob":"declare const version: string;\ninterface Opts {\n    arrayVsArrayAllMustBeFound?: \"any\" | \"all\";\n    caseSensitive?: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Like _.includes but with wildcards\n */\ndeclare function includesWithGlob(originalInput: string | string[], stringToFind: string | string[], originalOpts?: Opts): boolean;\n\nexport { defaults, includesWithGlob, version };","array-of-arrays-into-ast":"declare const version: string;\ninterface UnknownValueObj {\n    [key: string]: any;\n}\ninterface Opts {\n    dedupe: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Turns an array of arrays of data into a nested tree of plain objects\n */\ndeclare function generateAst(input: any[], originalOpts?: Partial<Opts>): UnknownValueObj;\n\nexport { defaults, generateAst, version };","array-of-arrays-sort-by-col":"declare const version: string;\n/**\n * Sort array of arrays by column, rippling the sorting outwards from that column\n */\ndeclare function sortByCol(arr: any[], axis?: number | string): any[];\n\nexport { sortByCol, version };","array-pull-all-with-glob":"declare const version: string;\ninterface Opts {\n    caseSensitive?: boolean;\n}\n/**\n * Like _.pullAll but with globs (wildcards)\n */\ndeclare function pull(originalInput: string[], originalToBeRemoved: string | string[], originalOpts?: Opts): string[];\n\nexport { pull, version };","arrayiffy-if-string":"declare function arrayiffy(something: string): [string];\ndeclare function arrayiffy(something: string): [];\n\nexport { arrayiffy };","ast-compare":"declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ndeclare type JsonObject = {\n    [Key in string]?: JsonValue;\n};\ndeclare type JsonArray = JsonValue[];\ninterface Opts {\n    hungryForWhitespace?: boolean;\n    matchStrictly?: boolean;\n    verboseWhenMismatches?: boolean;\n    useWildcards?: boolean;\n}\n/**\n * Compare anything: AST, objects, arrays, strings and nested thereof\n */\ndeclare function compare(b: JsonValue, s: JsonValue, originalOpts?: Opts): boolean | string;\n\nexport { compare };","ast-contains-only-empty-space":"/**\n * Does AST contain only empty space?\n */\ndeclare function empty(input: unknown): boolean;\n\nexport { empty };","ast-deep-contains":"declare const version: string;\ninterface Opts {\n    skipContainers?: boolean;\n    arrayStrictComparison?: boolean;\n}\ndeclare const defaults: Opts;\ninterface Callback {\n    (leftSideVal: any, rightSideVal: any, path: string): void;\n}\ninterface ErrorCallback {\n    (errStr: string): void;\n}\n/**\n * Like t.same assert on array of objects, where element order doesn't matter.\n */\ndeclare function deepContains(tree1: any, tree2: any, cb: Callback, errCb: ErrorCallback, originalOpts?: Opts): void;\n\nexport { deepContains, defaults, version };","ast-delete-object":"declare const version: string;\ninterface UnknownValueObj {\n    [key: string]: any;\n}\ninterface Opts {\n    matchKeysStrictly?: boolean;\n    hungryForWhitespace?: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Delete all plain objects in AST if they contain a certain key/value pair\n */\ndeclare function deleteObj(originalInput: any, objToDelete: UnknownValueObj, originalOpts?: Opts): any;\n\nexport { defaults, deleteObj, version };","ast-get-object":"declare const version: string;\ninterface UnknownValueObj {\n    [key: string]: any;\n}\ndeclare function getObj(originalAst: any, keyValPair: UnknownValueObj, replacementContentsArr?: UnknownValueObj[]): any;\n\nexport { getObj, version };","ast-get-values-by-key":"declare const version: string;\n/**\n * Extract values and paths from AST by keys OR set them by keys\n */\ndeclare function getByKey(originalInput: any, whatToFind: string | string[], originalReplacement?: any): any;\n\nexport { getByKey, version };","ast-is-empty":"declare const version: string;\n/**\n * Find out, is nested array/object/string/AST tree is empty\n */\ndeclare function isEmpty(input: any): boolean | null;\n\nexport { isEmpty, version };","ast-loose-compare":"declare const version: string;\ndeclare type JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ndeclare type JsonObject = {\n    [Key in string]?: JsonValue;\n};\ndeclare type JsonArray = JsonValue[];\n/**\n * Compare anything: AST, objects, arrays and strings\n */\ndeclare function looseCompare(bigObj: JsonValue, smallObj: JsonValue): boolean | undefined;\n\nexport { looseCompare, version };","ast-monkey":"export { traverse } from 'ast-monkey-traverse';\n\ndeclare const version: string;\ndeclare type JsonValue = string | number | boolean | null | undefined | JsonObject | JsonArray;\ndeclare type JsonObject = {\n    [Key in string]?: JsonValue;\n};\ndeclare type JsonArray = JsonValue[];\ninterface Finding {\n    index: number;\n    key: string;\n    val: any;\n    path: number[];\n}\ninterface FindOpts {\n    key: null | string;\n    val: any;\n    only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function find(input: JsonValue, originalOpts: FindOpts): Finding[];\ninterface GetOpts {\n    index: number;\n    only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function get(input: JsonValue, originalOpts: GetOpts): GetOpts;\ninterface SetOpts {\n    key: null | string;\n    val: any;\n    index: number;\n    only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function set(input: JsonValue, originalOpts: SetOpts): JsonValue;\ninterface DropOpts {\n    index: number;\n    only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function drop(input: JsonValue, originalOpts: DropOpts): JsonValue;\ninterface DelOpts {\n    key: null | string;\n    val: any;\n    only?: undefined | null | \"any\" | \"array\" | \"object\";\n}\ndeclare function del(input: JsonValue, originalOpts: DelOpts): JsonValue;\ndeclare function arrayFirstOnly(input: JsonValue): JsonValue;\n\nexport { arrayFirstOnly, del, drop, find, get, set, version };","ast-monkey-traverse":"declare const version: string;\ninterface Stop {\n    now: boolean;\n}\ninterface InnerObj {\n    depth: number;\n    path: string;\n    topmostKey: string;\n    parent: any;\n    parentType: string;\n    parentKey: string | null;\n}\ndeclare type Callback = (key: string, val: any, innerObj: InnerObj, stop: Stop) => any;\n/**\n * Utility library to traverse AST\n */\ndeclare function traverse(tree1: any, cb1: Callback): any;\n\nexport { traverse, version };","ast-monkey-traverse-with-lookahead":"declare const version: string;\ninterface Obj {\n    [key: string]: any;\n}\ndeclare type NextToken = [\n    key: \"string\",\n    value: any,\n    innerObj: {\n        depth: number;\n        path: string;\n        parent: any;\n        parentType: string;\n    }\n];\ninterface InnerObj {\n    depth: number;\n    path: string;\n    topmostKey?: string;\n    parent?: any;\n    parentType?: string;\n    next?: NextToken[];\n}\ndeclare type Callback = (key: string | Obj, val: any, innerObj: InnerObj, stop: {\n    now: boolean;\n}) => any;\ndeclare function traverse(tree1: any, cb1: Callback, lookahead?: number): void;\n\nexport { traverse, version };","ast-monkey-util":"declare function pathNext(str: string): string;\n\ndeclare function pathPrev(str: string): null | string;\n\ndeclare function pathUp(str: string): string;\n\ndeclare function parent(str: string): null | string;\n\ndeclare const version: string;\n\nexport { parent, pathNext, pathPrev, pathUp, version };","bitbucket-slug":"/**\n * Generate BitBucket readme header anchor slug URLs\n */\ndeclare function bSlug(str: string): string;\n\nexport { bSlug };","charcode-is-valid-xml-name-character":"declare function isProduction4(char: string): boolean;\ndeclare function isProduction4a(char: string): boolean;\n\nexport { isProduction4, isProduction4a, isProduction4 as validFirstChar, isProduction4a as validSecondCharOnwards };","check-types-mini":"interface Obj {\n    [key: string]: any;\n}\ninterface Opts {\n    ignoreKeys: string | string[];\n    ignorePaths: string | string[];\n    acceptArrays: boolean;\n    acceptArraysIgnore: string | string[];\n    enforceStrictKeyset: boolean;\n    schema: Obj;\n    msg: string;\n    optsVarName: string;\n}\n/**\n * Validate options object\n */\ndeclare function checkTypesMini(obj: Obj, ref: Obj | null, originalOptions?: Partial<Opts>): void;\n\nexport { checkTypesMini };","codsen-parser":"import { TagToken, CommentToken, TextToken, RuleToken, AtToken, EspToken, CharCb } from 'codsen-tokenizer';\n\ndeclare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ndeclare type Severity = 0 | 1 | 2;\ninterface ErrorObj {\n    ruleId?: string;\n    message: string;\n    idxFrom: number;\n    idxTo: number;\n    fix: null | {\n        ranges: Ranges;\n    };\n    severity?: Severity;\n    keepSeparateWhenFixing?: boolean;\n}\ninterface TagTokenWithChildren extends TagToken {\n    children: TokenWithChildren[];\n}\ninterface CommentTokenWithChildren extends CommentToken {\n    children: TokenWithChildren[];\n}\ndeclare type TokenWithChildren = TextToken | TagTokenWithChildren | RuleToken | AtToken | CommentTokenWithChildren | EspToken;\ninterface SupplementedErrorObj extends ErrorObj {\n    tokenObj: TokenWithChildren;\n}\ndeclare type ErrCb = (obj: Partial<SupplementedErrorObj>) => void;\ninterface Opts {\n    reportProgressFunc: null | ((percDone: number) => void);\n    reportProgressFuncFrom: number;\n    reportProgressFuncTo: number;\n    tagCb: null | ((obj: TokenWithChildren) => void);\n    charCb: null | CharCb;\n    errCb: null | ErrCb;\n}\ndeclare const defaults: Opts;\n/**\n * Parser aiming at broken or mixed code, especially HTML & CSS\n */\ndeclare function cparser(str: string, originalOpts?: Partial<Opts>): any[];\n\nexport { CommentTokenWithChildren, ErrorObj, TagTokenWithChildren, TokenWithChildren, cparser, defaults, version };","codsen-tokenizer":"interface Selector {\n    value: string;\n    selectorStarts: number;\n    selectorEnds: number;\n}\ndeclare type TokenType = \"text\" | \"tag\" | \"rule\" | \"at\" | \"comment\" | \"esp\";\ndeclare type TokenKind = \"simplet\" | \"not\" | \"doctype\" | \"cdata\" | \"xml\" | \"inline\";\ndeclare type CommentKind = \"simple\" | \"only\" | \"not\" | \"block\" | \"line\" | \"simplet\";\ninterface TextToken {\n    type: \"text\";\n    start: number;\n    end: number;\n    value: string;\n}\ninterface CommentToken {\n    type: \"comment\";\n    start: number;\n    end: number;\n    value: string;\n    closing: null | boolean;\n    kind: CommentKind;\n    language: \"html\" | \"css\";\n}\ninterface EspToken {\n    type: \"esp\";\n    start: number;\n    end: number;\n    value: string;\n    head: null | string;\n    headStartsAt: null | number;\n    headEndsAt: null | number;\n    tail: null | string;\n    tailStartsAt: null | number;\n    tailEndsAt: null | number;\n}\ndeclare type PropertyValueWithinArray = TextToken | EspToken;\ninterface Property {\n    property: null | string;\n    propertyStarts: null | number;\n    propertyEnds: null | number;\n    colon: null | number;\n    value: string | PropertyValueWithinArray[];\n    valueStarts: null | number;\n    valueEnds: null | number;\n    importantStarts: null | number;\n    importantEnds: null | number;\n    important: null | string;\n    semi: null | number;\n    start: number;\n    end: number;\n}\ninterface Attrib {\n    attribName: string;\n    attribNameRecognised: boolean;\n    attribNameStartsAt: number;\n    attribNameEndsAt: number;\n    attribOpeningQuoteAt: null | number;\n    attribClosingQuoteAt: null | number;\n    attribValueRaw: string;\n    attribValue: (TextToken | Property | CommentToken | EspToken)[];\n    attribValueStartsAt: null | number;\n    attribValueEndsAt: null | number;\n    attribStarts: number;\n    attribEnds: number;\n    attribLeft: number;\n}\ninterface RuleToken {\n    type: \"rule\";\n    start: number;\n    end: number;\n    value: string;\n    left: null | number;\n    nested: null | boolean;\n    openingCurlyAt: null | number;\n    closingCurlyAt: null | number;\n    selectorsStart: null | number;\n    selectorsEnd: null | number;\n    selectors: Selector[];\n    properties: (Property | TextToken)[];\n}\ninterface TagToken {\n    type: \"tag\";\n    start: number;\n    end: number;\n    value: string;\n    tagNameStartsAt: number;\n    tagNameEndsAt: number;\n    tagName: string;\n    recognised: null | boolean;\n    closing: null | boolean;\n    void: null | boolean;\n    pureHTML: null | boolean;\n    kind: null | TokenKind;\n    attribs: Attrib[];\n}\ninterface AtToken {\n    type: \"at\";\n    start: number;\n    end: number;\n    value: string;\n    left: null | number;\n    nested: null | false;\n    identifier: null | string;\n    identifierStartsAt: null | number;\n    identifierEndsAt: null | number;\n    query: string;\n    queryStartsAt: number;\n    queryEndsAt: number;\n    openingCurlyAt: null | number;\n    closingCurlyAt: null | number;\n    rules: (RuleToken | TextToken)[];\n}\ndeclare type Token = TextToken | TagToken | RuleToken | AtToken | CommentToken | EspToken;\ninterface LayerKindAt {\n    type: \"at\";\n    token: AtToken;\n}\ninterface LayerSimple {\n    type: \"simple\" | \"block\";\n    value: string;\n    position: number;\n}\ninterface LayerEsp {\n    type: \"esp\";\n    openingLump: string;\n    guessedClosingLump: string;\n    position: number;\n}\ndeclare type Layer = LayerKindAt | LayerSimple | LayerEsp;\ninterface CharacterToken {\n    chr: string;\n    i: number;\n    type: TokenType;\n}\ndeclare type TokenCb = (token: Token, next: Token[]) => void;\ndeclare type CharCb = (token: CharacterToken, next: CharacterToken[]) => void;\ninterface Opts {\n    tagCb: null | TokenCb;\n    tagCbLookahead: number;\n    charCb: null | CharCb;\n    charCbLookahead: number;\n    reportProgressFunc: null | ((percDone: number) => void);\n    reportProgressFuncFrom: number;\n    reportProgressFuncTo: number;\n}\n\ndeclare function matchLayerLast(wholeEspTagLump: string, layers: Layer[], matchFirstInstead?: boolean): undefined | number;\n\ndeclare const version: string;\ndeclare const defaults: Opts;\ninterface Res {\n    timeTakenInMilliseconds: number;\n}\n/**\n * HTML and CSS lexer aimed at code with fatal errors, accepts mixed coding languages\n */\ndeclare function tokenizer(str: string, originalOpts?: Partial<Opts>): Res;\ndeclare const util: {\n    matchLayerLast: typeof matchLayerLast;\n};\n\nexport { AtToken, CharCb, CommentToken, EspToken, RuleToken, TagToken, TextToken, defaults, tokenizer, util, version };","color-shorthand-hex-to-six-digit":"declare const version: string;\n/**\n * Convert shorthand hex color codes into full\n */\ndeclare function conv(originalInput: any): any;\n\nexport { conv, version };","csv-sort":"declare function isNumeric(str: any): boolean;\ndeclare function findType(something: string): string;\n\ndeclare const version: string;\ninterface Res {\n    res: string[][];\n    msgContent: null | string;\n    msgType: null | string;\n}\n/**\n * Sorts double-entry bookkeeping CSV coming from internet banking\n */\ndeclare function sort(input: string): Res;\n\nexport { findType, isNumeric, sort, version };","csv-split-easy":"declare const version: string;\ninterface Opts {\n    removeThousandSeparatorsFromNumbers: boolean;\n    padSingleDecimalPlaceNumbers: boolean;\n    forceUKStyle: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function splitEasy(str: string, originalOpts?: Partial<Opts>): string[][];\n\nexport { defaults, splitEasy, version };","detect-is-it-html-or-xhtml":"declare const version: string;\ndeclare type Output = \"html\" | \"xhtml\" | null;\ndeclare function detectIsItHTMLOrXhtml(input: string): Output;\n\nexport { detectIsItHTMLOrXhtml, version };","detect-templating-language":"declare const version: string;\ndeclare type Output = \"Nunjucks\" | \"Jinja\" | \"JSP\" | null;\ndeclare function detectLang(str: string): {\n    name: Output;\n};\n\nexport { detectLang, version };","detergent":"declare type EndOfLine = \"lf\" | \"crlf\" | \"cr\";\ninterface Opts {\n    fixBrokenEntities: boolean;\n    removeWidows: boolean;\n    convertEntities: boolean;\n    convertDashes: boolean;\n    convertApostrophes: boolean;\n    replaceLineBreaks: boolean;\n    removeLineBreaks: boolean;\n    useXHTML: boolean;\n    dontEncodeNonLatin: boolean;\n    addMissingSpaces: boolean;\n    convertDotsToEllipsis: boolean;\n    stripHtml: boolean;\n    eol: EndOfLine;\n    stripHtmlButIgnoreTags: string[];\n    stripHtmlAddNewLine: string[];\n    cb: null | ((str: string) => string);\n}\ndeclare const defaultOpts: Opts;\ninterface ApplicableOpts {\n    fixBrokenEntities: boolean;\n    removeWidows: boolean;\n    convertEntities: boolean;\n    convertDashes: boolean;\n    convertApostrophes: boolean;\n    replaceLineBreaks: boolean;\n    removeLineBreaks: boolean;\n    useXHTML: boolean;\n    dontEncodeNonLatin: boolean;\n    addMissingSpaces: boolean;\n    convertDotsToEllipsis: boolean;\n    stripHtml: boolean;\n    eol: boolean;\n}\ninterface Res {\n    res: string;\n    applicableOpts: ApplicableOpts;\n}\n\ndeclare const version: string;\n/**\n * Extracts, cleans and encodes text\n */\ndeclare function det(str: string, inputOpts?: Partial<Opts>): Res;\n\nexport { det, defaultOpts as opts, version };","easy-replace":"declare const version: string;\ninterface Opts {\n    leftOutsideNot: string | string[];\n    leftOutside: string | string[];\n    leftMaybe: string | string[];\n    searchFor: string | string[];\n    rightMaybe: string | string[];\n    rightOutside: string | string[];\n    rightOutsideNot: string | string[];\n    i: {\n        leftOutsideNot: boolean;\n        leftOutside: boolean;\n        leftMaybe: boolean;\n        searchFor: boolean;\n        rightMaybe: boolean;\n        rightOutside: boolean;\n        rightOutsideNot: boolean;\n    };\n}\ndeclare function er(originalSource: string, options: Opts, originalReplacement: string): string;\n\nexport { er, version };","edit-package-json":"declare const version: string;\ndeclare function set(str: string, path: string, valToInsert: string | number): string;\ndeclare function del(str: string, path: string): string;\n\nexport { del, set, version };","email-all-chars-within-ascii":"declare const version: string;\ninterface Res {\n    type: \"character\" | \"line length\";\n    line: number;\n    column: number;\n    positionIdx: number;\n    value: number | string;\n    codePoint?: undefined | number;\n    UTF32Hex?: undefined | string;\n}\ninterface Opts {\n    lineLength: number;\n}\ndeclare const defaults: Opts;\ndeclare function within(str: string, originalOpts?: Partial<Opts>): Res[];\n\nexport { defaults, version, within };","email-comb":"interface Obj {\n    [key: string]: any;\n}\n\ndeclare const version: string;\ninterface HeadsAndTailsObj {\n    heads: string;\n    tails: string;\n}\ninterface Opts {\n    whitelist: string[];\n    backend: HeadsAndTailsObj[];\n    uglify: boolean;\n    removeHTMLComments: boolean;\n    removeCSSComments: boolean;\n    doNotRemoveHTMLCommentsWhoseOpeningTagContains: string[];\n    reportProgressFunc: null | ((percDone: number) => void);\n    reportProgressFuncFrom: number;\n    reportProgressFuncTo: number;\n}\ninterface Res {\n    log: {\n        timeTakenInMilliseconds: number;\n        traversedTotalCharacters: number;\n        traversedTimesInputLength: number;\n        originalLength: number;\n        cleanedLength: number;\n        bytesSaved: number;\n        percentageReducedOfOriginal: number;\n        nonIndentationsWhitespaceLength: number;\n        nonIndentationsTakeUpPercentageOfOriginal: number;\n        commentsLength: number;\n        commentsTakeUpPercentageOfOriginal: number;\n        uglified: null | Obj;\n    };\n    result: string;\n    countAfterCleaning: number;\n    countBeforeCleaning: number;\n    allInHead: string[];\n    allInBody: string[];\n    deletedFromHead: string[];\n    deletedFromBody: string[];\n}\ndeclare const defaults: Opts;\n/**\n * Remove unused CSS from email templates\n */\ndeclare function comb(str: string, originalOpts?: Partial<Opts>): Res;\n\nexport { comb, defaults, version };","emlint":"import { TypedEmitter } from 'tiny-typed-emitter';\nimport { TagToken, CommentToken as CommentToken$1, TextToken as TextToken$1, RuleToken as RuleToken$1, AtToken as AtToken$1, EspToken as EspToken$1 } from 'codsen-tokenizer';\n\ndeclare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ninterface Selector {\n    value: string;\n    selectorStarts: number;\n    selectorEnds: number;\n}\ndeclare type CommentKind = \"simple\" | \"only\" | \"not\" | \"block\" | \"line\" | \"simplet\";\ninterface TextToken {\n    type: \"text\";\n    start: number;\n    end: number;\n    value: string;\n}\ninterface CommentToken {\n    type: \"comment\";\n    start: number;\n    end: number;\n    value: string;\n    closing: null | boolean;\n    kind: CommentKind;\n    language: \"html\" | \"css\";\n}\ninterface EspToken {\n    type: \"esp\";\n    start: number;\n    end: number;\n    value: string;\n    head: null | string;\n    headStartsAt: null | number;\n    headEndsAt: null | number;\n    tail: null | string;\n    tailStartsAt: null | number;\n    tailEndsAt: null | number;\n}\ndeclare type PropertyValueWithinArray = TextToken | EspToken;\ninterface Property {\n    property: null | string;\n    propertyStarts: null | number;\n    propertyEnds: null | number;\n    colon: null | number;\n    value: string | PropertyValueWithinArray[];\n    valueStarts: null | number;\n    valueEnds: null | number;\n    importantStarts: null | number;\n    importantEnds: null | number;\n    important: null | string;\n    semi: null | number;\n    start: number;\n    end: number;\n}\ninterface Attrib {\n    attribName: string;\n    attribNameRecognised: boolean;\n    attribNameStartsAt: number;\n    attribNameEndsAt: number;\n    attribOpeningQuoteAt: null | number;\n    attribClosingQuoteAt: null | number;\n    attribValueRaw: string;\n    attribValue: (TextToken | Property | CommentToken | EspToken)[];\n    attribValueStartsAt: null | number;\n    attribValueEndsAt: null | number;\n    attribStarts: number;\n    attribEnds: number;\n    attribLeft: number;\n}\ninterface RuleToken {\n    type: \"rule\";\n    start: number;\n    end: number;\n    value: string;\n    left: null | number;\n    nested: null | boolean;\n    openingCurlyAt: null | number;\n    closingCurlyAt: null | number;\n    selectorsStart: null | number;\n    selectorsEnd: null | number;\n    selectors: Selector[];\n    properties: (Property | TextToken)[];\n}\ninterface AtToken {\n    type: \"at\";\n    start: number;\n    end: number;\n    value: string;\n    left: null | number;\n    nested: null | false;\n    identifier: null | string;\n    identifierStartsAt: null | number;\n    identifierEndsAt: null | number;\n    query: string;\n    queryStartsAt: number;\n    queryEndsAt: number;\n    openingCurlyAt: null | number;\n    closingCurlyAt: null | number;\n    rules: (RuleToken | TextToken)[];\n}\n\ndeclare type Severity$1 = 0 | 1 | 2;\ninterface ErrorObj {\n    ruleId?: string;\n    message: string;\n    idxFrom: number;\n    idxTo: number;\n    fix: null | {\n        ranges: Ranges;\n    };\n    severity?: Severity$1;\n    keepSeparateWhenFixing?: boolean;\n}\ninterface TagTokenWithChildren extends TagToken {\n    children: TokenWithChildren[];\n}\ninterface CommentTokenWithChildren extends CommentToken$1 {\n    children: TokenWithChildren[];\n}\ndeclare type TokenWithChildren = TextToken$1 | TagTokenWithChildren | RuleToken$1 | AtToken$1 | CommentTokenWithChildren | EspToken$1;\n\ndeclare type JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ndeclare type JsonObject = {\n    [Key in string]?: JsonValue;\n};\ndeclare type JsonArray = JsonValue[];\ndeclare type Severity = 0 | 1 | 2;\ninterface RulesObj {\n    [rulesName: string]: Severity | [severity: Severity, ...opts: string[]];\n}\ninterface Config {\n    rules: RulesObj;\n}\ninterface AttribSupplementedWithParent extends Attrib {\n    parent: TagTokenWithChildren;\n}\ndeclare type TagEvent = (node: TagTokenWithChildren) => void;\ndeclare type AtEvent = (node: AtToken) => void;\ndeclare type RuleEvent = (node: RuleToken) => void;\ndeclare type TextEvent = (node: TextToken) => void;\ndeclare type EspEvent = (node: EspToken) => void;\ndeclare type CharacterEvent = ({ chr, i }: {\n    chr: string;\n    i: number;\n}) => void;\ndeclare type AttributeEvent = (node: AttribSupplementedWithParent) => void;\ndeclare type AstEvent = (node: JsonObject[]) => void;\ndeclare type CommentEvent = (node: CommentTokenWithChildren) => void;\ndeclare type EntityEvent = (node: {\n    idxFrom: number;\n    idxTo: number;\n}) => void;\ninterface RuleObjType {\n    tag?: TagEvent;\n    at?: AtEvent;\n    rule?: RuleEvent;\n    text?: TextEvent;\n    esp?: EspEvent;\n    character?: CharacterEvent;\n    attribute?: AttributeEvent;\n    ast?: AstEvent;\n    comment?: CommentEvent;\n    entity?: EntityEvent;\n}\ninterface MessageObj extends ErrorObj {\n    line: number;\n    column: number;\n    severity: Severity;\n    keepSeparateWhenFixing: boolean;\n}\n\ninterface ErrorObjWithRuleId extends ErrorObj {\n    ruleId: string;\n}\n/**\n * Pluggable email template code linter\n */\ndeclare class Linter extends TypedEmitter<RuleObjType> {\n    constructor();\n    messages: MessageObj[];\n    str: string;\n    strLineStartIndexes: number[];\n    config: Config;\n    hasBeenCalledWithKeepSeparateWhenFixing: boolean;\n    processedRulesConfig: RulesObj;\n    verify(str: string, config: Config): ErrorObj[];\n    report(obj: ErrorObjWithRuleId): void;\n}\n\ndeclare type IdxRange = [charFrom: number, charTo: number];\ndeclare type CbValues = (idxRange: IdxRange) => void;\ninterface Opts$1 {\n    offset: number;\n    from: number;\n    to: number;\n}\ndeclare function splitByWhitespace(str: string, cbValues: CbValues, cbWhitespace?: CbValues, originalOpts?: Partial<Opts$1>): void;\n\ndeclare const badChars: Map<number, string>;\n\ninterface Opts {\n    caseInsensitive: boolean;\n    canBeCommaSeparated: boolean;\n    quickPermittedValues: (string | RegExp)[];\n    permittedValues: string[];\n    noSpaceAfterComma: boolean;\n}\ndeclare function validateString(str: string, idxOffset: number, originalOpts?: Partial<Opts>): ErrorObj[];\n\ndeclare const wholeExtensionRegex: RegExp;\ndeclare const isoDateRegex: RegExp;\ndeclare const fontSizeRegex: RegExp;\ndeclare const linkTypes: string[];\ndeclare const astErrMessages: {\n    \"tag-missing-opening\": string;\n    \"tag-missing-closing\": string;\n    \"tag-void-frontal-slash\": string;\n};\ndeclare function isLetter(str: unknown): boolean;\ndeclare function isAnEnabledValue(maybeARulesValue: unknown): Severity;\ndeclare function isObj(something: unknown): boolean;\ndeclare function isAnEnabledRule(rules: RulesObj, ruleId: string): Severity;\n\ndeclare const util_wholeExtensionRegex: typeof wholeExtensionRegex;\ndeclare const util_splitByWhitespace: typeof splitByWhitespace;\ndeclare const util_isAnEnabledValue: typeof isAnEnabledValue;\ndeclare const util_isAnEnabledRule: typeof isAnEnabledRule;\ndeclare const util_astErrMessages: typeof astErrMessages;\ndeclare const util_validateString: typeof validateString;\ndeclare const util_fontSizeRegex: typeof fontSizeRegex;\ndeclare const util_isoDateRegex: typeof isoDateRegex;\ndeclare const util_linkTypes: typeof linkTypes;\ndeclare const util_isLetter: typeof isLetter;\ndeclare const util_badChars: typeof badChars;\ndeclare const util_isObj: typeof isObj;\ndeclare namespace util {\n  export {\n    util_wholeExtensionRegex as wholeExtensionRegex,\n    util_splitByWhitespace as splitByWhitespace,\n    util_isAnEnabledValue as isAnEnabledValue,\n    util_isAnEnabledRule as isAnEnabledRule,\n    util_astErrMessages as astErrMessages,\n    util_validateString as validateString,\n    util_fontSizeRegex as fontSizeRegex,\n    util_isoDateRegex as isoDateRegex,\n    util_linkTypes as linkTypes,\n    util_isLetter as isLetter,\n    util_badChars as badChars,\n    util_isObj as isObj,\n  };\n}\n\ndeclare const version: string;\n\nexport { Linter, util, version };","generate-atomic-css":"declare const headsAndTails: {\n    CONFIGHEAD: string;\n    CONFIGTAIL: string;\n    CONTENTHEAD: string;\n    CONTENTTAIL: string;\n};\ndeclare function extractFromToSource(str: string, fromDefault?: number, toDefault?: number): [from: number, to: number, source: string];\n\ndeclare const version: string;\ninterface Opts {\n    includeConfig: boolean;\n    includeHeadsAndTails: boolean;\n    pad: boolean;\n    configOverride: null | string;\n    reportProgressFunc: null | ((percDone: number) => void);\n    reportProgressFuncFrom: number;\n    reportProgressFuncTo: number;\n}\ndeclare const defaults: Opts;\ndeclare function genAtomic(str: string, originalOpts?: Opts): {\n    log: {\n        count: number;\n    };\n    result: string;\n};\n\nexport { defaults, extractFromToSource, genAtomic, headsAndTails, version };","helga":"declare const version: string;\ninterface Opts {\n    targetJSON: boolean;\n}\ndeclare const defaults: {\n    targetJSON: boolean;\n};\ndeclare function helga(str: string, originalOpts?: Opts): {\n    minified: string;\n    beautified: string;\n};\n\nexport { defaults, helga, version };","html-all-known-attributes":"declare const version: string;\ndeclare const allHtmlAttribs: Set<string>;\n\nexport { allHtmlAttribs, version };","html-crush":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n    lineLengthLimit: number;\n    removeIndentations: boolean;\n    removeLineBreaks: boolean;\n    removeHTMLComments: boolean | 0 | 1 | 2;\n    removeCSSComments: boolean;\n    reportProgressFunc: null | ((percDone: number) => void);\n    reportProgressFuncFrom: number;\n    reportProgressFuncTo: number;\n    breakToTheLeftOf: string[];\n    mindTheInlineTags: string[];\n}\ndeclare const defaults: Opts;\ninterface Res {\n    log: {\n        timeTakenInMilliseconds: number;\n        originalLength: number;\n        cleanedLength: number;\n        bytesSaved: number;\n        percentageReducedOfOriginal: number;\n    };\n    applicableOpts: {\n        removeHTMLComments: boolean;\n        removeCSSComments: boolean;\n    };\n    ranges: Ranges;\n    result: string;\n}\n/**\n * Minifies HTML/CSS: valid or broken, pure or mixed with other languages\n */\ndeclare function crush(str: string, originalOpts?: Partial<Opts>): Res;\n\nexport { crush, defaults, version };","html-entities-not-email-friendly":"interface Obj {\n    [key: string]: any;\n}\ndeclare const notEmailFriendly: Obj;\ndeclare const notEmailFriendlySetOnly: Set<string>;\ndeclare const notEmailFriendlyLowercaseSetOnly: Set<string>;\ndeclare const notEmailFriendlyMinLength = 2;\ndeclare const notEmailFriendlyMaxLength = 31;\n\nexport { notEmailFriendly, notEmailFriendlyLowercaseSetOnly, notEmailFriendlyMaxLength, notEmailFriendlyMinLength, notEmailFriendlySetOnly };","html-img-alt":"declare const version: string;\ninterface Opts {\n    unfancyTheAltContents: boolean;\n}\ndeclare function alts(str: string, originalOpts?: Partial<Opts>): string;\n\nexport { alts, version };","html-table-patcher":"declare const version: string;\ninterface Opts {\n    cssStylesContent: string;\n    alwaysCenter: boolean;\n}\ndeclare const defaults: Opts;\n/**\n * Visual helper to place templating code around table tags into correct places\n */\ndeclare function patcher(str: string, generalOpts?: Partial<Opts>): {\n    result: string;\n};\n\nexport { defaults, patcher, version };","is-char-suitable-for-html-attr-name":"declare function isAttrNameChar(char: any | string): boolean;\n\nexport { isAttrNameChar };","is-html-attribute-closing":"declare const version: string;\ndeclare function isAttrClosing(str: string, idxOfAttrOpening: number, isThisClosingIdx: number): boolean;\n\nexport { isAttrClosing, version };","is-html-tag-opening":"declare const defaultOpts: {\n    allowCustomTagNames: boolean;\n    skipOpeningBracket: boolean;\n};\n\ndeclare const version: string;\ninterface Opts {\n    allowCustomTagNames: boolean;\n    skipOpeningBracket: boolean;\n}\ndeclare function isOpening(str: string, idx?: number, originalOpts?: Partial<Opts>): boolean;\n\nexport { defaultOpts as defaults, isOpening, version };","is-language-code":"declare const version: string;\ninterface Res {\n    res: boolean;\n    message: string | null;\n}\ndeclare function isLangCode(str: string): Res;\n\nexport { isLangCode, version };","is-media-descriptor":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ninterface Opts {\n    offset: number;\n}\ninterface ResObj {\n    idxFrom: number;\n    idxTo: number;\n    message: string;\n    fix: {\n        ranges: Ranges;\n    } | null;\n}\n\ndeclare const version: string;\ndeclare const defaults: {\n    offset: number;\n};\ndeclare function isMediaD(originalStr: string, originalOpts?: Partial<Opts>): ResObj[];\n\nexport { defaults, isMediaD, version };","is-relative-uri":"declare const version: string;\ninterface Opts {\n    flagUpUrisWithSchemes: boolean;\n    offset: number;\n}\ninterface Res {\n    res: boolean;\n    message: string | null;\n}\ndeclare function isRel(str: string, originalOpts?: Partial<Opts>): Res;\n\nexport { isRel, version };","js-row-num":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n    padStart: number;\n    overrideRowNum: null | number;\n    returnRangesOnly: boolean;\n    triggerKeywords: string[];\n    extractedLogContentsWereGiven: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function fixRowNums(str: string, originalOpts?: Partial<Opts>): string | Ranges;\n\nexport { defaults, fixRowNums, version };","json-comb-core":"declare const version: string;\ninterface Obj {\n    [key: string]: any;\n}\ndeclare function sortAllObjectsSync(input: any): any;\ndeclare function getKeyset<ValueType>(arrOfPromises: Iterable<PromiseLike<ValueType> | ValueType>, originalOpts?: {\n    placeholder?: boolean;\n}): Promise<Obj>;\ndeclare function getKeysetSync(arrOriginal: Obj[], originalOpts?: {\n    placeholder?: any;\n}): {};\ninterface EnforceKeysetOpts {\n    doNotFillThesePathsIfTheyContainPlaceholders: string[];\n    placeholder: boolean;\n    useNullAsExplicitFalse: boolean;\n}\ndeclare function enforceKeyset(obj: Obj, schemaKeyset: Obj, originalOpts?: EnforceKeysetOpts): Promise<Obj>;\ndeclare function enforceKeysetSync(obj: Obj, schemaKeyset: Obj, originalOpts?: EnforceKeysetOpts): any;\ndeclare function noNewKeysSync(obj: Obj, schemaKeyset: Obj): any;\ndeclare function findUnusedSync(arrOriginal: any[], originalOpts?: {\n    placeholder?: boolean;\n    comments?: string;\n}): string[];\n\nexport { enforceKeyset, enforceKeysetSync, findUnusedSync, getKeyset, getKeysetSync, noNewKeysSync, sortAllObjectsSync, version };","json-variables":"declare const version: string;\ninterface Obj {\n    [key: string]: any;\n}\ninterface Opts {\n    heads: string;\n    tails: string;\n    headsNoWrap: string;\n    tailsNoWrap: string;\n    lookForDataContainers: boolean;\n    dataContainerIdentifierTails: string;\n    wrapHeadsWith: string | string[];\n    wrapTailsWith: string | string[];\n    dontWrapVars: string[];\n    preventDoubleWrapping: boolean;\n    wrapGlobalFlipSwitch: boolean;\n    noSingleMarkers: boolean;\n    resolveToBoolIfAnyValuesContainBool: boolean;\n    resolveToFalseIfAnyValuesContainBool: boolean;\n    throwWhenNonStringInsertedInString: boolean;\n    allowUnresolved: boolean | string;\n}\ndeclare const defaults: Opts;\n/**\n * Resolves custom-marked, cross-referenced paths in parsed JSON\n */\ndeclare function jVar(input: Obj, originalOpts?: Partial<Opts>): Obj;\n\nexport { defaults, jVar, version };","lerna-clean-changelogs":"declare const version: string;\ndeclare function cleanChangelogs(changelogContents: string, extras?: boolean): {\n    version: string;\n    res: string;\n};\n\nexport { cleanChangelogs, version };","line-column-mini":"declare const version: string;\ndeclare function getLineStartIndexes(str: string): number[];\n/**\n * Convert string index to line-column position\n */\ndeclare function lineCol(input: string | number[], idx: number, skipChecks?: boolean): {\n    line: number;\n    col: number;\n} | null;\n\nexport { getLineStartIndexes, lineCol, version };","object-all-values-equal-to":"declare const version: string;\ninterface Opts {\n    arraysMustNotContainPlaceholders: boolean;\n}\ndeclare function allEq(inputOriginal: any, valueOriginal: any, originalOpts?: Partial<Opts>): boolean;\n\nexport { allEq, version };","object-boolean-combinations":"declare const version: string;\ninterface BoolValueObj {\n    [key: string]: boolean;\n}\ninterface UnknownValueObj {\n    [key: string]: any;\n}\ndeclare function combinations(originalIncomingObject: UnknownValueObj, originalOverrideObject?: undefined | UnknownValueObj): BoolValueObj[];\n\nexport { combinations, version };","object-delete-key":"declare const version: string;\ninterface Obj {\n    [key: string]: any;\n}\ndeclare type Only = \"array\" | \"object\" | \"any\";\ninterface Opts {\n    key: null | string;\n    val: any;\n    cleanup: boolean;\n    only: Only;\n}\ndeclare function deleteKey(originalInput: Obj, originalOpts?: Partial<Opts>): Obj;\n\nexport { deleteKey, version };","object-fill-missing-keys":"declare const version: string;\ninterface Obj {\n    [key: string]: any;\n}\ninterface Opts {\n    placeholder: boolean;\n    doNotFillThesePathsIfTheyContainPlaceholders: string[];\n    useNullAsExplicitFalse: boolean;\n}\ndeclare function fillMissing(originalIncompleteWrapper: Obj, originalSchemaWrapper: Obj, originalOptsWrapper?: Opts): Obj;\n\nexport { fillMissing, version };","object-flatten-all-arrays":"declare const version: string;\ninterface Obj {\n    [key: string]: any;\n}\ninterface Opts {\n    flattenArraysContainingStringsToBeEmpty: boolean;\n}\ndeclare function flattenAllArrays(originalIncommingObj: Obj, originalOpts?: Partial<Opts>): Obj;\n\nexport { flattenAllArrays, version };","object-flatten-referencing":"interface Obj {\n    [key: string]: any;\n}\ninterface Opts {\n    wrapHeadsWith: string;\n    wrapTailsWith: string;\n    dontWrapKeys: string[];\n    dontWrapPaths: string[];\n    xhtml: boolean;\n    preventDoubleWrapping: boolean;\n    preventWrappingIfContains: string[];\n    objectKeyAndValueJoinChar: string;\n    wrapGlobalFlipSwitch: boolean;\n    ignore: string[];\n    whatToDoWhenReferenceIsMissing: 0 | 1 | 2;\n    mergeArraysWithLineBreaks: boolean;\n    mergeWithoutTrailingBrIfLineContainsBr: boolean;\n    enforceStrictKeyset: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function flattenObject(objOrig: Obj, originalOpts?: Partial<Opts>): any[];\ndeclare function flattenArr(arrOrig: any[], originalOpts?: Partial<Opts>, wrap?: boolean, joinArraysUsingBrs?: boolean): string;\ndeclare function arrayiffyString(something: string | any): any;\n\ndeclare const version: string;\ndeclare function flattenReferencing(originalInput1: any, originalReference1: any, opts1?: Partial<Opts>): any;\n\nexport { arrayiffyString, defaults, flattenArr, flattenObject, flattenReferencing, version };","object-merge-advanced":"declare const version: string;\ndeclare type argType = \"date\" | \"date\" | \"object\" | \"array\" | \"string\" | \"number\" | \"function\" | \"bigint\" | \"boolean\" | \"symbol\" | \"null\" | \"undefined\";\ninterface InfoObj {\n    path: string | undefined;\n    key: string | null;\n    type: [argType, argType];\n}\ninterface Opts {\n    cb?: null | ((input1: any, input2: any, result: any, infoObj?: InfoObj) => any);\n    mergeObjectsOnlyWhenKeysetMatches?: boolean;\n    ignoreKeys?: string | string[];\n    hardMergeKeys?: string | string[];\n    hardArrayConcatKeys?: string[];\n    mergeArraysContainingStringsToBeEmpty?: boolean;\n    oneToManyArrayObjectMerge?: boolean;\n    hardMergeEverything?: boolean;\n    hardArrayConcat?: boolean;\n    ignoreEverything?: boolean;\n    concatInsteadOfMerging?: boolean;\n    dedupeStringsInArrayValues?: boolean;\n    mergeBoolsUsingOrNotAnd?: boolean;\n    useNullAsExplicitFalse?: boolean;\n}\ninterface SettledOpts extends Opts {\n    cb: null | ((input1: any, input2: any, result: any, infoObj?: InfoObj) => any);\n    mergeObjectsOnlyWhenKeysetMatches: boolean;\n    ignoreKeys: string[];\n    hardMergeKeys: string[];\n    hardArrayConcatKeys: string[];\n    mergeArraysContainingStringsToBeEmpty: boolean;\n    oneToManyArrayObjectMerge: boolean;\n    hardMergeEverything: boolean;\n    hardArrayConcat: boolean;\n    ignoreEverything: boolean;\n    concatInsteadOfMerging: boolean;\n    dedupeStringsInArrayValues: boolean;\n    mergeBoolsUsingOrNotAnd: boolean;\n    useNullAsExplicitFalse: boolean;\n}\ndeclare const defaults: SettledOpts;\n/**\n * Recursively, deeply merge of anything\n */\ndeclare function externalApi(input1orig: any, input2orig: any, originalOpts: Opts): any;\n\nexport { defaults, externalApi as mergeAdvanced, version };","object-no-new-keys":"declare const version: string;\ndeclare type JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ndeclare type JsonObject = {\n    [Key in string]?: JsonValue;\n};\ndeclare type JsonArray = JsonValue[];\ninterface Opts {\n    mode: 1 | 2;\n}\ndeclare function noNewKeys(inputOuter: JsonValue, referenceOuter: JsonValue, originalOptsOuter?: Opts): any;\n\nexport { noNewKeys, version };","object-set-all-values-to":"declare const version: string;\ninterface Obj {\n    [key: string]: any;\n}\ndeclare function setAllValuesTo(inputOriginal: Obj, valueOriginal?: any): Obj;\n\nexport { setAllValuesTo, version };","ranges-apply":"import { Ranges } from 'ranges-merge';\nexport { Range, Ranges } from 'ranges-merge';\n\ndeclare const version: string;\ndeclare function rApply(str: string, originalRangesArr: Ranges, progressFn?: (percentageDone: number) => void): string;\n\nexport { rApply, version };","ranges-crop":"import { Ranges } from 'ranges-merge';\nexport { Range, Ranges } from 'ranges-merge';\n\ndeclare const version: string;\ndeclare function rCrop(arrOfRanges: Ranges, strLen: number): Ranges;\n\nexport { rCrop, version };","ranges-ent-decode":"import { Ranges } from 'ranges-merge';\n\ndeclare const version: string;\ninterface Opts {\n    isAttributeValue: boolean;\n    strict: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function rEntDecode(str: string, originalOpts?: Partial<Opts>): Ranges;\n\nexport { defaults, rEntDecode, version };","ranges-invert":"import { Ranges } from 'ranges-merge';\n\ndeclare const version: string;\ninterface Opts {\n    strictlyTwoElementsInRangeArrays?: boolean;\n    skipChecks?: boolean;\n}\ndeclare function rInvert(arrOfRanges: Ranges, strLen: number, originalOptions?: Opts): Ranges;\n\nexport { rInvert, version };","ranges-is-index-within":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n    inclusiveRangeEnds?: boolean;\n    returnMatchedRangeInsteadOfTrue?: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function isIndexWithin(originalIndex: number, rangesArr: Ranges, originalOpts?: Opts): boolean | Range;\n\nexport { defaults, isIndexWithin, version };","ranges-iterate":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Obj {\n    i: number;\n    val: any;\n}\ndeclare type Callback = (obj: Obj) => void;\ndeclare function rIterate(str: string, originalRanges: Ranges, cb: Callback, offset?: number): void;\n\nexport { rIterate, version };","ranges-merge":"import { Ranges } from 'ranges-sort';\nexport { Range, Ranges } from 'ranges-sort';\n\ndeclare const version: string;\ndeclare type ProgressFn = (percentageDone: number) => void;\ninterface Opts {\n    mergeType: 1 | 2 | \"1\" | \"2\";\n    progressFn: null | undefined | ProgressFn;\n    joinRangesThatTouchEdges: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function rMerge(arrOfRanges: Ranges, originalOpts?: Partial<Opts>): Ranges;\n\nexport { defaults, rMerge, version };","ranges-offset":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ndeclare function rOffset(arrOfRanges: Ranges, offset?: number): Ranges;\n\nexport { rOffset, version };","ranges-process-outside":"import { Ranges } from 'ranges-crop';\n\ndeclare const version: string;\ndeclare type OffsetValueCb = (amountToOffset: number) => void;\ndeclare type Callback = (fromIdx: number, toIdx: number, offsetValueCb: OffsetValueCb) => void;\ndeclare function rProcessOutside(originalStr: string, originalRanges: Ranges, cb: Callback, skipChecks?: boolean): void;\n\nexport { rProcessOutside, version };","ranges-push":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\n\ndeclare const version: string;\ninterface Opts {\n    limitToBeAddedWhitespace: boolean;\n    limitLinebreaksCount: number;\n    mergeType: 1 | 2 | \"1\" | \"2\" | undefined;\n}\ndeclare const defaults: Opts;\ndeclare class Ranges {\n    constructor(originalOpts?: Partial<Opts>);\n    ranges: Range[];\n    opts: Opts;\n    add(originalFrom: number, originalTo?: number, addVal?: undefined | null | string): void;\n    add(originalFrom: Range[] | Range | null): void;\n    push(originalFrom: number, originalTo?: number, addVal?: undefined | null | string): void;\n    push(originalFrom: Range[] | Range | null): void;\n    current(): null | Range[];\n    wipe(): void;\n    replace(givenRanges: Range[]): void;\n    last(): Range | null;\n}\n\nexport { Range, Ranges, defaults, version };","ranges-regex":"import { Ranges } from 'ranges-merge';\n\ndeclare const version: string;\ndeclare function rRegex(regx: RegExp, str: string, replacement?: string | null | undefined): Ranges;\n\nexport { rRegex, version };","ranges-sort":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\ndeclare const version: string;\ndeclare type ProgressFn = (percentageDone: number) => void;\ninterface Opts {\n    strictlyTwoElementsInRangeArrays: boolean;\n    progressFn: undefined | null | ProgressFn;\n}\ndeclare const defaults: Opts;\ndeclare function rSort(arrOfRanges: Ranges, originalOptions?: Partial<Opts>): Ranges;\n\nexport { Range, Ranges, defaults, rSort, version };","regex-empty-conditional-comments":"declare const version: string;\ndeclare function emptyCondCommentRegex(): RegExp;\n\nexport { emptyCondCommentRegex, version };","regex-is-jinja-nunjucks":"declare const version: string;\ndeclare function isJinjaNunjucksRegex(): RegExp;\n\nexport { isJinjaNunjucksRegex, version };","regex-is-jsp":"declare const version: string;\ndeclare function isJSP(): RegExp;\n\nexport { isJSP, version };","regex-jinja-specific":"declare const version: string;\ndeclare function isJinjaSpecific(): RegExp;\n\nexport { isJinjaSpecific, version };","str-indexes-of-plus":"declare const version: string;\ndeclare function strIndexesOfPlus(str: string, searchValue: string, fromIndex?: string | number): number[];\n\nexport { strIndexesOfPlus, version };","string-apostrophes":"import { Ranges } from 'ranges-apply';\n\ndeclare const version: string;\ninterface Inputs {\n    from: number;\n    to?: number;\n    value?: string;\n    convertEntities?: boolean;\n    convertApostrophes?: boolean;\n    offsetBy?: (amount: number) => void;\n}\ndeclare function convertOne(str: string, { from, to, value, convertEntities, convertApostrophes, offsetBy, }: Inputs): Ranges;\n/**\n * Typographically-correct the apostrophes and single/double quotes\n */\ndeclare function convertAll(str: string, opts?: Inputs): {\n    result: string;\n    ranges: Ranges;\n};\n\nexport { convertAll, convertOne, version };","string-character-is-astral-surrogate":"declare function isHighSurrogate(something: string | undefined): boolean;\ndeclare function isLowSurrogate(something: string | undefined): boolean;\n\nexport { isHighSurrogate, isLowSurrogate };","string-collapse-leading-whitespace":"declare const version: string;\ndeclare function collWhitespace(str: string, originallineBreakLimit?: number): string;\n\nexport { collWhitespace, version };","string-collapse-white-space":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Extras {\n    whiteSpaceStartsAt: null | number;\n    whiteSpaceEndsAt: null | number;\n    str: string;\n}\ninterface CbObj extends Extras {\n    suggested: Range;\n}\ndeclare type Callback = (cbObj: CbObj) => any;\ninterface Opts {\n    trimStart: boolean;\n    trimEnd: boolean;\n    trimLines: boolean;\n    trimnbsp: boolean;\n    removeEmptyLines: boolean;\n    limitConsecutiveEmptyLinesTo: number;\n    enforceSpacesOnly: boolean;\n    cb: Callback;\n}\ndeclare const defaults: Opts;\ninterface Res {\n    result: string;\n    ranges: Ranges;\n}\ndeclare const cbSchema: string[];\ndeclare function collapse(str: string, originalOpts?: Partial<Opts>): Res;\n\nexport { cbSchema, collapse, defaults, version };","string-convert-indexes":"declare const version: string;\ndeclare function nativeToUnicode(str: string, indexes: any): number | string;\ndeclare function unicodeToNative(str: string, indexes: any): number | string;\n\nexport { nativeToUnicode, unicodeToNative, version };","string-extract-class-names":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Result {\n    res: string[];\n    ranges: Ranges;\n}\n/**\n * Extracts CSS class/id names from a string\n */\ndeclare function extract(str: string): Result;\n\nexport { extract, version };","string-extract-sass-vars":"declare const version: string;\ninterface UnknownValueObj {\n    [key: string]: any;\n}\ninterface Opts {\n    throwIfEmpty?: boolean;\n    cb?: null | ((varValue: string) => any);\n}\ndeclare const defaults: Opts;\ndeclare function extractVars(str: string, originalOpts?: Partial<Opts>): UnknownValueObj;\n\nexport { defaults, extractVars, version };","string-find-heads-tails":"declare const version: string;\ninterface Opts {\n    fromIndex?: number;\n    throwWhenSomethingWrongIsDetected?: boolean;\n    allowWholeValueToBeOnlyHeadsOrTails?: boolean;\n    source?: string;\n    matchHeadsAndTailsStrictlyInPairsByTheirOrder?: boolean;\n    relaxedAPI?: boolean;\n}\ndeclare const defaults: {\n    fromIndex: number;\n    throwWhenSomethingWrongIsDetected: boolean;\n    allowWholeValueToBeOnlyHeadsOrTails: boolean;\n    source: string;\n    matchHeadsAndTailsStrictlyInPairsByTheirOrder: boolean;\n    relaxedAPI: boolean;\n};\ninterface ResObj {\n    headsStartAt: number;\n    headsEndAt: number;\n    tailsStartAt: number;\n    tailsEndAt: number;\n}\ndeclare function strFindHeadsTails(str: string, heads: string | string[], tails: string | string[], originalOpts?: Opts): ResObj[];\n\nexport { defaults, strFindHeadsTails, version };","string-find-malformed":"declare const version: string;\ninterface Opts {\n    stringOffset?: number;\n    maxDistance?: number;\n    ignoreWhitespace?: boolean;\n}\ndeclare const defaults: Opts;\ninterface DataObj {\n    idxFrom: number;\n    idxTo: number;\n}\ndeclare function findMalformed(str: string, refStr: string, cb: (obj: DataObj) => void, originalOpts?: Opts | undefined | null): void;\n\nexport { defaults, findMalformed, version };","string-fix-broken-named-entities":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ndeclare const allRules: string[];\ninterface cbObj {\n    rangeFrom: number;\n    rangeTo: number;\n    rangeValEncoded: string | null;\n    rangeValDecoded: string | null;\n    ruleName: string;\n    entityName: string | null;\n}\ninterface Opts {\n    decode: boolean;\n    cb: null | ((obj: cbObj) => void);\n    entityCatcherCb: null | ((from: number, to: number) => void);\n    textAmpersandCatcherCb: null | ((idx: number) => void);\n    progressFn: null | ((percDone: number) => void);\n}\ndeclare function fixEnt(str: string, originalOpts?: Partial<Opts>): Ranges;\n\nexport { allRules, fixEnt, version };","string-left-right":"declare const version: string;\ndeclare function right(str: string, idx?: number | null): number | null;\ndeclare function rightStopAtNewLines(str: string, idx: number): number | null;\ndeclare function rightStopAtRawNbsp(str: string, idx: number): number | null;\ndeclare function left(str: string, idx?: number | null): number | null;\ndeclare function leftStopAtNewLines(str: string, idx: number): number | null;\ndeclare function leftStopAtRawNbsp(str: string, idx: number): number | null;\ninterface SeqOutput {\n    gaps: [number, number][];\n    leftmostChar: number;\n    rightmostChar: number;\n}\ndeclare function leftSeq(str: string, idx: number, ...args: any[]): SeqOutput | null;\ndeclare function rightSeq(str: string, idx: number, ...args: any[]): SeqOutput | null;\ndeclare function chompLeft(str: string, idx: number, ...args: any[]): number | null;\ndeclare function chompRight(str: string, idx: number, ...args: any[]): number | null;\n\nexport { chompLeft, chompRight, left, leftSeq, leftStopAtNewLines, leftStopAtRawNbsp, right, rightSeq, rightStopAtNewLines, rightStopAtRawNbsp, version };","string-match-left-right":"interface Opts {\n    cb: undefined | null | ((wholeCharacterOutside?: string | undefined, theRemainderOfTheString?: string, firstCharOutsideIndex?: number) => string | boolean);\n    i: boolean;\n    trimBeforeMatching: boolean;\n    trimCharsBeforeMatching: string | string[];\n    maxMismatches: number;\n    firstMustMatch: boolean;\n    lastMustMatch: boolean;\n    hungry: boolean;\n}\ndeclare function matchLeftIncl(str: string, position: number, whatToMatch: (() => string) | string | string[], opts?: Partial<Opts>): boolean | string;\ndeclare function matchLeft(str: string, position: number, whatToMatch: (() => string) | string | string[], opts?: Partial<Opts>): boolean | string;\ndeclare function matchRightIncl(str: string, position: number, whatToMatch: (() => string) | string | string[], opts?: Partial<Opts>): boolean | string;\ndeclare function matchRight(str: string, position: number, whatToMatch: (() => string) | string | string[], opts?: Partial<Opts>): boolean | string;\n\nexport { matchLeft, matchLeftIncl, matchRight, matchRightIncl };","string-overlap-one-on-another":"declare const version: string;\ninterface Opts {\n    offset: number;\n    offsetFillerCharacter: string;\n}\ndeclare function overlap(str1: string, str2: string, originalOpts?: Partial<Opts>): string;\n\nexport { overlap, version };","string-process-comma-separated":"declare const version: string;\ndeclare type ErrCb = (indexes: [from: number, to: number][], explanation: string, isFixable: boolean) => void;\ninterface Opts {\n    from: number;\n    to: number;\n    offset: number;\n    leadingWhitespaceOK: boolean;\n    trailingWhitespaceOK: boolean;\n    oneSpaceAfterCommaOK: boolean;\n    innerWhitespaceAllowed: boolean;\n    separator: string;\n    cb: null | ((from: number, to: number) => void);\n    errCb: null | ErrCb;\n}\ndeclare function processCommaSep(str: string, originalOpts?: Partial<Opts>): void;\n\nexport { processCommaSep, version };","string-range-expander":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\n\ndeclare const version: string;\ninterface Opts {\n    str: string;\n    from: number;\n    to: number;\n    ifLeftSideIncludesThisThenCropTightly: string;\n    ifLeftSideIncludesThisCropItToo: string;\n    ifRightSideIncludesThisThenCropTightly: string;\n    ifRightSideIncludesThisCropItToo: string;\n    extendToOneSide: false | \"left\" | \"right\";\n    wipeAllWhitespaceOnLeft: boolean;\n    wipeAllWhitespaceOnRight: boolean;\n    addSingleSpaceToPreventAccidentalConcatenation: boolean;\n}\ndeclare const defaults: Opts;\ndeclare function expander(originalOpts: Partial<Opts>): Range;\n\nexport { defaults, expander, version };","string-remove-duplicate-heads-tails":"declare const version: string;\ninterface Opts {\n    heads: string[];\n    tails: string[];\n}\ninterface LenientOpts {\n    heads: string | string[];\n    tails: string | string[];\n}\ndeclare const defaults: Opts;\ndeclare function remDup(str: string, originalOpts?: LenientOpts): string;\n\nexport { defaults, remDup, version };","string-remove-thousand-separators":"declare const version: string;\ninterface Opts {\n    removeThousandSeparatorsFromNumbers: boolean;\n    padSingleDecimalPlaceNumbers: boolean;\n    forceUKStyle: boolean;\n}\ndeclare function remSep(str: string, originalOpts?: Partial<Opts>): string;\n\nexport { remSep, version };","string-remove-widows":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface HeadsAndTailsObj {\n    heads: string | string[];\n    tails: string | string[];\n}\ninterface Opts {\n    removeWidowPreventionMeasures: boolean;\n    convertEntities: boolean;\n    targetLanguage: \"html\" | \"css\" | \"js\";\n    UKPostcodes: boolean;\n    hyphens: boolean;\n    minWordCount: number;\n    minCharCount: number;\n    ignore: HeadsAndTailsObj[] | string | string[];\n    reportProgressFunc: null | ((percDone: number) => void);\n    reportProgressFuncFrom: number;\n    reportProgressFuncTo: number;\n    tagRanges: Range[] | null;\n}\ndeclare const defaults: Opts;\ninterface Res {\n    res: string;\n    ranges: Ranges;\n    log: {\n        timeTakenInMilliseconds: number;\n    };\n    whatWasDone: {\n        removeWidows: boolean;\n        convertEntities: boolean;\n    };\n}\ndeclare function removeWidows(str: string, originalOpts?: Partial<Opts>): Res;\n\nexport { defaults, removeWidows, version };","string-split-by-whitespace":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\n\ndeclare const version: string;\ninterface Opts {\n    ignoreRanges: Range[];\n}\ndeclare function splitByW(str: string, originalOpts?: Partial<Opts>): string[];\n\nexport { splitByW, version };","string-strip-html":"import { Ranges as Ranges$1 } from 'ranges-push';\n\ndeclare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Tag {\n    attributes: string[];\n    lastClosingBracketAt: number;\n    lastOpeningBracketAt: number;\n    slashPresent: number;\n    leftOuterWhitespace: number;\n    onlyPlausible: boolean;\n    nameStarts: number;\n    nameContainsLetters: boolean;\n    nameEnds: number;\n    name: string;\n}\ninterface CbObj {\n    tag: Tag;\n    deleteFrom: null | number;\n    deleteTo: null | number;\n    insert: null | string;\n    rangesArr: Ranges$1;\n    proposedReturn: Range | null;\n}\ninterface Opts {\n    ignoreTags: string[];\n    ignoreTagsWithTheirContents: string[];\n    onlyStripTags: string[];\n    stripTogetherWithTheirContents: string[];\n    skipHtmlDecoding: boolean;\n    trimOnlySpaces: boolean;\n    stripRecognisedHTMLOnly: boolean;\n    dumpLinkHrefsNearby: {\n        enabled: boolean;\n        putOnNewLine: boolean;\n        wrapHeads: string;\n        wrapTails: string;\n    };\n    cb: null | ((cbObj: CbObj) => void);\n}\ndeclare const defaults: {\n    ignoreTags: never[];\n    ignoreTagsWithTheirContents: never[];\n    onlyStripTags: never[];\n    stripTogetherWithTheirContents: string[];\n    skipHtmlDecoding: boolean;\n    trimOnlySpaces: boolean;\n    stripRecognisedHTMLOnly: boolean;\n    dumpLinkHrefsNearby: {\n        enabled: boolean;\n        putOnNewLine: boolean;\n        wrapHeads: string;\n        wrapTails: string;\n    };\n    cb: null;\n};\ninterface Res {\n    log: {\n        timeTakenInMilliseconds: number;\n    };\n    result: string;\n    ranges: Ranges;\n    allTagLocations: [number, number][];\n    filteredTagLocations: [number, number][];\n}\n/**\n * Strips HTML tags from strings. No parser, accepts mixed sources.\n */\ndeclare function stripHtml(str: string, originalOpts?: Partial<Opts>): Res;\n\nexport { CbObj, defaults, stripHtml, version };","string-trim-spaces-only":"declare type Range = [from: number, to: number] | [from: number, to: number, whatToInsert: string | null | undefined];\ndeclare type Ranges = Range[] | null;\n\ndeclare const version: string;\ninterface Opts {\n    classicTrim: boolean;\n    cr: boolean;\n    lf: boolean;\n    tab: boolean;\n    space: boolean;\n    nbsp: boolean;\n}\ndeclare const defaults: Opts;\ninterface Res {\n    res: string;\n    ranges: Ranges;\n}\ndeclare function trimSpaces(str: string, originalOpts?: Partial<Opts>): Res;\n\nexport { defaults, trimSpaces, version };","string-uglify":"declare const version: string;\ndeclare function uglifyArr(arr: string[]): string[];\ndeclare function uglifyById(refArr: string[], idNum: number): string;\n\nexport { uglifyArr, uglifyById, version };","string-unfancy":"declare const version: string;\ndeclare function unfancy(str: string): string;\n\nexport { unfancy, version };","stristri":"interface Opts {\n    html: boolean;\n    css: boolean;\n    text: boolean;\n    templatingTags: boolean;\n    js: boolean;\n    reportProgressFunc: null | ((percDone: number) => void);\n    reportProgressFuncFrom: number;\n    reportProgressFuncTo: number;\n}\ninterface Res {\n    log: {\n        timeTakenInMilliseconds: number;\n    };\n    result: string;\n    applicableOpts: {\n        html: boolean;\n        css: boolean;\n        text: boolean;\n        templatingTags: boolean;\n        js: boolean;\n    };\n    templatingLang: {\n        name: null | string;\n    };\n}\ndeclare const defaultOpts: Opts;\n\ndeclare const version: string;\n/**\n * Extracts or deletes HTML, CSS, text and/or templating tags from string\n */\ndeclare function stri(input: string, originalOpts?: Partial<Opts>): Res;\n\nexport { defaultOpts as defaults, stri, version };","tap-parse-string-to-object":"declare const version: string;\ninterface Res {\n    ok: boolean;\n    assertsTotal: number;\n    assertsPassed: number;\n    assertsFailed: number;\n    suitesTotal: number;\n    suitesPassed: number;\n    suitesFailed: number;\n}\ninterface StreamInterface extends NodeJS.ReadWriteStream {\n    read(size?: number): any;\n}\ndeclare function parseTap(something: string | StreamInterface): Res | Promise<Res>;\n\nexport { parseTap, version };","test-mixer":"declare const version: string;\ndeclare type PlainObject = {\n    [name: string]: any;\n};\ndeclare type PlainObjectOfBool = {\n    [name: string]: boolean;\n};\ndeclare function mixer(ref?: PlainObject, defaultsObj?: PlainObject): PlainObjectOfBool[];\n\nexport { mixer, version };","util-array-object-or-both":"interface Opts {\n    msg?: string;\n    optsVarName?: string;\n}\ndeclare function arrObjOrBoth(str: string, originalOpts?: Opts): \"array\" | \"object\" | \"any\";\n\nexport { arrObjOrBoth };","util-nonempty":"declare const version: string;\ndeclare function nonEmpty(input: any): boolean;\n\nexport { nonEmpty, version };"};
