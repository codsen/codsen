export const examples = {"all-named-html-entities":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  allNamedEntities,\n  allNamedEntitiesSetOnly,\n  allNamedEntitiesSetOnlyCaseInsensitive,\n  entStartsWith,\n  entEndsWith,\n  entStartsWithCaseInsensitive,\n  entEndsWithCaseInsensitive,\n  brokenNamedEntities,\n  decode,\n  minLength,\n  maxLength,\n  uncertain,\n} from \"all-named-html-entities\";\n\nassert.equal(Object.keys(allNamedEntities).length, 2125);\nassert.equal(entStartsWith.A.E[0], \"AElig\");"},"allNamedEntities.js":{"title":"`allNamedEntities`","code":"import { strict as assert } from \"assert\";\n\nimport { allNamedEntities } from \"all-named-html-entities\";\n\n// total named entities count:\nassert.equal(Object.keys(allNamedEntities).length, 2125);\n\n// show the first-one:\nassert.equal(Object.keys(allNamedEntities).sort()[0], \"AElig\");\n\n// &AElig; decoded:\nassert.equal(allNamedEntities.AElig, \"Æ\");"},"entEndsWith.js":{"title":"`entEndsWith`","code":"import { strict as assert } from \"assert\";\n\nimport { entEndsWith } from \"all-named-html-entities\";\n\n// here's list of named HTML entities which end with character \"2\":\nassert.deepEqual(entEndsWith[\"2\"], {\n  1: [\"blk12\", \"frac12\"],\n  p: [\"sup2\"],\n});\n\n// query directly\nassert.equal(entEndsWith[\"2\"].p[0], \"sup2\");"},"entStartsWith.js":{"title":"`entStartsWith`","code":"import { strict as assert } from \"assert\";\n\nimport { entStartsWith } from \"all-named-html-entities\";\n\n// for perf reasons, they're pre-grouped by first two letters\nassert.deepEqual(entStartsWith.A, {\n  a: [\"Aacute\"],\n  b: [\"Abreve\"],\n  c: [\"Acirc\", \"Acy\"],\n  E: [\"AElig\"],\n  f: [\"Afr\"],\n  g: [\"Agrave\"],\n  l: [\"Alpha\"],\n  m: [\"Amacr\"],\n  M: [\"AMP\"],\n  n: [\"And\"],\n  o: [\"Aogon\", \"Aopf\"],\n  p: [\"ApplyFunction\"],\n  r: [\"Aring\"],\n  s: [\"Ascr\", \"Assign\"],\n  t: [\"Atilde\"],\n  u: [\"Auml\"],\n});\n\n// query directly\nassert.equal(entStartsWith.A.E[0], \"AElig\");"},"entStartsWithCaseInsensitive.js":{"title":"`entStartsWithCaseInsensitive`","code":"import { strict as assert } from \"assert\";\n\nimport { entStartsWithCaseInsensitive } from \"all-named-html-entities\";\n\n// case-insensitive \"entStartsWithCaseInsensitive\" is useful\n// when looking for possibly mis-typed entities; emlint uses it\n\n// which entities, lowercased, start with \"j\"?\nassert.deepEqual(entStartsWithCaseInsensitive.j, {\n  c: [\"jcirc\", \"jcy\"],\n  f: [\"jfr\"],\n  m: [\"jmath\"],\n  o: [\"jopf\"],\n  s: [\"jscr\", \"jsercy\"],\n  u: [\"jukcy\"],\n});"}},"array-group-str-omit-num-char":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { groupStr } from \"array-group-str-omit-num-char\";\n\nassert.deepEqual(groupStr([\"a1-1\", \"a2-2\", \"b3-3\", \"c4-4\"]), {\n  \"a*-*\": 2,\n  \"b3-3\": 1,\n  \"c4-4\": 1,\n});"}},"array-includes-with-glob":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { includesWithGlob } from \"array-includes-with-glob\";\n\nassert.equal(includesWithGlob([\"xc\", \"yc\", \"zc\"], \"*c\"), true);\n// (all 3)\n\nassert.equal(includesWithGlob([\"xc\", \"yc\", \"zc\"], \"*a\"), false);\n// (none found)\n\nassert.equal(includesWithGlob([\"something\", \"anything\", \"zzz\"], \"some*\"), true);\n// (1 hit)"},"arrayVsArrayAllMustBeFound.js":{"title":"`opts.arrayVsArrayAllMustBeFound`","code":"import { strict as assert } from \"assert\";\n\nimport { includesWithGlob } from \"array-includes-with-glob\";\n\nlet source = [\"aaa\", \"bbb\", \"ccc\"];\nlet whatToLookFor = [\"a*\", \"d*\"];\n\n// the default setting for opts.arrayVsArrayAllMustBeFound is \"any\"\nassert.equal(includesWithGlob(source, whatToLookFor), true);\nassert.equal(\n  includesWithGlob(source, whatToLookFor, {\n    arrayVsArrayAllMustBeFound: \"any\",\n  }),\n  true\n);\n// true, because one element, 'a*' was found in source (it was its first element)\n\nassert.equal(\n  includesWithGlob(source, whatToLookFor, {\n    arrayVsArrayAllMustBeFound: \"all\",\n  }),\n  false\n);\n// false, because not all elements were found, the 'd*' is missing"}},"array-of-arrays-into-ast":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { generateAst } from \"array-of-arrays-into-ast\";\n\nassert.deepEqual(generateAst([[1, 2, 3], [1, 2], [5]]), {\n  1: [\n    {\n      2: [\n        {\n          3: [null],\n        },\n        null,\n      ],\n    },\n  ],\n  5: [null],\n});"}},"array-of-arrays-sort-by-col":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { sortByCol } from \"array-of-arrays-sort-by-col\";\n\n// sort by second column, index number 1\nassert.deepEqual(sortByCol([[1, 9, 4], [1], [1, 9, 3], [1, 9, 2]], 1), [\n  [1, 9, 2],\n  [1, 9, 3],\n  [1, 9, 4],\n  [1],\n]);"},"sort-by-column.js":{"title":"Sort by a certain column","code":"import { strict as assert } from \"assert\";\n\nimport { sortByCol } from \"array-of-arrays-sort-by-col\";\n\n// Sort by a second element (column index === 1):\nassert.deepEqual(sortByCol([[1, 9, 0], [1], [1, 8, 2], [1, 7, 5]], 1), [\n  [1, 7, 5],\n  [1, 8, 2],\n  [1, 9, 0],\n  [1],\n]);\n// notice 7-8-9"}},"array-pull-all-with-glob":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { pull } from \"array-pull-all-with-glob\";\n\nassert.deepEqual(\n  pull(\n    [\"keep_me\", \"name-1\", \"name-2\", \"name-jhkgdhgkhdfghdkghfdk\"],\n    [\"name-*\"]\n  ),\n  [\"keep_me\"]\n);"}},"arrayiffy-if-string":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { arrayiffy } from \"arrayiffy-if-string\";\n\nassert.deepEqual(arrayiffy(\"aaa\"), [\"aaa\"]);\n\nassert.deepEqual(arrayiffy(\"\"), []);\n\nassert.equal(arrayiffy(true), true);\n\nassert.equal(arrayiffy(), undefined);"}},"ast-compare":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { compare } from \"ast-compare\";\n\n// Find out, does an object/array/string/nested-mix is a subset or equal to another input:\nassert.equal(\n  compare(\n    {\n      a: {\n        b: \"d\",\n        c: [],\n        e: \"f\",\n        g: \"h\",\n      },\n    },\n    {\n      a: {\n        b: \"d\",\n        c: [],\n      },\n    }\n  ),\n  true\n);"},"compare-arrays.js":{"title":"Compare Arrays","code":"import { strict as assert } from \"assert\";\n\nimport { compare } from \"ast-compare\";\n\nassert.equal(compare([\"a\", \"b\", \"c\"], [\"a\", \"b\"]), true);\n// true, because second is a subset of first\n\nassert.equal(compare([\"a\", \"b\", \"c\"], [\"b\", \"a\"]), false);\n// => false, because order is wrong\n\nassert.equal(compare([\"a\", \"b\"], [\"a\", \"b\", \"c\"]), false);\n// => false, because second is not a subset of first (it's opposite)\n\nassert.equal(\n  compare([{ a: \"b\" }, { c: \"d\" }, { e: \"f\" }], [{ a: \"b\" }, { c: \"d\" }]),\n  true\n);\n// => plain objects nested in arrays"},"compare-objects.js":{"title":"Compare Plain Objects","code":"import { strict as assert } from \"assert\";\n\nimport { compare } from \"ast-compare\";\n\n// Find out, does an object/array/string/nested-mix is a subset or equal to another input:\nassert.equal(compare({ a: \"1\", b: \"2\", c: \"3\" }, { a: \"1\", b: \"2\" }), true);\n// true, because second (smallObj) is subset of (or equal) first (bigObj).\n\nassert.equal(compare({ a: \"1\", b: \"2\" }, { a: \"1\", b: \"2\", c: \"3\" }), false);\n// => false, because second (smallObj) is not a subset (or equal) to first (bigObj)."},"compare-strings.js":{"title":"Compare Strings","code":"import { strict as assert } from \"assert\";\n\nimport { compare } from \"ast-compare\";\n\nassert.equal(compare(\"a\\nb\", \"a\\nb\"), true);\n\nassert.equal(compare(\"a\", \"b\"), false);"},"opts-hungryForWhitespace.js":{"title":"`opts.hungryForWhitespace`","code":"import { strict as assert } from \"assert\";\n\nimport { compare } from \"ast-compare\";\n\n// by default, key values will be strictly matched using `===`\nassert.equal(\n  compare(\n    { a: \"\\n\\n\\n\", b: \"\\t\\t\\t\", c: \"whatever\" },\n    { a: \"\\r\\r\\r\", b: \"       \" },\n    {\n      hungryForWhitespace: false,\n    }\n  ),\n  false\n);\n\n// whitespace is matched leniently with the following option:\nassert.equal(\n  compare(\n    { a: \"\\n\\n\\n\", b: \"\\t\\t\\t\", c: \"whatever\" },\n    { a: \"\\r\\r\\r\", b: \"       \" },\n    {\n      hungryForWhitespace: true,\n    }\n  ),\n  true\n);\n\n// the fun doesn't stop here, any \"empty\" structures will be\n// reported as matching:\nassert.equal(\n  compare(\n    { a: { z: \"\\n\\n\\n\" }, b: [\"\\t\\t\\t\"], c: \"whatever\" },\n    { a: [[[[[\"\\r\\r\\r\"]]]]], b: { c: { d: \" \" } } },\n    {\n      hungryForWhitespace: true, // <--- !\n    }\n  ),\n  true // <--- !!!\n);\n// \"empty\" thing is:\n//   - string that trims to zero-length\n//   - array with zero or more whitespace strings only\n//   - plain object with zero or more keys with \"empty\" values\n//     (empty arrays, empty plain objects or empty strings)"},"opts-useWildcards.js":{"title":"`opts.useWildcards`","code":"import { strict as assert } from \"assert\";\n\nimport { compare } from \"ast-compare\";\n\n// by default, key values are matches as strings\nassert.equal(\n  compare(\n    { a: \"1\", b: \"2a\", c: \"3\" },\n    { a: \"1\", b: \"2*\" },\n    { useWildcards: false }\n  ),\n  false\n);\n\n// once enabled, strings are matched via https://www.npmjs.com/package/matcher\n// where \"*\" means any sequence of characters\nassert.equal(\n  compare(\n    { a: \"1\", b: \"2a\", c: \"3\" },\n    { a: \"1\", b: \"2*\" },\n    { useWildcards: true }\n  ),\n  true\n);"},"opts-verboseWhenMismatches.js":{"title":"`opts.verboseWhenMismatches`","code":"import { strict as assert } from \"assert\";\n\nimport { compare } from \"ast-compare\";\n\n// by default, returns a boolean without explanation\nassert.equal(\n  compare(\n    { a: \"1\", b: \"2\" },\n    { a: \"1\", b: \"2\", c: \"3\" },\n    {\n      verboseWhenMismatches: false, // <---\n    }\n  ),\n  false\n);\n\nassert.equal(\n  compare(\n    { a: \"1\", b: \"2\" },\n    { a: \"1\", b: \"2\", c: \"3\" },\n    {\n      verboseWhenMismatches: true, // <---\n    }\n  ),\n  'The given object has key \"c\" which the other-one does not have.'\n);\n\n// when opts.verboseWhenMismatches is enabled, a negative result is\n// string (explanation). A positive result is boolean \"true\".\nassert.equal(\n  compare(\n    { a: \"1\", b: \"2\" },\n    { a: \"1\", b: \"2\" },\n    {\n      verboseWhenMismatches: true, // <---\n    }\n  ),\n  true\n);"}},"ast-contains-only-empty-space":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { empty } from \"ast-contains-only-empty-space\";\n\nassert.equal(\n  empty({\n    a: [\n      {\n        x: {\n          y: [\n            {\n              z: [\"\\n\"],\n            },\n          ],\n        },\n      },\n    ],\n    b: [\"\\t\\t\\t  \"],\n    c: [\"\\n \\n\\n\"],\n    d: [\"\\t   \"],\n  }),\n  true\n);"},"various.js":{"title":"Various","code":"import { strict as assert } from \"assert\";\n\nimport { empty } from \"ast-contains-only-empty-space\";\n\nassert.equal(empty([{ content: {} }]), true);\n\nassert.equal(empty([{ tag: \"style\" }]), false);\n\n// Works on simple arrays as well:\nassert.equal(empty([\"   \", \" \"]), true);\n\n// Works on strings as well:\nassert.equal(empty(\"   \"), true);\n\n// Object keys that have values as null are considered empty:\nassert.equal(empty({ a: null }), true);"}},"ast-deep-contains":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { deepContains } from \"ast-deep-contains\";\n\nconst gathered = [];\nconst errors = [];\n\nconst reference = [\n  { c: \"2\" }, // will end up not used\n  { a: \"1\", b: \"2\", c: \"3\" },\n  { x: \"8\", y: \"9\", z: \"0\" },\n];\n\nconst structureToMatch = [\n  { a: \"1\", b: \"2\", c: \"3\" }, // matches but has different position in the source\n  { x: \"8\", y: \"9\" }, // \"z\" missing\n];\n\n// This program pre-matches first, then matches objects as a set-subset\ndeepContains(\n  reference,\n  structureToMatch,\n  (leftSideVal, rightSideVal) => {\n    // This callback does the pre-matching and picks the key pairs for you.\n    // It's up to you what you will do with left- and right-side\n    // values - we normally feed them to unit test asserts but here we just push\n    // to array:\n    gathered.push([leftSideVal, rightSideVal]);\n  },\n  (err) => {\n    errors.push(err);\n  }\n);\n\n// imagine instead of pushing pairs into array, you fed them into assert\n// function in unit tests:\nassert.deepEqual(gathered, [\n  [\"1\", \"1\"],\n  [\"2\", \"2\"],\n  [\"3\", \"3\"],\n  [\"8\", \"8\"],\n  [\"9\", \"9\"],\n]);\nassert.equal(errors.length, 0);"}},"ast-delete-object":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { deleteObj } from \"ast-delete-object\";\n\n// if all keys in source object match target object's keys, the\n// source object gets deleted:\nassert.deepEqual(\n  deleteObj(\n    [\n      \"elem1\",\n      {\n        findme1: \"zzz\",\n        findme2: \"yyy\",\n        somethingelse: \"qqq\",\n      },\n      \"elem2\",\n    ],\n    {\n      findme1: \"zzz\",\n      findme2: \"yyy\",\n    }\n  ),\n  [\"elem1\", \"elem2\"]\n);"},"opts-hungryForWhitespace.js":{"title":"`opts.hungryForWhitespace`","code":"import { strict as assert } from \"assert\";\n\nimport { deleteObj } from \"ast-delete-object\";\n\nassert.deepEqual(\n  deleteObj(\n    [\n      { a: \"\\n\" }, // that's empty\n      {\n        key3: \"val3\",\n        key4: \"val4\",\n      },\n      { b: \"   \" }, // that's empty\n      { c: \"\" }, // that's empty\n    ],\n    {}, // empty thing to match again - we match \"empty\" vs \"empty\"\n    { matchKeysStrictly: false, hungryForWhitespace: true }\n  ),\n  [\n    {\n      key3: \"val3\",\n      key4: \"val4\",\n    },\n  ]\n);\n\n// but\nassert.deepEqual(\n  deleteObj(\n    [\n      { a: \"\\n\" }, // that's empty\n      {\n        key3: \"val3\",\n        key4: \"val4\",\n      },\n      { b: \"   \" }, // that's empty\n      { c: \"\" }, // that's empty\n    ],\n    {}, // empty thing to match again - we match \"empty\" vs \"empty\"\n    { matchKeysStrictly: false, hungryForWhitespace: false }\n  ),\n  [\n    { a: \"\\n\" },\n    {\n      key3: \"val3\",\n      key4: \"val4\",\n    },\n    { b: \"   \" },\n    { c: \"\" },\n  ]\n);\n// nothing happened because empty things were matched strictly, \"===\""},"opts-matchKeysStrictly.js":{"title":"`opts.matchKeysStrictly`","code":"import { strict as assert } from \"assert\";\n\nimport { deleteObj } from \"ast-delete-object\";\n\nconst source = [\n  \"elem1\",\n  {\n    findme1: \"zzz\",\n    findme2: \"yyy\",\n    somethingelse: \"qqq\", // <--- this key will block deletion\n  },\n  \"elem2\",\n];\n\n// nothing happens - matching was strict\nassert.deepEqual(\n  deleteObj(\n    source,\n    {\n      findme1: \"zzz\",\n      findme2: \"yyy\",\n    },\n    {\n      matchKeysStrictly: true, // <--- strict matching\n    }\n  ),\n  source\n);\n\n// but\nassert.deepEqual(\n  deleteObj(\n    source,\n    {\n      findme1: \"zzz\",\n      findme2: \"yyy\",\n    },\n    {\n      matchKeysStrictly: false,\n    }\n  ),\n  [\"elem1\", \"elem2\"]\n);"}},"ast-get-object":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { getObj } from \"ast-get-object\";\n\n// get - two input arguments\nassert.deepEqual(\n  getObj(\n    [\n      // <- search in this, the first argument, in this case, a nested array\n      {\n        tag: \"meta\",\n        content: \"UTF-8\",\n        something: \"else\",\n      },\n      {\n        tag: \"title\",\n        attrs: \"Text of the title\",\n      },\n    ],\n    {\n      // <- search for this object, the second argument\n      tag: \"meta\",\n    }\n  ),\n  [\n    {\n      tag: \"meta\",\n      content: \"UTF-8\",\n      something: \"else\",\n    },\n  ]\n);\n\n// set - three input arguments\nassert.deepEqual(\n  getObj(\n    [\n      {\n        tag: [\"two\", \"values\"],\n        content: \"UTF-8\",\n        something: \"else\",\n      },\n      {\n        tag: \"title\",\n        attrs: \"Text of the title\",\n      },\n    ],\n    {\n      tag: [\"two\", \"values\"],\n    },\n    [\n      {\n        tag: [\"three\", \"values\", \"here\"],\n        content: \"UTF-8\",\n        something: \"else\",\n      },\n    ]\n  ),\n  [\n    {\n      tag: [\"three\", \"values\", \"here\"], // <--- got updated\n      content: \"UTF-8\",\n      something: \"else\",\n    },\n    {\n      tag: \"title\",\n      attrs: \"Text of the title\",\n    },\n  ]\n);"}},"ast-get-values-by-key":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { getByKey } from \"ast-get-values-by-key\";\n\n// GETTER\n// ======\n\n// returns \"object-path\" notation paths where arrays use dots:\nassert.deepEqual(\n  getByKey(\n    {\n      parsed: [\n        {\n          tag: \"html\",\n        },\n      ],\n    },\n    \"tag\" // value to search for\n  ),\n  [{ val: \"html\", path: \"parsed.0.tag\" }]\n);\n\n// SETTER\n// ======\n\nassert.deepEqual(\n  getByKey(\n    {\n      parsed: [\n        {\n          tag: \"html\",\n        },\n      ],\n      foo: {\n        tag: null,\n      },\n      bar: {\n        tag: null,\n      },\n    },\n    \"tag\", // value to search for\n    [123, 456] // pot of values to pick from (one result not enough)\n  ),\n  {\n    parsed: [\n      {\n        tag: 123,\n      },\n    ],\n    foo: {\n      tag: 456,\n    },\n    bar: {\n      tag: null, // value pot was depleted and there was nothing left to put here\n    },\n  }\n);"},"real-use.js":{"title":"Replace all null's in keys `amount` with zero, but only under `orders`","code":"import { strict as assert } from \"assert\";\n\nimport { getByKey } from \"ast-get-values-by-key\";\n\nconst source = {\n  orders: [\n    {\n      date: \"2020-09-26\",\n      amount: null, // replace\n      product: \"Bramble\",\n    },\n    {\n      date: \"2020-09-26\",\n      amount: 2,\n      product: \"Croodle\",\n    },\n    {\n      date: \"2020-09-26\",\n      amount: null, // replace\n      product: \"Zapple\",\n    },\n  ],\n};\n\n// first GET\nconst findings = getByKey(\n  source, // what to process\n  \"amount\" // what to look for\n);\nassert.deepEqual(findings, [\n  { val: null, path: \"orders.0.amount\" },\n  { val: 2, path: \"orders.1.amount\" },\n  { val: null, path: \"orders.2.amount\" },\n]);\n\n// prepare replacement array for SET third input argument\nconst replacement = findings.map(({ val }) => +val);\nassert.deepEqual(replacement, [0, 2, 0]);\n\n// then SET\nconst result = getByKey(\n  source, // what to process\n  \"amount\", // what to look for\n  replacement // pot of replacement values to consume (single-use, FIFO stack)\n);\nassert.deepEqual(result, {\n  orders: [\n    {\n      date: \"2020-09-26\",\n      amount: 0, // replace\n      product: \"Bramble\",\n    },\n    {\n      date: \"2020-09-26\",\n      amount: 2,\n      product: \"Croodle\",\n    },\n    {\n      date: \"2020-09-26\",\n      amount: 0, // replace\n      product: \"Zapple\",\n    },\n  ],\n});"},"wildcards.js":{"title":"Using wildcards (`matcher` api)","code":"import { strict as assert } from \"assert\";\n\nimport { getByKey } from \"ast-get-values-by-key\";\n\nconst source = {\n  popsicles: 1,\n  tentacles: 0,\n  nested: [\n    {\n      cutticles: \"yes\",\n    },\n  ],\n};\n\n// Two input arguments - getter:\nconst findings = getByKey(source, [\"*cles\"]);\n\nassert.deepEqual(findings, [\n  {\n    val: 1,\n    path: \"popsicles\",\n  },\n  {\n    val: 0,\n    path: \"tentacles\",\n  },\n  {\n    val: \"yes\",\n    path: \"nested.0.cutticles\",\n  },\n]);\n\n// notice the path \"nested.0.cutticles\" is as per object-path notation -\n// it's not \"nested[0].cutticles\" as in \"normal\" JS paths\n\n// Three input arguments - setter:\nassert.deepEqual(getByKey(source, [\"*cles\"], [\"a\", \"b\", \"c\"]), {\n  popsicles: \"a\",\n  tentacles: \"b\",\n  nested: [\n    {\n      cutticles: \"c\",\n    },\n  ],\n});"}},"ast-is-empty":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isEmpty } from \"ast-is-empty\";\n\nassert.equal(\n  isEmpty({\n    a: \"\",\n  }),\n  true\n);\n\nassert.equal(\n  isEmpty({\n    a: [\"\"],\n    b: {\n      c: {\n        d: \"\",\n      },\n    },\n  }),\n  true\n);\n\nassert.equal(\n  isEmpty([\n    {\n      a: [\"\"],\n      b: { c: { d: \"\" } },\n    },\n    \"\",\n    [\"\", \"\", \"\"],\n  ]),\n  true\n);"}},"ast-loose-compare":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { looseCompare } from \"ast-loose-compare\";\n\nassert.equal(\n  looseCompare(\n    {\n      a: {\n        b: \"d\",\n        c: [],\n        e: \"f\",\n        g: \"h\",\n      },\n    },\n    {\n      a: {\n        b: \"d\",\n        c: [],\n      },\n    }\n  ),\n  true\n);"},"more-examples.js":{"title":"More Examples","code":"import { strict as assert } from \"assert\";\n\nimport { looseCompare } from \"ast-loose-compare\";\n\nassert.equal(\n  looseCompare({ a: \"1\", b: \"2\", c: \"3\" }, { a: \"1\", b: \"2\" }),\n  true\n);\n// true, because second (smallObj) is subset of (or equal) first (bigObj).\n\nassert.equal(\n  looseCompare({ a: \"1\", b: \"2\" }, { a: \"1\", b: \"2\", c: \"3\" }),\n  false\n);\n// false, because second (smallObj) is not a subset (or equal) to first (bigObj).\n\nassert.equal(looseCompare([\"a\", \"b\", \"c\"], [\"a\", \"b\"]), true);\n// true, because second is a subset of first\n\nassert.equal(looseCompare([\"a\", \"b\"], [\"a\", \"b\", \"c\"]), false);\n// false, because second is not a subset of first\n\nassert.equal(looseCompare(\"aaaaa\\nbbbbb\", \"aaaaa\\nbbbbb\"), true);\n// true, because strings are equal\n\nassert.equal(looseCompare({ a: \"a\" }), undefined);\n// the second argument is missing"},"whitespace.js":{"title":"Empty Values","code":"import { strict as assert } from \"assert\";\n\nimport { looseCompare } from \"ast-loose-compare\";\n\n// both values are empty - they trim() to zero-length\nassert.equal(\n  looseCompare(\n    {\n      a: \"a\",\n      b: \"\\n \\n\\n\",\n    },\n    {\n      a: \"a\",\n      b: \"\\t\\t \\t\",\n    }\n  ),\n  true\n);"}},"ast-monkey":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { find } from \"ast-monkey\";\n\nassert.deepEqual(\n  find(\n    {\n      a1: {\n        b1: \"c1\",\n      },\n      a2: {\n        b2: \"c2\",\n      },\n      z1: {\n        x1: \"y1\",\n      },\n    },\n    { key: \"a*\" }\n  ),\n  [\n    {\n      index: 1,\n      key: \"a1\",\n      val: {\n        b1: \"c1\",\n      },\n      path: [1],\n    },\n    {\n      index: 3,\n      key: \"a2\",\n      val: {\n        b2: \"c2\",\n      },\n      path: [3],\n    },\n  ]\n);"}},"ast-monkey-traverse":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { traverse } from \"ast-monkey-traverse\";\n\nconst paths = [];\nconst source = {\n  a: {\n    foo: {\n      bar: [\n        {\n          foo: \"c\",\n        },\n      ],\n      d: {\n        e: {\n          foo: \"f\",\n        },\n      },\n    },\n  },\n};\n\ntraverse(source, (key, val, innerObj) => {\n  // if currently an object is traversed, you get both \"key\" and \"val\"\n  // if it's array, only \"key\" is present, \"val\" is undefined\n  let current = val !== undefined ? val : key;\n  if (\n    // it's object (not array)\n    val !== undefined &&\n    // and has the key we need\n    key === \"foo\"\n  ) {\n    // push the path to array in the outer scope\n    paths.push(innerObj.path);\n  }\n  return current;\n});\n\n// notice object-path notation \"a.foo.bar.0.foo\" - array segments use dots too:\nassert.deepEqual(paths, [\"a.foo\", \"a.foo.bar.0.foo\", \"a.foo.d.e.foo\"]);"},"compatible-with-object-path.js":{"title":"Compatible With `object-path`","code":"import { strict as assert } from \"assert\";\nimport op from \"object-path\";\n\nimport { traverse } from \"ast-monkey-traverse\";\n\nconst input = { a: \"1\", b: [{ c: \"2\" }] };\nObject.freeze(input); // let's freeze it, just for fun\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => {\n  let current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n});\n\n// notice the object-path notation is \"b.0.c\" not \"b[0].c\"\nassert.deepEqual(result1, [\"a\", \"b\", \"b.0\", \"b.0.c\"]);\n\n// each reported path is fully compatible with `object-path` get() method\nassert.deepEqual(op.get(input, \"a\"), \"1\");\nassert.deepEqual(op.get(input, \"b\"), [{ c: \"2\" }]);\nassert.deepEqual(op.get(input, \"b.0\"), { c: \"2\" });\nassert.deepEqual(op.get(input, \"b.0.c\"), \"2\");"},"stopping.js":{"title":"Stop","code":"import { strict as assert } from \"assert\";\n\nimport { traverse } from \"ast-monkey-traverse\";\n\nconst input = { a: \"1\", b: { c: \"2\" } };\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => {\n  let current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n});\nassert.deepEqual(result1, [\"a\", \"b\", \"b.c\"]);\n\n// now let's stop the traversal at path \"b\" (that's real\n// path, how object-path would reference it)\nconst result2 = [];\ntraverse(input, (key1, val1, innerObj, stop) => {\n  let current = val1 !== undefined ? val1 : key1;\n  result2.push(innerObj.path);\n  if (innerObj.path === \"b\") {\n    stop.now = true; // <---------------- !!!!!!!!!!\n  }\n  return current;\n});\nassert.deepEqual(result2, [\"a\", \"b\"]);"}},"ast-monkey-traverse-with-lookahead":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { traverse } from \"ast-monkey-traverse-with-lookahead\";\n\nconst input = [\n  {\n    a: \"b\",\n  },\n  {\n    c: \"d\",\n  },\n  {\n    e: \"f\",\n  },\n];\nconst gathered = [];\n\n// callback interface:\ntraverse(\n  input,\n  (key1, val1, innerObj) => {\n    gathered.push([key1, val1, innerObj]);\n  },\n  1 // <---------------- report one upcoming value\n);\n\nassert.deepEqual(gathered, [\n  // ===================\n  [\n    {\n      a: \"b\",\n    },\n    undefined,\n    {\n      depth: 0,\n      path: \"0\",\n      parent: [\n        {\n          a: \"b\",\n        },\n        {\n          c: \"d\",\n        },\n        {\n          e: \"f\",\n        },\n      ],\n      parentType: \"array\",\n      next: [\n        [\n          \"a\",\n          \"b\",\n          {\n            depth: 1,\n            path: \"0.a\",\n            parent: {\n              a: \"b\",\n            },\n            parentType: \"object\",\n          },\n        ],\n      ],\n    },\n  ],\n  // ===================\n  [\n    \"a\",\n    \"b\",\n    {\n      depth: 1,\n      path: \"0.a\",\n      parent: {\n        a: \"b\",\n      },\n      parentType: \"object\",\n      next: [\n        [\n          {\n            c: \"d\",\n          },\n          undefined,\n          {\n            depth: 0,\n            path: \"1\",\n            parent: [\n              {\n                a: \"b\",\n              },\n              {\n                c: \"d\",\n              },\n              {\n                e: \"f\",\n              },\n            ],\n            parentType: \"array\",\n          },\n        ],\n      ],\n    },\n  ],\n  // ===================\n  [\n    {\n      c: \"d\",\n    },\n    undefined,\n    {\n      depth: 0,\n      path: \"1\",\n      parent: [\n        {\n          a: \"b\",\n        },\n        {\n          c: \"d\",\n        },\n        {\n          e: \"f\",\n        },\n      ],\n      parentType: \"array\",\n      next: [\n        [\n          \"c\",\n          \"d\",\n          {\n            depth: 1,\n            path: \"1.c\",\n            parent: {\n              c: \"d\",\n            },\n            parentType: \"object\",\n          },\n        ],\n      ],\n    },\n  ],\n  // ===================\n  [\n    \"c\",\n    \"d\",\n    {\n      depth: 1,\n      path: \"1.c\",\n      parent: {\n        c: \"d\",\n      },\n      parentType: \"object\",\n      next: [\n        [\n          {\n            e: \"f\",\n          },\n          undefined,\n          {\n            depth: 0,\n            path: \"2\",\n            parent: [\n              {\n                a: \"b\",\n              },\n              {\n                c: \"d\",\n              },\n              {\n                e: \"f\",\n              },\n            ],\n            parentType: \"array\",\n          },\n        ],\n      ],\n    },\n  ],\n  // ===================\n  [\n    {\n      e: \"f\",\n    },\n    undefined,\n    {\n      depth: 0,\n      path: \"2\",\n      parent: [\n        {\n          a: \"b\",\n        },\n        {\n          c: \"d\",\n        },\n        {\n          e: \"f\",\n        },\n      ],\n      parentType: \"array\",\n      next: [\n        [\n          \"e\",\n          \"f\",\n          {\n            depth: 1,\n            path: \"2.e\",\n            parent: {\n              e: \"f\",\n            },\n            parentType: \"object\",\n          },\n        ],\n      ],\n    },\n  ],\n  // ===================\n  [\n    \"e\",\n    \"f\",\n    {\n      depth: 1,\n      path: \"2.e\",\n      parent: {\n        e: \"f\",\n      },\n      parentType: \"object\",\n      next: [],\n    },\n  ],\n  // ===================\n]);"}},"ast-monkey-util":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  pathNext,\n  pathPrev,\n  pathUp,\n  parent,\n} from \"ast-monkey-util\";\n\nassert.equal(pathNext(\"9.children.3\"), \"9.children.4\");\n\nassert.equal(pathPrev(\"9.children.33\"), \"9.children.32\");\n\nassert.equal(pathUp(\"9.children.1.children.2\"), \"9.children.1\");\n\nassert.equal(parent(\"9.children.3\"), \"children\");"}},"bitbucket-slug":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { bSlug } from \"bitbucket-slug\";\n\nassert.equal(\n  bSlug(\"# Let's backwards-engineer BitBucket anchor link slug algorithm\"),\n  \"markdown-header-lets-backwards-engineer-bitbucket-anchor-link-slug-algorithm\"\n);"}},"charcode-is-valid-xml-name-character":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  isProduction4,\n  isProduction4a,\n  validFirstChar,\n  validSecondCharOnwards,\n} from \"charcode-is-valid-xml-name-character\";\n\n// Spec: https://www.w3.org/TR/REC-xml/#NT-NameStartChar\n\nassert.equal(isProduction4(\"Z\"), true);\nassert.equal(isProduction4(\"?\"), false);\n\nassert.equal(isProduction4a(\"?\"), false);\nassert.equal(isProduction4a(\"-\"), true);\n\nassert.equal(validFirstChar(\"a\"), true);\nassert.equal(validFirstChar(\"1\"), false);\n\nassert.equal(validSecondCharOnwards(\"a\"), true);\nassert.equal(validSecondCharOnwards(\"?\"), false);"}},"check-types-mini":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { checkTypesMini } from \"check-types-mini\";\n\nassert.throws(\n  () => {\n    checkTypesMini(\n      {\n        // object to check\n        option1: \"setting1\",\n        option2: \"false\",\n        option3: false,\n      },\n      {\n        // reference defaults object\n        option1: \"setting1\",\n        option2: false,\n        option3: false,\n      }\n    );\n  },\n  (err) => {\n    assert(/not boolean but string/.test(err));\n    return true;\n  }\n);"}},"codsen-parser":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { cparser } from \"codsen-parser\";\n\nassert.deepEqual(cparser(\"<br>z</a>\"), [\n  {\n    type: \"tag\",\n    kind: \"inline\",\n    tagName: \"br\",\n    tagNameStartsAt: 1,\n    tagNameEndsAt: 3,\n    closing: false,\n    void: true,\n    pureHTML: true,\n    recognised: true,\n    start: 0,\n    end: 4,\n    value: \"<br>\",\n    attribs: [],\n    children: [],\n  },\n  {\n    type: \"text\",\n    start: 4,\n    end: 5,\n    value: \"z\",\n  },\n  {\n    type: \"tag\",\n    kind: \"inline\",\n    tagName: \"a\",\n    tagNameStartsAt: 7,\n    tagNameEndsAt: 8,\n    closing: true,\n    void: false,\n    pureHTML: true,\n    recognised: true,\n    start: 5,\n    end: 9,\n    value: \"</a>\",\n    attribs: [],\n    children: [],\n  },\n]);"}},"codsen-tokenizer":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { tokenizer } from \"codsen-tokenizer\";\n\nconst gathered = [];\n\n// it operates from a callback, like Array.prototype.forEach()\ntokenizer(`<td nowrap>`, {\n  tagCb: (obj) => {\n    gathered.push(obj);\n  },\n});\n\nassert.deepEqual(gathered, [\n  {\n    type: \"tag\",\n    start: 0,\n    end: 11,\n    value: \"<td nowrap>\",\n    tagNameStartsAt: 1,\n    tagNameEndsAt: 3,\n    tagName: \"td\",\n    recognised: true,\n    closing: false,\n    void: false,\n    pureHTML: true,\n    kind: null,\n    attribs: [\n      {\n        attribName: \"nowrap\",\n        attribNameRecognised: true,\n        attribNameStartsAt: 4,\n        attribNameEndsAt: 10,\n        attribOpeningQuoteAt: null,\n        attribClosingQuoteAt: null,\n        attribValueRaw: null,\n        attribValue: [],\n        attribValueStartsAt: null,\n        attribValueEndsAt: null,\n        attribStarts: 4,\n        attribEnds: 10,\n        attribLeft: 2,\n      },\n    ],\n  },\n]);"}},"color-shorthand-hex-to-six-digit":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { conv } from \"color-shorthand-hex-to-six-digit\";\n\n// converts shorthand hex color codes within strings (imagine that could be\n// email template source code):\nassert.equal(\n  conv(\"aaaa #f0c zzzz\\n\\t\\t\\t#fc0\"),\n  \"aaaa #ff00cc zzzz\\n\\t\\t\\t#ffcc00\"\n);\n\n// converts shorthand hex colour codes within plain objects:\nassert.deepEqual(\n  conv({\n    a: \"#ffcc00\",\n    b: \"#f0c\",\n    c: \"text\",\n  }),\n  {\n    a: \"#ffcc00\",\n    b: \"#ff00cc\",\n    c: \"text\",\n  }\n);\n\n// converts shorthand hex colour codes within arrays:\nassert.deepEqual(conv([\"#fc0\", \"#f0c\", \"text\", \"\"]), [\n  \"#ffcc00\",\n  \"#ff00cc\",\n  \"text\",\n  \"\",\n]);\n\n// converts shorthand hex colour codes within nested spaghetti's:\nassert.deepEqual(\n  conv([[[[[[{ x: [\"#fc0\"] }]]]]], { z: \"#f0c\" }, [\"text\"], { y: \"\" }]),\n  [[[[[[{ x: [\"#ffcc00\"] }]]]]], { z: \"#ff00cc\" }, [\"text\"], { y: \"\" }]\n);\n\n// in all other cases it silently returns the input:\nassert.equal(conv(null), null);"}},"csv-sort":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { sort } from \"csv-sort\";\n\n// Sorts double-entry bookkeeping CSV's - bank statements for example\n// see https://en.wikipedia.org/wiki/Double-entry_bookkeeping\n\nassert.deepEqual(\n  sort(`Acc Number,Description,Debit Amount,Credit Amount,Balance,\n123456,Client #1 payment,,1000,1940\n123456,Bought carpet,30,,950\n123456,Bought table,10,,940\n123456,Bought pens,10,,1000\n123456,Bought chairs,20,,980\n`),\n  {\n    res: [\n      [\"Acc Number\", \"Description\", \"Debit Amount\", \"Credit Amount\", \"Balance\"],\n      [\"123456\", \"Client #1 payment\", \"\", \"1000\", \"1940\"],\n      [\"123456\", \"Bought table\", \"10\", \"\", \"940\"],\n      [\"123456\", \"Bought carpet\", \"30\", \"\", \"950\"],\n      [\"123456\", \"Bought chairs\", \"20\", \"\", \"980\"],\n      [\"123456\", \"Bought pens\", \"10\", \"\", \"1000\"],\n    ],\n    msgContent: null,\n    msgType: null,\n  }\n);\n// you'll have to join elements and lines from the array yourself"}},"csv-split-easy":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { splitEasy } from \"csv-split-easy\";\n\nassert.deepEqual(\n  splitEasy(\n    'Product Name,Main Price,Discounted Price\\nTestarossa (Type F110),\"100,000\",\"90,000\"\\nF50,\"2,500,000\",\"1,800,000\"'\n  ),\n  [\n    [\"Product Name\", \"Main Price\", \"Discounted Price\"],\n    [\"Testarossa (Type F110)\", \"100000\", \"90000\"],\n    [\"F50\", \"2500000\", \"1800000\"],\n  ]\n);"}},"detect-is-it-html-or-xhtml":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { detectIsItHTMLOrXhtml } from \"detect-is-it-html-or-xhtml\";\n\nassert.equal(\n  detectIsItHTMLOrXhtml(\n    `<img src=\"some.jpg\" width=\"zzz\" height=\"zzz\" border=\"0\" style=\"display:block;\" alt=\"zzz\"/>`\n  ),\n  \"xhtml\"\n);"}},"detect-templating-language":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { detectLang } from \"detect-templating-language\";\n\n// detects Nunjucks\nassert.deepEqual(\n  detectLang(`<div>{% if something %}x{% else %}y{% endif %}</div>`),\n  { name: \"Nunjucks\" }\n);\n\n// detects JSP (Java Server Pages)\nassert.deepEqual(\n  detectLang(\n    `<div><c:set var=\"someList\" value=\"\\${jspProp.someList}\" /></div>`\n  ),\n  { name: \"JSP\" }\n);"}},"detergent":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { det, opts, version } from \"detergent\";\n\n// on default setting, widow removal and encoding are enabled:\nassert.equal(det(\"clean this text £\").res, \"clean this text&nbsp;&pound;\");"}},"easy-replace":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { er } from \"easy-replace\";\n\nassert.equal(\n  er(\n    \"&nBsp; NBsp &nbSP NbsP;\",\n    {\n      leftOutsideNot: \"\",\n      leftOutside: \"\",\n      leftMaybe: [\"&\", \"&amp;\"],\n      searchFor: \"nbsp\",\n      rightMaybe: \";\",\n      rightOutside: \"\",\n      rightOutsideNot: \"\",\n      i: {\n        searchFor: true,\n      },\n    },\n    \"&nbsp;\"\n  ),\n  \"&nbsp; &nbsp; &nbsp; &nbsp;\"\n);"}},"edit-package-json":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { set, del } from \"edit-package-json\";\n\n// edit JSON as string\nassert.equal(\n  set(\n    `{\n  \"name\": \"test\",\n  \"dependencies\": {\n    \"ranges-apply\": \"^2.0.0\",\n    \"string-left-right\": \"^2.3.30\"\n  },\n  \"devDependencies\": {}\n}`,\n    \"dependencies.ranges-apply\", // path to amend\n    \"^3.2.2\" // new value\n  ),\n  `{\n  \"name\": \"test\",\n  \"dependencies\": {\n    \"ranges-apply\": \"^3.2.2\",\n    \"string-left-right\": \"^2.3.30\"\n  },\n  \"devDependencies\": {}\n}`\n);\n\n// delete from JSON string\nassert.equal(\n  del(\n    `{\n  \"name\": \"test\",\n  \"dependencies\": {\n    \"ranges-apply\": \"^2.0.0\",\n    \"string-left-right\": \"^2.3.30\"\n  },\n  \"devDependencies\": {}\n}`,\n    \"devDependencies\" // path to delete\n  ),\n  `{\n  \"name\": \"test\",\n  \"dependencies\": {\n    \"ranges-apply\": \"^2.0.0\",\n    \"string-left-right\": \"^2.3.30\"\n  }\n}`\n);"},"mini-del.js":{"title":"Minimal example, `del()`","code":"import { strict as assert } from \"assert\";\n\nimport { del } from \"edit-package-json\";\n\n// edit JSON as string\nassert.equal(\n  del(\n    `{\n  \"a\": \"b\",\n  \"c\": \"d\"\n}`,\n    \"c\" // path to delete\n  ),\n  `{\n  \"a\": \"b\"\n}`\n);"},"mini-set.js":{"title":"Minimal example, `set()`","code":"import { strict as assert } from \"assert\";\n\nimport { set } from \"edit-package-json\";\n\n// edit JSON as string\nassert.equal(\n  set(\n    `{\n  \"a\": \"b\",\n  \"c\": {\n    \"d\": \"e\"\n  }\n}`,\n    \"c.d\", // path\n    \"x\" // value to put\n  ),\n  `{\n  \"a\": \"b\",\n  \"c\": {\n    \"d\": \"x\"\n  }\n}`\n);"}},"email-all-chars-within-ascii":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { within } from \"email-all-chars-within-ascii\";\n\n// enforces all characters to be within ASCII:\nassert.deepEqual(within(`<div>Motörhead</div>`), [\n  {\n    type: \"character\",\n    line: 1,\n    column: 9,\n    positionIdx: 8,\n    value: \"ö\",\n    codePoint: 246,\n    UTF32Hex: \"00f6\",\n  },\n]);\n\n// enforces line lengths (500 is best for email):\nassert.deepEqual(within(`abcde`, { lineLength: 3 }), [\n  {\n    type: \"line length\",\n    line: 1,\n    column: 5,\n    positionIdx: 5,\n    value: 5,\n  },\n]);"}},"email-comb":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\nimport { comb, defaults, version } from \"email-comb\";\n\nconst source = `<head>\n<style type=\"text/css\">\n.unused1[z] {a:1;}\n.used[z] {a:2;}\n</style>\n</head>\n<body class=\"  used  \"><a class=\"used unused3\">z</a>\n</body>\n`;\n\nconst intended = `<head>\n<style type=\"text/css\">\n.used[z] {a:2;}\n</style>\n</head>\n<body class=\"used\"><a class=\"used\">z</a>\n</body>\n`;\n\nassert.equal(comb(source).result, intended);"},"minify-uglify.js":{"title":"Minifies and uglifies","code":"import { strict as assert } from \"assert\";\nimport { comb } from \"email-comb\";\n\nconst someHtml = `<html>\n<body id=\"used-1\">\n  <table class=\"unused-2 unused-3\">\n    <tr>\n      <td class=\"unused-4 unused-5\">text</td>\n    </tr>\n  </table>\n\n  <style>\n    #used-1 {\n      color: #ccc;\n    }\n    .unused-6 {\n      display: block;\n    }\n    #unused-7 {\n      height: auto;\n    }\n  </style>\n</body>\n</html>`;\n\nassert.equal(\n  comb(someHtml, {\n    uglify: true,\n    htmlCrushOpts: {\n      removeLineBreaks: true,\n    },\n  }).result,\n  `<html>\n<body id=\"q\">\n<table><tr><td>text\n</td></tr></table>\n<style>#q{color:#ccc;}\n</style>\n</body>\n</html>`\n);"},"reports-extracted.js":{"title":"Returns all extracted and deleted classes and id's","code":"import { strict as assert } from \"assert\";\nimport { comb } from \"email-comb\";\n\nconst { allInHead, allInBody, deletedFromHead, deletedFromBody } = comb(\n  `<!DOCTYPE html>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Tile</title>\n<style type=\"text/css\">\ndiv.non-existent-class{display: block;}\ntable#other div#non-existent-id{width:100%; display: inline-block;}\n</style>\n</head>\n<body>\n<table>\n<td>\n  <img class=\"unused1 unused2\" src=\"image.jpg\" width=\"zzz\" height=\"zzz\" border=\"0\" style=\"display:block;\" alt=\"zzz\">\n  <br><br>\n  <hr class=\"unused3\">\n  <br><br id=\"unused4\">\n</td>\n</tr>\n</table>\n</body>\n</html>\n`\n);\n\nassert.deepEqual(allInHead, [\n  \"#non-existent-id\",\n  \"#other\",\n  \".non-existent-class\",\n]);\nassert.deepEqual(allInBody, [\"#unused4\", \".unused1\", \".unused2\", \".unused3\"]);\nassert.deepEqual(deletedFromHead, [\n  \"#non-existent-id\",\n  \"#other\",\n  \".non-existent-class\",\n]);\nassert.deepEqual(deletedFromBody, [\n  \"#unused4\",\n  \".unused1\",\n  \".unused2\",\n  \".unused3\",\n]);"},"style-within-body.js":{"title":"Works even if `<style>` is within `<body>` and there's no `<head>`","code":"import { strict as assert } from \"assert\";\nimport { comb } from \"email-comb\";\n\nconst someHtml = `<html>\n<body id=\"unused-1\">\n  <table class=\"unused-2 unused-3\">\n    <tr>\n      <td class=\"unused-4 unused-5\">text</td>\n    </tr>\n  </table>\n\n  <style>\n    .unused-6 {\n      display: block;\n    }\n    #unused-7 {\n      height: auto;\n    }\n  </style>\n</body>\n</html>`;\n\nassert.equal(\n  comb(someHtml).result,\n  `<html>\n<body>\n  <table>\n    <tr>\n      <td>text</td>\n    </tr>\n  </table>\n</body>\n</html>`\n);"},"whitelist-wildcards.js":{"title":"Whitelist using wildcards","code":"import { strict as assert } from \"assert\";\nimport { comb } from \"email-comb\";\n\nconst someHtml = `<html>\n<head>\n<style type=\"text/css\">\n  .module-1{display: none !important;}\n  .module-2{display: none !important;}\n  .module-3{display: none !important;}\n  .module-zzzzkldfjglfjhlfjlhfglj{display: none !important;}\n  .head-only-class-1 a.module-94:hover{width: 100% !important;}\n  #head-only-id-1[lang|en]{width: 100% !important;}\n</style>\n</head>\n<body>\n<table class=\"module-92\" width=\"100%\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tr class=\"module-93 body-only-class-1\">\n  <td id=\"body-only-id-1\" class=\"module-94 module-lkfjgldhglktjja\">\n    <img class=\"module-91\" src=\"image.jpg\" />\n  </td>\n</tr>\n</table>\n</body>\n</html>\n`;\n\nlet intended = `<html>\n<head>\n<style type=\"text/css\">\n  .module-1{display: none !important;}\n  .module-2{display: none !important;}\n  .module-3{display: none !important;}\n  .module-zzzzkldfjglfjhlfjlhfglj{display: none !important;}\n</style>\n</head>\n<body>\n<table class=\"module-92\" width=\"100%\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tr class=\"module-93\">\n  <td class=\"module-94 module-lkfjgldhglktjja\">\n    <img class=\"module-91\" src=\"image.jpg\" />\n  </td>\n</tr>\n</table>\n</body>\n</html>\n`;\n\nassert.equal(\n  comb(someHtml, {\n    whitelist: [\".module-*\", \".particular\"],\n  }).result,\n  intended\n);"}},"emlint":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { Linter } from \"emlint\";\n\nconst linter = new Linter();\n\n// Correct \"not\" type Outlook conditional would be:\n// <!--[if !mso]><!-->\n//   <span class=\"foo\">z</span>\n// <!--<![endif]-->\n\n// We have a \"not\" type opening but \"only\" type\n// closing:\nconst messages = linter.verify(\n  `<!--[if !mso]><!-->\n  <span class=\"foo\">z</span>\n<![endif]-->`,\n  {\n    rules: {\n      all: 2,\n    },\n  }\n);\n\nassert.deepEqual(messages, [\n  {\n    line: 3,\n    column: 1,\n    severity: 2,\n    ruleId: \"comment-mismatching-pair\",\n    message: `Add \"<!--\".`,\n    idxFrom: 49,\n    idxTo: 61,\n    fix: {\n      ranges: [[49, 49, \"<!--\"]],\n    },\n    keepSeparateWhenFixing: true,\n  },\n]);"}},"extract-search-index":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { extract } from \"extract-search-index\";\n\nassert.equal(\n  extract(`The quick brown fox jumps over the lazy dog.`),\n  \"quick brown fox jumps over lazy dog\"\n);\n\n// works with HTML, strips tags\nassert.equal(extract(\"<tralala><div>some&nbsp;text</div>\"), \"some text\");"}},"generate-atomic-css":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  genAtomic,\n  version,\n  headsAndTails,\n  extractFromToSource,\n} from \"generate-atomic-css\";\n\nassert.deepEqual(\n  genAtomic(\n    `a\n\n/* GENERATE-ATOMIC-CSS-CONFIG-STARTS\n.pb$$$ { padding-bottom: $$$px !important; } | 5 | 10\n\n.mt$$$ { margin-top: $$$px !important; } | 1\nGENERATE-ATOMIC-CSS-CONFIG-ENDS\nGENERATE-ATOMIC-CSS-CONTENT-STARTS */\n\ntralala\n\n/* GENERATE-ATOMIC-CSS-CONTENT-ENDS */\n\nz`,\n    {\n      includeConfig: false,\n      includeHeadsAndTails: false,\n    }\n  ),\n  {\n    log: { count: 8 },\n    result: `a\n\n.pb5  { padding-bottom:  5px !important; }\n.pb6  { padding-bottom:  6px !important; }\n.pb7  { padding-bottom:  7px !important; }\n.pb8  { padding-bottom:  8px !important; }\n.pb9  { padding-bottom:  9px !important; }\n.pb10 { padding-bottom: 10px !important; }\n\n.mt0 { margin-top:   0 !important; }\n.mt1 { margin-top: 1px !important; }\n\nz\n`,\n  }\n);"}},"html-all-known-attributes":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { allHtmlAttribs } from \"html-all-known-attributes\";\n\nassert.equal(allHtmlAttribs.has(\"href\"), true);\n\nassert.equal(allHtmlAttribs.size, 702);\n\n// iterating:\nconst gathered = [];\nfor (let x of allHtmlAttribs) {\n  // push first three\n  if (gathered.length < 3) {\n    gathered.push(x);\n  }\n}\nassert.deepEqual(gathered, [\"abbr\", \"accept\", \"accept-charset\"]);"}},"html-crush":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { crush, defaults, version } from \"html-crush\";\n\nassert.equal(\n  crush(\n    `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td>\n      hi\n    </td>\n  </tr>\n</table>`,\n    { removeLineBreaks: true }\n  ).result,\n  `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td> hi\n</td></tr></table>`\n);"}},"html-entities-not-email-friendly":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  notEmailFriendly,\n  notEmailFriendlySetOnly,\n  notEmailFriendlyLowercaseSetOnly,\n  notEmailFriendlyMinLength,\n  notEmailFriendlyMaxLength,\n} from \"html-entities-not-email-friendly\";\n\n// it's object, mapping entity names to numeric equivalents\nassert.equal(Object.keys(notEmailFriendly).length, 1841);\n\n// it's a Set, only listing the bad entity names\nassert.equal(notEmailFriendlySetOnly.size, 1841);\n\n// is &GreaterTilde; email-friendly?\nassert.equal(notEmailFriendlySetOnly.has(\"GreaterTilde\"), true);\n// no, use numeric entity\n\n// is &nbsp; email-friendly?\nassert.equal(notEmailFriendlySetOnly.has(\"nbsp\"), false);\n// yes, it's OK"}},"html-img-alt":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { alts } from \"html-img-alt\";\n\n// string-in, string-out:\nassert.equal(\n  alts('zzz<img src=\"spacer.gif\" >zzz'),\n  'zzz<img src=\"spacer.gif\" alt=\"\" >zzz'\n);"}},"html-table-patcher":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { patcher } from \"html-table-patcher\";\n\nassert.equal(\n  patcher(\n    `<table>\n{% if customer.details.hasAccount %}\n<tr>\n  <td>\n    variation #1\n  </td>\n</tr>\n{% else %}\n<tr>\n  <td>\n    variation #2\n  </td>\n</tr>\n{% endif %}\n</table>`\n  ).result,\n  `<table>\n\n<tr>\n  <td>\n    {% if customer.details.hasAccount %}\n  </td>\n</tr>\n\n<tr>\n  <td>\n    variation #1\n  </td>\n</tr>\n\n<tr>\n  <td>\n    {% else %}\n  </td>\n</tr>\n\n<tr>\n  <td>\n    variation #2\n  </td>\n</tr>\n\n<tr>\n  <td>\n    {% endif %}\n  </td>\n</tr>\n\n</table>`\n);"}},"is-char-suitable-for-html-attr-name":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isAttrNameChar } from \"is-char-suitable-for-html-attr-name\";\n\n// Follows the spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\nassert.equal(isAttrNameChar(\"a\"), true);\nassert.equal(isAttrNameChar(\"?\"), false);"}},"is-html-attribute-closing":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isAttrClosing } from \"is-html-attribute-closing\";\n\nconst str = `<a href=\"zzz\" target=\"_blank\" style=\"color: black;\">`;\n\n// <a href=\"zzz\" target=\"_blank\" ...\n//                      ^\n//                  index 21\n\n// <a href=\"zzz\" target=\"_blank\" ...\n//                             ^\n//                         index 28\n\nassert.equal(\n  isAttrClosing(\n    str, // reference string\n    21, // known opening (or in absence of a quote, a start of a value)\n    28 // we ask, is this a closing on the attribute?\n  ),\n  true // the answer\n);"},"broken-1.js":{"title":"Broken #1","code":"import { strict as assert } from \"assert\";\n\nimport { isAttrClosing } from \"is-html-attribute-closing\";\n\nassert.equal(\n  isAttrClosing(\n    `<a href=\"z' click here</a>`,\n    //       ^ ^\n    //       | \\\n    //       |  \\_________________________________\n    //       |                                   |\n    8, // known opening                          |\n    10 // is this an attribute closing at index 10?\n  ),\n  true\n);\n// => yes, indeed a closing of an attribute (not counting\n// the code is broken)"},"broken-2.js":{"title":"Broken #2","code":"import { strict as assert } from \"assert\";\n\nimport { isAttrClosing } from \"is-html-attribute-closing\";\n\nassert.equal(\n  isAttrClosing(\n    `<a b = = = \"c\" d = = = 'e'>`,\n    //          ^ ^\n    //          | |\n    //          | L_______________________________\n    //          |                                |\n    11, // known opening                         |\n    13 // is this an attribute closing at index 13?\n  ),\n  true\n);\n// => true - indeed a closing of an attribute (not counting\n// the code is broken)"},"broken-3.js":{"title":"Broken #3","code":"import { strict as assert } from \"assert\";\n\nimport { isAttrClosing } from \"is-html-attribute-closing\";\n\n// Correct code:\n// <img class=\"so-called\" alt=\"!\" border='10'/>\n\n// Broken code:\nconst str = `<img class=\"so-called \"alt !' border 10'/>`;\n//                      ^\n//                known opening at idx 11\n\nassert.equal(isAttrClosing(str, 11, 22), true);\n// => true - indeed a closing of an attribute\n\nassert.equal(isAttrClosing(str, 11, 28), false);\n// => not a closing of an attribute\n\nassert.equal(isAttrClosing(str, 11, 39), false);\n// => not a closing of an attribute"}},"is-html-tag-opening":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isOpening } from \"is-html-tag-opening\";\n\nconst text = `<span>a < b<span>`;\n\n// opening span tag's opening\nassert.equal(isOpening(text, 0), true);\n\n// unencoded bracket between a and b\nassert.equal(isOpening(text, 8), false);\n\n// closing span tag's opening\nassert.equal(isOpening(text, 11), true);"},"opts.allowCustomTagNames.js":{"title":"`opts.allowCustomTagNames`","code":"import { strict as assert } from \"assert\";\n\nimport { isOpening } from \"is-html-tag-opening\";\n\n// recognised tag\nassert.equal(isOpening(`abc <div>`, 4), true);\n//                          ^\n\n// unrecognised tag\nassert.equal(isOpening(`abc <zzz>`, 4), false);\n//                          ^\n\n// but with opts.allowCustomTagNames result is \"true\"\nassert.equal(\n  isOpening(`abc <zzz>`, 4, {\n    allowCustomTagNames: true,\n  }),\n  true\n);"},"opts.skipOpeningBracket.js":{"title":"`opts.skipOpeningBracket`","code":"import { strict as assert } from \"assert\";\n\nimport { isOpening } from \"is-html-tag-opening\";\n\n// missing opening bracket:\nassert.equal(isOpening(`<a>div class=\"w-64 h-3\">`, 3), false);\n//                         ^\n// result is instant \"false\" because `idx` has to be\n// on an opening bracket (besides checking for tag name\n// being present and recognised and attributes being present)\n\n// but with opts.skipOpeningBracket we remove the requirement\n// that \"idx\" has to be on a bracket - algorithm detects valid\n// tag name and the attribute that follows and recognise it's a\n// tag starting:\nassert.equal(\n  isOpening(`<a>div class=\"w-64 h-3\">`, 3, {\n    skipOpeningBracket: true,\n  }),\n  true\n);"}},"is-language-code":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isLangCode } from \"is-language-code\";\n\nassert.deepEqual(isLangCode(\"de-419-DE\"), {\n  res: false,\n  message: 'Two region subtags, \"419\" and \"de\".',\n});\n\nassert.deepEqual(isLangCode(\"sr-Latn\"), {\n  res: true,\n  message: null,\n});"},"various.js":{"title":"Various examples","code":"import { strict as assert } from \"assert\";\n\nimport { isLangCode } from \"is-language-code\";\n\nassert.equal(isLangCode(\"de\").res, true);\n// => true because it's a German language code\n\nassert.equal(isLangCode(\"fr\").res, true);\n// => true because it's a French language code\n\nassert.equal(isLangCode(\"ja\").res, true);\n// => true because it's a Japanese language code\n\nassert.equal(isLangCode(\"zzz\").res, false);\n// => false - unrecognised. npm package \"ietf-language-tag-regex\" would fail this\n\nassert.equal(isLangCode(\"1\").res, false);\n// => false - not recognised language code\n\nassert.equal(isLangCode(\"x-klingon\").res, true);\n// => true - private use\n\nassert.equal(isLangCode(\"x-whatever\").res, true);\n// => true - private use\n\nassert.equal(isLangCode(\"zh-Hant\").res, true);\n// => true - Chinese written using the Traditional Chinese script\n\nassert.equal(isLangCode(\"zh-cmn-Hans-CN\").res, true);\n// => true - Chinese, Mandarin, Simplified script, as used in China\n\nassert.equal(isLangCode(\"zh-Hans-CN\").res, true);\n// => true - Chinese written using the Simplified script as used in mainland China\n\nassert.equal(isLangCode(\"sr-Latn-RS\").res, true);\n// => true - Serbian written using the Latin script as used in Serbia\n\nassert.equal(isLangCode(\"sl-rozaj\").res, true);\n// => true - Resian dialect of Slovenian\n\nassert.equal(isLangCode(\"sl-nedis\").res, true);\n// => true - Nadiza dialect of Slovenian\n\nassert.equal(isLangCode(\"de-CH-1901\").res, true);\n// => true - German as used in Switzerland using the 1901 variant [orthography]\n\nassert.equal(isLangCode(\"sl-IT-nedis\").res, true);\n// => true - Slovenian as used in Italy, Nadiza dialect\n\nassert.equal(isLangCode(\"hy-Latn-IT-arevela\").res, true);\n// => true - Eastern Armenian written in Latin script, as used in Italy\n\nassert.equal(isLangCode(\"en-US\").res, true);\n// => true - English as used in the United States\n\nassert.equal(isLangCode(\"de-CH-x-phonebk\").res, true);\n// => true - private use subtag (x-)\n\nassert.equal(isLangCode(\"az-Arab-x-AZE-derbend\").res, true);\n// => true - private use subtag\n\nassert.equal(isLangCode(\"x-whatever\").res, true);\n// => true - private use subtag using singleton x-\n\nassert.equal(isLangCode(\"qaa-Qaaa-QM-x-southern\").res, true);\n// => true\n\nassert.equal(isLangCode(\"de-Qaaa\").res, true);\n// => true - private use script subtag (Qaaa)\n\nassert.equal(isLangCode(\"sr-Latn-QM\").res, true);\n// => true - Serbian, Latin script, private region QM\n\nassert.equal(isLangCode(\"en-US-u-islamcal\").res, true);\n// => true - tag with extension\n\nassert.equal(isLangCode(\"zh-CN-a-myext-x-private\").res, true);\n// => true - tag with extension\n\nassert.equal(isLangCode(\"en-a-myext-b-another\").res, true);\n// => true - tag with extension\n\nassert.equal(isLangCode(\"de-419-DE\").res, false);\n// => false - two region tags\n\nassert.equal(isLangCode(\"a-DE\").res, false);\n// => false - use of a single-character subtag in primary position\n\nassert.equal(isLangCode(\"ar-a-aaa-b-bbb-a-ccc\").res, false);\n// => false - two extensions with same single-letter prefix"}},"is-media-descriptor":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isMediaD } from \"is-media-descriptor\";\n\nassert.deepEqual(isMediaD(\"screeen\"), [\n  {\n    idxFrom: 0,\n    idxTo: 7,\n    message: `Did you mean \"screen\"?`,\n    fix: {\n      ranges: [[0, 7, \"screen\"]],\n    },\n  },\n]);"}},"is-relative-uri":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isRel } from \"is-relative-uri\";\n\nassert.deepEqual(isRel(\".../resource.txt\"), {\n  res: false,\n  message: `Three consecutive dots.`,\n});"}},"js-row-num":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { fixRowNums } from \"js-row-num\";\n\n// sets line number to 002 because it's on row number two\nassert.equal(\n  fixRowNums(`const foo = \"bar\";\\n console.log(\\`0 foo = \\${foo}\\`)`),\n  `const foo = \"bar\";\\n console.log(\\`002 foo = \\${foo}\\`)`\n);"}},"json-comb-core":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\n// STEP #1\n// =======\n\n// calculate the schema - superset of all possible keys used across\n// all JSON files\nconst schema = getKeysetSync([\n  {\n    // <- object #1\n    a: \"a\",\n    b: \"c\",\n    c: {\n      d: \"d\",\n      e: \"e\",\n    },\n  },\n  {\n    // <- object #2\n    a: \"a\",\n  },\n  {\n    // <- object #3\n    c: {\n      f: \"f\",\n    },\n  },\n]);\n\nassert.deepEqual(schema, {\n  a: false,\n  b: false,\n  c: {\n    d: false,\n    e: false,\n    f: false,\n  },\n});\n\n// STEP #2\n// =======\n\n// now we can normalise the object #2 for example:\nassert.deepEqual(\n  enforceKeysetSync(\n    {\n      // <- object #2\n      a: \"a\",\n    },\n    schema\n  ),\n  {\n    a: \"a\",\n    b: false,\n    c: {\n      d: false,\n      e: false,\n      f: false,\n    },\n  }\n);"},"enforceKeyset.js":{"title":"Asynchronous `enforceKeyset()`","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\n// Let's enforce the keyset using previously-calculated schema.\n\n// Let's use an async IIFE to trigger the action and let us use await:\n(async () => {\n  // let's create three plain objects, each somewhat overlapping with others:\n  let obj1 = {\n    b: [\n      {\n        c: \"ccc\",\n        d: \"ddd\",\n      },\n    ],\n    a: \"aaa\",\n  };\n  let obj2 = {\n    a: \"ccc\",\n    e: \"eee\",\n  };\n  let obj3 = {\n    a: \"zzz\",\n  };\n  // calculate the schema:\n  let schema = await getKeyset([obj1, obj2, obj3]);\n\n  assert.deepEqual(schema, {\n    a: false,\n    b: [\n      {\n        c: false,\n        d: false,\n      },\n    ],\n    e: false,\n  });\n\n  assert.deepEqual(await enforceKeyset(obj1, schema), {\n    a: \"aaa\",\n    b: [\n      {\n        c: \"ccc\",\n        d: \"ddd\",\n      },\n    ],\n    e: false, // <------ new key added\n  });\n\n  assert.deepEqual(await enforceKeyset(obj2, schema), {\n    a: \"ccc\",\n    b: [\n      // <------- new key added\n      {\n        c: false,\n        d: false,\n      },\n    ],\n    e: \"eee\",\n  });\n\n  assert.deepEqual(await enforceKeyset(obj3, schema), {\n    a: \"zzz\",\n    b: [\n      // <------- new key added\n      {\n        c: false,\n        d: false,\n      },\n    ],\n    e: false, // <------- new key added\n  });\n})();"},"enforceKeysetSync.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\nconst schema = {\n  a: false,\n  b: false,\n  c: {\n    d: false,\n    e: false,\n    f: false,\n  },\n};\n\nassert.deepEqual(\n  enforceKeysetSync(\n    {\n      c: { d: \"x\" },\n    },\n    schema\n  ),\n  {\n    a: false,\n    b: false,\n    c: {\n      d: \"x\",\n      e: false,\n      f: false,\n    },\n  }\n);"},"findUnusedSync-2.js":{"title":"Synchronous `findUnusedSync()` - example #2","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\n// This function will work on arrays of both normalised and not normalised object sets.\nassert.deepEqual(\n  findUnusedSync([\n    {\n      a: [\n        {\n          k: false,\n          l: false,\n          m: false,\n        },\n        {\n          k: \"k\",\n          l: false,\n          m: \"m\",\n        },\n      ],\n      b: \"bbb1\",\n      c: false,\n    },\n    {\n      a: [\n        {\n          k: \"k\",\n          l: false,\n          m: \"m\",\n        },\n        {\n          k: \"k\",\n          l: false,\n          m: \"m\",\n        },\n      ],\n      b: \"bbb2\",\n      c: false,\n    },\n    { b: false },\n    { c: false },\n  ]),\n  [\"c\", \"a[0].l\"]\n);"},"findUnusedSync.js":{"title":"Synchronous `findUnusedSync()` - example #1","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\nassert.deepEqual(\n  findUnusedSync([\n    {\n      // <- object #1\n      a: false,\n      b: \"bbb1\",\n      c: false,\n    },\n    {\n      // <- object #2\n      a: \"aaa\",\n      b: \"bbb2\",\n      c: false,\n    },\n    {}, // <- object #3\n  ]),\n  [\"c\"]\n);"},"getKeyset.js":{"title":"Asynchronous `getKeyset()`","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\n// Let's calculate the schema of the following arrays of plain objects,\n// and do it asynchronously.\n\n// Let's use an async IIFE to trigger the action and let us use await:\n(async () => {\n  // First, prepare array of promises:\n  let source = [\n    {\n      a: \"a\",\n      b: \"c\",\n      c: {\n        d: \"d\",\n        e: \"e\",\n      },\n    },\n    {\n      a: \"a\",\n    },\n    {\n      c: {\n        f: \"f\",\n      },\n    },\n  ].map((el) => Promise.resolve(el));\n\n  // use async/await to avoid using .then\n  assert.deepEqual(await getKeyset(source), {\n    a: false,\n    b: false,\n    c: {\n      d: false,\n      e: false,\n      f: false,\n    },\n  });\n})();"},"getKeysetSync.js":{"title":"Synchronous `getKeysetSync()`","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\nconst schema = getKeysetSync([\n  {\n    // <- object #1\n    a: \"a\",\n    b: \"c\",\n    c: {\n      d: \"d\",\n      e: \"e\",\n    },\n  },\n  {\n    // <- object #2\n    a: \"a\",\n  },\n  {\n    // <- object #3\n    c: {\n      f: \"f\",\n    },\n  },\n]);\n\nassert.deepEqual(schema, {\n  a: false,\n  b: false,\n  c: {\n    d: false,\n    e: false,\n    f: false,\n  },\n});"},"noNewKeys-2.js":{"title":"Synchronous `noNewKeysSync()` - example #2","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\nassert.deepEqual(\n  noNewKeysSync(\n    {\n      // <- input we're checking\n      z: [\n        {\n          a: \"a\",\n          b: \"b\",\n          c: \"c\",\n        },\n        {\n          a: false,\n          b: false,\n          c: \"c\",\n        },\n      ],\n    },\n    {\n      // <- reference keyset\n      z: [\n        {\n          a: \"a\",\n          b: \"b\",\n        },\n        {\n          a: false,\n          b: false,\n        },\n      ],\n    }\n  ),\n  [\"z[0].c\", \"z[1].c\"]\n);"},"noNewKeys.js":{"title":"Synchronous `noNewKeysSync()` - example #1","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\n// We are going to catch the rogue key `b`:\n\nassert.deepEqual(\n  noNewKeysSync(\n    {\n      // <- input we're checking\n      a: \"a\",\n      b: \"b\",\n      c: \"c\",\n    },\n    {\n      // <- reference keyset\n      a: \"aaa\",\n      c: \"ccc\",\n    }\n  ),\n  [\"b\"] // list of rogue paths\n);"},"sortAllObjectsSync.js":{"title":"Synchronous `getKeysetSync()`","code":"import { strict as assert } from \"assert\";\n\nimport {\n  getKeysetSync,\n  getKeyset,\n  enforceKeyset,\n  enforceKeysetSync,\n  sortAllObjectsSync,\n  noNewKeysSync,\n  findUnusedSync,\n} from \"json-comb-core\";\n\nassert.deepEqual(\n  sortAllObjectsSync({\n    a: \"a\",\n    c: \"c\",\n    b: \"b\",\n  }),\n  {\n    a: \"a\",\n    b: \"b\",\n    c: \"c\",\n  }\n);"}},"json-variables":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { jVar } from \"json-variables\";\n\nassert.deepEqual(\n  jVar({\n    a: \"some text %%_var1.key1.0_%% more text %%_var2.key2.key3.1_%%\",\n    b: \"something\",\n    var1: { key1: [\"value1\"] },\n    var2: { key2: { key3: [\"\", \"value2\"] } },\n  }),\n  {\n    a: \"some text value1 more text value2\",\n    b: \"something\",\n    var1: { key1: [\"value1\"] },\n    var2: { key2: { key3: [\"\", \"value2\"] } },\n  }\n);"}},"lerna-clean-changelogs":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { cleanChangelogs } from \"lerna-clean-changelogs\";\n\n// are all values equal to null:\nassert.equal(\n  cleanChangelogs(`# Change Log\n\nAll notable changes to this project will be documented in this file.\nSee [Conventional Commits](https://conventionalcommits.org) for commit guidelines.\n\n## 2.9.2 (2018-12-27)\n\n**Note:** Version bump only for package ranges-apply\n\n## [2.9.1](https://gitlab.com/codsen/codsen/tree/master/packages/ranges-apply/compare/ranges-apply@2.9.0...ranges-apply@2.9.1) (2018-12-27)\n\n**Note:** Version bump only for package ranges-apply\n\n## 2.9.0 (2018-12-26)\n\n### Bug Fixes\n\n* aaa\n\n### Features\n\n* bbb\n\n`).res,\n  //\n  //\n  //\n  // output:\n  `# Change Log\n\nAll notable changes to this project will be documented in this file.\nSee [Conventional Commits](https://conventionalcommits.org) for commit guidelines.\n\n## 2.9.0 (2018-12-26)\n\n### Bug Fixes\n\n- aaa\n\n### Features\n\n- bbb\n`\n);"}},"line-column-mini":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { lineCol, getLineStartIndexes } from \"line-column-mini\";\n\n// index 14 is letter \"k\" on the fourth line:\nassert.deepEqual(lineCol(\"abc\\ndef\\r\\nghi\\njkl\", 14), {\n  line: 4,\n  col: 2,\n});\n\n// ---------------------------------------------------------\n\n// if you know you might query multiple times, use caching\nconst lineIndexes = getLineStartIndexes(\"abc\\ndef\\r\\nghi\\njkl\");\nassert.deepEqual(lineCol(lineIndexes, 14), {\n  line: 4,\n  col: 2,\n});\n// other queries will be by magnitude faster:\nassert.deepEqual(lineCol(lineIndexes, 15), {\n  line: 4,\n  col: 3,\n});\n\n// by the way...\nassert.deepEqual(lineCol(lineIndexes, 99), null);"}},"object-all-values-equal-to":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { allEq } from \"object-all-values-equal-to\";\n\n// are all values equal to null:\nassert.equal(allEq({ a: null, c: null }, null), true);\n// yes\n\n// are all values equal to \"false\":\nassert.equal(allEq({ a: false, c: \"zzz\" }, false), false);\n// no\n\n// are all values equal to \"false\"?\nassert.equal(\n  allEq(\n    {\n      a: {\n        b: false,\n        c: [\n          {\n            d: false,\n            e: false,\n          },\n          {\n            g: false,\n          },\n        ],\n      },\n      c: false,\n    },\n    false // reference value to check\n  ),\n  true // answer is, yes\n);"}},"object-boolean-combinations":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { combinations } from \"object-boolean-combinations\";\n\nassert.deepEqual(\n  combinations({\n    a: true,\n    b: false,\n    c: true,\n  }),\n  [\n    { a: false, b: false, c: false },\n    { a: true, b: false, c: false },\n    { a: false, b: true, c: false },\n    { a: true, b: true, c: false },\n    { a: false, b: false, c: true },\n    { a: true, b: false, c: true },\n    { a: false, b: true, c: true },\n    { a: true, b: true, c: true },\n  ]\n);\n// you get 2^n plain objects in an array"}},"object-delete-key":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { deleteKey } from \"object-delete-key\";\n\n// deleting key 'c', with value 'd'\nassert.deepEqual(\n  deleteKey(\n    {\n      a: \"b\",\n      c: \"d\",\n    },\n    {\n      key: \"c\",\n      val: \"d\",\n    }\n  ),\n  { a: \"b\" }\n);\n\n// deleting key 'b' with value - array ['c', 'd']\nassert.deepEqual(\n  deleteKey(\n    {\n      a: { e: [{ b: [\"c\", \"d\"] }] },\n      b: [\"c\", \"d\"],\n    },\n    {\n      key: \"b\",\n      val: [\"c\", \"d\"],\n    }\n  ),\n  {}\n);\n// notice program cleaned after itself, it didn't leave empty \"a\" key"},"by-key-only.js":{"title":"Deletion by the key only","code":"import { strict as assert } from \"assert\";\n\nimport { deleteKey } from \"object-delete-key\";\n\nassert.deepEqual(\n  deleteKey(\n    {\n      a: \"a\",\n      b: \"jlfghdjkhkdfhgdf\",\n      c: [{ b: \"weuhreorhelhgljdhflghd\" }],\n    },\n    {\n      key: \"b\",\n    }\n  ),\n  { a: \"a\" }\n);"},"by-value-only.js":{"title":"Deletion by the value only","code":"import { strict as assert } from \"assert\";\n\nimport { deleteKey } from \"object-delete-key\";\n\nassert.deepEqual(\n  deleteKey(\n    {\n      a: \"a\",\n      skldjfslfl: \"x\",\n      c: [{ dlfgjdlkjlfgjhfg: \"x\" }],\n    },\n    {\n      val: \"x\",\n    }\n  ),\n  { a: \"a\" }\n);\n\n// same but without cleanup:\nassert.deepEqual(\n  deleteKey(\n    {\n      a: \"a\",\n      skldjfslfl: \"x\",\n      c: [{ dlfgjdlkjlfgjhfg: \"x\" }],\n    },\n    {\n      val: \"x\",\n      cleanup: false,\n    }\n  ),\n  {\n    a: \"a\",\n    c: [{}], // <--- !\n  }\n);"},"disable-cleanup.js":{"title":"Disable the cleanup which would otherwise happen after deletion","code":"import { strict as assert } from \"assert\";\n\nimport { deleteKey } from \"object-delete-key\";\n\nassert.deepEqual(\n  deleteKey(\n    {\n      a: { e: [{ b: { c: \"d\" } }] },\n      b: { c: \"d\" },\n    },\n    {\n      key: \"b\",\n      val: { c: \"d\" },\n      cleanup: false,\n    }\n  ),\n  { a: { e: [{}] } }\n);"},"wildcards.js":{"title":"Wildcards","code":"import { strict as assert } from \"assert\";\n\nimport { deleteKey } from \"object-delete-key\";\n\nassert.deepEqual(\n  deleteKey(\n    {\n      a: [\"beep\", \"\", \"c\", \"boop\"],\n      bap: \"bap\",\n    },\n    {\n      key: \"b*p\",\n      only: \"array\",\n    }\n  ),\n  {\n    a: [\"\", \"c\"],\n    bap: \"bap\",\n  }\n);"}},"object-fill-missing-keys":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { fillMissing } from \"object-fill-missing-keys\";\n\n// deleting key 'c', with value 'd'\nassert.deepEqual(\n  fillMissing(\n    {\n      // input object that could have came from JSON\n      b: \"b\",\n    },\n    {\n      // schema reference object\n      a: false,\n      b: false,\n      c: false,\n    }\n  ),\n  {\n    // patched result\n    a: false,\n    b: \"b\",\n    c: false,\n  }\n);"},"do-not-fill.js":{"title":"An option to not fill the paths if they contain placeholders","code":"import { strict as assert } from \"assert\";\n\nimport { fillMissing } from \"object-fill-missing-keys\";\n\nassert.deepEqual(\n  fillMissing(\n    {\n      // input object\n      a: {\n        b: false, // <---- we don't want to automatically normalise this key\n        x: \"x\",\n      },\n      z: \"z\",\n    },\n    {\n      // reference schema object\n      a: {\n        b: {\n          c: false,\n          d: false,\n        },\n        x: false,\n      },\n      z: false,\n    },\n    {\n      doNotFillThesePathsIfTheyContainPlaceholders: [\"a.b\"],\n    }\n  ),\n  {\n    a: {\n      b: false, // <---\n      x: \"x\",\n    },\n    z: \"z\",\n  }\n);"},"truncation.js":{"title":"Truncation upon request, to minimize the object footprint","code":"import { strict as assert } from \"assert\";\n\nimport { fillMissing } from \"object-fill-missing-keys\";\n\nassert.deepEqual(\n  fillMissing(\n    {\n      // input object\n      a: {\n        b: {\n          // this object in \"b\"'s value will be removed and set to placeholder \"false\"\n          c: false,\n          d: false,\n        },\n        x: {\n          // this too\n          y: false,\n        },\n      },\n      z: \"z\",\n    },\n    {\n      // schema object\n      a: {\n        b: {\n          c: false,\n          d: false,\n        },\n        x: false,\n      },\n      z: false,\n    },\n    {\n      // settings\n      doNotFillThesePathsIfTheyContainPlaceholders: [\"lalala\", \"a.b\", \"a.x\"],\n    }\n  ),\n  {\n    // result\n    a: {\n      b: false,\n      x: false,\n    },\n    z: \"z\",\n  }\n);"},"useNullAsExplicitFalse.js":{"title":"`opts.useNullAsExplicitFalse`","code":"import { strict as assert } from \"assert\";\n\nimport { fillMissing } from \"object-fill-missing-keys\";\n\n// on\nassert.deepEqual(\n  fillMissing(\n    {\n      // object we're working on\n      a: null,\n    },\n    {\n      // reference schema\n      a: [\"z\"],\n    },\n    {\n      // options\n      useNullAsExplicitFalse: true, // <--- !\n    }\n  ),\n  {\n    // result\n    a: null,\n  }\n);\n\n// off\nassert.deepEqual(\n  fillMissing(\n    {\n      // object we're working on\n      a: null,\n    },\n    {\n      // reference schema\n      a: [\"z\"],\n    },\n    {\n      // options\n      useNullAsExplicitFalse: false, // <--- !\n    }\n  ),\n  {\n    // result\n    a: [\"z\"],\n  }\n);"},"using-placeholder-true.js":{"title":"Using placeholder to cause the value population","code":"import { strict as assert } from \"assert\";\n\nimport { fillMissing } from \"object-fill-missing-keys\";\n\nassert.deepEqual(\n  fillMissing(\n    {\n      // object we work upon\n      a: {\n        b: true, // <-- not placeholder but lower in data hierarchy (boolean)\n        x: \"x\",\n      },\n      z: \"z\",\n    },\n    {\n      // reference (schema) object\n      a: {\n        b: {\n          c: false,\n          d: false,\n        },\n        x: false,\n      },\n      z: false,\n    },\n    {\n      doNotFillThesePathsIfTheyContainPlaceholders: [\"a.b\"],\n    }\n  ),\n  {\n    a: {\n      b: {\n        c: false, // <---- values added!\n        d: false, // <---- values added!\n      },\n      x: \"x\",\n    },\n    z: \"z\",\n  }\n);"}},"object-flatten-all-arrays":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { flattenAllArrays } from \"object-flatten-all-arrays\";\n\nassert.deepEqual(\n  flattenAllArrays({\n    a: \"a\",\n    b: \"b\",\n    c: [\n      {\n        b: \"b\",\n        a: \"a\",\n      },\n      {\n        d: \"d\",\n        c: \"c\",\n      },\n    ],\n  }),\n  {\n    a: \"a\",\n    b: \"b\",\n    c: [\n      {\n        a: \"a\",\n        b: \"b\",\n        c: \"c\",\n        d: \"d\",\n      },\n    ],\n  }\n);"}},"object-flatten-referencing":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { flattenReferencing } from \"object-flatten-referencing\";\n\nassert.deepEqual(\n  flattenReferencing(\n    {\n      key1: \"val11.val12\",\n      key2: \"val21.val22\",\n    },\n    {\n      key1: \"Contact us\",\n      key2: \"Tel. 0123456789\",\n    }\n  ),\n  {\n    key1: \"%%_val11.val12_%%\",\n    key2: \"%%_val21.val22_%%\",\n  }\n);"}},"object-merge-advanced":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { mergeAdvanced } from \"object-merge-advanced\";\n\nassert.deepEqual(\n  mergeAdvanced(\n    {\n      a: [\"c\"],\n      m: \"n\",\n    },\n    {\n      a: \"b\",\n      k: \"l\",\n    },\n    {\n      ignoreKeys: [\"a\"],\n    }\n  ),\n  {\n    a: [\"c\"],\n    k: \"l\",\n    m: \"n\",\n  }\n);"}},"object-no-new-keys":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { noNewKeys } from \"object-no-new-keys\";\n\nassert.deepEqual(\n  noNewKeys(\n    {\n      a: {\n        b: \"b\",\n        c: \"c\",\n      },\n      x: \"y\",\n    },\n    {\n      a: {\n        c: \"z\",\n      },\n    }\n  ),\n  [\"a.b\", \"x\"]\n);"}},"object-set-all-values-to":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { setAllValuesTo } from \"object-set-all-values-to\";\n\nassert.deepEqual(\n  setAllValuesTo({\n    a: \"a\",\n    b: \"b\",\n    c: \"c\",\n    d: \"d\",\n  }),\n  {\n    a: false,\n    b: false,\n    c: false,\n    d: false,\n  }\n);\n\n// you can change the default \"false\" to something else:\nassert.deepEqual(\n  setAllValuesTo(\n    {\n      a: \"a\",\n      b: \"b\",\n      c: \"c\",\n      d: \"d\",\n    },\n    \"x\"\n  ),\n  {\n    a: \"x\",\n    b: \"x\",\n    c: \"x\",\n    d: \"x\",\n  }\n);"}},"ranges-apply":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rApply } from \"ranges-apply\";\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\nconst ranges = [\n  [4, 19, \"bad grey wolf\"],\n  [35, 43, \"little Red Riding Hood\"],\n];\nassert.equal(\n  rApply(oldString, ranges),\n  \"The bad grey wolf jumps over the little Red Riding Hood.\"\n);"}},"ranges-crop":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rCrop } from \"ranges-crop\";\n\nassert.deepEqual(\n  rCrop(\n    [\n      [2, 3],\n      [9, 10, \"bad grey wolf\"],\n      [1, 2],\n    ],\n    7\n  ),\n  [[1, 3]] // sorted, merged and cropped\n);"}},"ranges-ent-decode":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rEntDecode } from \"ranges-ent-decode\";\n\n// see codsen.com/ranges/\nassert.deepEqual(rEntDecode(\"a &#x26; b &amp; c\"), [\n  [2, 8, \"&\"], // <--- that's Ranges notation, instructing to replace\n  [11, 16, \"&\"],\n]);"}},"ranges-invert":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rInvert } from \"ranges-invert\";\n\nassert.deepEqual(\n  rInvert(\n    [\n      [3, 5],\n      [5, 7],\n    ],\n    9 // string length needed to set the boundary\n  ),\n  [\n    [0, 3],\n    [7, 9],\n  ]\n);"}},"ranges-is-index-within":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isIndexWithin } from \"ranges-is-index-within\";\n\nassert.equal(\n  isIndexWithin(8, [\n    [1, 2],\n    [5, 10],\n  ]),\n  true\n);\n\nassert.equal(\n  isIndexWithin(12, [\n    [1, 2],\n    [5, 10],\n  ]),\n  false\n);"}},"ranges-iterate":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rIterate } from \"ranges-iterate\";\n\n// Ranges in the following example \"punches out\" a \"hole\" from `a` to `g`\n// (included), replacing it with `xyz`. That's what gets iterated.\n\nconst gathered = [];\n\n// a callback-based interface:\nrIterate(\"abcdefghij\", [[0, 7, \"xyz\"]], ({ i, val }) => {\n  gathered.push(`i = ${i}; val = ${val}`);\n});\n\nassert.deepEqual(gathered, [\n  \"i = 0; val = x\",\n  \"i = 1; val = y\",\n  \"i = 2; val = z\",\n  \"i = 3; val = h\",\n  \"i = 4; val = i\",\n  \"i = 5; val = j\",\n]);"}},"ranges-merge":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rMerge } from \"ranges-merge\";\n\n// joining edges:\nassert.deepEqual(\n  rMerge([\n    [1, 2],\n    [2, 3],\n    [9, 10],\n  ]),\n  [\n    [1, 3],\n    [9, 10],\n  ]\n);\n\n// an overlap:\nassert.deepEqual(\n  rMerge([\n    [1, 5],\n    [2, 10],\n  ]),\n  [[1, 10]]\n);"}},"ranges-offset":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rOffset } from \"ranges-offset\";\n\nassert.deepEqual(\n  rOffset(\n    [\n      [3, 5],\n      [8, 7],\n    ],\n    10\n  ),\n  [\n    [13, 15],\n    [18, 17],\n  ]\n);\n\n// ranges are empty, nothing happens:\nassert.deepEqual(rOffset(null, 10), null);\n\n// if input does not resemble ranges, nothing happens:\nassert.deepEqual(rOffset(true, 10), true);"}},"ranges-process-outside":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rProcessOutside } from \"ranges-process-outside\";\n\nconst gathered = [];\n\n// a callback interface:\nrProcessOutside(\n  \"abcdefghij\",\n  [\n    [1, 5], // delete from \"b\" to \"f\"\n  ],\n  (fromIdx, toIdx, offsetValueCb) => {\n    gathered.push(fromIdx);\n  }\n);\n\nassert.deepEqual(gathered, [0, 5, 6, 7, 8, 9]);"}},"ranges-push":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { Ranges } from \"ranges-push\";\nimport { rApply } from \"ranges-apply\";\n\nconst gatheredRanges = new Ranges();\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\n\n// push the ranges\ngatheredRanges.push(35, 43, \"little Red Riding Hood\");\ngatheredRanges.push(4, 19, \"bad grey wolf\");\n\n// retrieve the merged and sorted ranges by calling .current()\nassert.deepEqual(gatheredRanges.current(), [\n  [4, 19, \"bad grey wolf\"],\n  [35, 43, \"little Red Riding Hood\"],\n]);\n\nassert.equal(\n  rApply(oldString, gatheredRanges.current()),\n  \"The bad grey wolf jumps over the little Red Riding Hood.\"\n);\n\n// wipe all gathered ranges\ngatheredRanges.wipe();\nassert.equal(gatheredRanges.current(), null);"}},"ranges-regex":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rRegex } from \"ranges-regex\";\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\nconst result = rRegex(/the/gi, oldString);\n\n// all regex matches, but in Ranges notation (see codsen.com/ranges/):\nassert.deepEqual(result, [\n  [0, 3],\n  [31, 34],\n]);\n\n// if you slice the ranges, you'll get original regex caught values:\nassert.deepEqual(\n  result.map(([from, to]) => oldString.slice(from, to)),\n  [\"The\", \"the\"]\n);"},"clashing-replacements.js":{"title":"Clashing replacement values","code":"import { strict as assert } from \"assert\";\n\nimport { rRegex } from \"ranges-regex\";\nimport { rApply } from \"ranges-apply\";\nimport { Ranges } from \"ranges-push\";\n\n// Two tasks:\n// 1. replace numbers with asterisks (*)\n// 2. but delete all zero chunks\n\n// tasks clash\n\nconst source = \"sequence: 1234 5678 0000 1234\";\nconst gatheredRanges = new Ranges();\n// now can push() new ranges into \"gatheredRanges\"\n\n// 1.\n\n// conceal number chunks:\nconst fix1 = rRegex(/\\d/g, source, \"*\");\n// \\d matches digit\nassert.deepEqual(fix1, [\n  [10, 14, \"****\"],\n\n  [15, 19, \"****\"],\n\n  [20, 24, \"****\"],\n\n  [25, 29, \"****\"],\n]);\n// replacement is correct:\nassert.equal(rApply(source, fix1), \"sequence: **** **** **** ****\");\n// push it in:\ngatheredRanges.push(fix1);\n\n// 2.\n\n// delete zero chunks:\nconst fix2 = rRegex(/\\b[0]+\\b/g, source);\nassert.deepEqual(fix2, [[20, 24]]);\n// deletion is correct:\nassert.equal(rApply(source, fix2), \"sequence: 1234 5678  1234\");\n// push it in:\ngatheredRanges.push(fix2);\n\n// 3. - MERGE and APPLY\n\n// what have we got in \"gatheredRanges\"?\nassert.deepEqual(gatheredRanges.current(), [\n  [10, 14, \"****\"],\n  [15, 19, \"****\"],\n  [20, 24, \"****\"],\n  [25, 29, \"****\"],\n]);\n// notice [[19, 23, \"brown\"]] is absent - \"ranges-merge\" program detected\n// we're deleting an encompassing range of indexes [12, 29] which\n// encompasses to-be-inserted values range at [19, 23] and discarded the\n// latter.\n\n// apply both fixes in one go:\nassert.equal(\n  rApply(source, gatheredRanges.current()),\n  \"sequence: **** **** **** ****\"\n);\n\n// hey, the zero chunk deletion range [20, 24] was merged with\n// replacement range [20, 24, \"****\"] and former got lost!\n\n// How do we make that the deletion would make precedence over everything\n// else?\n\n// Answer is, put `null` in replacement. It will be interpreted as explicit\n// deletion.\n\n// insert null as replacement:\nconst fix3 = rRegex(/\\b[0]+\\b/g, source, null);\nassert.deepEqual(fix3, [[20, 24, null]]);\n// deletion is correct:\nassert.equal(rApply(source, fix3), \"sequence: 1234 5678  1234\");\n\n// wipe the \"gatheredRanges\"\ngatheredRanges.wipe();\n\n// push again\ngatheredRanges.push(fix1); // asterisks\ngatheredRanges.push(fix3); // zero chunk\n\n// apply again:\nassert.equal(\n  rApply(source, gatheredRanges.current()),\n  \"sequence: **** ****  ****\"\n);\n// null in [20, 24, null] overrode the insertion instruction [20, 24, \"****\"]"},"nothing-to-find.js":{"title":"Nothing was found","code":"import { strict as assert } from \"assert\";\n\nimport { rRegex } from \"ranges-regex\";\n\nassert.equal(rRegex(/abc/g, \"xyz\"), null);\n// Falsy null means no ranges, other Ranges ecosystem\n// packages will accept null as input value\n// For the record, an empty array is truthy"},"replacement-mini.js":{"title":"Replacing values","code":"import { strict as assert } from \"assert\";\n\nimport { rRegex } from \"ranges-regex\";\nimport { rApply } from \"ranges-apply\";\n\n// Task: fix \"brow\" typo using regex and Ranges\n\nconst source = \"the typo in 'quick brow fox' sentence\";\n\n// 1. \"brow\"\nconst fix1 = rRegex(/\\bbrow\\b/g, source);\n// \\b matches word boundary\nassert.deepEqual(fix1, [[19, 23]]);\n// apply ranges to get the result string:\nassert.equal(rApply(source, fix1), \"the typo in 'quick  fox' sentence\");\n\n// But in Ranges terms, two elements mean deletion range, not replacement!\n// For replacement, you add a third element, value to put.\nconst fix2 = rRegex(/\\bbrow\\b/g, source, \"brown\");\n// \\b matches word boundary\nassert.deepEqual(fix2, [[19, 23, \"brown\"]]);\n// apply ranges to get the result string:\nassert.equal(rApply(source, fix2), \"the typo in 'quick brown fox' sentence\");"}},"ranges-sort":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { rSort } from \"ranges-sort\";\n\n// Ranges (see codsen.com/ranges/) are sorted:\nassert.deepEqual(\n  rSort([\n    [2, 3],\n    [9, 10, \"bad grey wolf\"],\n    [1, 2],\n  ]),\n  [\n    [1, 2],\n    [2, 3],\n    [9, 10, \"bad grey wolf\"],\n  ]\n);"}},"regex-empty-conditional-comments":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { emptyCondCommentRegex } from \"regex-empty-conditional-comments\";\n\n// empty comment which was meant to target Outlook-only\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if !mso]>\n<![endif]-->`),\n  true\n);\n\n// empty comment which was meant to target non-Outlook-only\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if !mso]><!-- -->\n<!--<![endif]-->`),\n  true\n);\n\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if !mso]><!-- -->\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<!--<![endif]-->`),\n  false\n);\n\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if gte mso 9]><xml>\n<o:OfficeDocumentSettings>\n<o:AllowPNG/>\n<o:PixelsPerInch>96</o:PixelsPerInch>\n</o:OfficeDocumentSettings>\n</xml><![endif]-->`),\n  false\n);\n\nassert.equal(\n  emptyCondCommentRegex().exec(\"<html><!--[if !mso]><![endif]--><title>\")[0],\n  \"<!--[if !mso]><![endif]-->\"\n);\n\nassert.deepEqual(\n  `<html> <!--[if !mso]><![endif]--> <title>text</title> <!--[if gte mso 9]>\n<xml>\n<![endif]-->`.match(emptyCondCommentRegex()),\n  [\"<!--[if !mso]><![endif]-->\"]\n);"}},"regex-is-jinja-nunjucks":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isJinjaNunjucksRegex } from \"regex-is-jinja-nunjucks\";\n\n// detects Jinja/Nunjucks code\nassert.equal(\n  isJinjaNunjucksRegex().test(\n    `<div>{% if data.purchases.count > 1 %}these{% else %}this{% endif %}</div>`\n  ),\n  true\n);\n\n// in case if it's not nunjucks\nassert.equal(isJinjaNunjucksRegex().test(`<div>tralala</div>`), false);"}},"regex-is-jsp":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isJSP } from \"regex-is-jsp\";\n\n// detects JSP code\nassert.equal(isJSP().test(`<div><% out.println(\"Hi!\"); %></div>`), true);\n\n// in case if it's not JSP\nassert.equal(isJSP().test(`<div>text</div>`), false);"}},"regex-jinja-specific":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { isJinjaSpecific } from \"regex-jinja-specific\";\n\nassert.equal(\n  isJinjaSpecific().test(`<div>{{ '%.2f'|format(3.1415926) }}</div>`),\n  true\n);\n\n// in case of ambiguous, Nunjucks-or-Jinja code\nassert.equal(isJinjaSpecific().test(`<div>{{ value }}</div>`), false);"}},"str-indexes-of-plus":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { strIndexesOfPlus } from \"str-indexes-of-plus\";\n\n// searches for string in a string, returns array:\nassert.deepEqual(strIndexesOfPlus(\"abc-abc-abc-abc\", \"abc\"), [0, 4, 8, 12]);\n\n// all graphemes are counted as one, emoji too:\nassert.deepEqual(\n  strIndexesOfPlus(\"🐴-🦄\", \"🦄\"),\n  [2] // not [3] considering unicorn is 2-characters long\n);\n\n// you can offset the start of a search:\nassert.deepEqual(strIndexesOfPlus(\"abczabc\", \"abc\", 3), [4]);"}},"string-apostrophes":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { convertOne, convertAll } from \"string-apostrophes\";\n\nassert.deepEqual(\n  convertAll(`In the '60s, rock 'n' roll`, {\n    convertApostrophes: true,\n    convertEntities: false,\n  }),\n  {\n    result: \"In the ’60s, rock ’n’ roll\",\n    ranges: [\n      [7, 8, \"’\"],\n      [18, 21, \"’n’\"],\n    ],\n  }\n);\n\nassert.deepEqual(\n  convertOne(`test's`, {\n    from: 4,\n    to: 5,\n    convertApostrophes: true,\n    convertEntities: true,\n  }),\n  [[4, 5, \"&rsquo;\"]]\n);"}},"string-bionic-split":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { split } from \"string-bionic-split\";\n\nconst sources = [\n  \"the\",\n  \"quick\",\n  \"brown\",\n  \"fox\",\n  \"jumps\",\n  \"over\",\n  \"a\",\n  \"lazy\",\n  \"dog\",\n];\n\nconst splitSources = sources.map(\n  (str) => `${str.slice(0, split(str))} + ${str.slice(split(str))}`\n);\n\nassert.deepEqual(splitSources, [\n  \"t + he\",\n  \"qui + ck\",\n  \"bro + wn\",\n  \"f + ox\",\n  \"jum + ps\",\n  \"ov + er\",\n  \"a + \",\n  \"la + zy\",\n  \"d + og\",\n]);"}},"string-character-is-astral-surrogate":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  isHighSurrogate,\n  isLowSurrogate,\n} from \"string-character-is-astral-surrogate\";\n\n// 🧢 = \\uD83E\\uDDE2\n\nassert.equal(isHighSurrogate(\"\\uD83E\"), true);\n// the first character, high surrogate of the cap is indeed a high surrogate\n\nassert.equal(isHighSurrogate(\"\\uDDE2\"), false);\n// the second character, low surrogate of the cap is NOT a high surrogate\n\nassert.equal(isLowSurrogate(\"\\uD83E\"), false);\n// the first character, high surrogate of the cap is NOT a low surrogate\n// it's a high surrogate\n\nassert.equal(isLowSurrogate(\"\\uDDE2\"), true);\n// the second character, low surrogate of the cap is indeed a low surrogate"}},"string-collapse-leading-whitespace":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { collWhitespace } from \"string-collapse-leading-whitespace\";\n\n// if leading/trailing whitespace doesn't contain \\n, collapse to a single space\nassert.equal(collWhitespace(\"  aaa   \"), \" aaa \");\n\n// otherwise, collapse to a single \\n (default setting)\nassert.equal(collWhitespace(\"     \\n\\n   aaa  \\n\\n\\n    \"), \"\\naaa\\n\");\n\n// does nothing to trimmed strings:\nassert.equal(collWhitespace(\"aaa\"), \"aaa\");\n\n// if there are multiple lines string is still processed in trim-fashion -\n// only beginning and ending whitespace is changed:\nassert.equal(\n  collWhitespace(\"  abc  \\n  def  \\n  ghi  \"),\n  \" abc  \\n  def  \\n  ghi \"\n);"}},"string-collapse-white-space":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { collapse } from \"string-collapse-white-space\";\n\nassert.equal(\n  collapse(\"  aaa     bbb    ccc   dddd  \").result,\n  \"aaa bbb ccc dddd\"\n);\n\nassert.equal(collapse(\"   \\t\\t\\t   aaa   \\t\\t\\t   \").result, \"aaa\");\n\nassert.equal(\n  collapse(\"   aaa   bbb  \\n    ccc   ddd   \", { trimLines: false }).result,\n  \"aaa bbb \\n ccc ddd\"\n);\n\nassert.equal(\n  collapse(\"   aaa   bbb  \\n    ccc   ddd   \", { trimLines: true }).result,\n  \"aaa bbb\\nccc ddd\"\n);\n\n// \\xa0 is an unencoded non-breaking space:\nassert.equal(\n  collapse(\n    \"     \\xa0    aaa   bbb    \\xa0    \\n     \\xa0     ccc   ddd   \\xa0   \",\n    { trimLines: true, trimnbsp: true }\n  ).result,\n  \"aaa bbb\\nccc ddd\"\n);"},"cb.js":{"title":"Minify a chunk of CSS selector","code":"import { strict as assert } from \"assert\";\n\nimport { collapse } from \"string-collapse-white-space\";\n\nassert.equal(\n  collapse(`div > span`, {\n    cb: ({ suggested, whiteSpaceStartsAt, whiteSpaceEndsAt, str }) => {\n      if (str[whiteSpaceStartsAt - 1] === \">\") {\n        // console.log(`> on the left! - wipe this whitespace`);\n        return [whiteSpaceStartsAt, whiteSpaceEndsAt];\n      }\n      if (str[whiteSpaceEndsAt] === \">\") {\n        // console.log(`> on the right! - wipe this whitespace`);\n        return [whiteSpaceStartsAt, whiteSpaceEndsAt];\n      }\n      return suggested;\n    },\n  }).result,\n  \"div>span\"\n);"}},"string-convert-indexes":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  nativeToUnicode,\n  unicodeToNative,\n} from \"string-convert-indexes\";\n\n// CONVERTING NATIVE JS INDEXES TO UNICODE-CHAR-COUNT-BASED\n// 𝌆 - \\uD834\\uDF06\n\n// at index 1, we have low surrogate, that's still grapheme index zero\nassert.equal(nativeToUnicode(\"\\uD834\\uDF06aa\", \"1\"), \"0\");\n// notice it's retained as string. The same type as input is retained!\n\n// at index 2, we have first letter a - that's second index, counting graphemes\nassert.equal(nativeToUnicode(\"\\uD834\\uDF06aa\", 3), 2);\n\n// convert many indexes at once - any nested data structure is fine:\nassert.deepEqual(nativeToUnicode(\"\\uD834\\uDF06aa\", [1, 0, 2, 3]), [0, 0, 1, 2]);\n\n// numbers from an AST-like complex structure are still picked out and converted:\nassert.deepEqual(nativeToUnicode(\"\\uD834\\uDF06aa\", [1, \"0\", [[[2]]], 3]), [\n  0, // notice matching type is retained\n  \"0\", // notice matching type is retained\n  [[[1]]],\n  2,\n]);\n\n// CONVERTING UNICODE-CHAR-COUNT-BASED TO NATIVE JS INDEXES\n// 𝌆 - \\uD834\\uDF06\n\nassert.deepEqual(unicodeToNative(\"\\uD834\\uDF06aa\", [0, 1, 2]), [0, 2, 3]);\n\nassert.deepEqual(unicodeToNative(\"\\uD834\\uDF06aa\", [1, 0, 2]), [2, 0, 3]);\n\nassert.throws(() => unicodeToNative(\"\\uD834\\uDF06aa\", [1, 0, 2, 3]));\n// throws an error!\n// that's because there's no character (counting Unicode characters) with index 3\n// we have only three Unicode characters, so indexes go only up until 2"}},"string-extract-class-names":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { extract } from \"string-extract-class-names\";\n\n// extracts classes and/or id's\nconst str = \"div#brambles.nushes#croodles\";\nconst { res, ranges } = extract(str);\nassert.deepEqual(res, [\"#brambles\", \".nushes\", \"#croodles\"]);\nassert.deepEqual(ranges, [\n  [3, 12],\n  [12, 19],\n  [19, 28],\n]);\n\n// `res` can be produced by slicing `ranges`:\nassert.deepEqual(\n  res,\n  ranges.map(([from, to]) => str.slice(from, to))\n);"},"bracket-notation.js":{"title":"Supports legacy bracket notation emails used to use","code":"import { strict as assert } from \"assert\";\n\nimport { extract } from \"string-extract-class-names\";\n\n// Yahoo has changed many years ago so email template\n// must be really arcane to contain this notation\n// https://github.com/hteumeuleu/email-bugs/issues/49\n\nassert.deepEqual(extract(`td[id=\" abc-def \"]`), {\n  res: [\"#abc-def\"],\n  ranges: [[8, 15]],\n});\n\n// notice the hash # is not covered by range indexes!"},"contrived-complex.js":{"title":"Non-parsing algorithm can tackle really dodgy CSS","code":"import { strict as assert } from \"assert\";\n\nimport { extract } from \"string-extract-class-names\";\n\n// probably invalid input, but works anyway:\nassert.deepEqual(extract(\"?#id1#id2? #id3#id4> p > #id5#id6\").res, [\n  \"#id1\",\n  \"#id2\",\n  \"#id3\",\n  \"#id4\",\n  \"#id5\",\n  \"#id6\",\n]);"},"with-space.js":{"title":"Processes whole CSS selectors","code":"import { strict as assert } from \"assert\";\n\nimport { extract } from \"string-extract-class-names\";\n\nassert.deepEqual(extract(\"div.first.second#third a[target=_blank]\").res, [\n  \".first\",\n  \".second\",\n  \"#third\",\n]);"}},"string-extract-sass-vars":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { extractVars } from \"string-extract-sass-vars\";\n\nassert.deepEqual(\n  extractVars(`// all variables are here!!!\n// ------------------------------------------\n$red: #ff6565; // this is red\n// $green: #63ffbd; // no green here\n$yellow: #ffff65; // this is yellow\n$blue: #08f0fd; // this is blue\n$fontfamily: Helvetica, sans-serif;\n$border: 1px solid #dedede;\n$borderroundedness: 3px;\n$customValue1: tralala;\n$customValue2: tralala;\n// don't mind this comment about #ff6565;\n$customValue3: 10;`),\n  {\n    red: \"#ff6565\",\n    yellow: \"#ffff65\",\n    blue: \"#08f0fd\",\n    fontfamily: \"Helvetica, sans-serif\",\n    border: \"1px solid #dedede\",\n    borderroundedness: \"3px\",\n    customValue1: \"tralala\",\n    customValue2: \"tralala\",\n    customValue3: 10,\n  }\n);"},"opts-cb.js":{"title":"Convert 3-digit color hex codes to 6-digit","code":"import { strict as assert } from \"assert\";\nimport { conv } from \"color-shorthand-hex-to-six-digit\";\n\nimport { extractVars } from \"string-extract-sass-vars\";\n// import \"color-shorthand-hex-to-six-digit\" to convert three-digit colour hex\n// codes to six-digit:\n\nassert.deepEqual(\n  extractVars(\"$blue: #2af;\", {\n    throwIfEmpty: true,\n    cb: (val) => conv(val), // converts hex codes only, bypasses the rest\n  }),\n  { blue: \"#22aaff\" }\n);"},"throw-if-empty.js":{"title":"Raises alarm if variables file has been wiped","code":"import { strict as assert } from \"assert\";\n\nimport { extractVars } from \"string-extract-sass-vars\";\n\nassert.throws(() =>\n  extractVars(\"\", {\n    throwIfEmpty: true,\n  })\n);"}},"string-find-heads-tails":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { strFindHeadsTails } from \"string-find-heads-tails\";\n\n// processing an arbitrary, custom templating markup:\nassert.deepEqual(\n  strFindHeadsTails(\n    \"some text %%_var1-%% more text %%_var2_%%\",\n    [\"%%_\", \"%%-\"], // two flavours of heads\n    [\"-%%\", \"_%%\"] // two flavours of tails\n  ),\n  [\n    {\n      headsStartAt: 10,\n      headsEndAt: 13,\n      tailsStartAt: 17,\n      tailsEndAt: 20,\n    },\n    {\n      headsStartAt: 31,\n      headsEndAt: 34,\n      tailsStartAt: 38,\n      tailsEndAt: 41,\n    },\n  ]\n);"}},"string-find-malformed":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { findMalformed } from \"string-find-malformed\";\n\n// Below, we look for dodgy cases of `<!--`\nconst gathered = [];\nfindMalformed(\n  \"<div><!-something--></div>\",\n  \"<!--\",\n  // your callback function:\n  (obj) => {\n    gathered.push(obj);\n  },\n  {\n    maxDistance: 1, // Levenshtein distance\n  }\n);\nassert.deepEqual(gathered, [\n  {\n    idxFrom: 5,\n    idxTo: 8,\n  },\n]);"}},"string-fix-broken-named-entities":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\nimport { rApply } from \"ranges-apply\";\n\nimport { fixEnt } from \"string-fix-broken-named-entities\";\n\nconst source = \"&nsp;x&nsp;y&nsp;\";\n\n// returns Ranges notation, see codsen.com/ranges/\nassert.deepEqual(fixEnt(source), [\n  [0, 5, \"&nbsp;\"],\n  [6, 11, \"&nbsp;\"],\n  [12, 17, \"&nbsp;\"],\n]);\n\n// render result from ranges using \"ranges-apply\":\nassert.equal(rApply(source, fixEnt(source)), \"&nbsp;x&nbsp;y&nbsp;\");"},"sift-raw-ampersands-from-entities.js":{"title":"Sift raw ampersands in a string from broken character references","code":"// encode those raw ampersands and fix broken character references\n\nimport { strict as assert } from \"assert\";\nimport { rApply } from \"ranges-apply\";\n\nimport { fixEnt } from \"string-fix-broken-named-entities\";\n\nconst source = \"&&nsp;&&nsp;&\";\n\nconst finalRanges = [];\nconst indexesOfRawAmpersands = [];\n\n// fixEnt() returns Ranges (see codsen.com/ranges/)\nconst resultRanges = fixEnt(source, {\n  textAmpersandCatcherCb: (idx) => indexesOfRawAmpersands.push(idx),\n});\n\n// check the ranges - all broken NBSP's were fixed:\nassert.deepEqual(resultRanges, [\n  [1, 6, \"&nbsp;\"],\n  [7, 12, \"&nbsp;\"],\n]);\n\n// don't apply the ranges yet, dump them into the \"finalRanges\" array\n// it's because applying them onto a string,\n// rApply(source, resultRanges);\n// will mess up the index positions, we'll need to calculate again.\n// The whole point of Ranges is they're COMPOSABLE.\n\nresultRanges.forEach((range) => {\n  finalRanges.push(range);\n});\n\n// check the positions of reported raw ampersands:\nassert.deepEqual(indexesOfRawAmpersands, [0, 6, 12]);\n\n// replace each character at these positions: 0, 6 and 12\n// with string \"&amp;\" - in terms of Ranges, it's a matter\n// of building a Ranges array:\nconst replacementRanges = indexesOfRawAmpersands.map((idx) => [\n  idx,\n  idx + 1,\n  \"&amp;\",\n]);\n// this is Ranges notation, array of arrays: [from index, to index, what-to-replace]\nassert.deepEqual(replacementRanges, [\n  [0, 1, \"&amp;\"], // we're saying, replace indexes from 0 to 1 with &amp;\n  [6, 7, \"&amp;\"],\n  [12, 13, \"&amp;\"],\n]);\n\n// push them into resultRanges as well:\nreplacementRanges.forEach((range) => {\n  resultRanges.push(range);\n});\n\n// check what's been gathered so far:\nassert.deepEqual(resultRanges, [\n  [1, 6, \"&nbsp;\"],\n  [7, 12, \"&nbsp;\"],\n  [0, 1, \"&amp;\"],\n  [6, 7, \"&amp;\"],\n  [12, 13, \"&amp;\"],\n]);\n\n// apply Ranges onto a string - all amendments at once!\nconst finalResultStr = rApply(source, resultRanges);\n\n// check result\nassert.equal(finalResultStr, \"&amp;&nbsp;&amp;&nbsp;&amp;\");\n\n// Voilà! We fixed broken entities and encoded raw ampersands"}},"string-left-right":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  left,\n  right,\n  leftSeq,\n  rightSeq,\n  chompLeft,\n  chompRight,\n  leftStopAtNewLines,\n  rightStopAtNewLines,\n} from \"string-left-right\";\n\n// get the closest non-whitespace character to the left of \"d\" (which itself\n// is at string index 6)\nconst str = \"abc   def\";\n//             |   |\n//           012345678\n\nassert.equal(\n  `next non-whitespace character to the left of ${str[6]} (index 6) is ${\n    str[left(str, 6)]\n  } (index ${left(str, 6)})`,\n  \"next non-whitespace character to the left of d (index 6) is c (index 2)\"\n);"}},"string-match-left-right":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport {\n  matchLeftIncl,\n  matchRightIncl,\n  matchLeft,\n  matchRight,\n} from \"string-match-left-right\";\n\n// 3rd character is \"d\" because indexes start from zero.\n// We're checking the string to the left of it, \"bcd\", inclusive of current character (\"d\").\n// This means, \"bcd\" has to end with existing character and the other chars to the left\n// must match exactly:\nassert.equal(matchLeftIncl(\"abcdefghi\", 3, [\"bcd\"]), \"bcd\");\n\n// neither \"ab\" nor \"zz\" are to the left of 3rd index, \"d\":\nassert.equal(matchLeft(\"abcdefghi\", 3, [\"ab\", `zz`]), false);\n\n// \"def\" is to the right of 3rd index (including it), \"d\":\nassert.equal(matchRightIncl(\"abcdefghi\", 3, [\"def\", `zzz`]), \"def\");\n\n// One of values, \"ef\" is exactly to the right of 3rd index, \"d\":\nassert.equal(matchRight(\"abcdefghi\", 3, [\"ef\", `zz`]), \"ef\");"},"cb.js":{"title":"The Callback Use","code":"import { strict as assert } from \"assert\";\n\nimport {\n  matchLeftIncl,\n  matchRightIncl,\n  matchLeft,\n  matchRight,\n} from \"string-match-left-right\";\n\n// imagine you looped the string and wanted to catch where does attribute \"class\" start\n// and end (not to mention to ensure that it's a real attribute, not something ending with this\n// string \"class\").\n// You catch \"=\", an index number 8.\n// This library can check, is \"class\" to the left of it and feed what's to the left of it\n// to your supplied callback function, which happens to be a checker \"is it a space\":\nfunction isSpace(char) {\n  return typeof char === \"string\" && char.trim() === \"\";\n}\n\nassert.equal(\n  matchLeft('<a class=\"something\">', 8, \"class\", { cb: isSpace }),\n  \"class\"\n);"}},"string-overlap-one-on-another":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { overlap } from \"string-overlap-one-on-another\";\n\nassert.equal(overlap(\"aaa\", \"bbb\", { offset: -2 }), \"bbbaa\");"},"empty-str.js":{"title":"Empty Strings","code":"import { strict as assert } from \"assert\";\n\nimport { overlap } from \"string-overlap-one-on-another\";\n\nassert.equal(\n  overlap(\"\", \"456\", { offset: 99, offsetFillerCharacter: \"zzzz\" }),\n  \"456\"\n);\n// even though offset is long enough to warrant the filler, no characters\n// are added to the \"456\" because the first argument string is empty."}},"string-process-comma-separated":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { processCommaSep } from \"string-process-comma-separated\";\n\nconst gatheredChunks = [];\nconst gatheredErrors = [];\nconst rawnbsp = \"\\u00a0\";\n\n// it's a callback-interface:\nprocessCommaSep(`<FRAMESET rows=\" ,,\\t50% ,${rawnbsp} 50% ,\\t\\t,\">`, {\n  from: 16, // <- beginning of the attribute's value\n  to: 35, // <- ending of the attribute's value\n  separator: \",\",\n  cb: (idxFrom, idxTo) => {\n    gatheredChunks.push([idxFrom, idxTo]);\n  },\n  errCb: (ranges, message) => {\n    gatheredErrors.push({ ranges, message });\n  },\n});\n\nassert.deepEqual(gatheredChunks, [\n  [20, 23],\n  [27, 30],\n]);\n\nassert.deepEqual(gatheredErrors, [\n  { ranges: [[16, 17]], message: \"Remove whitespace.\" },\n  { ranges: [[17, 18]], message: \"Remove separator.\" },\n  { ranges: [[18, 19]], message: \"Remove separator.\" },\n  { ranges: [[19, 20]], message: \"Remove whitespace.\" },\n  { ranges: [[23, 24]], message: \"Remove whitespace.\" },\n  { ranges: [[25, 27]], message: \"Remove whitespace.\" },\n  { ranges: [[30, 31]], message: \"Remove whitespace.\" },\n  { ranges: [[32, 34]], message: \"Remove whitespace.\" },\n  { ranges: [[31, 32]], message: \"Remove separator.\" },\n  { ranges: [[34, 35]], message: \"Remove separator.\" },\n]);"}},"string-range-expander":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { expander } from \"string-range-expander\";\n\n// let's say we have picked the \"zzzz\" index range - [16, 20]\n// \"something>\\n\\t    zzzz <here\"\n//                    |   |\n//                  from  to\n//\n// PS. \"\\n\" and \"\\t\" take up a single character's length\n\nassert.deepEqual(\n  expander({\n    str: \"something>\\n\\t    zzzz <here\",\n    from: 16,\n    to: 20,\n    ifRightSideIncludesThisThenCropTightly: \"<\",\n  }),\n  [10, 21]\n);"}},"string-remove-duplicate-heads-tails":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { remDup } from \"string-remove-duplicate-heads-tails\";\n\nassert.equal(\n  remDup(\"{{ Hi {{ first_name }}! }}\", {\n    heads: \"{{ \",\n    tails: \" }}\",\n  }),\n  \"Hi {{ first_name }}!\"\n);"}},"string-remove-thousand-separators":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { remSep } from \"string-remove-thousand-separators\";\n\n// 🇬🇧 🇺🇸 thousand separators:\nassert.equal(remSep(\"1,000,000.00\"), \"1000000.00\");\n\n// 🇷🇺  thousand separators:\nassert.equal(remSep(\"1 000 000,00\"), \"1000000,00\");\n// (if you want it converted to Western notation with dot,\n// set opts.forceUKStyle = true\n\n// 🇨🇭 thousand separators:\nassert.equal(remSep(\"1'000'000.00\"), \"1000000.00\");\n\n// IT'S SMART TOO:\n\n// will not delete if the thousand separators are mixed:\nconst input = \"100,000,000.000\";\nassert.equal(remSep(input), input);\n// ^ does nothing\n\n// but will remove empty space, even if there is no decimal separator:\n// (that's to cope with Russian notation integers that use thousand separators)\nassert.equal(remSep(\"100 000 000 000\"), \"100000000000\");\n\n// while removing thousand separators, it will also pad the digits to two decimal places\n// (optional, on by default, to turn it off set opts.padSingleDecimalPlaceNumbers to `false`):\nassert.equal(remSep(\"100,000.2\"), \"100000.20\");\nconsole.log();\n// ^ Western notation\n\nassert.equal(remSep(\"100 000,2\"), \"100000,20\");\n// ^ Russian notation\n\nassert.equal(remSep(\"100'000.2\"), \"100000.20\");\n// ^ Swiss notation"}},"string-remove-widows":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { removeWidows } from \"string-remove-widows\";\n\nconst { ranges, res } = removeWidows(\"Some text with many words on one line.\");\n\n// see codsen.com/ranges/\nassert.deepEqual(ranges, [[32, 33, \"&nbsp;\"]]);\n\nassert.equal(res, \"Some text with many words on one&nbsp;line.\");"},"widow-word-removal-from-html.js":{"title":"Widow word removal from text within HTML","code":"import { strict as assert } from \"assert\";\nimport { stripHtml } from \"string-strip-html\";\n\nimport { removeWidows } from \"string-remove-widows\";\n\nconst someHtml = `The quick brown fox jumps of the lazy dog.<div class=\"a\">`;\n\n// default widow word removal libs are not aware of HTML:\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  removeWidows(someHtml).res,\n  `The quick brown fox jumps of the lazy dog.<div&nbsp;class=\"a\">` // 😱\n);\n\n// luckily, removeWidows() consumes optional HTML tag locations\nassert.equal(\n  removeWidows(someHtml, {\n    tagRanges: stripHtml(someHtml)\n      // remove the third argument, what to insert (\"&nbsp;\" string in these cases)\n      .ranges.map(([from, to]) => [from, to]),\n  }).res,\n  `The quick brown fox jumps of the lazy&nbsp;dog.<div class=\"a\">` // ✅\n);"}},"string-split-by-whitespace":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { splitByW } from \"string-split-by-whitespace\";\n\n// Split by whitespace is easy - use native String.prototype.split()\nassert.deepEqual(\"abc  def ghi\".split(/\\s+/), [\"abc\", \"def\", \"ghi\"]);\n\nconst source = `\\n     \\n    a\\t \\nb    \\n      \\t`;\n\n// this program is nearly equivalent to regex-based split:\nassert.deepEqual(source.split(/\\s+/), [\"\", \"a\", \"b\", \"\"]);\nassert.deepEqual(splitByW(source), [\"a\", \"b\"]);\n// regex-based split needs more filtration but it's native solution\n\n// ADDITIONALLY...\n\n// this program allows to exclude certain index ranges:\nassert.deepEqual(\n  splitByW(\"a b c d e\", {\n    ignoreRanges: [[0, 2]], // that's \"a\" and space after it\n  }),\n  [\"b\", \"c\", \"d\", \"e\"]\n);"}},"string-strip-html":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\n\nassert.equal(\n  stripHtml(`Some text <b>and</b> text.`).result,\n  `Some text and text.`\n);\n\n// prevents accidental string concatenation\nassert.equal(stripHtml(`aaa<div>bbb</div>ccc`).result, `aaa bbb ccc`);\n\n// tag pairs with content, upon request\nassert.equal(\n  stripHtml(`a <pre><code>void a;</code></pre> b`, {\n    stripTogetherWithTheirContents: [\n      \"script\", // default\n      \"style\", // default\n      \"xml\", // default\n      \"pre\", // <-- custom-added\n    ],\n  }).result,\n  `a b`\n);\n\n// detects raw, legit brackets:\nassert.equal(stripHtml(`a < b and c > d`).result, `a < b and c > d`);"},"c-plus-plus.js":{"title":"Ignores code tags and their contents","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\n\nconst someHtml = `<code>#include <stdio.h>;</code> and <code>#include &lt;stdio.h&gt;</code>`;\n\n// default behaviour:\nassert.equal(stripHtml(someHtml).result, `#include; and #include`);\n\n// ignore <code> tag pairs\nassert.equal(\n  stripHtml(someHtml, {\n    ignoreTagsWithTheirContents: [\"code\"],\n    skipHtmlDecoding: true,\n  }).result,\n  someHtml\n);"},"cb-which-does-nothing.js":{"title":"A Bypass Callback and a Do-Nothing Callback","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\n\n// this callback just pushes proposed result to \"rangesArr\",\n// that's what gets used in the result calculation:\nconst cb1 = ({\n  tag,\n  deleteFrom,\n  deleteTo,\n  insert,\n  rangesArr,\n  proposedReturn,\n}) => {\n  rangesArr.push(deleteFrom, deleteTo, insert);\n};\nconst result1 = stripHtml(\"abc<hr>def\", { cb: cb1 }).result;\nassert.equal(result1, `abc def`);\n\n// to prove it works, don't do anything:\nconst cb2 = ({\n  tag,\n  deleteFrom,\n  deleteTo,\n  insert,\n  rangesArr,\n  proposedReturn,\n}) => {\n  // nothing here 🙈\n};\nconst result2 = stripHtml(\"abc<hr>def\", { cb: cb2 }).result;\nassert.equal(result2, \"abc<hr>def\");"},"extract-html-head-contents.js":{"title":"Extract HTML `<head>` contents","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>\n  <body>\n    the content\n  </body>\n</html>`;\n\n// The task asks not to include <head...> and </head>.\n// First, extract head tag-to-head tag, including contents\nconst headWithHeadTags = stripHtml(someHtml, {\n  onlyStripTags: [\"head\"],\n  stripTogetherWithTheirContents: [\"head\"],\n})\n  .filteredTagLocations.reduce(\n    (acc, [from, to]) => `${acc}${someHtml.slice(from, to)}`,\n    \"\"\n  )\n  .trim();\n\nassert.equal(\n  headWithHeadTags,\n  `<head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>`\n);\n\nconst headContents = headWithHeadTags.replace(/<\\/?head>/g, \"\").trim();\nassert.equal(\n  headContents,\n  `<meta charset=\"utf-8\">\n    <title>the title</title>`\n);"},"leave-href-and-label.js":{"title":"Retain href and link label","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\n\nconst someHtml = `<a href=\"https://twitter.com/loretparisi\">twitter:loretparisi&nbsp;&oslash;</a>`;\n\nassert.equal(\n  stripHtml(someHtml, {\n    skipHtmlDecoding: true,\n  }).result,\n  `twitter:loretparisi&nbsp;&oslash;`\n);\n\nassert.equal(\n  stripHtml(someHtml, {\n    skipHtmlDecoding: true,\n    cb: ({ tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn }) => {\n      let temp;\n      if (\n        tag.name === \"a\" &&\n        tag.attributes &&\n        tag.attributes.some((attr) => {\n          if (attr.name === \"href\") {\n            temp = attr.value;\n            return true;\n          }\n        })\n      ) {\n        rangesArr.push([deleteFrom, deleteTo, `${temp} ${insert || \"\"}`]);\n      } else {\n        rangesArr.push(proposedReturn);\n      }\n    },\n  }).result,\n  `https://twitter.com/loretparisi twitter:loretparisi&nbsp;&oslash;`\n);"},"leave-only-html.js":{"title":"Leave only HTML","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(\n  stripHtml(someHtml).allTagLocations.reduce(\n    (acc, [from, to]) => `${acc}${someHtml.slice(from, to)}`,\n    \"\"\n  ),\n  `<!DOCTYPE html><html lang=\"en\" dir=\"ltr\"><head><meta charset=\"utf-8\"><title></title></head><body><h1></h1></body></html>`\n);"},"leave-only-opening-td.js":{"title":"Leave only opening `td` tags","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\n// the first way\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  stripHtml(someHtml, {\n    // notice there's no: onlyStripTags: [\"td\"]\n    // we operate purely via callback\n    cb: ({ tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn }) => {\n      if (tag.name === \"td\" && !tag.slashPresent) {\n        rangesArr.push(proposedReturn);\n      }\n    },\n  }).ranges.reduce(\n    (acc, [from, to]) => `${acc}${someHtml.slice(from, to).trim()}`,\n    \"\"\n  ),\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);\n\n// the second way:\n// -----------------------------------------------------------------------------\n\nlet resultStr = \"\";\n// notice we don't even assign stripHtml() output to anything - we rely only\n// on the callback, it mutates the \"resultStr\" in the upper scope\nstripHtml(someHtml, {\n  // notice there's no: onlyStripTags: [\"td\"]\n  // we operate purely via callback\n  cb: ({ tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn }) => {\n    if (tag.name === \"td\" && !tag.slashPresent) {\n      resultStr += someHtml.slice(deleteFrom, deleteTo).trim();\n    }\n  },\n});\nassert.equal(\n  resultStr,\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);"},"leave-only-td.js":{"title":"Leave only `td` tags","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\nassert.equal(\n  stripHtml(someHtml, {\n    onlyStripTags: [\"td\"],\n  }).filteredTagLocations.reduce(\n    (acc, [from, to]) => `${acc}${someHtml.slice(from, to)}`,\n    \"\"\n  ),\n  `<td class=\"col1\"></td><td class=\"col2\"></td><td class=\"col3\"></td><td class=\"col4\"></td>`\n);"},"minimal-ranges.js":{"title":"Minimal example using Ranges","code":"// We strip tags and fix apostrophes\n// that's part of what https://codsen.com/os/detergent/ does\n\nimport { strict as assert } from \"assert\";\n\nimport { rApply } from \"ranges-apply\";\nimport { stripHtml } from \"string-strip-html\";\nimport { convertAll } from \"string-apostrophes\";\n\nfunction stripAndFixApos(str) {\n  if (!str || typeof str !== \"string\") {\n    return \"\";\n  }\n  // Keep in mind, Ranges are array of 2-3 element arrays.\n  // But absent Ranges are marked as null, not empty array.\n  // It's so that we could test in \"if-else\" easily - null\n  // is falsy but empty array is truthy.\n  // That's why below we take precautions with \"|| []\".\n  return rApply(\n    str,\n    (stripHtml(str).ranges || []).concat(convertAll(str).ranges || [])\n  );\n}\n\n// strips tags and fixes apostrophes:\nassert.equal(\n  stripAndFixApos(`Let's Go <strong>Larval</strong>`),\n  `Let’s Go Larval`\n);\n\n// no tags, no apostrophes:\nassert.equal(stripAndFixApos(`zzz`), `zzz`);"},"remove-html.js":{"title":"Remove all HTML from a string","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(stripHtml(someHtml).result, `Title\\nSome text.`);"},"strip-from-json.js":{"title":"Strip HTML from a raw JSON string","code":"import { strict as assert } from \"assert\";\nimport { traverse } from \"ast-monkey-traverse\";\n\nimport { stripHtml } from \"string-strip-html\";\n\nconst stripFromJsonStr = (str) => {\n  return traverse(JSON.parse(str), (key, val) => {\n    // if currently an object is traversed, you get both \"key\" and \"val\"\n    // if it's array, only \"key\" is present, \"val\" is undefined\n    let current = val !== undefined ? val : key;\n    if (\n      // ensure it's a plain object, not array (monkey will report only \"key\" in\n      // arrays and \"val\" will be undefined)\n      // also ensure object's value a string, not boolean or number, because we\n      // don't strip HTML from booleans or numbers or anything else than strings\n      typeof val === \"string\"\n    ) {\n      // monkey's callback is like Array.map - whatever you return gets written:\n      return stripHtml(val).result;\n    }\n    // default return, do nothing:\n    return current;\n  });\n};\n\n// nothing to strip, \"<\" is false alarm:\nassert.equal(\n  JSON.stringify(stripFromJsonStr(`{\"Operator\":\"<\",\"IsValid\":true}`), null, 0),\n  `{\"Operator\":\"<\",\"IsValid\":true}`\n);\n\n// some HTML within one of key values, monkey will skip the boolean:\nassert.equal(\n  JSON.stringify(\n    stripFromJsonStr(`{\"Operator\":\"a <div>b</div> c\",\"IsValid\":true}`),\n    null,\n    0\n  ),\n  `{\"Operator\":\"a b c\",\"IsValid\":true}`\n);"},"title-case-with-tag-skipping.js":{"title":"Set the title case using `title` package","code":"// This program will not touch any single tags (<br class=\"z\"/> for example)\n// or in case of paired tags, paired tags and content between\n\nimport { strict as assert } from \"assert\";\nimport title from \"title\";\n\nimport { rInvert } from \"ranges-invert\";\nimport { rApply } from \"ranges-apply\";\nimport { rRegex } from \"ranges-regex\";\nimport { stripHtml } from \"string-strip-html\";\n\nfunction tagAwareTitle(str) {\n  let whitelist = [\"eslint\", \"readme\", \"npm\"];\n  let { filteredTagLocations } = stripHtml(str, {\n    stripTogetherWithTheirContents: [\"*\"],\n  });\n  let inverted = rInvert(\n    filteredTagLocations.concat(\n      whitelist.reduce((acc, curr) => {\n        let rangesFindings = rRegex(new RegExp(curr, \"gi\"), str);\n        if (rangesFindings) {\n          return acc.concat(rangesFindings);\n        }\n        return acc;\n      }, [])\n    ),\n    str.length\n  );\n\n  if (Array.isArray(inverted) && inverted.length) {\n    // take inverted ranges, for example, [[3, 4], [10, 15]]\n    // and add third element, replacement, which is same character\n    // indexes only processed through \"title\":\n    return rApply(\n      str,\n      inverted.map(([from, to]) => [from, to, title(str.slice(from, to))])\n    );\n  }\n  // otherwise, just apply title() on the whole string:\n  return title(str);\n}\n\n// middle:\nassert.equal(\n  tagAwareTitle(`This is a title with some <code>code</code> in it`),\n  `This Is a Title with Some <code>code</code> In It`\n);\n\n// leading:\nassert.equal(\n  tagAwareTitle(`<span class=\"xyz\">abc</span> defgh ESLint`),\n  `<span class=\"xyz\">abc</span> Defgh ESLint`\n);"},"widow-word-removal-from-html.js":{"title":"Widow word removal from text within HTML","code":"import { strict as assert } from \"assert\";\n\nimport { stripHtml } from \"string-strip-html\";\nimport { removeWidows } from \"string-remove-widows\";\n\nconst someHtml = `The quick brown fox jumps of the lazy dog.<div class=\"a\">`;\n\n// default widow word removal libs are not aware of HTML:\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  removeWidows(someHtml).res,\n  `The quick brown fox jumps of the lazy dog.<div&nbsp;class=\"a\">` // 😱\n);\n\n// luckily, removeWidows() consumes optional HTML tag locations\nassert.equal(\n  removeWidows(someHtml, {\n    tagRanges: stripHtml(someHtml)\n      // remove the third argument, what to insert (\"&nbsp;\" string in these cases)\n      .ranges.map(([from, to]) => [from, to]),\n  }).res,\n  `The quick brown fox jumps of the lazy&nbsp;dog.<div class=\"a\">` // ✅\n);"}},"string-trim-spaces-only":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { trimSpaces } from \"string-trim-spaces-only\";\n\nassert.deepEqual(trimSpaces(\"  aaa   \"), {\n  res: \"aaa\",\n  ranges: [\n    [0, 2],\n    [5, 8],\n  ],\n});\n\nassert.deepEqual(trimSpaces(\"   \\t  zz   \\n    \"), {\n  res: \"\\t  zz   \\n\",\n  ranges: [\n    [0, 3],\n    [12, 16],\n  ],\n});"}},"string-truncator":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { truncate } from \"string-truncator\";\n\n// maxLen setting means limit length to equivalent of 10\n// longest letter lengths (font \"Outfit\" letter lengths are used)\n// and you can override those references with your font-specific lengths\nassert.deepEqual(truncate(\"Supermotodelicious\", { maxLen: 10 }), {\n  result: \"Supermotodelic\",\n  addEllipsis: true,\n});\n\nassert.deepEqual(\n  truncate(\n    \"the quick brown fox jumps over the lazy dog and then bites him in the tail and runs away\",\n    {\n      maxLen: 10,\n      maxLines: 2,\n    }\n  ),\n  {\n    result: \"the quick brown fox jumps over\",\n    addEllipsis: true,\n  }\n);"}},"string-uglify":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { uglifyById, uglifyArr, version } from \"string-uglify\";\n\n// notice we put dots and hashes for classes and id's but algorithm will work\n// fine too if you won't.\nconst names = [\n  \".module-promo-all\",\n  \".module-promo-main\",\n  \".module-promo-second\",\n  \"#zzz\",\n];\n\n// notice we put dots and hashes for classes and id's but algorithm will work\n// fine too if you won't.\nassert.deepEqual(uglifyArr(names), [\".o\", \".s\", \".z\", \"#l\"]);\n\n// uglify a particular id number (inefficient):\nassert.equal(uglifyById(names, 3), \"#l\");"}},"string-unfancy":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { unfancy } from \"string-unfancy\";\n\n// U+2019\n// https://www.fileformat.info/info/unicode/char/2019/index.htm\n// https://mothereff.in/js-escapes\nconst rightSingleQuote = \"\\u2019\";\n\nassert.equal(unfancy(`someone${rightSingleQuote}s`), \"someone's\");\n\n// works with encoded HTML:\nassert.equal(unfancy(\"someone&rsquo;s\"), \"someone's\");"}},"stristri":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { stri } from \"stristri\";\n\n// strips both HTML and Nunjucks, leaves text only:\nassert.equal(\n  stri(\n    `<html><div>The price is{% if data.price > 100 %} high{% endif %}</div>`,\n    {\n      html: true,\n      css: true,\n      text: false,\n      templatingTags: true,\n    }\n  ).result,\n  \"The price is high\"\n);"}},"tap-parse-string-to-object":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { parseTap } from \"tap-parse-string-to-object\";\n\n// synchronous parsing (there's also async, see in examples)\nassert.deepEqual(\n  parseTap(`TAP version 13\nok 1 - test/test.js # time=22.582ms { # Subtest: 01.01 - string input\nok 1 - 01.01.01\nok 2 - 01.01.02\n1..2\nok 1 - 01.01 - string input # time=7.697ms\n\n # Subtest: 01.02 - non-string input\nok 1 - 01.02.01\nok 2 - 01.02.02\nok 3 - 01.02.03\nok 4 - 01.02.04\nok 5 - 01.02.05\n1..5\nok 2 - 01.02 - non-string input # time=2.791ms\n\n 1..2 # time=22.582ms\n}\n\nok 2 - test/umd-test.js # time=16.522ms { # Subtest: UMD build works fine\nok 1 - should be equivalent\n1..1\nok 1 - UMD build works fine # time=10.033ms\n\n 1..1 # time=16.522ms\n}\n\n1..2\n\n# time=1816.082ms\n`),\n  {\n    ok: true,\n    assertsTotal: 8,\n    assertsPassed: 8,\n    assertsFailed: 0,\n    suitesTotal: 2,\n    suitesPassed: 2,\n    suitesFailed: 0,\n  }\n);"}},"test-mixer":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { mixer } from \"test-mixer\";\n\n// check all possible combinations of all boolean opts:\nconst defaultOpts = {\n  scrapeWindshield: true,\n  checkOil: true,\n  inflateTires: false,\n  extinguishersCount: 1, // as non-boolean will be ignored\n};\n\n// generates 2^3 = 8 combinations all possible bools\nassert.deepEqual(\n  mixer(\n    {\n      // empty first arg object means you want all combinations\n    },\n    defaultOpts\n  ),\n  [\n    {\n      scrapeWindshield: false,\n      checkOil: false,\n      inflateTires: false,\n      extinguishersCount: 1,\n    },\n    {\n      scrapeWindshield: true,\n      checkOil: false,\n      inflateTires: false,\n      extinguishersCount: 1,\n    },\n    {\n      scrapeWindshield: false,\n      checkOil: true,\n      inflateTires: false,\n      extinguishersCount: 1,\n    },\n    {\n      scrapeWindshield: true,\n      checkOil: true,\n      inflateTires: false,\n      extinguishersCount: 1,\n    },\n    {\n      scrapeWindshield: false,\n      checkOil: false,\n      inflateTires: true,\n      extinguishersCount: 1,\n    },\n    {\n      scrapeWindshield: true,\n      checkOil: false,\n      inflateTires: true,\n      extinguishersCount: 1,\n    },\n    {\n      scrapeWindshield: false,\n      checkOil: true,\n      inflateTires: true,\n      extinguishersCount: 1,\n    },\n    {\n      scrapeWindshield: true,\n      checkOil: true,\n      inflateTires: true,\n      extinguishersCount: 1,\n    },\n  ]\n);\n\n// let's \"pin\" a value, prepare two sets of options objects,\n// one where scrapeWindshield === true and another with \"false\"\n\n// you'll get 2 ^ (3-1) = 4 variations:\nconst variationsWithScrapeWindshieldOn = mixer(\n  {\n    scrapeWindshield: true,\n  },\n  defaultOpts\n);\nassert.deepEqual(variationsWithScrapeWindshieldOn, [\n  {\n    scrapeWindshield: true, // <--- pinned\n    checkOil: false,\n    inflateTires: false,\n    extinguishersCount: 1,\n  },\n  {\n    scrapeWindshield: true, // <--- pinned\n    checkOil: true,\n    inflateTires: false,\n    extinguishersCount: 1,\n  },\n  {\n    scrapeWindshield: true, // <--- pinned\n    checkOil: false,\n    inflateTires: true,\n    extinguishersCount: 1,\n  },\n  {\n    scrapeWindshield: true, // <--- pinned\n    checkOil: true,\n    inflateTires: true,\n    extinguishersCount: 1,\n  },\n]);\n\n// also 4 variations, similar but with scrapeWindshield === false pinned:\nconst variationsWithScrapeWindshieldOff = mixer(\n  {\n    scrapeWindshield: false,\n  },\n  defaultOpts\n);\nassert.equal(variationsWithScrapeWindshieldOff.length, 4);"}},"tsd-extract":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\nimport { extract } from \"tsd-extract\";\n\nconst { value } = extract(\n  `interface Opts1 { foo: boolean };\ninterface Opts2 { bar: boolean };`,\n  \"Opts2\"\n);\n\nassert.equal(value, \"interface Opts2 { bar: boolean };\");"},"function-definitions.js":{"title":"Extracting function type definitions","code":"import { strict as assert } from \"assert\";\nimport { extract } from \"tsd-extract\";\n\n// Real type definitions from ast-monkey-util:\nconst source = `\ndeclare function pathNext(str: string): string;\ndeclare function pathPrev(str: string): null | string;\ndeclare function pathUp(str: string): string;\ndeclare function parent(str: string): null | string;\ndeclare const version: string;\nexport { parent, pathNext, pathPrev, pathUp, version };\n`;\n\n// If you try to extract a function,\nconst { value, content: content1 } = extract(source, \"parent\");\n//                    ^\n//                 that's ES6 destructuring assignment + renaming\n\n// The \"value\" will be the whole statement:\nassert.equal(value, \"declare function parent(str: string): null | string;\");\n\n// But what do we do if we don't want the \"declare\" part?\n// extract \"content\", then manually prepend:\nassert.equal(content1, \"(str: string): null | string;\");\n\n// Imagine, if this was JSX, you'd create a functional component\n// which accepts the \"prepend\" prop. A primitive substitute example:\n\nfunction extractWithPrepend(prepend, ...etc) {\n  return `${prepend}${extract(...etc).content}`;\n}\n\nassert.equal(\n  extractWithPrepend(\n    \"function parent\", // prepend this\n    // all the same args as before:\n    source,\n    \"parent\"\n  ),\n  \"function parent(str: string): null | string;\"\n);\n\n// On codsen.com, we manually prepend \"content\" the same way\n// because if we used \"value\", resulting \"declare\" would confuse people."}},"util-array-object-or-both":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { arrObjOrBoth } from \"util-array-object-or-both\";\n\n// normalises string, a user preference:\n\nassert.equal(arrObjOrBoth(\"arrays\"), \"array\");\nassert.equal(arrObjOrBoth(\"array\"), \"array\");\nassert.equal(arrObjOrBoth(\"arr\"), \"array\");\nassert.equal(arrObjOrBoth(\"a\"), \"array\");\n\nassert.equal(arrObjOrBoth(\"objects\"), \"object\");\nassert.equal(arrObjOrBoth(\"object\"), \"object\");\nassert.equal(arrObjOrBoth(\"obj\"), \"object\");\nassert.equal(arrObjOrBoth(\"o\"), \"object\");\n\nassert.equal(arrObjOrBoth(\"whatever\"), \"any\");\nassert.equal(arrObjOrBoth(\"either\"), \"any\");\nassert.equal(arrObjOrBoth(\"both\"), \"any\");\nassert.equal(arrObjOrBoth(\"any\"), \"any\");\nassert.equal(arrObjOrBoth(\"all\"), \"any\");\nassert.equal(arrObjOrBoth(\"e\"), \"any\");"}},"util-nonempty":{"_quickTake.js":{"title":"Quick Take","code":"import { strict as assert } from \"assert\";\n\nimport { nonEmpty } from \"util-nonempty\";\n\nassert.equal(nonEmpty(\"z\"), true);\nassert.equal(nonEmpty(\"\"), false);\nassert.equal(nonEmpty([\"a\"]), true);\nassert.equal(nonEmpty([123]), true);\nassert.equal(nonEmpty([[[[[[[[[[[]]]]]]]]]]]), true);\nassert.equal(nonEmpty({ a: \"\" }), true);\nassert.equal(nonEmpty({ a: \"a\" }), true);\nassert.equal(nonEmpty({}), false);\n\nconst f = () => {\n  return \"z\";\n};\nassert.equal(nonEmpty(f), false);\n// (answer is instantly false if input is not array, plain object or string)"}}};
